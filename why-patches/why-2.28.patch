diff --git src/explain.ml src/explain.ml
index a5ac119..7b4f968 100644
--- src/explain.ml
+++ src/explain.ml
@@ -75,9 +75,9 @@ let print_formula fmt s =
   if String.length s > 0 then
     fprintf fmt "formula = \"%s\"@\n" s
 
-let print_kind ?(quote=false) fmt (loc,k) =
-  (* 
-     Option_misc.iter (fun lab ->  fprintf fmt "label = %s@\n" lab) labopt; 
+let print_kind ?(quote=false) fmt (loc,k,lab) =
+  (*
+     Option_misc.iter (fun lab ->  fprintf fmt "label = %s@\n" lab) labopt;
   *)
   if quote then
     begin
@@ -101,6 +101,11 @@ let print_kind ?(quote=false) fmt (loc,k) =
   else
     begin
       raw_loc fmt loc;
+      begin match lab with
+      | None -> ()
+      | Some s ->
+            fprintf fmt "source_label = \"%s\"@\n" s
+      end;
       match k with
 	| EKOther s -> fprintf fmt "kind = Other@\ntext = \"%s\"@\n" s
 	| EKAbsurd -> fprintf fmt "kind = Absurd@\n"
@@ -120,8 +125,8 @@ let print_kind ?(quote=false) fmt (loc,k) =
     end
 
 
-let print ?(quote=false) fmt  ((*loc,*)e) = 
-  print_kind ~quote fmt (e.vc_loc,e.vc_kind)
+let print ?(quote=false) fmt e =
+  print_kind ~quote fmt (e.vc_loc,e.vc_kind,e.vc_label)
 
 let msg_of_loopinv = function
   | "" -> "loop invariant"
diff --git src/logic_decl.mli src/logic_decl.mli
index bc11023..9b55ae7 100644
--- src/logic_decl.mli
+++ src/logic_decl.mli
@@ -58,7 +58,9 @@ type vc_expl =
     { lemma_or_fun_name : string;
       behavior : string;
       vc_loc : Loc.floc;
-      vc_kind : expl_kind }
+      vc_kind : expl_kind;
+      vc_label : string option
+    }
 
 type obligation = Loc.floc * vc_expl * string * sequent
     (* loc, explanation, id, sequent *) 
diff --git src/main.ml src/main.ml
index 3afa104..f118f9c 100644
--- src/main.ml
+++ src/main.ml
@@ -580,6 +580,7 @@ let rec interp_decl ?(_prelude=false) d =
 	    behavior = "";
 	    vc_loc = l;
 	    vc_kind = EKLemma;
+            vc_label = None;
 	  }
 	in
 	let (l,xpl,id,s) = 
diff --git src/project.ml src/project.ml
index c19ef69..e2f6963 100644
--- src/project.ml
+++ src/project.ml
@@ -321,6 +321,7 @@ let rec get_goal lf beh e =
 	    Logic_decl.behavior = beh;
 	    Logic_decl.vc_loc = loc;
 	    Logic_decl.vc_kind = k;
+            Logic_decl.vc_label = None;
 	  }
 	in
 	let (proofs,elements) = get_proof (List.tl elements) in
diff --git src/util.ml src/util.ml
index fdaeade..a916333 100644
--- src/util.ml
+++ src/util.ml
@@ -1185,14 +1185,14 @@ let cook_loop_invariant _internal_lab (userlab : string option) p =
    refined explanation.
 *)
 let cook_explanation (userlab : string option) e =
-  let e,l =
+  let e,l, maylab =
     match e with
-      | VCEexternal s -> EKOther s, dummy_reloc 
-      | VCEabsurd -> EKAbsurd, dummy_reloc
+      | VCEexternal s -> EKOther s, dummy_reloc, None
+      | VCEabsurd -> EKAbsurd, dummy_reloc, None
       | VCEassert (k,p) -> 
           (match k with 
             | `ASSERT -> EKAssert
-            | `CHECK -> EKCheck), (reloc_xpl (List.hd p))      
+            | `CHECK -> EKCheck), (reloc_xpl (List.hd p)), None
       | VCEpre(lab,loc,_p) -> 
 	  begin
 	    if debug then eprintf "Util.cook_explanation: label,loc for pre = %s,%a@." lab
@@ -1206,37 +1206,39 @@ let cook_explanation (userlab : string option) e =
 		    | _ -> raise Not_found		  
 		in
 		if debug then eprintf "Util: kind for '%s' is '%s'@." lab k;
-		EKPre k, (f,l,b,e)
+		EKPre k, (f,l,b,e), Some lab
 	      with Not_found ->
 		if debug then eprintf "Util: cannot find a kind for '%s'@." lab;
-		EKPre "", (f,l,b,e)
+		EKPre "", (f,l,b,e), Some lab
 	    with Not_found -> 
 	      if debug then eprintf "Util: cannot find a loc for '%s'@." lab;
-	      EKPre "", Loc.extract loc
+	      EKPre "", Loc.extract loc, Some lab
 	  end
 
-      | VCEpost p -> EKPost, (reloc_xpl p)
-      | VCEwfrel -> EKWfRel, dummy_reloc 
-      | VCEvardecr p -> EKVarDecr, (reloc_xpl_term p)
+      | VCEpost p -> EKPost, (reloc_xpl p), None
+      | VCEwfrel -> EKWfRel, dummy_reloc, None
+      | VCEvardecr p -> EKVarDecr, (reloc_xpl_term p), None
       | VCEinvinit(internal_lab,p) -> 
 	  let s,loc  = cook_loop_invariant internal_lab userlab p in
-	  EKLoopInvInit s, loc 
+	  EKLoopInvInit s, loc, None
       | VCEinvpreserv(internal_lab,p) -> 
 	  let s,loc  = cook_loop_invariant internal_lab userlab p in
-	  EKLoopInvPreserv s, loc
-  in 
+	  EKLoopInvPreserv s, loc, None
+  in
+  let new_lab = if userlab = None then maylab else userlab in
   match e with
     | EKPre _ -> 
 	(* for pre-conditions, we want to focus on the call, not an the formula to prove *)
-	e,l
+	e,l, new_lab
     | _ -> e, 
-	match userlab with
+	(match new_lab with
 	  | None -> l
 	  | Some lab -> 
-	      (try loc_of_label lab with Not_found -> 
+	      try loc_of_label lab with Not_found -> 
 		if debug then
 		  eprintf "Warning: no loc found for user label %s@." lab;
-		l)
+		l),
+         new_lab
 
     
 let explanation_table = Hashtbl.create 97
diff --git src/util.mli src/util.mli
index c3c9b35..1a57468 100644
--- src/util.mli
+++ src/util.mli
@@ -172,7 +172,8 @@ val create_post : predicate -> (assertion * 'b list) option
 val loc_of_label: string -> Loc.floc
 
 val cook_explanation : 
-    string option -> raw_vc_explain -> Logic_decl.expl_kind * Loc.floc 
+    string option -> raw_vc_explain ->
+       Logic_decl.expl_kind * Loc.floc * string option
 
 val program_locs : (string,(string * string * Loc.floc)) Hashtbl.t
 
diff --git src/vcg.ml src/vcg.ml
index 45e5a6e..b14b77d 100644
--- src/vcg.ml
+++ src/vcg.ml
@@ -894,12 +894,16 @@ let vcg_from_wp _loc ids name beh w =
   let cpt = ref 0 in
   let push_one (ctx, concl) = 
     let formula_userlab, raw_explain = explain_for_pred None None concl in	
-    let kind,loc =  Util.cook_explanation formula_userlab raw_explain in
+    let kind,loc, lab =  Util.cook_explanation formula_userlab raw_explain in
+    if formula_userlab = None then
+       Format.printf "formula_userlab unset: %s@." name;
     let explain = (*Logic_decl.ExplVC*)
       { Logic_decl.lemma_or_fun_name = name ;
 	Logic_decl.behavior = beh;
 	Logic_decl.vc_loc = loc ;
-	Logic_decl.vc_kind = kind }
+        Logic_decl.vc_kind = kind ;
+        Logic_decl.vc_label = lab;
+      }
     in
     try
       discharge loc ctx concl

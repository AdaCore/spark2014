~ STT/1 ~ 7.1.2 ~ ~ This paragraph is confusing.  What is a "more obvious view"?  Perhaps a more "intuitive" or "natural" view?  In the phrase "this may be given explicitly" to what does "this" refer? The read or update of a volatile variable or state abstraction is considered to be both a read and an update of the entity. In Global and Depends aspects this means that volatile entities will be regarded as being both an input and an output and this may be given explicitly. However if a variable or abstract state is explicitly designated as being a Volatile Input or a Volatile Output, an abbreviated form of the Global and Depends aspect is permitted which gives a more obvious view of the global and dependency.~
~ STT/2~ 7.1.2~ ~ This sentence is missing something (a semicolon or a dash?): In a Depends aspect it need not appear as an output an implicit self dependency of the entity will be declared.~
~ STT/3 ~ 7.1.2 ~ ~ Ditto for this sentence: In a Depends aspect it need not appear as an input an implicit self dependency of the entity will be declared.~
~ STT/4 ~ 7.1.2 ~ ~ singular/plural mismatch, and "a assertion": A volatile variable or state abstractions cannot be mentioned directly in a assertion expression as the reading of a volatile may affect its value.~
~ STT/5 ~ 7.1.3 ~ ~ "... since modular [is] analysis {is} performed before ..." ~
~ STT/6 ~ 7.1.3 ~ p. 49 ~   the parenthetical parts of this sentence are confusing: State abstraction provides a mechanism for naming, in a package’s visible_part, state (typically variable declarations) that will be declared within the package’s body (or private_part, or within private descendants of the package). It would make sense to say "(typically variables)" since the variables are the state, not their declarations.  But it would be even better to leave it out, or move it later in the sentence.  It also doesn't make sense to parenthesize "or private_part, or within private descendants of the package" since there is nothing parenthetical about this. I also find it funny to say that State abstraction is primarily about "naming", and also note that the names are used outside of the visible part, e.g. during a refinement in the body.  All in all, I think this sentence should be rewritten, or perhaps even dropped completely.~
~ STT/7 ~ 7.1.3 ~ p. 49 ~ "The hidden state of a package may be represented by one or more state abstractions, with [each] {any} pair of state abstractions representing disjoint sets of hidden variables."~
~ STT/8 ~ 7.1.3 (and probably elsewhere) ~ p. 49 (and elsewhere) ~ No need to capitalize "aspect."  E.g. "Global Aspect" => "Global aspect".~
~ STT/9 ~ 7.1.3 (and perhaps elsewhere) ~ p. 49 ~ In syntax descriptions, reserved words should be bolded or quoted or upper-cased or somehow distinguished from non-terminals.  E.g., in:   ( state_name with property_list ) the "with" should be <b>with</b> or WITH or 'with' or something like that.
~ STT/10 ~ 7.1.3 ~ p. 49 (and later) ~ In the following legality rule:  7. A package_declaration or generic_package_declaration requires a     completion [(a body)] if it contains a non-null Abstract State aspect     specification. the magic phrase "requires a completion" (of 3.11.1 fame) appears.  I suspect it should be changed to "shall have a completion" to avoid implying that the presence of this aspect triggers the "requires a completion" semantics. My belief is that we still want the programmer to insert a "pragma Elaborate_Body" for example, if there is nothing else in the spec that would normally trigger the "requires a completion" semantics. I think we want to be able to erase Abstract_State aspects and still have a legal Ada program. NOTE: The "requires completion" wording also appears later in 7.1.3, and should probably also be changed to "shall have a completion."~
~ STT/11 ~ 7.1.3 ~ p. 50 ~ In the following: 2. The hidden state of a package P consists of: * any variables declared immediately within the private part or body of P; and * the visible state and state abstractions of any packages declared immediately within the private part or body of P, and of any private child units of P or of their public descendants. This seems to leave out the hidden state of nested packages.  Shouldn't we change the last bullet to be two bullets: * the hidden state of any packages declared immediately within the visible   part of P * the hidden and visible state and state abstractions of any packages declared   immediately within the private part or body of P, and of any private child  units of P or of their public descendants.
~ STT/12 ~ 7.1.3 ~ p. 50 ~ Here is a more general question about private descendants: We seem to be treating them as "part" of the parent, but whether or not a particular private descendant is included in a program can depend on whether it is mentioned in a "with" clause by a public descendant.  So this implies that some private descendants might not be included, even though the parent is included in a program.  How does this affect the model? Should we treat private descendants on which the parent has no dependence as though there were a public descendant? Similarly, should we treat public descendants on which the parent *has* a dependence in the way we were proposing to treat private descendants? Or should we treat each library package independently? (That would be the simplest!)
~ STT/13 ~ 7.1.3 ~ p. 50 ~ (Editorial) Two paragraphs are numbered "1.". The paragraph numbered "2." has the following typo: "The specification is [is] checked..." The paragraph numbered "3." should use "that" rather than "which": "... with a property list [which] {that} includes the Volatile property..." In the Example, a comment should be revised:  "... abstract state name{d} State ..." In the Example, "Global" is bolded in some cases and not in others. In general the "bolding" is not consistent (here and elsewhere).
~ STT/14 ~ A.1.1 ~ ~ "Swap" example used to explain shift from "Derives" to "Depends" is not helpful because it is symmetric.  It starts from:   Derives X from Y & Y from X and goes to Depends => (X => Y, Y => X) so it is unclear whether "Derives" and "Depends" use essentially the same order or if the order should be reversed.
~ STT/15 ~ A.1.3 ~ ~ quantified expression needs to be parenthesized:   Post => (for all I in X’Range => (X (I) = 0)); Also, why is "Depends" in bold, while Pre and Post are not?
~ STT/16 ~ A.2.1 ~ ~ why are some things bolded (e.g. "Pre") and some not (e.g. "Post")?~
~ JK1 ~ introduction ~ n/a ~ It is visible that the introduction has been written by several 	persons simultaneously; it lacks coherence, there are repetitions. Nothing 	serious though.~
~ JK2 ~ 1 ~ 3/3 ~ Mixture of test and proof: that's correct, but it is unnecessarily 	restrictive. Can we say something like: Support for proof of only part 	of the program, and combination with other verification methods such as 	testing.~
~ JK3 ~ 1 ~ 3/4 ~ If one uses pragmas, any Ada compiler can be used, not only an Ada 2012 compiler, right?~
~ JK4 ~ 1 ~ 3/5 ~ I don't understand this paragraph. Obviously the language needs a 	compiler that implements it! No need to mention GNAT specifically.~
~ JK5 ~ 1.2 ~ 4/1-4 ~ I think there is no need to mention the tools. SPARK 2014 is a 	language, and exists independently of the tools. I also think it would be OK 	for the language definition to include more than is supported by the first 	release, and it would also be OK for the tool to support more than just what is 	defined in the language definition. This is already the case anyway (GNAT has 	some vendor-specific pragmas).~
~ JK6 ~ 7.2.8 & 7.2.9 ~ 58 - 59 ~ I do not feel the need for Refined_Pre and Refined_Post. The same 	effect can be easily achieved by a wrapper subprogram, where the wrapped 	subprogram has the refined pre/post as normal pre/post. ~
~ YM01 ~ 1.5 ~ 5/1st para after bullet points ~ The Verification Rules are presented as enforcement of flow analysis only. This is not the case, for example Verification Rules for Loop_Invariant have nothing to do with flow analysis.~
~ YM02 ~ 1.6 ~ 6/2 ~ The LRM says that SPARK 2014 pragmas either have no dynamics semantics, or are used "to define assertions whose success shall be proven statically". This is not the case, as Loop_Invariant and Loop_Variant can perfectly be used for their dynamic role only.~
~ YM03 ~ 3.2.4 ~ 19 ~ If subtype predicates are to be included in SPARK 2014, additional verification rules should be created, so that formal verification is possible at the level of an individual subprogram. In particular, the variables that are mentioned in the Global contract of a subprogram should have the corresponding predicate verified on entry (for IN and IN OUT) and exit (for OUT and IN OUT) of the subprogram. Also, the Ada RM rules (see RM 3.2.4 Dynamic Semantics) only define checks for values of parameters whose type has a subtype predicate attached. But no check is performed when the subtype predicate is attached to a component of the type. For example, in the code below, no violation is detected when calling Violate on a parameter of type T. It would be expected in SPARK to have the same kind of rules that Ada has for type invariants (that apply on any "part" of an object that has a type invariant attached).~
procedure P is
   type R is tagged record
      A, B : Integer;
   end record with Predicate => R.A = R.B;
   procedure Violate (C : in out R) is
   begin
      C.A := C.B + 1;
   end Violate;

   type T is record
      C : R;
   end record;
   procedure Violate (D : in out T) is
   begin
      D.C.A := D.C.A + 1;
   end Violate;

   E : T;
begin
   E := (C => (A | B => 0));
   Violate (E);    --  not detected

   E := (C => (A | B => 0));
   Violate (E.C);  --  detected
end P;

As subtype predicates are an important specification feature of Ada 2012, it would not be understandable to leave it outside SPARK 2014. But this requires work to define sensible Verification Rules. Note that it may be appropriate to define reasonable constraints on the content of the predicate in SPARK 2014 (like the fact the expression cannot refer to global variables), to both simplify verification and facilitate their correct use.~
~ YM04 ~ 6.8 ~ 45 ~ Nothing is currently added to expression functions in the LRM, wrt Ada LRM. Does that mean they cannot be given a Global/Depends/Contract_Cases aspect?~
~ YM05 ~ 7.1.5 ~ 52 ~ The rationale for providing an Initial_Condition aspect is not clear, now that initialization of library-level constants and variables has been restricted in SPARK to compiler-known values. The LRM says this serves to establish the "precondition" of the program proper, but this is given by the compiler-known values initializing the library-level constants and variables. It seems that Initial_Condition is mostly useful for stating the effect of statements in package body elaboration, which should be mentioned.~
~ YM06 ~ 7.2.2 ~ 53 ~ I am not convinced by the rationale for refined pre/post/global/depends/contract_cases. Here is what it says: "1. The semantics of properties defined in terms of abstract state can only be precisely defined in terms of the corresponding concrete state, though nested abstraction is also necessary to manage hierarchies of data." Although this was true for SPARK 2005, this is not the case anymore with SPARK 2014. Functional properties expressed as pre/post/contract_cases can use actual program functions (instead of separate logic functions in SPARK 2005), whose implementation is precisely defined in terms of the concrete state. Regarding global/depends contracts, the benefit of re-specifying them in terms of concrete state is not obvious at all. "2. There may be multiple possible refinements for a given abstract specification and so the user should be able to specify what they actually want." The main way that a user specifies this "refinement" is by an "implementation" of the specified abstraction. Of course there are multiple possible implementations for an abstraction, but what is the benefit of stating twice (in the implementation, and in the refined aspects) the same implementation? "3. This is necessary to support development via stepwise refinement." The implementation is not really a refinement of the spec. The real refinement (like in the B method) is between a higher-level specification and a lower-level specification. I don't believe we provide useful features here for stepwise refinement. Overall, I feel that refinement was useful in SPARK 2005, but won't be useful in SPARK 2014. I did not see an example which could not be slightly rewritten (say, by introducing a wrapper function) to attain the same verification goals with only Pre/Post/Global/Depends. Note that this is independent of Refined_State, which is clearly needed. Given the additional complexity of refined Pre/Post/etc. for little gain, I favor not putting them in SPARK 2014.~
~ YM07 ~ 7.3.2 ~ 60 ~ In order for type invariants to be always true outside of the unit implementing the type, restrictions should be imposed on the expression stating the type invariant property. In particular, it should not mention global variables, or else it could be broken anytime by code modifying the global variable. Additionally, there should be Verification Rules that state in which cases a global variable (mentioned in the Global contract) has its type invariant checked, similarly to what should be done for predicate subtypes.~
~ YM08 ~ 7.4 ~ 60 ~ Verification tools should be prevented from using the value of the deferred constant when analyzing a unit which has no visibility over the private part where the value of the constant is defined.~
~ YM09 ~ 8.3 ~ 61 ~ Expanding on YM08, there should be visibility rules for verification. Otherwise, nothing prevents a verification tool from looking at the body of a subprogram inside the package body of P to perform the verification of the body of another subprogram inside the package body of Q. If SPARK 2014 defines a language for modular verification, visibility rules that prevent the above should be given.~
~ CD1 ~ 5.9.2 ~ 30 ~ In the section Verification Rules, it is not clear what is described here. Maybe there should be a sentence per pragma? As for Assume, the manual states that it is not required to prove that the Boolean expression is true. For a reader, it sounds like this proof may be attempted though and raise a warning if it is not proved. As I understand pragma Assume, it is not the case. The proof should not be attempted but the result should be assumed to be true (the manual says that it can be assumed only). An other small point, if Loop_Invariant is described 5.5.3 Language Definition, shouldn't the information about it being a cut point appear rather in this section?~
!Implementer: TJJ
!Reviewer: AH, STT
!Revision reviewed:
!TN Description: Review of LRM 0.3 Draft
!Check messages under this TN - Are all issues addressed?:
!Review completed:
!TN marked dead:

!Label:
!Location:
!Description:
!Action Taken:
!Checked By:

!Label: FS001
!Location: Section 7.2.3 Legality Rule 4
!Description: This rule states that a package with a non-null Abstract_State
              aspect shall have a completion (a body).
              Effectively, this rule can only be checked at compilation time.
              If we were to enforce it at the analysis stage, we would be
              breaking modular analysis (since we would request that bodies
              are in place before proceeding with the analysis).
!Action Taken: Updated text to clarify the meaning of this rule.
!Checked By: AH

!Label: STT001,
!Location: 1.8, 8/2 (also 1.9.5, 12/6):
!Description: We indicate that Pre and Post cannot possibly be
generated, but we do know how to infer some Pre/Postconditions from the
code (cf. CodePeer).  So perhaps we should say that we don't support
that currently, but might at some later date.
!Action Taken: These sections have been rewritten the stating that the extent of synthesis is a tool issue but stating that there are minimum requirements.
!Checked By: AH

!Label: STT002,
!Location: 1.8, 8/11:
!Description: Do we still call the section on external inputs and
outputs "Volatile State"?
!Action Taken: Changed the title to External State and added a few words
to indicate that an external state need not be Volatile.  Used the term
Volatile state to refer to both variables and state abstractions.
!Checked By: AH

!Label: STT003
!Location: 1.9.6, 13/10 (also 14/10):
!Description: Formatting glitch: "SPARK_Mode" came out as
"SPARKSUBSCRIBTINBMode."
!Action Taken: This is a artifact of the diff.  The method used for the
diff has been updated and should resolve this problem.
!Checked By: AH

!Label: STT004
!Location: 1.9.6, 13/14:
!Description: Avoid use of "may not" -- use "might not" instead.  "May
not" tends to be ambiguous between "must not" and "might not", and is
not permitted in ISO standards.
!Action Taken:  Replace may not by might not or shall not as appropriate
throughout the document.
!Checked By: AH

!Label: STT005
!Location: 1.9.6, 14/2:
!Description: This starts out "It is the *use* of a construct no in
SPARK 2014..."  This is somewhat hard to understand, and is not parallel
in construction with the prior paragraph, and is hard to distinguish
from the prior paragraph.  What exactly does "use" mean as opposed to
"appear".  Is "use" supposed to mean "call" as opposed to "appear directly"?
!Action Taken: The wording is not clear but the intention is that a
declaration of an entity, although not in SPARK may not be a problem,
e.g., the declaration of an access type or a subprogram that is not in
SPARK.  It is only when an object of the unsupported type is declared or
there is a call to the unsupported subprogram that they become something
that affects the analysis.  The idea is that we could ignore certain
declarations, increase the number of non-SPARK units (package specs I
guess) that could be accepted, and reduce the number of places where the
SPARK_Mode aspect has to be used.  I do not think this idea has been
accepted and if this is the case the questionable paragraph should be
deleted and the preceding one updated.
Reworded in terms of declarations and the use of those declarations
!Checked By: AH

!Label: STT006
!Location: 3.9 27/5:
!Description:
Is is worth supporting Pre'Class, etc., if we aren't supporting
dispatching calls?  The class-wide aspects seem relevant only in the
presence of dispatching calls.
!Action Taken: I have changed the text to say that the attribute 'Class
is not currently supported. References to 'Class attributes have either been removed or have been qualified with a note stating that they are not currently supported.
!Checked By: AH

!Label: STT007
!Location: 5.1 29/3:
!Description: Once we support tasking, presumably entry_call_statement,
requeue_statement, and delay_statement will be "in SPARK."  Shouldn't we
somehow distinguish temporary restrictions and long-term restrictions?
!Action Taken: Added the following note:
[A future release of |SPARK| is planned to support the Ravenscar
multi-tasking
profile and then some of the tasking statements such as
``entry_call_statement``, and ``delay_statement`` will be permitted.]
The requeue statement is not in the Ravenscar profile.
I think we need to go through the SPARK RM and make sure we note where
future enhancements are likely.]  TO BE COMPLETED.
!Checked By: AH

!Label: STT008
!Location: 5.5.3 30/4:
!Description: "... for an legality rule ..." -> "... for a legality rule
..."
!Action Taken: Done.
!Checked By: AH

!Label: STT009
!Location: 5.5.3 30/5:
!Description:
Loop_Variant is claimed to be similar to pragma Assert, but in fact has
little or nothing in common with pragma Assert.
!Action Taken: I think it was trying to make use of the existing rules
for assert.  I have reworded it to make it less of a comparison with
Assert as follows: Under static semantics:
#. Pragma Loop_Variant is used to demonstrate that a loop will terminate by
   specifying expressions that will increase or decrease as the loop is
   executed.

Under Legality Rules:
#. Loop_Variant has an expected actual parameter which is a specialization of an
   Ada expression. Otherwise, it has the same name resolution and legality
   rules as pragma Assert, except for extra legality rules given below.

!Checked By: AH

!Label: STT010
!Location: 5.5.3 33/15:
!Description:
I could not understand this sentence:
"The prefix of a Loop_Entry attribute_Reference shall not contain a use
of an entity declared within the loop_statement but not within the
prefix itself."
What sort of prefix includes declarations?  Did you mean "within the
enclosing invariant or variant expression"?
!Action Taken: I do not know the answer to this I defer to SBB. I have
sent an email to SBB. SBB has replied with an example - it is complex like the rule.  I have added the example as a note in the SPARK RM.
!Checked By: AH

!Label: STT011
!Location: 5.5.3 33/16:
!Description:
I don't understand why the rule about statically denoting an entity or
an object_renaming_declaration "if the attrib_ref is potentially
unevaluated or the attrib_ref does not apply to the innermost enclosing
loop_statement." A hint of a rationale for this rule would help!

Should we reverse the description of this rule, such as:
Under the following circumstances:
  ...
the prefix of the Loop_Entry shall statically denote an entity...
!Action Taken:
Comment from SBB:
This follows the corresponding Ada RM rule for 'Old
  The prefix of an Old attribute_reference that is potentially
  unevaluated shall statically denote an entity.

and has the same rationale. If we allowed

    procedure P (X : in out String; Idx : Positive) is
    begin
        Outer :
          loop
            if Idx in X'Range then
              loop
                  pragma Loop_Invariant (X(Idx) >
                                        X(Idx)'Loop_Entry(Outer));

this would introduce an exception in the case where Idx is not
in X'Range. Sounds like you are saying that adding words to this
effect as a note would be helpful.
TJJ added note.
!Checked By: AH

!Label: STT012
!Location: 6.1.4 42/8:
!Description: This note indicating that the rule disallowing function
calls is a name resolution rule seems odd.  Better would be to make rule
1. into a name resolution rule, and then make this second rule be a NOTE
immediately following it, explaining why it is a name resolution rule.
!Action Taken: Moved it a name resoultion rule section.  Also update
introduction to state that name resoultion rules may be present
!Checked By: AH

!Label: STT013
!Location: 6.1.4 42/4:
!Description: "...with a mode_selector of In_Out or Out{put}."
!Action Taken: Done.
!Checked By:AH

!Label: STT014
!Location: 6.1.4 43/3:
!Description: Are we defining "mode in" = "mode_selector Input"?  That
seems confusing.  Why not just talk about mode "Input"?  Ditto for "mode
out" and "mode in out".  Also, there seems no "mode" corresponding to
the "mode_selector Proof_In".
!Action Taken: I agree - removed reference to mode in or out.
!Checked By: AH

!Label: STT015
!Location: 6.1.4 43/4:
!Description:
The wording "... is always fully initialized on every call..." is a bit
confusing, as it could mean must be initialized before the call.  It
would be clearer if it said "... is always fully initialized as a result
of any successful execution of a call..."
!Action Taken: Changed the text as suggested.
!Checked By: AH

!Label: STT016
!Location: 6.1.4 43/7:
!Description: Comment is missing "not": "... the subprogram does {not}
reference any global items."
!Action Taken: See JEB/18
!Checked By: AH

!Label: STT017
!Location: 6.1.5 44/1:
!Description: What does it mean to say "... are simple specifications"?
  Did you define "simple" specifications somewhere?
!Action Taken: I meant they are a simpler form of formal specification.
  I have removed the throw away remark.
!Checked By: AH

!Label: STT018
!Location: 6.1.5 45/5:
!Description: "dentoed" => "denoted"
!Action Taken: Done.
!Checked By: AH

!Label: STT019
!Location: 6.1.5 45/7:
!Description:
As with STT012, this note indicating that the (implicit) rule
disallowing function calls is a name resolution rule, should be altered
by putting the rules which are name-resolution rules in a
name-resolution section, and then including this explanation as a note
below them.
!Action Taken: Done.
!Checked By: AH

!Label: STT020
!Location: 6.1.5 45/9:
!Description:
This paragraph talks about "output_list which is a null symbol" but that
is not permitted by the syntax.  I believe this should be restated in
terms of the "null_dependency_clause".
!Action Taken: Done.
!Checked By: AH

!Label: STT021
!Location: 6.1.5 45/(last):
!Description:
Is there a reason we allow "A =>+ A"?  This seems likely to have been an
error of some sort.  It also violates the rule requiring distinct
entities in the input_list after expanding it into its equivalent "A =>
(A, A)".  If we do allow this, we should probably change the equivalence
to indicate that each member of the output list is union'ed with the
input list to produce the equivalent input list for that output.  Not
clear this is a good idea in my mind! (note that some of the later
examples, such as "(A, B) =>+ (A, X, Y)", will need to be modified if we
do disallow this).
!Action Taken: The reason is for the following shorthand (avilable in
SPARK 2005:
    (A, B, C) =>+ (A, D, E) is equivalent to
    (A => (A, D, E),
    B => (A, B, D, E),
    C => (A, C, D, E))
I will add this explanation as a note.
!Checked By: AH

!Label: STT022
!Location: 6.1.5 46/2:
!Description: Missing "of"?  "... the input_list {of} a
null_dependency_clause ..."
!Action Taken: See JEB/19
!Checked By: AH


!Label: STT023
!Location: 6.1.6 47/(second to last):
!Description:
It is a bit subtle to claim that erasing ghost functions and assertions
that use them has no effect on the dynamic semantics of a valid SPARK
program, when viewed as an Ada program.  The Ada program will have fewer
assertions in it, and presuming they are executed, that seems like a
change, but I guess we could say "(other than evaluating fewer
known-to-be-true assertion expressions)."
!Action Taken: Added this caveat.
!Checked By: AH

!Label: STT024
!Location: 6.1.6 49/3:
!Description: "... an External [state] entity shall ..."
!Action Taken: Done.
!Checked By: AH

!Label: STT025
!Location: 6.1.6 49/(last):
!Description: "... a[n] non-ghost-updating assignment statement is [is]
handled by ..."
!Action Taken: Done.
!Checked By: AH

!Label: STT026
!Location: 6.2 50/(second to last):
!Description:
"... and give [a]rise to flow errors..."
"... if it is different [to] {from} the specified ..."
!Action Taken: Done.
!Checked By: AH

!Label: STT027
!Location: 7.1.2 56/2(and following):
!Description:
"[An external]{External} state may be *volatile state* ..."
"... an assignment to [a] volatile state is not ..."
"... read of [a] volatile state ..."
"... intervening update of [a] volatile state ..."
(In general, "an external state" should be simply "external state" or
"an external variable" or "an external object" or "an external state
abstraction".  Similarly, "a volatile state" or "a hidden state" should
be reworded somehow.  In general these paragraphs have a number of
grammar problems, presumably due to a global replacement of "volatile"
with "external."  E.g., "a external" occurs at least once.)
!Action Taken: Replaced an external state, etc by External state, etc
throughout the document.  Also checked for occurences of a external and
either removed or corrected each instance.
!Checked By: AH


!Label: STT028
!Location: 7.1.2 56/9:
!Description: "... it may be specified as external, in which {case} it
may be also ..."
!Action Taken:Done.
!Checked By: AH

!Label: STT029
!Location: 7.1.2 56/10:
!Description:
For me, it is weird to be required to specify "non-volatile" rather than
that being the default.  Making "volatile" the default for abstract
state seems counter intuitive, given that for normal objects,
"non-volatile" is the default, and the notion of "volatile" seems pretty
low-level, rather than being "abstract."  In general I am not very
comfortable with this section.  My sense is that most external
communication will be via calls to imported subprograms (through I/O
APIs), and using the term "volatile" for most of that sounds much too
low level.  The point of introducing the term "external" was to lift up
the level of abstraction.  Instead we seem to have intermixed the notion
of external communication and the low-level notion of volatile objects.
  That doesn't seem like an improvement to me! And I have no good
understanding of why external state that is input or output only is
necessarily volatile.  Do we actually care how external communication is
accomplished at the low level?
!Action Taken: I agree with you to a large extent.  I have been unhappy
about the different default between external state and external
variables.  Steve was very concerned that we should not be able to
abstract volatile state into non-volatile state which is why external
state ended up being volatile by default.  Volatility is still important
at the more abstract level because it is still necessary to know (for
bot flow analysis and proof) that two possibly indirect reads of a
volatile state might not return the same value, for example:

package P with Abstract_State => (S with External) is
  procedure Read (V : out Integer) with Global => S;
end P;

function Get_2 return Boolean
is
    V1, V2 : Integer;
begin
    P.Read (V1);
    P.Read (V2);
    pragma Assert (V1 = V2);
    return True;
end Get_2;

(Note we could not write this example with the current rules)

There are two problems here - the first is that we should not be calling
P.Read in a function as the function now has a side effect but this is not
apparent from the specification of P.Read. The second is that we would
be able to prove that V1 = V2 because the volatility of S is not
apparent but the assertion is likely to fail.

I think there is a halfway house.  We could disregard volatility with
respect to External state except when it is Input_Only or an
Output_Only.  So we have
an external state abstraction which may be mapped on to volatile or
non-volatile state or a mixture of the two.  We already have rules to
ensure an external state abstraction which maps on to a mixture is
always considered as In_Out in Global and Depends aspects, so this
should mitigate Steve's concerns.

If an external state abstraction is refined on to just volatile
input_only or volatile output only then it may be specified as
Input_Only or Output_Only.  This allows it to be treated as just an
input or just an output in Global and Depends aspects (although the flow
and proof tools would know it is volatile).

Taking the previous example:

-- S may only be refined on to non volatile components because
-- S a global Input indicating that there is no side effect
package P_Non_Volatile with Abstract_State => (S with External) is
  procedure Read (V : out Integer) with Global => S;
end P_Non_Volatile;

-- This function is fine because we now that P_Non_Volatile.Read
-- has no side effect
function Get_2 return Boolean
is
    V1, V2 : Integer;
begin
    P_Non_Volatile.Read (V1);
    P_Non_Volatile.Read (V2);
    pragma Assert (V1 = V2);
    return True;
end Get_2;

-- S may only be refined on to non-volatile, volatile or a mixture of both
-- because S is Global In_Out - the call of Read has a side effect.
-- S a global Input indicating that there is no side effect
package P_May_Be_Volatile with Abstract_State => (S with External) is
  procedure Read (V : out Integer) with Global => (In_Out => S);
end P_May_Be_Volatile;

-- We can no longer write function Get_2 because Read has a side effect.
procedure Get_2 (Result : out Boolean)
with Global => (P_May_Be_Volatile.S => In_Out)
is
    V1, V2 : Integer;
begin
    P_May_Be_Volatile.Read (V1);
    P_May_Be_Volatile.Read (V2);
    pragma Assert (V1 = V2);  -- As P_May_Be_Volatile.S is an In_Out global
    Result := True;          -- of Read so we will no longer be able to
prove
                              -- V1 = V2.
end Get_2;

-- S may only be refined on to Input_Only states
package P_Input_Only_Volatile
with Abstract_State => (S with External, Input_Only)
is
  procedure Read (V : out Integer) with Global => S;
    -- Treated like an input but the tools know its
    -- voltle because its Input_Only
end P_Input_Only_Volatile;

-- We can no longer write function Get_2 because S is volatile.
procedure Get_2_In (Result : out Boolean)
with Global => P_Input_Only_Volatile.S
-- We treat it like an input but its known to be volatile

is
    V1, V2 : Integer;
begin
    P_Input_Only_Volatile.Read (V1);
    P_Input_Only_Volatile.Read (V2);
    pragma Assert (V1 = V2);  -- As P_Input_Only_Volatile.S is volatile
    Result := True;          -- we will no longer be able to prove
                              -- V1 = V2.
end Get_2_In;

I have updated the SPARK RM text to reflect this half-way house.

!Checked By: AH

!Label: STT030
!Location: 7.1.3 57/9-58/2:
!Description: This all feels a bit complex.  Is there some way to
simplify this set of rules (as well as the earlier discussion of
external/volatile)?
!Action Taken:Changed in accordance with actions from last comment (STT29).
!Checked By:AH

!Label: STT031
!Location: 7.1.4 59/9:
!Description:
"... shall denote, in its Global aspect, the state abstraction[s]{(s)}
with ..."
"... then the state abstraction[s]{(s)} shall be denoted ..."
!Action Taken: Replaced as suggested.
!Checked By:TJJ

!Label: STT032
!Location: 7.1.4 59/(last):
!Description: "(state_name_with_{options} { , state_name_with_options } )"
!Action Taken: Corrected as suggested (Repeat of JEB/27).
!Checked By: AH

!Label: STT033
!Location: 7.1.4 60/1:
!Description: It would be nice if reserved words (e.g. "with") were in
bold or somehow otherwise clearly distinguished from syntactic categories.
!Action Taken:Some sort of formatting issue with ResT - Ada language highlighting present in latest version.
!Checked By: AH

!Label: STT034
!Location: 7.1.4 60/1 (and following):
!Description: As mentioned above, it seems odd to make "Volatile" the
default, and have a "Non_Volatile" aspect.  In any case, it seems we
ought to mention the Non_Volatile (or Volatile) aspect in the Legality
or Static Semantics rules.
!Action Taken:A state abstraction may now only be specified as External and then may be specified as Input_Only or Output_Only.  There are no longer any Volatile or Non_Volatile options.
!Checked By: AH

!Label: STT035
!Location: 7.1.4 61/2:
!Description: Indentation is goofed up.  Presumably procedure Init and
Op_1 should be at same indent level as Is_Ready.
!Action Taken: Corrected indentation.
!Checked By: AH

!Label: STT036
!Location: 7.1.4 61/(last):
!Description: "... represent the state abstractions in
[expressions]{Global and Depends specifications}."
!Action Taken: Replaced as suggested.
!Checked By: AH

!Label: STT037
!Location: 7.1.5 62/8,10,12:
!Description:
Each of these legality rules needs a "shall" somewhere, or should be
moved to Name Resolution or Static Semantics:
"1. An Initializes aspect [may] {shall} only appear in ..."
"3. ..." => Move to Name Resolution
"5. Each name in the input_list [denotes] {shall denote} an entire ..."
!Action Taken: Replaced as suggested.
!Checked By: AH

!Label: STT038
!Location: 7.1.6 62/14:
!Description:
If a visible variable is initialized at its point of declaration, does
it need to appear in the Initializes list as well?  This talks about
"the elaboration of the package."  Does this include the elaboration of
visible declarations?  That seems a bit redundant.
!Action Taken:Yes it is but it provides a consistent appoach.  In modular development the Initializes aspect shows the intent - an initialization in the visible part is just one way of implementing that intent. No action taken.
!Checked By:  AH

!Label: STT039
!Location: 7.1.5 63/2:
!Description: "... [a] {an} input_list then ... in determining {the}
initialized value ..."
!Action Taken: Corrected as suggested.
!Checked By: AH

!Label: STT040
!Location: 7.1.6 63/(third from last):
!Description:
"1. An Initial_Condition aspect [may] {shall} only be placed ..."
(This "may only ..." usage appears many times in the LRM.  I won't
mention it further, but it should be fixed systematically, if at all.)
!Action Taken: Replaced as suggested.
!Checked By: AH

!Label: STT041
!Location: 7.1.6 63/(last):
!Description: Related to STT038 -- If a visible declaration is
initialized at its point of declaration, can it appear in
Initial_Condition but not in Initializes?  Does it need to appear in
Initial_Condition if it is initialized at its declaration point and not
in Initializes, and would that mean it still has the value it was given
at its declaration?
!Action Taken:A variable declared in the visible part of a package cannot be denoted in a Initial_Condition if it is not in the Initializes aspect [I know it is redundant but it keeps things simple - I am prepared to be convinced otherwise]. The Initializes aspect onls states that the variable will have a valid value, not what its value will be, so yes, the value could be changed duruing package elaboration and it is the value on completion of package elaboration that is given in the Initial_Condition aspect.  No action taken.
!Checked By: AH

!Label: STT042
!Location: 7.1.6 64/4:
!Description: You use "predicate" as a verb here.  Perhaps "... may only
[predicate] {depend on} properties of the state ..."
!Action Taken: Replaced as suggested.
!Checked By: AH

!Label: STT043
!Location: 7.2.1 65/4:
!Description: "... the constituents of each state_name [has] {have} to
be initialized ..."
!Action Taken: Corrected as suggested.
!Checked By: AH

!Label: STT044
!Location: 7.2.1 65/12,13:
!Description: Rules 4 and 5 don't read like "Legality Rules."  Should
rule 4 be a Name Resolution rule, and should rule 5 be restated with a
"shall"?
!Action Taken:Changed as suggested.
!Checked By: AH

!Label: STT045
!Location: 7.2.1 66/2:
!Description: "7. A constituent [denotes] {shall denote} ..."
!Action Taken: Replaced as suggested.
!Checked By: AH

!Label: STT046
!Location: 7.2.3 68/3:
!Description: Why is the limited_with_clause needed going from the
encapsulating package spec back to the private child?  Isn't it adequate
to have a "with" clause on the body of the encapsulating package?
Couldn't we just do a post-compilation check that the body of the
encapsulating package has such a "with" clause?  If we decide it is
cleaner to have the limited_with from the spec, it should probably be a
"limited private" with clause, since I think a normal "limited with"
would be illegal.
!Action Taken:For modular, constructive  analysis we cannot use post-compilation checks.  I think the current scheme is easier to check before all the code is written.  An alternative would be to record the information in the front end.  When an Abstract_State aspect has a Part_Of aspect, the package declaring the encapsuating state has to be with'd if it is not its parent, and in the internal representation of the package declaring the encapsulating state we record that the subordinate state is part of the encapsulating state.  I do not think this would be too hard to do and would be prefereble to the limited withs.
After discussing th the Tele-conf call it has been decided to take the approach outlined above.  Updated the rules and examples and added notes about analysis tools recording declarations containig Part_Of indicators.
!Checked By: AH

!Label: STT047
!Location: 7.2.3 68/4,6:
!Description:
"... associated with the declaration which denotes a{n} encapsulating ..."
"... a state abstraction named as a{n} encapsulating state ..."
!Action Taken: Corrected as suggested.
!Checked By: AH

!Label: STT048
!Location: 7.2.3 68/15:
!Description: As mentioned in STT046, this should probably be a "limited
private with P.Priv;" if it is needed at all.
!Action Taken:Removed limited with.
!Checked By: AH


!Label: STT049
!Location: 7.2.3 70/3:
!Description: Procedure Init_B1 should be indented relative to its
enclosing package Inner.
!Action Taken: Indentation corrected.
!Checked By: AH

!Label: STT050
!Location: 7.2.5 73/9:
!Description: "* No other global_items ... in the [a] Refined_Global
aspect ..."
!Action Taken: Replaced as suggested.
AH action not completed.
!Checked By: AH

!Label: STT051
!Location: 7.2.5 73/11:
!Description: This is a bit confusing.  It would be helpful if you
reiterated that this paragraph and the three that follow only apply when
the original Global mode was In_Out (rather than simply saying "When all
of these conditions are satisfied" perhaps say "For this special case of
Global mode In_Out ...").
!Action Taken:Update along the lines suggested.
!Checked By: AH


!Label: STT052
!Location: 7.2.6 74/(second to last):
!Description:
"Outputs in the [a] Refined_Depends aspect ..."
"Inputs in an input_list {shall} denote distinct entities."
!Action Taken: Corrected as suggested.
!Checked By: AH

!Label: STT053
!Location: 7.2.8 76/2:
!Description:
The default Refined_Post for an expression function is presumably:
Func'Result = <expr>.  This is not what this paragraph says.  Similarly,
the statement in 1.9.4 about "a postcondition may be recast as the
expression of an expression function" is a bit confusing, and perhaps
should be more explicit. Note that the statement in 1.9.4 should
probably be repeated in section 6.1.1 (and rephrased as appropriate).
!Action Taken:Updated 1.9.4 text again and noted same in 6.1.1 and made default Refined_Post explicit.
!Checked By: AH

!Label: STT054
!Location: 7.2.9 76/9:
!Description: "1. A[n] state abstraction ..."
!Action Taken: Corrected as suggested.
!Checked By: AH

!Label: STT055
!Location: 7.2.9 76/13:
!Description: "5. A state abstraction [which] {that} is specified as
just External state, referred to as a *plain External state* [and] {,}
may have constituents ..."
!Action Taken: Corrected as suggested.
!Checked By: AH


!Label: STT056
!Location: 7.2.9 77/1:
!Description: Don't we need "limited private with
Externals.{Temperature, Pressure, Main_Display, Secondary_Display}"
according to 7.2.3?
!Action Taken:Corrected example.
!Checked By: AH


!Label: STT057
!Location: 7.2.9 77/2:
!Description:
"procedure Display ... with Global => {(}Displays {=> Output)}"
Displays is Output_Only, so it needs to be used as an output.
!Action Taken: Corrected as suggested.
!Checked By: AH

!Label: STT058
!Location: 7.2.9 77/4:
!Description:
Typo in the comment:
"-- be In_Out and it is both {input} and an output. ...."
!Action Taken: Corrected as suggested.
!Checked By: AH

!Label: STT059
!Location: 7.2.9 77/6-78/3:
!Description: Why do we have "limited with Externals"?  These are
children of Externals, so the "limited with" is redundant.
!Action Taken:Corrected example.
!Checked By: AH

!Label: STT060
!Location: 7.7 81/9:
!Description: Static Semantics rule 3 seems to be a legality rule, while
Legality Rule 1 seems to be a Static Semantics rule.
!Action Taken:I have moved Static semantic rule 3 as the first legatity rule.  I have left the original legality rule 1 as as a second legality rule.  It would require some rewording to make this legality rule a semantic rule.  As it is it needs to follow what was semantic rule 3.  I think it is reasonable to leave the original legality rule 1 as a legality rule as it defines how the early call region is determined.
!Checked By: AH

!Label: STT061
!Location: 7.7 83/2:
!Description: What do you mean by "the freezing point of a tagged type
must meet the same restrictions as would be required for a call to each
of tis overriding primitive operations"?  I can't quite imagine how that
works.
!Action Taken: Updated by SBB. TJJ to review
!Checked By:

!Label: STT062
!Location: 7.7 83/9, 84/6:
!Description: It seems a bit weird to have a reference from the SPARK
lrm to the GNAT Pro user's guide.  Why don't we just incorporate the
rules rather than reference them (we could add a NOTE to say where the
rules came from)?
!Action Taken:Done as suggested.
!Checked By: AH


!Label: STT063
!Location: 7.7.1 85/3:
!Description: "... The implicit write associated with a read of [an]
external input{-}only state is permitted..."
!Action Taken: Corrected as suggested.
!Checked By: AH

!Label: STT064
!Location: 7.7.1 85/(last):
!Description: The extended example in 7.2.9 may need to be revised to
conform to these rules about pragma Elaborate of library units providing
constituents of a state abstraction.
!Action Taken:
Action to be completed after release to the advisory panel.
!Checked By:

!Label: AH/1
!Location: 1.9.4 Paragraph 2, Sentence 1, Page 11
!Description: Poor grammar in the first sentence, the use of "which"
seems clumsy.
!Action Taken: Sentence has now been rephrased.
!Checked By: AH

!Label: AH/2
!Location: 1.9.7 Final sentence
!Description: I was expecting more description of the abstraction of
volatile variables here. Could we at least add a forward reference to
the section on externals?
!Action Taken:Added reference to external state.  Changed the discussion of volatility to just variables - this is current but it looks like it will change again.
!Checked By: AH

!Label: AH/3
!Location: 1.10 Pg 16
!Description: The aims of this issue of the RM are different. The aim is
to fully define the main SPARK 2014 language features. Subsequent
updates for R1 are only expected to fix problems arising during
implementation of the tools.
!Action Taken: Replaced existing text with a paragraph modelled around your text.
!Checked By: AH

!Label: AH/4
!Location: 5.5.3 Page 30
!Description: There are a number of ToDos in here targeted for the
Milestone 3 version of this document but this is the Milestone 3 version.
It looks like these ToDos are complete.
!Action Taken: Done by Jon
!Checked By: AH

!Label: AH/5
!Location: 6.1.6 Page 48
!Description: This section contains several todos that a) don't have a
target milestone and b) do not use the standard ToDo syntax.
!Action Taken: Standard ToDo syntax used everywhere. Added target milestones (these need be reviewed).
!Checked By:

!Label: AH/6
!Location: General
!Description: Need to ensure that all ToDos have a milestone associated
with them.
!Action Taken: Confirmed. All ToDos have associated milestones (not sure if these are correct though).
!Checked By:


!Label: SM/1
!Location: General
!Description: We need to fix the problem with diff'ing & subscripts if
we are going to issue this to the AP. If this turns out to be too hard
then the alternative is to issue a change description.
!Action Taken: None. Unfortunately we don't know if it will be possible
               to generate a Diff pdf of the two revisions until we try
               and we need the final version of the LRM to do that.
!Checked By:

!Label: SM/2
!Location: 1.8 Page/para:  Page 7, second bullet from bottom
!Description: The added sentence at the end of the second bullet is
confusing: the previous point isn't about achieving 100% proof - its
about having the largest possible subset, and anyway 100% proof isn't
always achievable. So I think this needs to be something like
"maximising the percentage of VCs that can be automatically proved is a
core goal ...". I even wonder if the note is needed at all, but it is
presumably there as a result of an action from the previous review.
!Action Taken:Reworded as follows: "Note, however, that a core goal of
  is to provide a language expressive enough for the whole of a program
  to written in |SPARK| making it potentially entirely provable largely using
  automatic proof tools."
!Checked By:

!Label: SM/3
!Location: 6.1.3 - 6.1.6 Page/para: 39, 41, etc.
!Description: I think Trevor said he didn't want the Language definition
subheading in sections where High-Level Requirements had been removed,
but this has not been applied consistently, see eg. 6.1.3, 6.1.4, 6.1.5,
6.1.6.
!Action Taken:Done
!Checked By: AH


!Label: SBB_01
!Location: NA
!Description:
In
    "an legality rule given below"

"An" => "a".
    -- Steve

!Action Taken: Corrected as suggested.
!Checked By: AH


!Label: SBB_02
!Location: NA
!Description:
We've got:
    Apart from the legality rule that restricts the use of
    Loop_Invariant to a loop (see Loop Invariants, Variants and Entry
    Values).

I think that was supposed to be parenthesized and tacked onto the end of
the preceding sentence as a modifier.
!Action Taken:Done
!Checked By: AH

!Label: SBB_03
!Location: NA
!Description:
Typo in the following sentence:
if If it is a volatile variable it has to be specified as an an input
only or an output only external state.
!Action Taken: Corrected.
!Checked By: AH


!Label: SBB_04
!Location: source/subprograms.rst
!Description:
Typo in the following:
    specification of the outer subprogram has an entity deonted by a
!Action Taken: Corrected.
!Checked By: AH


!Label: SBB_05
!Location: source/packages.rst
!Description:We've got:
   A Refined_Global Aspect may only appear on a body_stub (if one is
   present) or the body (if no stub is present)
   of a subprogram which is declared in the visible part of a package
   and whose Global aspect denotes one or more
   state abstractions declared in the Abstract_State aspect of the
   package.

Hristian asked about the above wording.

Two issues:

    1) "may" makes it sound like a Refined_Global is never required.
       Is this the intent?

     2) I think "declared in the Abstract_State aspect of the package"
        should be "whose refinements are visible" and "visible part"
        should be "specification" (i.e. include private part).

      Consider:

           package Outer with Abstract_State => Foo is
           private
              package Inner is
                 procedure Proc with Global => Foo;
              end Inner;
           end Outer;

To make the singular/plural grammar less awkward, perhaps
     "whose Global aspect denotes at least one state abstraction
      whose refinement is visible"
!Action Taken: Changed the wording to the following:
#. A Refined_Global aspect shall be specified on a body_stub (if one is
   present) or subprogram body if and only if it has a declaration in the
   visible part of an enclosing package, the declaration has a
   Global aspect which denotes a state abstraction declared by the package and
   the refinement of the state abstraction is visible.
I do not agree with your suggestion of including the private part.  I added a restriction some time ago that a state abstraction cannot be mentioned in the private part of a package because the private part of a package is logically part of the body where the refinement is visible.  I think I discussed this with you.
I have also updated the text for Refined_Depends as this was worded similarly:
#. A Refined_Depends aspect shall be specified on a body_stub (if one is
   present) or subprogram body if and only if it has a declaration in the
   visible part of an enclosing package and the declaration has a
   Depends aspect which denotes a state abstraction declared by the package and
   the refinement of the state abstraction is visible.
!Checked By: AH

!Label: SBB_06
!Location: source/packages.rst
!Description:I think I identified a problem with my elaboration checking scheme in the case of a dispatching call where the callee that we dispatch to in turn calls anther subp whose body hasn't been elaborated yet.
I don't remember if this case is handled right - I'll check, but I may need to do something in that area.
!Action Taken:Steve looked this and decided there is not a problem.
!Checked By:AH

!Label: SBB_07
!Location:General
!Description:Just caught my eye, although you are already aware of this.
This is just a reminder.

   Pragma Loop_Variant is an assertion (as defined in RM 11.4.2(1.1/3))
   and is governed in the same way as pragma
   Assert by the Assert assertion aspect.

We changed our minds on this one and every assertion pragma gets its own assertion aspect. So the above is wrong.

Better would be
   Pragma Loop_Variant is an assertion (as defined in RM 11.4.2(1.1/3))
   and is governed
   Loop_Invariant is an assertion aspect[and
   may be used in an Assertion_Policy pragma].
!Action Taken: Under Dynamic Semantics:
...  Pragma Loop_Variant is an assertion (as defined in Ada RM 11.4.2(1.1/3)) and is governed by the Loop_Variant assertion aspect [and may be used in an Assertion_Policy pragma].

Similarly for Loop_Invariant:
Pragma Loop_Invariant is an assertion (as defined in Ada
   RM 11.4.2(1.1/3)) and is governed by the Loop_Invariant  assertion aspect
   [and may be used in an  Assertion_Policy pragma].
!Checked By:

!Label: SBB_08
!Location:7.2.3
!Description:No. A public child cannot see the body of its parent.
Bbb can see the refinement of Aaa_State in Aaa's body.

Are you saying that the following Refined_Global spec is illegal?

   package Aaa with State_Abstraction => Aaa_State,
                    Initializes => Aaa_State is
     package Bbb is
        procedure Ccc with Global => (In_Out => Aaa_State);
     end Bbb;
   end Aaa;

   package body Aaa
     with Refined_State => (Aaa_State => Body_Var) is
     Body_Var : Integer := 0;

     package Bbb is
        procedure Ccc with Refined_Global => (In_Out => Body_Var) is
        begin
            Body_Var := Body_Var / 2;
        end Ccc;
     end Bbb;
   end Aaa;


If so, then I'd like to discuss this.

!Action Taken:I have largely rewritten this section so that the above example is now legal.  This section needs to be carefully re-reviewed.
!Checked By:


!Label: JEB/01
!Location: General
Page/Para:
!Description: Desirable: Generally should legality rules be numbered,
some are not such as loops (5.5.3) or ghost functions (6.1.6).
!Action Taken:Ghost Functions, 6.1.6 updated; Section 5.5 Loops updated.
!Checked By:

!Label: JEB/02
!Location: 1.8
Page/Para: page 7, final sub-bullet of bullet 3
!Description: Mandatory: Worth making clear that the final sentence is
referring to the user supplying a contract, rather than a contract being
generated, as is being described in the penultimate sentence. At first
reading it appears that the tools might be able to generate shadow
annotations.
!Action Taken:Replaced text with "Parts of the program which
       are not compliant with |SPARK| subset cannot be fully verified by the
       tools but units containing such non-compliances may be represented by
       their declaration supplemented with |SPARK| specific aspects manually
       specified to give an accurate and truthful contract for the unit
       (see section :ref:`in_out` for further details)"
!Checked By:

!Label: JEB/03
!Location: 1.9.4
Page/Para: page 11, para 3
!Description:  Desirable: is it possible to reword to remove the double
use of the word "expression" in "expression of an expression function"
!Action Taken: Highlighted expression_function_declaration as a
syntactic term. Expression of an expression function declaration is Ada
terminology.
!Checked By: AH

!Label: JEB/04
!Location: 1.9.5
Page/Para: page 12, bullet 3
!Description: Mandatory:  It could be clearer at this point that legacy
code may not all be SPARK 2014. Otherwise it seems little different from
the first case.
!Action Taken:Done
!Checked By:

!Label: JEB/05
!Location: 1.9.5
Page/Para: page 12, final bullet
!Description: Desirable: make it cleared whether this is manual or
automatic. I suspect manual.
!Action Taken:Done.
!Checked By:

!Label: JEB/06
!Location: 3.1
Page/Para: page 17
!Description: Typo: please keep capitalisation of, for example
Default_Value / default_value consistent.
!Action Taken:
Default_Value is the correct Ada capitalisation.  I have made all
references to Default_Value consistent with this.  Additionally,
component_declarations should be emphasised as a syntactic term and a
record component has a default_expression (again a syntactic term)
rather than a Default_Value as originally stated.
!Checked By:

!Label: JEB/07
!Location: 4.5
Page/Para: page 25, para 1
!Description: Typo: "to reassociated" -> "to reassociate"
!Action Taken: Done.
!Checked By: AH

!Label: JEB/08
!Location: 4.5
Page/Para: page 25, para 1
!Description: Typo: are we using US or UK English for spelling of behaviour?
!Action Taken: US spelling is used throughout the document as in the Ada RM.
!Checked By: AH

!Label: JEB/09
!Location: 5.5.3
Page/Para: page29, para 2
!Description: Desirable: I find the wording of the first sentence
confusing, the LRM refers to Assertion policy not Assertion aspect.
!Action Taken:
Assertion policy is an Ada term which applies to all types of assertions
(which includes pre and post conditions).  I have tried to make this
clearer by adding the following note after assertion policy: [controlled
by the Ada Assertion_Policy pragma].
!Checked By: AH

!Label: JEB/10
!Location: 5.5.3
Page/Para: page 29, para 2/3
!Description: Desirable: could you use "ignored/checked" in place of
"disabled/enabled" to match the policy identifier values.
!Action Taken: Done.
!Checked By: AH

!Label: JEB/11
!Location: 5.5.3
Page/Para: page 31, first bullet
!Description: Desirable: replace "must" with "shall only", currently it
reads as if a post condition has to include and Old attribute.
!Action Taken:
Good point I have changed the test as you have suggested and also
replaced a must by a shall only in the note:
[Roughly speaking, a ``Loop_Invariant`` or ``Loop_Variant`` pragma
shall only occur immediately within a loop statement except that
intervening block statements are ignored for purposes of this rule.]

!Checked By: AH

!Label: JEB/12
!Location: 5.5.3
Page/Para: page 31
!Description: Mandatory: Is a Loop_Entry attribute reference permitted
within the prefix of a Loop_Entry attribute? (c.f. Old not permitted in
Old) but not explicitly covered by adopting rules for old attribute.
!Action Taken:
Well spotted.  I hope to rewrite this section to have rule numberings. I
will add an extra rule to prevent X'Loop_Entry'Loop_Entry.
!Checked By:

!Label: JEB/13
!Location: 6.1.1
Page/Para: page34, para 3
!Description: Typo: implmenting
!Action Taken: Done.
!Checked By: AH

!Label: JEB/14
!Location:  6.1.4
Page/Para: page36, Language Definition
!Description: Mandatory: Add comment about only specified for initial
declaration and reference to refined global aspect (c.f. depends).
!Action Taken:
Done.  I have also made it a legality rule for both Global and Depends
aspects as the implementer of these aspects did not realise that they
could be applied to a body stub if this is the initial declaration.
It was only mentioned in the text not as a rule.

!Checked By:  AH

!Label: JEB/15
!Location: 6.1.3
Page/Para: page 36, Note
!Description: Observation: At what point are the notes to be closed off?
As this is not a ToDo will it be tracked?
!Action Taken:
I think it is possible to track notes but I will address this note
(along with the todo regarding refined contract cases).

AH note not yet resolved.
!Checked By:

!Label: JEB/16
!Location:  6.1.4
Page/Para: page 37, Verification rule 1
!Description: Typo: why is global_item in quotes? Formatting problem?
!Action Taken: A missing space after the "A" - corrected.
!Checked By: AH

!Label: JEB/17
!Location: 6.1.4
Page/Para: page37, Verification rule 2 bullet 2
!Description: Mandatory: This needs to be reworded somehow, currently it
reads as if "is always fully initialised" is a consequence not a
determinator of mode. Perhaps it just needs the word "and" to be
inserted: "not an input and is always fully"
!Action Taken: Changed as suggested.
!Checked By: AH

!Label: JEB/18
!Location: 6.1.4
Page/Para: page 38, first line code comment
!Description: Mandatory: "does reference" should read "does not reference"
!Action Taken: Done.
!Checked By: AH

!Label: JEB/19
!Location: 6.1.5
Page/Para: page 40, Static Semantics item 4
!Description: Typo: "is the input_list of a null_dependency_clause"
word "of" is missing.
!Action Taken: Done.
!Checked By: AH

!Label: JEB/20
!Location: 6.1.5
Page/Para: page 40, Static Semantics item 8
!Description: Typo: implmentation.
!Action Taken: Done.
!Checked By: AH

!Label: JEB/21
!Location: 6.1.6
Page/Para: page 42
!Description: Typo: Something odd has happened to format of todo blocks
on this page.
!Action Taken: Done.
!Checked By: AH

!Label: JEB/22
!Location: 6.1.6,
Page/Para: page 42, 2nd todo
!Description: Observation: I don't think this should be allowed as it
could modify the depends relation.
!Action Taken:
At the moment we do not support the direct declaration of ghost
variables.  They can only occur as a local variable declared within a
ghost function.
When we do support ghost variables we need to consider carefully whether
they should be part of the dependency relations.  My feeling is that
they should not as they are not supposed to play any part in determining
the unexceptional operation of the program.  Whether we wish to allow
them to be part of an non-ghost state abstraction is another thing to
ponder.  My first thoughts are that one would want ghost variables to be
visible so they can be used in assertion expressions and having them as
state abstractions would not be very useful.

!Checked By: AH

!Label: JEB/23
!Location: 6.1.6
Page/Para: page 41, 3rd todo
!Description: Observation: It is not clear to me that this would be
permitted other than in the context of the completion of a ghost entity.
!Action Taken:
I am against using ghost entities in non-ghost code other than in
assertion expressions.  I will raise this again in the next language
conference call.
!Checked By:

!Label: JEB/24
!Location: 7.1.3
Page/Para: page 49, para 1
!Description: Typo: "considered to an" -> considered an"
!Action Taken: Done.
!Checked By: AH

!Label: JEB/25
!Location: 7.1.3
Page/Para: page 49, para 3
!Description: Typo: "if If" -> "If" and "an an" -> "an"
!Action Taken: Done.
!Checked By: AH

!Label: JEB/26
!Location: 7.1.3
Page/Para: page 49, legality rules 3 and 4
!Description: Mandatory: the restriction of the formal parameter to a
non-scalar seems contrary to the examples on page 50.
!Action Taken: Yes the examples were not updated properly - now corrected.
!Checked By: AH

!Label: JEB/27
!Location: 7.1.4
Page/Para: page 51, Syntax.
!Description: Typo? : should "state_name_with_" be
"state_name_with_options"?
!Action Taken: Yes - corrected.
!Checked By: AH

!Label: JEB/28
!Location: 7.1.4
Page/Para: page 52, Legality rule 2
!Description: Typo: why is option_list in quotes here?
!Action Taken: Space missing after "the" - corrected.
!Checked By: AH

!Label: JEB/29
!Location: 7.1.6
Page/Para: page 55, Legality rules
!Description: Typo: inconsistent use of underscore and capitalisation
"Initial_Condition aspect" and Initial Condition Aspect" I prefer the
former so correct item 4.
!Action Taken: Done (legality rule 4 no longer exists).
!Checked By:

!Label: JEB/30
!Location: 7.2.1
Page/Para: page 56, para 1
!Description: Typo: inconsistent use of underscore "Refined_State" and
"Refined State".
!Action Taken:
I'm not sure about this one.  In general we have introduced the aspects
without underscores but then, once having defined the aspect mark, used
the aspect mark.  The Ada RM seems to use the underscore version of a
pragma/aspect in headings and generally.  Perhaps we should do the same?
In the mean time I have made the first reference to Refined_State aspect
in the section headed State Refinement with the underscore.

!Checked By: AH

!Label: JEB/31
!Location: 7.2.1
Page/Para: page 56, para 1
!Description: Desirable: final sentence is hard to read. Could this be
split into two distinct statements.
!Action Taken: Done.
!Checked By: AH

!Label: JEB/32
!Location: 7.2.1
Page/Para: page 57, para 1
!Description: Typo : has -> have
!Action Taken: Done.
!Checked By: AH

!Label: JEB/33
!Location: 7.2.3
Page/Para: page 58, para 2
!Description: Typos : "visibility on the" -> "visibility of the" and
"the the" -> "the".
!Action Taken: Done.
!Checked By: AH

!Label: JEB/34
!Location: 7.2.3
Page/Para: page 59, para before Static Semantics
!Description: Desirable: add comma after "aliasing". Otherwise it reads
as "To resolve such aliasing rules".
!Action Taken: Done.
!Checked By: AH

!Label: JEB/35
!Location: 7.2.3
Page/Para: page 59, Legality Rule 4
!Description: Typo: "as a encapsulating" -> "as an encapsulating"
!Action Taken: Done.
!Checked By:

!Label: JEB/36
!Location: 7.2.3
Page/Para: page 60, para 1
!Description: Typo: "is known as" -> "are known as"
!Action Taken: Done.
!Checked By: AH

!Label: JEB/37
!Location: 7.2.3
Page/Para: page 60,  para 2
!Description: Typo: "a a " -> "a"
!Action Taken: Done.
!Checked By: AH

!Label: JEB/38
!Location: 7.2.5
Page/Para: page 64, Legality rule 2, final bullet
!Description:  Desirable: should the final sentence be a bullet point in
its own right. It is applicable more widely than to the remainder of
this bullet point.
!Action Taken: Done.
!Checked By: AH

!Label: JEB/39
!Location: 7.2.6
Page/Para: page 65, Legality Rules 2
!Description: Desirable: is this really a rule in its own right. It
seems to summarise the next rule.
!Action Taken:  I agree the rule mas been merged with the next.
!Checked By: AH

!Label: JEB/40
!Location: 7.2.6
Page/Para: page 66, para 1
!Description: Mandatory: The wording here very confusing I suggest
rewording. There are two key points that are misleading.
1)      The wording suggests that there is a unique result from the
input list refinement, this is not necessarily the case.
2)      The discussion of the union of "extra input_lists" could easily
be interpreted as not including the first refined input list, ie the one
that is not "extra".
!Action Taken: Rewording attempted.
!Checked By: AH

!Label: JEB/41
!Location: 7.2.7
Page/Para: page 66, Legality rule 1
!Description: Mandatory: Do you permit a refined precondition on a
body/body stub where there is no precondition on the subprogram spec,
noting that the verification rules would require that the precondition
is in fact True.
!Action Taken:
Agreed - text updated to say default precondition is True.
Added similar text to refined post condition.
!Checked By: AH

!Label: JEB/42
!Location: 7.2.9
Page/Para: page 68, Dynamic Semantics 5
!Description: Typo: "as plain External state and may" -> "as plain
External state, may"
!Action Taken:Done.
!Checked By: AH

!Label: JEB/43
!Location: 7.2.9
Page/Para: page 68, Dynamic Semantics 7
!Description: Desirable: This is a rule on Global Aspect that can only
be checked when analysing Refined_Global Aspect. Could it be reworded so
that Global Aspect with plain External that is not In_Out cannot be
refined in Refined_Gobal aspect to volatile state components.
!Action Taken: Yes that's better it covers the following rule too.  I
have removed the now redundant rule.
!Checked By: AH

!Label: JEB/44
!Location: 7.2.9
Page/Para: page 68, final comment in code
!Description: Typo: "is both and an" -> "is both an input and an"
!Action Taken: Done.
!Checked By: AH

!Label: JEB/45
!Location: 7.7
Page/Para: page 73, Legality rules para 2
!Description: Mandatory: "early call region of," There is something
missing here. I don't understand the first sentence.
!Action Taken: The "of" is superfluous and has been deleted.  The
sentence is still complex and is heavily couched in Ada speak, but
without the superflous "of" I think it make sense.
!Checked By: AH

!Label: JEB/46
!Location: 7.7
Page/Para: page 73, para 6
!Description: Typo: "earl" -> "early"
!Action Taken:Done.
!Checked By: AH

!Label: JEB/47
!Location: 7.7
Page/Para: General
!Description: Observation: I am not familiar with the Ada preelaboration
rules so have found this hard to review.
!Action Taken: Yes they are complex.  Steve wrote this bit and he is an
expert and they seem to make sense to me.
!Checked By: AH

!Label: JEB/48
!Location: Chapter 12
Page/Para: page 87, para 5
!Description: Typo : "reference any fixed" -> "references any fixed"
!Action Taken: Done.
!Checked By: AH

!Label: JEB/49
!Location:  13.12
Page/Para:  page 90, para 1
!Description: Typo : "Priofiles"!
!Action Taken: Done.
!Checked By: AH

!Label: JEB/50
!Location:  15.1.2
Page/Para:  page 95, Todo
!Description:  Observation: Yes please say which packages are supported
in SPARK 2014.
!Action Taken: This is still to be decided.  Some such as Standard are
included but others may require SPARK 2014 versions of some sort.
!Checked By: AH

!Label: JEB/51
!Location:  Appendix A
Page/Para:  General
!Description: Observation : I have not reviewed this section this time
around.
!Action Taken: Ok. AH will review this.
!Checked By:  AH


!Label: AH/7
!Location: A.1.3
!Description:  The ToDo in this section about false alarm management
needs resolving. pragma Warning() will be used.
!Action Taken: Mentioned that depending on the outcome of M423-014
either pragma Annotate or pragma Warning will
                be utilised to accept warnings/errors.
!Checked By: AH

!Label:  AH/8
!Location: Pairs_14.Additional_14
!Description: Code contains TBD: confirm that no inherits clause which
can be removed.
!Action Taken: Comment inside code has been removed!
!Checked By: AH

!Label: AH/9
!Location: A.2 Private/Public child visibility
!Description: ToDo in this section can be completed, we should discuss
how to handle this  I think we can just create SPARK 2014 equivalents
with addition of limited with clauses.
!Action Taken: Removed ToDo and mentioned that SPARK 2014 introduces no
visibility restrictions.
!Checked By: AH

!Label: AH/10
!Location: A.2 Private, abstract state, refining onto mixture of the above
!Description: Last sentence However, it is available under the
codeasm_abstract_state_refined_in_embedded_and_private_child. contains
an unresolved link.
!Action Taken: Added a missing '\'. This isn't an actual link. We don't
expect it to
                be resolved automatically. We simply say where the file
is located in
                the repository.
AH: most readers of this document will not have access to the
repository. We need to come up with another solution. I suggest we just
delete this sentence.
!Checked By: AH

!Label: AH/11
!Location: A.2.3
!Description: ToDo starting " Note that the syntax for identifying the
main program" is now redundant.
!Action Taken: Deleted ToDo.
!Checked By: AH

!Label: AH/12
!Location: Input driver using Append and Tail contracts
!Description: There will not be an equivalent of 'Tail in SPARK 2014,
however, we will be able to demonstrate how something equivalent to it
can be constructed using generics. Please set the ToDo Milestone to M4.
!Action Taken: Updated ToDo's text and set it to Milestone 4.
!Checked By: AH

!Label: AH/13
!Location: Complex I/O Device
!Description: I'm not sure why this section hasn't been completed.
Please discuss.
!Action Taken: I thought that there was syntax missing. But that
               actually was no longer the case. This section has now been completed.
!Checked By: AH

!Label: AH/14
!Location: Increasing values in input stream
!Description: Comment AH/11 applies here also.
!Action Taken: Applied the same ToDo as in AH/11.
!Checked By:  AH


!Label: AH/15
!Location: General (within the mapping spec)
!Description: There are still ToDos that mention milestone 3. As this
doc is the Milestone 3 doc we need to either complete the work or change the milestone. NB
todos containing : syntax is not yet defined" need to be implemented as
the syntax should be fully defined now.
!Action Taken: Mapping-spec's ToDos now mention Milestone 4 and
reference their relevant TN's (if possible).
!Checked By: AH

!Label: AH/16
!Location: 7.2.3
!Description: Typo "both and input and and output"
!Action Taken: Corrected.
!Checked By:

!Label: YM001
!Location: General
!Description: general comment: the order between "Dynamic Semantics" and "Verification Rules"
is sometimes reversed. This should be the same everywhere.
!Action Taken: "Verification Rules" now always come after "Dynamic Semantics".

NOT DONE - section 7.2.8 and 7.7.1
!Checked By:

!Label: YM002
!Location: 1.4 Method of Description
!Description: It says "Syntax: this section gives the format of the SPARK 2014 aspects and
pragmas." Why new attributes are not mentioned?
!Action Taken:Reworded less specifically: "Syntax: this section gives the format of any |SPARK| specific syntax."
!Checked By: AH

!Label: YM003
!Location: 1.4 Method of Description
!Description:It says: "simply provides explanatory detail." Should the plural be used?
"details"? (In the following, "detail" or "details" are used interchangeably
it seems, which one should be used in which case?)
!Action Taken:The subtleties of English. I think it is ok.  I will try to be
consistent elsewhere and in most places where it says further details, which I
think is fine also, but in a later heading we say Further Detail - will change that to Further Details.
!Checked By: AH

!Label: YM004
!Location: 1.8 SPARK 2014 Strategic Requirements
!Description:It says "SPARK 2014 shall complete by generation from the body code". I would
understand better "SPARK 2014 shall support completion of contracts by
generation from the body code".
!Action Taken:Reworded as "|SPARK| shall support synthesis of certain aspects from the body code"
!Checked By: AH

!Label: YM005
!Location: 1.8 SPARK 2014 Strategic Requirements
!Description:The last two strategic requirements are in fact the same.
!Action Taken:Re order the two subsections and changed wording in DO-333 subsection to indicate that we may go further than an unambiguous language.
!Checked By: AH

!Label: YM006
!Location: 1.8 SPARK 2014 Strategic Requirements
!Description:It says "guarantee that some implementation-dependent choice cannot effect the
externally-visible behavior of the program", but integer size is such an
implementation-dependent choice, and it clearly has an effect on program
behavior. So this paragraph should be rephrased.
!Action Taken: Added the caveat "other than the fundamental data types and
  constants" - I hope this is sufficient.
!Checked By: AH

!Label: YM007
!Location: 1.9.1 Principal Language Restrictions
!Description:It says "Aliasing of names is not permitted." It should add "(but renamings are allowed)".
!Action Taken:Added.
!Checked By: AH

!Label: YM008
!Location:4.4. Expressions
!Description:It mentioned Type_Invariant, which will be pushed after Release 1 probably, so should be removed here.
!Action Taken: Removed relevant bullet point.
!Checked By: AH

!Label: YM009
!Location:4.4. Expressions
!Description:It also mentions Type_Invariant'Class which should
definitely be removed. Or they should be mentioned in the note below for
Dynamic_Predicate that says:
!Action Taken: Covered by action taken for YM008.
!Checked By: AH

!Label: YM010
!Location:4.4. Expressions
!Description:It also mentions Type_Invariant'Class which should
definitely be removed. Or they should be mentioned in the note below for
Dynamic_Predicate that says: "[The Dynamic_Predicate rule is redundant because no use of the Dynamic_Predicate is currently in SPARK 2014. This rule is added in anticipation of the possible relaxation of that restriction.]"
!Action Taken: Duplicate of YM008 and YM009.
!Checked By: AH

!Label: YM011
!Location:5.5.3.1.
!Description:The Verification Rules for Loop_Variant should disappear, as part of the
general rule that run-time checks lead to proof obligations. And the "Checked
by Proof" subtitle should not be used anymore.
!Action Taken: Removed verification rule.
!Checked By: AH

!Label: YM012
!Location:5.5.3.2. Attribute Loop_Entry
!Description:It says: "These rules follow the corresponding Ada RM rule for 'Old" and
continues with a single rule. Should there be a list of rules here?
!Action Taken:Changed to singular as it relates to the rule given above.
!Checked By:

!Label: YM013
!Location:6.1.2. Subprogram Contracts
!Description:It mentions Pre'Class and Post'Class which should not be mentioned for that release.
!Action Taken: 'Class is no longer mentioned.
!Checked By:

!Label: YM014
!Location:6.1.3. Contract Cases
!Description:It says "Upon a call of a subprogram or entry which is subject to an enabled Contract_Cases aspect", but entries are not in SPARK 2014, so the reference to entry should be removed here.
!Action Taken: Removed "or entry".
!Checked By: AH

!Label: YM015
!Location:6.1.4. Global Aspects
!Description:There is a special case 7 in the legality rules that either should be removed
(as it is covered by the verification rules), or should be expanded to other
similar cases. Right now, it excludes:

   procedure P with Global => (Input => X) is
     procedure Loc with Global => (Output => X);

but it allows:

   procedure P with Global => null is
     procedure Loc with Global => (Output => X);
or
   procedure P with Global => null is
     procedure Loc with Global => (Input => X);
!Action Taken: These examples may be allowed if X is state declared within P but shouldn't be allowed if X is declared outside of P. Added new legality rule to cover this.
!Checked By: AH

!Label: YM016
!Location:6.1.4. Global Aspects
!Description:The dynamic semantics part just says: "There are no dynamic semantics
associated with a Global aspect." It would be better to copy here the rationale
given for Depends: "as it is used purely for static analysis purposes and is
not executed."
!Action Taken: Appended suggested rationale.
!Checked By: AH

!Label: YM017
!Location:6.1.5 Depends Aspects
!Description:Legality rule 11 mentions a "null output_list" where it should mention instead the null_dependency_clause.
!Action Taken: Corrected as suggested.
!Checked By: AH

!Label: YM018
!Location:6.1.5 Depends Aspects
!Description:Verification rule 3 is a consequence of rules 1 and 2, so should either be
removed, or given in brackets: "Each input of the implementation of a
subprogram body is denoted by an input of the Depends aspect of the
subprogram."
!Action Taken: Surrounded the rule in brackets.
!Checked By: AH

!Label: YM019
!Location:6.1.6. Ghost Functions
!Description:I find it very hard to understand because the rules mentions ghost variables,
ghost procedures and ghost functions, although only ghost functions are
currently in the language. It would be better to reword it for release 1 to
only mention ghost functions. (and keep the rest as comments or in a TN)
!Action Taken: Legality rule 1 explains that even thought the more general term "ghost entities"
               is used, it should be regarded as "ghost functions" for now.
!Checked By: AH

!Label: YM020
!Location:6.1.6. Ghost Functions
!Description:Besides, it says "Within a ghost procedure, a volatile non-global object shall
not be read.", but what about volatile global objects??? I guess they should
not be read either.
!Action Taken: Updated rule to disallow all volatile objects in general.
!Checked By: AH

!Label: YM021
!Location:6.4. Subprogram Calls
!Description:The reference to dispatching calls should be removed.
!Action Taken: Reference removed.
!Checked By: AH

!Label: YM022
!Location:6.4.2. Anti-Aliasing
!Description:The verification rules all start with "In SPARK 2014". There is no need for
such a precision in this document (and it's not given in other verification
rules).
!Action Taken: Deleted "In SPARK 2014".
!Checked By: AH

!Label: YM023
!Location:6.5. Return Statements
!Description:Any reason why extended_return_statements are not allowed? Actually, I have a
TN to implement those in proof! (M301-019)
!Action Taken: Changed to "No extensions or restrictions."
!Checked By: AH

!Label: YM024
!Location:7.1.1. Abstraction of State
!Description:Regarding the definition of the hidden state of a package P, what about the
hidden state of a package declared immediately within the private part or body
of P? It is not currently counted in the hidden state of P. It should.
TN to implement those in proof! (M301-019)
!Action Taken: Last bullet re-written.
!Checked By: AH

!Label: YM025
!Location:7.1.2. External State
!Description:It says "Ada aspects are used for specifying whether a variable is
external". It does not seem true, as External is not an Ada aspect.
!Action Taken: Added clarification of the actual ada aspects.
!Checked By: AH

!Label: YM026
!Location:7.1.2. External State
!Description:Since the legality rules "Nor shall it be denoted as an output/input of a
Depends aspect." are consequences of the other legality rules, should they be
in brackets?
!Action Taken: Added brackets.
!Checked By: AH

!Label: YM027
!Location:7.1.2. External State
!Description:Do Input_Only and Output_Only work well with the future aspects decribed by
Steve in M509-001?
  Assume_Unknown_Readers
  Assume_Unknown_Writers
  Read_Is_An_External_Effect
It does not look like it, which is a major problem for evolving the language
in a direction desired by our customers (Secunet in particular).
!Action Taken: This is part of the on-going discussion on Externals. Leave action open for draft 0.3. Section 1.10 updated to reflect this.
!Checked By:

!Label: YM028
!Location:
!Description:It says in legality rule 4 that "A package_declaration or
generic_package_declaration shall have a completion [(a body)] if it contains a
non-null Abstract_State aspect specification." What about the following
package?

  package P with Abstract_State => State is
    G : Integer;
  private
    L : Integer with Part_Of => State;
  end P;
!Action Taken: Rule has been updated. The new version addresses this issue.
!Checked By: AH

!Label: YM029
!Location:7.1.6. Initial Condition Aspect
!Description:I don't understand what it means for a state_name to "appear" or be
"referenced" in an Initial_Condition aspect, as alluded to in legality rules 3
and 4. Does State "appear" or is "referenced" in the following legal example?

  package P
    with Abstract_State => State,
         Initial_Condition => Get = 0
  is
    function Get return Integer with Global => State;
  private
    G : Integer with Part_Of => State;
    function Get return Integer is (G);
  end P;
!Action Taken: Wording changed to make this more clear.
!Checked By: AH

!Label: YM030
!Location:7.1.6. Initial Condition Aspect
!Description:The verification rule of Initial_Condition derives from its dynamic semantics, so should it be stated?
!Action Taken: Added brackets around the entire verification rule.
!Checked By: AH

!Label: YM031
!Location:7.1.6. Initial Condition Aspect
!Description:The verification rule states: "The Boolean expression of the Initial_Condition
aspect of a package shall only depend on properties of the state of the package
specifying the Initial_Condition aspect otherwise it will not be possible to
discharge the proof obligation by analysis of the package alone." which is
false. What about relying on other packages Initial_Condition?
!Action Taken: This text has been removed.
!Checked By: AH

!Label: YM032
!Location:7.2.2. Refined State Aspect
!Description:It says in static semantics rule 2: "A constituent with an option_list is used
to indicate the options that apply to the constituent." but there are no
option_list in the grammar for refinement_list.
!Action Taken: Removed rule (was out of synch with the syntax).
!Checked By: AH

!Label: YM033
!Location:7.2.4. Initialization Issues
!Description:It mentions "volatile states" in the verification rule, which does not match
the otherwise used terminology of "external state".
!Action Taken: Changed "volatile state" into "external state".

TODO still one usage of volatile states.
!Checked By:

!Label: YM034
!Location:7.3.2. Type Invariants
!Description:It says "will be completed for Milestone 3", I don't think we'll have time for
that, so I'd rather put it after Release 1.
!Action Taken: Updated as suggested.
!Checked By:

!Label: YM035
!Location:10.1.2.1.
!Description:The legality rules for where an abstract view of a variable is allowed exclude
Refined_Global and Refined_Depends. These should be added.
!Action Taken: Added Refined_Global and Refined_Depends as suggested.
!Checked By: AH

!Label: YM036
!Location:10.1.2.1.
!Description:Rule 3 in static semantics mentions the "volatile" characteristic of an
abstract view. Shouldn't it say "external"?
!Action Taken: Changed second "volatile" into "external".
!Checked By: AH

!Label: YM037
!Location:14. Shared Variable Control (Annex C.6)
!Description:It says "A volatile variable shall not be declared within the body of a
function, directly or indirectly." Is it the same as saying that a volatile
variable shall always be library-level?
!Action Taken:No it is saying that a volatile variable cannot be declared within a function body which is a lot less restrictive.  No action taken.
!Checked By: AH

!Label: TJJ001
!Location:1 Introduction
!Description:We have "... compiled and executed by any Ada 2012 implementation"
It need not be Ada 2012 but must avoiud 'Update, 'Loop_Entry and 'Old cannot
be used in a pragma.
!Action Taken:The new text is:
... "compiled by and executed by any Ada implementation; for
instance an Ada 95 compiler provided the use of Ada 2005 and Ada 2012 specific
features are avoided.  The |SPARK| attributes Update and Loop_Entry can be used
only if the Ada implementation supports them.  Additionally the attribute Old
can be used only in a postcondition and not in a pragma."
!Checked By: AH

!Label: TJJ002
!Location:1 Introduction - Requirements given in this document
!Description:The section does not really contain any information that is not covered elsewhere.  Delete the section.
!Action Taken:Copied the section to the parked HLR document and then deleted the section from the SPARK RM.
!Checked By: AH

!Label: TJJ002
!Location:1.3 How to Interpret ...
!Description:Need to add that the language description assumes that all
SPARK aspects are present.
!Action Taken:Added a paragraph to state this but also noted that some aspects
may be synthesized.
!Checked By: AH

!Label: TJJ003
!Location:1.4 Method of description
!Description:I do not think we need to put in all sections as stated, rather, we should adopt the scheme used by the Ada 2012 RM where a sections are only present as required.
!Action Taken:Removed the paragraph stating that they are aalways required.
!Checked By: AH

!Label: TJJ004
!Location:1.5 Formal Analysis
!Description: I think we should state the formal anlyses listed are static analysis techniques as we use this term elsewhere.
!Action Taken:Added this statement
!Checked By: AH

!Label: TJJ005
!Location:1.6 Dynamic....
!Description: I don't think we should use the terms dataflow or annotations.
!Action Taken:changed words to use flow analysis and drop annotations.
!Checked By: AH

!Label: TJJ005
!Location:1.6 Dynamic....
!Description:May be compiled and executed by any Ada 2012 implementation.  Why restrict it to Ada 2012
!Action Taken:changed words to any Ada implementation.
!Checked By: AH

!Label: TJJ007
!Location:1.7 Requirements given in this document
!Description:The section does not really contain any information that is not covered elsewhere.  Delete the section.
!Action Taken:Copied the section to the parked HLR document and then deleted the section from the SPARK RM.
!Checked By: AH

!Label: TJJ008
!Location:1.8 SPARK strategic requirements
!Description:This section should mention executable semantics and infinite integer arithmetic for assertion expressions.
!Action Taken:Added bulletted subsection to explain this.
!Checked By: AH

!Label: TJJ009
!Location:1.8 SPARK strategic requirements
!Description:The subsection on generative and retrospective needs rewriting it is not consistent with the rest of the RM.  The strategic requirement and its focus should be the synthesis of aspects rather than methods of analysis.
!Action Taken:Rewrote this section.
!Checked By: AH

!Label: TJJ010
!Location:1.8 SPARK strategic requirements
!Description:The subsection on code profiles needs to be more explicit as to why they are needed and when they might be used.
!Action Taken:Rewrote this section.
!Checked By: AH

!Label: TJJ011
!Location:1.8 SPARK strategic requirements
!Description:The subsection on interfacing with other languages is a bit of a jumble.  It repeats what is covered by the previous bullet point and what is
covered by the retrospective analysis subsection.
!Action Taken:Rewrote this section to make it specific to interfacing to languages other than Ada.
!Checked By: AH

!Label: TJJ012
!Location:1.8 SPARK strategic requirements
!Description:We should note that the security features are not due until after release 1.
!Action Taken:Done.
!Checked By: AH

!Label: TJJ013
!Location:1.9.1 Principal Language Restrictions
!Description:It is possible that a limited form of controlled types
could be supported in the future to support the container library. Similarly
we could extend the model of exceptions.
!Action Taken:I have added currently to the two relevant bullet points.
!Checked By: AH

!Label: TJJ014
!Location:1.9.1 Principal Language Restrictions
!Description:It is possible that a limited form of controlled types
could be supported in the future to support the container library. Similarly
we could extend the model of exceptions.
!Action Taken:I have added currently to the two relevant bullet points.
!Checked By: AH

!Label: TJJ015
!Location:1.9.2 Combining Formal ...
!Description:Change is only cost-effective to might be ...
!Action Taken:Done.
!Checked By: AH

!Label: TJJ016
!Location:1.9.3 Code profiles
!Description:In the Todo I think removing profies from the SPARK RM altogether
is a bad idea as they are an important feature - just as important as synthesis.
!Action Taken:Replace remove ... by Consider referencing ...
!Checked By: AH

!Label: TJJ017
!Location:1.9.4 Ghost Functions
!Description: Typo "|SPARK| currently supports ghost functions - though not ghost types or variables- which functions .."
!Action Taken:Corrected.
!Checked By: AH

!Label: TJJ018
!Location:1.9.5 Constructive, Generative, and ...
!Description:Change this section to be a section on synthesis of aspects.
Only introduce generative and retrospective analysis as way of using synthesized aspects.
!Action Taken:Done.
!Checked By: AH

!Label: AH/17
!Location:7.2.2 legality rule 3 note
!Description: The note "We may want to be able to override this error" should be removed.
!Action Taken:Deleted.

TODO not done
!Checked By:


!Label: AH/18
!Location: 7.2.3 para 1, sentence 1
!Description: The term "visible state" is potentially ambiguous, please consider expanding.
!Action Taken:Changed to "Each item of state dclared in the visible part ..."
!Checked By: AH

!Label: AH/19
!Location: 7.2.3 para 1, sentence 2
!Description: The last comma is unnecessary, please delete.
!Action Taken:Done.
!Checked By: AH

!Label: AH/20
!Location: 7.2.3 Para 6.
!Description:  The sentence "The following scenario:" would be easier to read if it was written "The fikkiwung scenario gives rise to ...:. I found myself reading the end of the sentence before reading the bullets.
!Action Taken:Changed to the following scenario gives rise to ...:

TODO superfluous full stop on the line folowing the bullets.
!Checked By:

!Label: AH/21
!Location: 7.2.5, Legality rule 4 last bullet
!Description:  The use of "them" in "one of them has" is ambiguous as it could be referring to the constituents of the abstract or the global_item.
!Action Taken:Reworded as "...  but denotes at least one ``constituent`` .."
!Checked By: AH

!Label: AH/22
!Location: Introduction
!Description: I'd recommend para 6 "The new aspects support ..." follows para 1
!Action Taken: Done.
!Checked By: AH

!Label: AH/23
!Location: Introduction para 4
!Description: Typo: "program to {be} compiled"
!Action Taken: Corrected.
!Checked By: AH

!Label: AH/24
!Location: Section 1.3, Todo and last sentence
!Description: I think the mapping spec has been updated. It certainly covers all of the aspects.
!Action Taken: Mapping spec has been updated. Removed the ToDo.
TODO last sentence also needs to change
!Checked By:

!Label: AH/25
!Location: Section 1.6 first para
!Description: Suggest the second sentence is reworded along the lines of: "The SPARK 2014 dynamic semantics are the same as Ada 2012 with the exception of some new aspects, pragmas and attributes which have dynamic semantics. Additionally, the new dynamic semantics only affect assertion expressions so if assertion expressions are ignored then the dynamic semantics of an Ada 2012 program are the same as a SPARK 2014 program."
!Action Taken: Replaced second sentence as suggested.
!Checked By: AH

!Label: AH/26
!Location: Section 1.6 second para
!Description: Typo: "with, say [with]"
!Action Taken: Corrected as suggested.
!Checked By: AH

!Label: AH/27
!Location: Section 1.8, 4th bullet
!Description: typo: on these contracts {as} early as
!Action Taken: Corrected as suggested.
!Checked By: AH

!Label: AH/28
!Location: Section 1.8 bullet 6
!Description: Typo: "code profile" -> "code policy"
!Action Taken: Corrected as suggested.
!Checked By: AH

!Label: AH/29
!Location:  Section 1.8 bullet beginning "Enhanced support for specifying ..."
!Description: Missing closing square bracket ].
!Action Taken: Added closing bracket.
!Checked By: AH

!Label: AH/30
!Location: Section 1.8 last bullet
!Description: Typo: "of {a} property is sound."
!Action Taken: Corrected as suggested.
!Checked By: AH

!Label: AH/31
!Location: Section 1.9.5
!Description:  "a [a]"
!Action Taken: Corrected
!Checked By:

!Label: AH/32
!Location: Section 1.9.7
!Description:  "read of {a} volatile variable"
!Action Taken: Corrected
!Checked By:

!Label: AH/33
!Location: Section 1.10
!Description:  Please state that there are some areas where there is currently significant discussion, e.g. "External" and refined pre/post.
Description 2, please reword to "There are two areas of the language where there is on-going significant discussion and so are likely to change. These areas are "Externals" and "Refined_Pre and Refined_Post."
!Action Taken: Done.
!Checked By:


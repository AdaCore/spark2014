\documentclass{article}

\usepackage[utf8]{inputenc}

\title{ALFA: Annotated Language for Functions in Ada}

\begin{document}

\maketitle
\sloppy
\section{Ada 2012}

Ada 2012 is the next version of the Ada standard, expected to be finalized in
2012. It contains many extensions that facilitate the expression of
specifications, for either dynamic or static checking.

\subsection{Standard}

The standard defines the following extensions to Ada 2005, which facilitate the
expression of specifications as subprogram contracts or type invariants:

\begin{itemize}
\item AI05-0001: bounded containers
\item AI05-0183: aspect specifications
\item AI05-0147: conditional expressions
\item AI05-0188: case expressions
\item AI05-0177: parameterized expressions
\item AI05-0176: quantified expressions
\item AI05-0146: type invariants
\item AI05-0153: subtype predicates
\end{itemize}

While the ARG website is the final authority on these extensions
(http://www.ada-auth.org/AI05-SUMMARY.HTML), we sketch in the following the
semantics and interest of each one.

Bounded containers introduce bounded versions of the existing generic
containers in Ada 2005 container library (vector, list, hashed set, ordered
set, hashed map, ordered map). The bound on the size of the container is used
to preallocate an array of the desired size, so that dynamic allocation is not
used for these containers. This opens up the possibility to perform proofs on
programs using containers, as the validity of cursors is far simpler in this
new model.

Aspect specifications allow defining contracts for subprograms, a contract
being a pair of a precondition (Pre) and a postcondition (Post). Special
contracts can also be issued for overriding, so that an overriding subprogram
can only weaken the inherited precondition and strengthen the inherited
postcondition. The standard defines a general syntax for aspects which allows
the definition of compiler-specific aspects, like the test-case aspect in GNAT
described below. In the postcondition, attribute 'Old applied on a name
indicates the value attached to this name at subprogram entry, and attribute
'Result applied to the name of the current function indicates the result
returned by this function. Preconditions and postconditions may be compiled
into executable assertions if the right option is given to the compiler (-gnata
in GNAT).  As an example, a contract for a square-root function is:

\begin{verbatim}
function Sqrt (X : Integer) return Integer with
  Pre  => X >= 0,
  Post => Sqrt'Result >= 0 and then
          Sqrt'Result ** 2 <= X and then
          (Sqrt'Result + 1) ** 2 > X;
\end{verbatim}

Conditional expressions and case expressions allow the use of 'if' and 'case'
in expressions, which simplifies specifications.

Parameterized expressions are a simple form of function definitions (or lambda
expressions) allowed in the specification part of a package. In particular,
simple boolean predicates on accessors to a (private) type, which are typically
the predicates one needs to write subprogram contracts, can be defined as
parameterized expressions. This has the advantage for proofs that parameterized
expressions (contrary to functions) 1) cannot have write side-effects, 2) have
a much simpler form than the usual functions, which is easier to translate into
proof predicates, 3) can be defined in a package specification which makes them
available for proof even if the package body is not.

Quantified expressions allow the expression of predicates which hold for all
elements in a range or a container, or for some element in a range or a
container.

Type invariants express invariant properties of private types, which should be
typically observed by any value of the type outside its package. However, the
standard only defines specific points at which this property is checked on a
value of the type, like entry and exit points of a subprogram. This does not
enforce by itself that the property always holds.

Subtype predicates express fine-grain properties of subtypes, like the various
enumeration values allowed for the discriminant of a record. Like for type
invariants, the standard only defines specific points at which this property is
checked.

\subsection{GNAT-Specific Extensions}

GNAT defines an aspect called Test\_Case, which applies to subprograms exactly
like the standard Pre and Post. A test-case is an aggregate with exactly three
components, all of which are compulsory:
\begin{itemize}
\item a Name component, of type string, which gives the name of the test-case;
\item a Requires component, of type boolean, which defines the entry condition
  for the test-case;
\item an Ensures component, of type boolean, which defines the exit condition
  for the test-case.
\end{itemize}

A test-case (N,Req,Ens) is a part of the specification which indicates that
under entry condition Req, the subprogram terminates with condition Ens. Thus,
the Requires component bears much resemblance with the precondition, and the
Ensures component bears much resemblance with the postcondition. Indeed, they
share the same semantic restrictions (w.r.t. 'Old and 'Result).  More than one
test-case can be defined for a subprogram. No two test-cases on a subprogram
should have the same name.

Contrary to preconditions and postconditions, test-cases are not compiled into
executable assertions by the compiler. GNAT only checks that test-cases are
properly defined. Test-cases should be used by the verification toolkit either
for unit testing or for unit proof.

For unit testing, it is sufficient to write a test procedure which exercises a
test-case to consider this test-case successful. To exercise a test-case, a
test procedure must in order:
\begin{enumerate}
\item generate suitable arguments, by calling one or more subprograms
  called \textit{fixtures};
\item check that the requires is satisfied on these arguments;
\item optionally check that the precondition is satisfied on these arguments;
\item call the subprogram tested on these arguments;
\item optionally check that the postconditions is satisfied on these arguments;
\item check that the ensures is satisfied.
\end{enumerate}

The part about checking the contract of the subprogram is optional because some
test-cases may correspond to cases beyond the normal behavior of the subprogram
described in its contract. Typically, robustness tests deal with such abnormal
behavior.

For unit proof, it is sufficient to prove that the subprogram implements a
special contract, with:
\begin{itemize}
\item the requires, optionally and'ed with the original precondition, as
  precondition;
\item the ensures as postcondition.
\end{itemize}

The original precondition should be and'ed with the requires for those
test-cases which correspond to normal behavior, and the requires should be the
only precondition for those test-cases which correspond to abnormal behavior.

As an example, a contract with test-cases for an integer square-root function
is:

\begin{verbatim}
function Sqrt (X : Integer) return Integer with
  Pre  => X >= 0,
  Post => Sqrt'Result >= 0 and then
          Sqrt'Result ** 2 <= X and then
          (Sqrt'Result + 1) ** 2 > X,
  Test_Case => (Name     => "test case 1",
                Requires => X = 100, 
                Ensures  => Sqrt'Result = 10),
  Test_Case => (Name     => "test case 2",
                Requires => X < 100, 
                Ensures  => Sqrt'Result >= 0 and then 
                            Sqrt'Result < 10);
\end{verbatim}

\section{ALFA}

ALFA is a sub-language of Ada 2012 which identifies which subprograms are fit
for formal verification. ALFA does not work as an Ada profile, as the complete
program does not need to be in ALFA for individual subprograms to be in
ALFA. Rather, subprograms are in ALFA or not depending exclusively on their
specification and body. In particular, the location in the source where a
subprogram is defined (inside a package or another subprogram, in the public or
private part, etc.) should not influence whether it is in ALFA.

\subsection{ALFA Extensions}

ALFA considers that the pragma Assert immediately at the start of a loop
statement list have a special meaning. They define a loop-invariant for this
loop, which is used for unit proof.  As an example, the following
implementation of the integer square-root function has a loop-invariant:

\begin{verbatim}
function Sqrt (X : Integer) return Integer is
   Res, Two_Res, Res_Square : Integer := 0;
begin
   while Res_Square <= X loop
      pragma Assert (Res >= 0 and then
                     Two_Res = 2 * Res and then
                     Res_Square = Res * Res);
      Res_Square := Res_Square + Two_Res + 1;
      Two_Res    := Two_Res + 2;
      Res        := Res + 1;
  end loop;
  return Res - 1;
end Sqrt;
\end{verbatim}

The loop-invariant to be used for unit proof should be:
\begin{itemize}
\item true the first time the loop is entered;
\item provable from assuming it at some previous iteration through the loop and
  examining the effect of the loop body.
\end{itemize}

ALFA introduces a new form of containers called the verified containers, to be
used for proof of programs which manipulate containers. These are a variant of
bounded containers, with a different API meant to facilitate proofs.

\subsection{ALFA Restrictions}

\newcommand{\bnf}[1]{$\mathit{#1}$}

In the following, we refer to entities in the program with the name of the
corresponding non-terminal in the Ada BNF, like \bnf{subprogram\_body} for a
subprogram body. As a general rule, an entity is in ALFA only if all its
sub-entities which define it are in ALFA. As an example, a
\bnf{subprogram\_body} is defined in Ada BNF as:

\begin{verbatim}
subprogram_body ::=
  [overriding_indicator]
  subprogram_specification is
    declarative_part
  begin
    handled_sequence_of_statements
  end [designator];
\end{verbatim}

Thus, a \bnf{subprogram\_body} is in ALFA only if its
\bnf{overriding\_indicator} (if present), its \bnf{subprogram\_specification},
its \bnf{declarative\_part}, its \bnf{handled\_sequence\_of\_statements} and
its \bnf{designator} are in ALFA.

The additional rules below further restrict which entities are in ALFA.

\subsubsection{Lexical Elements}
\subsubsection{Declarations}
\subsubsection{Names and Expressions}
\subsubsection{Statements}
\subsubsection{Subprograms}

A subprogram is in ALFA if both its specification and its body are in ALFA,
when present. Notice that if a subprogram F calls directly a subprogram G, then
for F to be in ALFA, G's specification needs to be in ALFA.

A subprogram specification is in ALFA if:
\begin{enumerate}
\item All parameters and return are in ALFA;
\item The subprogram has a postcondition;
\item The contract of the subprogram is in ALFA.
\end{enumerate}

A contract is in ALFA if all expressions appearing in precondition,
postcondition and test-cases are specification expressions in ALFA. The
requirement that a subprogram has a postcondition ensures that the user states
desired properties to prove on this subprogram, and that callers can rely on a
precise indication of what this subprogram does. Of course, such a
postcondition can be simply 'True' in which case the user chooses not to give
any more precise information.

A specification expression in ALFA is an expression in ALFA which appears as
part of a contract or an invariant, and:
\begin{enumerate}
\item It may contain calls to parameterized expressions, but no calls to
  functions;
\item It may contain uses of verified containers, but no uses of other
  containers.
\end{enumerate}

A subprogram body is in ALFA if:
\begin{enumerate}
\item The corresponding subprogram specification is in ALFA;
\item All declarations in its declarative part are in ALFA;
\item It has no exception handler;
\item All statements in its sequence of statements are in ALFA.
\end{enumerate}

In particular, all calls in a body should be to subprograms whose specification
is in ALFA for the body to be ALFA.

\subsubsection{Package Specifications and Declarations}
\subsubsection{Use Clauses}
\subsubsection{Tasks and Synchronisation}
\subsubsection{Program Structure and Compilation Issues}
\subsubsection{Exceptions}
\subsubsection{Generic Units}
\subsubsection{Representation Issues}

More generally, the definition of which constructs are in ALFA or not should be
derived from the report written by Marc Sango for his internship on the
definition of a verification profile for Ada. Note that uses of 'or/and' are
not in ALFA whereas uses of 'or else/and then' are in ALFA.

\section{Translation to SPARK / Why}

A subprogram in ALFA should be translated into an intermediate representation
in SPARK or in Why. From this representation, the Examiner or Why tools can
generated Verification Conditions (VCs) to prove using an automatic prover.  In
order to facilitate fine-grain modular proof, each subprogram should lead to
the generation of a separate unit (package in SPARK, module in Why), which can
be proved independently. Notice that the generated SPARK is not executable, and
does not match in general the structure of the source Ada program, even if this
program is written in the SPARK subset of Ada. Ideally, the generated SPARK
should correspond to a simple subset of SPARK (for example no need for
visibility rules in this subset as everything is public). Thus, it should be
easier to formalize this subset and prove the correctness of transformations or
analyzes on this subset if needed.

\subsection{Generation of Annotations}

A valid SPARK or Why subprogram needs to indicate explicitly which global
variables can be read and/or written during the execution of this
subprogram. As this information is not present in the source Ada program, it
must be generated by our translation. As these reads and writes must account
for direct and indirect accesses, through any number of calls, this global
information must be retrieved by performing a global analysis on the closed set
of subprograms called directly and indirectly.

A special global variable called Heap represents all the dynamically allocated
memory, so that reads and writes to dynamically allocated memory show in SPARK
or Why contracts as reads and writes to Heap. Notice that without this Heap
variable, contracts would be wrong and break the consistency of the proof
system. For example, it would be possible to prove that Problem below always
returns True, because Set would be seen as a noop, and Get would be seen as a
constant function:

\begin{verbatim}
X : access Integer;

procedure Set is
   X.all := 0;
end Set;

function Get return Integer is
begin
   return X.all;
end Get;

function Problem return Boolean is
   X1 : Integer := Get;
begin
   Set;
   return X1 = Get;
end Problem;
\end{verbatim}

Contracts (precondition and postcondition) in SPARK and Why have a
slightly different semantics than contracts in Ada 2012, because contracts in
SPARK and Why completely ignore the possibility of a run-time error being
raised while evaluating the contract. When checking for absence of run-time
errors (which can be separated from contract checking), the absence of run-time
errors in contracts should also be proved, which requires the extension of
contracts with additional conjuncts in SPARK and Why. For example, the
following contract in Ada:

\begin{verbatim}
function Get (A : My_Array; X : Integer) return Element
   with Pre => A (X) /= Nil_Element;
\end{verbatim}

would become in SPARK:

\begin{verbatim}
function Get (A : My_Array; X : Integer) return Element;
--# pre X in My_Array'Range and then A (X) /= Nil_Element;
\end{verbatim}

\subsection{General Architecture}

The first requirement is to break the mutual dependencies between packages and
between subprograms in Ada, in order to 1) achieve modular verification at the
subprogram level and 2) prevent circular dependencies between units and between
elements of units, which are either not supported or supported with
restrictions in both SPARK and Why. These mutual dependencies come from
recursion between subprograms as well as cross calls between packages (P.F
calls Q.G which calls P.H) even without recursion. To that end, each
declarative part leads to the generation of two units: one for the data+types
of this declarative part, one for the subprogram specifications of this
declarative part.

As an example, a package P defining data and subprograms should lead to the
generation of a unit P\_Data for its data+types and P\_Spec for its subprogram
specifications. Then, a subprogram P.F in ALFA should be translated into the
only subprogram in unit P\_F, which manipulates data from P\_Data and calls
subprograms from P\_Spec (including potential calls to F in P\_Spec, which
correspond to recursive calls in the source program).

As another example, a subprogram F in ALFA defining local variables and local
subprograms should lead to the generation of a unit F\_Data for its local
variables and F\_Spec for its local subprogram specifications. Then, F's body
should be translated into the only subprogram in unit F, which manipulates data
from F\_Data and calls subprograms from F\_Spec.

Thus, the generated units should be layered in:
\begin{enumerate}
\item $<$data$>$: units which define global data in SPARK or Why, corresponding
  to either global or local variables in Ada. These units also define types.
\item $<$spec$>$: units which define subprogram specifications in SPARK or Why,
  corresponding to all subprograms specifications and definitions in Ada. These
  units also define parameterized expressions.
\item $<$body$>$: units which define a single subprogram specification and body
  in SPARK or Why from a subprogram in ALFA.
\end{enumerate}

\end{document}
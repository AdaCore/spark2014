\documentclass{article}

\usepackage[utf8]{inputenc}

\title{ALFA: Annotated Language of Functions in Ada}

\newcommand{\bnf}[1]{$\mathit{#1}$}

\begin{document}

\maketitle
\sloppy
\section{Ada 2012}

Ada 2012 is the next version of the Ada standard, expected to be finalized in
2012. It contains many extensions that facilitate the expression of
specifications, for either dynamic or static checking.

\subsection{Introduction to Ada}

\subsection{New in Ada 2012}

The standard defines the following extensions to Ada 2005, which facilitate the
expression of specifications as subprogram contracts or type invariants:

\begin{itemize}
\item AI05-0001: bounded containers
\item AI05-0183: aspect specifications
\item AI05-0147: conditional expressions
\item AI05-0188: case expressions
\item AI05-0177: parameterized expressions
\item AI05-0176: quantified expressions
\item AI05-0146: type invariants
\item AI05-0153: subtype predicates
\end{itemize}

While the ARG website is the final authority on these extensions
(http://www.ada-auth.org/AI05-SUMMARY.HTML), we sketch in the following the
semantics and interest of each one.

Bounded containers introduce bounded versions of the existing generic
containers in Ada 2005 container library (vector, list, hashed set, ordered
set, hashed map, ordered map). The bound on the size of the container is used
to preallocate an array of the desired size, so that dynamic allocation is not
used for these containers. This opens up the possibility to perform proofs on
programs using containers, as the validity of cursors is far simpler in this
new model.

Aspect specifications allow defining contracts for subprograms, a contract
being a pair of a precondition (Pre) and a postcondition (Post). Special
contracts can also be issued for overriding, so that an overriding subprogram
can only weaken the inherited precondition and strengthen the inherited
postcondition. The standard defines a general syntax for aspects which allows
the definition of compiler-specific aspects, like the test-case aspect in GNAT
described below. In the postcondition, attribute 'Old applied on a name
indicates the value attached to this name at subprogram entry, and attribute
'Result applied to the name of the current function indicates the result
returned by this function. Preconditions and postconditions may be compiled
into executable assertions if the right option is given to the compiler (-gnata
in GNAT).  As an example, a contract for a square-root function is:

\begin{verbatim}
function Sqrt (X : Integer) return Integer with
  Pre  => X >= 0,
  Post => Sqrt'Result >= 0 and then
          Sqrt'Result ** 2 <= X and then
          (Sqrt'Result + 1) ** 2 > X;
\end{verbatim}

Conditional expressions and case expressions allow the use of 'if' and 'case'
in expressions, which simplifies specifications.

Parameterized expressions are a simple form of function definitions (or lambda
expressions) allowed in the specification part of a package. In particular,
simple boolean predicates on accessors to a (private) type, which are typically
the predicates one needs to write subprogram contracts, can be defined as
parameterized expressions. This has the advantage for proofs that parameterized
expressions (contrary to functions) 1) cannot have write side-effects, 2) have
a much simpler form than the usual functions, which is easier to translate into
proof predicates, 3) can be defined in a package specification which makes them
available for proof even if the package body is not.

Quantified expressions allow the expression of predicates which hold for all
elements in a range or a container, or for some element in a range or a
container.

Type invariants express invariant properties of private types, which should be
typically observed by any value of the type outside its package. However, the
standard only defines specific points at which this property is checked on a
value of the type, like entry and exit points of a subprogram. This does not
enforce by itself that the property always holds.

Subtype predicates express fine-grain properties of subtypes, like the various
enumeration values allowed for the discriminant of a record. Like for type
invariants, the standard only defines specific points at which this property is
checked.

\subsection{GNAT-Specific Extensions}

GNAT defines an aspect called Test\_Case, which applies to subprograms exactly
like the standard Pre and Post. A test-case is an aggregate with exactly three
components, all of which are compulsory:
\begin{itemize}
\item a Name component, of type string, which gives the name of the test-case;
\item a Requires component, of type boolean, which defines the entry condition
  for the test-case;
\item an Ensures component, of type boolean, which defines the exit condition
  for the test-case.
\end{itemize}

A test-case (N,Req,Ens) is a part of the specification which indicates that
under entry condition Req, the subprogram terminates with condition Ens. Thus,
the Requires component bears much resemblance with the precondition, and the
Ensures component bears much resemblance with the postcondition. Indeed, they
share the same semantic restrictions (w.r.t. 'Old and 'Result).  More than one
test-case can be defined for a subprogram. No two test-cases on a subprogram
should have the same name.

Contrary to preconditions and postconditions, test-cases are not compiled into
executable assertions by the compiler. GNAT only checks that test-cases are
properly defined. Test-cases should be used by the verification toolkit either
for unit testing or for unit proof.

For unit testing, it is sufficient to write a test procedure which exercises a
test-case to consider this test-case successful. To exercise a test-case, a
test procedure must in order:
\begin{enumerate}
\item generate suitable arguments, by calling one or more subprograms
  called \textit{fixtures};
\item check that the requires is satisfied on these arguments;
\item optionally check that the precondition is satisfied on these arguments;
\item call the subprogram tested on these arguments;
\item optionally check that the postconditions is satisfied on these arguments;
\item check that the ensures is satisfied.
\end{enumerate}

The part about checking the contract of the subprogram is optional because some
test-cases may correspond to cases beyond the normal behavior of the subprogram
described in its contract. Typically, robustness tests deal with such abnormal
behavior.

For unit proof, it is sufficient to prove that the subprogram implements a
special contract, with:
\begin{itemize}
\item the requires, optionally and'ed with the original precondition, as
  precondition;
\item the ensures as postcondition.
\end{itemize}

The original precondition should be and'ed with the requires for those
test-cases which correspond to normal behavior, and the requires should be the
only precondition for those test-cases which correspond to abnormal behavior.

As an example, a contract with test-cases for an integer square-root function
is:

\begin{verbatim}
function Sqrt (X : Integer) return Integer with
  Pre  => X >= 0,
  Post => Sqrt'Result >= 0 and then
          Sqrt'Result ** 2 <= X and then
          (Sqrt'Result + 1) ** 2 > X,
  Test_Case => (Name     => "test case 1",
                Requires => X = 100, 
                Ensures  => Sqrt'Result = 10),
  Test_Case => (Name     => "test case 2",
                Requires => X < 100, 
                Ensures  => Sqrt'Result >= 0 and then 
                            Sqrt'Result < 10);
\end{verbatim}

\section{ALFA}

ALFA is a sub-language of Ada 2012 which identifies which subprograms are fit
for formal verification. ALFA does not work as an Ada profile, as the complete
program does not need to be in ALFA for individual subprograms to be in
ALFA. Rather, subprograms are in ALFA or not depending exclusively on their
specification and body. In particular, the location in the source where a
subprogram is defined (inside a package or another subprogram, in the public or
private part, etc.) should not influence whether it is in ALFA.

\subsection{ALFA Extensions}

ALFA considers that the pragma Assert immediately at the start of a loop
statement list have a special meaning. They define a loop-invariant for this
loop, which is used for unit proof.  As an example, the following
implementation of the integer square-root function has a loop-invariant:

\begin{verbatim}
function Sqrt (X : Integer) return Integer is
   Res, Two_Res, Res_Square : Integer := 0;
begin
   while Res_Square <= X loop
      pragma Assert (Res >= 0 and then
                     Two_Res = 2 * Res and then
                     Res_Square = Res * Res);
      Res_Square := Res_Square + Two_Res + 1;
      Two_Res    := Two_Res + 2;
      Res        := Res + 1;
  end loop;
  return Res - 1;
end Sqrt;
\end{verbatim}

The loop-invariant to be used for unit proof should be:
\begin{itemize}
\item true the first time the loop is entered;
\item provable from assuming it at some previous iteration through the loop and
  examining the effect of the loop body.
\end{itemize}

ALFA introduces a new form of containers called the formal containers, to be
used for proof of programs which manipulate containers. These are a variant of
bounded containers, with a different API meant to facilitate proofs.

\subsection{ALFA Restrictions}

In the following, we refer to entities in the program with the name of the
corresponding non-terminal in the Ada BNF, like \bnf{subprogram\_body} for a
subprogram body. As a general rule, an entity is in ALFA only if all its
sub-entities which define it are in ALFA. As an example, a
\bnf{subprogram\_body} is defined in Ada BNF as:

\begin{verbatim}
subprogram_body ::=
  [overriding_indicator]
  subprogram_specification is
    declarative_part
  begin
    handled_sequence_of_statements
  end [designator];
\end{verbatim}

Thus, a \bnf{subprogram\_body} is in ALFA only if the following are in ALFA:
\begin{itemize}
\item its \bnf{overriding\_indicator} (if present);
\item its \bnf{subprogram\_specification};
\item its \bnf{declarative\_part};
\item its \bnf{handled\_sequence\_of\_statements};
\item its \bnf{designator} (if present).
\end{itemize}

This general rule applies individually to every production rule in the BNF
which define program entities. Thus, some production rules defining a
non-terminal may be in ALFA while others for the same non-terminal are not in
ALFA.

The additional rules below further restrict which entities are in ALFA. These
rules build on the report written by Marc Sango for his internship on the
definition of a verification profile for Ada. 

\subsubsection{Lexical Elements}

No special rules.

\subsubsection{Declarations}

All entities related to access types are not in ALFA:
\begin{itemize}
\item the \bnf{aliased} keyword, wherever it appears;
\item \bnf{access\_type\_definition};
\item \bnf{access\_to\_object\_definition};
\item \bnf{general\_access\_modifier};
\item \bnf{access\_to\_subprogram\_definition};
\item \bnf{null\_exclusion};
\item \bnf{access\_definition}.
\end{itemize}

\noindent
[what about \bnf{aspect\_clause} in \bnf{component\_item}?]\\

Note in particular that a \bnf{default\_expression} in a
\bnf{component\_declaration} is allowed, as well as a \bnf{variant\_part} in
a \bnf{component\_list}.

\subsubsection{Names and Expressions}

An \bnf{identifier} or a \bnf{name} which has a corresponding declaration is in
ALFA if-and-only-if its declaration is in ALFA. As a consequence, a call is in
ALFA only if the declaration of the subprogram called is in ALFA.\\

\noindent
[what about \bnf{aspect\_clause} in \bnf{basic\_declarative\_item}?]\\

All entities related to access types are not in ALFA:
\begin{itemize}
\item \bnf{explicit\_dereference};
\item \bnf{implicit\_dereference};
\item the \bnf{Access} terminal defining an \bnf{attribute\_designator};
\item the \bnf{null} terminal defining a \bnf{primary};
\item \bnf{allocator}.
\end{itemize}

Uses of the keywords \bnf{and}, \bnf{or} and \bnf{xor} are not in ALFA. Only
the keywords for the lazy operations \bnf{and\ then} and \bnf{or\ else} are in
ALFA.\\

An expression in ALFA which appears as part of a contract or an invariant must
respect additional constraints:
\begin{enumerate}
\item it may contain calls to parameterized expressions, but no calls to
  functions;
\item it may contain uses of formal containers, but no uses of other
  containers.
\end{enumerate}

\subsubsection{Statements}

\noindent
\bnf{goto\_statement} is not in ALFA.

Note in particular that all possible \bnf{exit\_statement} are in ALFA,
including those which exit an outter loop.

\subsubsection{Subprograms}

A subprogram may have both a \bnf{subprogram\_declaration} and a
\bnf{subprogram\_body}. Such a subprogram is in ALFA only if both its
declaration and body are in ALFA. Additionally, the subprogram should have a
postcondition attached to its declaration. The requirement that a subprogram
has a postcondition ensures that the user states desired properties to prove on
this subprogram, and that callers can rely on a precise indication of what this
subprogram does. Of course, such a postcondition can be simply 'True' in which
case the user chooses not to give any more precise information.

Note that \bnf{extended\_return\_statement} is in ALFA.

\subsubsection{Package Specifications and Declarations}

No special rules. In particular, renamings and the optional statements in a
package body are in ALFA.

\subsubsection{Use Clauses}

No special rules.

\subsubsection{Tasks and Synchronisation}

Most probably, the same restrictions as in RavenSPARK should be enforced for
the sequential verification to apply to the concurrent code.

\subsubsection{Program Structure and Compilation Issues}

No special rules.

\subsubsection{Exceptions}

All entities related to exception handling are not in ALFA:
\begin{itemize}
\item \bnf{exception\_handler};
\item \bnf{choice\_parameter\_specification};
\item \bnf{exception\_choice}.
\end{itemize}

\subsubsection{Generic Units}

No special rules.

\subsubsection{Representation Issues}

[To be discussed.]

\section{Formal Verification}

All of data-flow verification, contract verification and verification of
absence of run-time errors can be performed independently. The results of
contract verification and verification of absence of run-time errors are only
valid if data-flow is correct, which in practice means that data-flow
verification should be performed as a pre-requisite.

\subsection{Data-Flow Verification}

The \bnf{mode} part of a \bnf{parameter\_specification} has a stronger
semantics in ALFA than in Ada, similar to what is found in SPARK:
\begin{itemize}
\item a \bnf{parameter\_specification} of mode \bnf{in} must be initialized at
  subprogram entry, and there must exist at least one syntactic path through
  the subprogram which reads it;
\item a \bnf{parameter\_specification} of mode \bnf{out} must be initialized on
  all syntactic paths through the subprogram before reaching subprogram exit;
\item a \bnf{parameter\_specification} of mode \bnf{in\ out} must be initialized
  at subprogram entry, and there must exist at least one syntactic path through
  the subprogram which assigns to it before reaching subprogram exit.
\end{itemize}

Likewise, reads of variables are only allowed if all syntactic paths through
the subprogram before reaching the read do initialize the complete aggregate
object from which a part is read. This restriction is similar to the SPARK
one. It applies both to local variables and parameters.

[need expansion of what is a data-flow error, regarding useless computations]

\subsection{Contract Verification}

\subsection{Verification of Absence of Run-Errors}


\section{Translation to SPARK / Why}

A subprogram in ALFA should be translated into an intermediate representation
in SPARK or in Why. From this representation, the Examiner or Why tools can
generated Verification Conditions (VCs) to prove using an automatic prover.  In
order to facilitate fine-grain modular proof, each subprogram should lead to
the generation of a separate unit (package in SPARK, module in Why), which can
be proved independently. Notice that the generated SPARK is not executable, and
does not match in general the structure of the source Ada program, even if this
program is written in the SPARK subset of Ada. Ideally, the generated SPARK
should correspond to a simple subset of SPARK (for example no need for
visibility rules in this subset as everything is public). Thus, it should be
easier to formalize this subset and prove the correctness of transformations or
analyzes on this subset if needed.

\subsection{Introduction to SPARK/Why}

\subsection{Generation of Annotations}

A valid SPARK or Why subprogram needs to indicate explicitly which global
variables can be read and/or written during the execution of this
subprogram. As this information is not present in the source Ada program, it
must be generated by our translation. As these reads and writes must account
for direct and indirect accesses, through any number of calls, this global
information must be retrieved by performing a global analysis on the closed set
of subprograms called directly and indirectly.

A special global variable called Heap represents all the dynamically allocated
memory, so that reads and writes to dynamically allocated memory show in SPARK
or Why contracts as reads and writes to Heap. Notice that without this Heap
variable, contracts would be wrong and break the consistency of the proof
system. For example, it would be possible to prove that Problem below always
returns True, because Set would be seen as a noop, and Get would be seen as a
constant function:

\begin{verbatim}
X : access Integer;

procedure Set is
   X.all := 0;
end Set;

function Get return Integer is
begin
   return X.all;
end Get;

function Problem return Boolean is
   X1 : Integer := Get;
begin
   Set;
   return X1 = Get;
end Problem;
\end{verbatim}

Contracts (precondition and postcondition) in SPARK and Why have a
slightly different semantics than contracts in Ada 2012, because contracts in
SPARK and Why completely ignore the possibility of a run-time error being
raised while evaluating the contract. When checking for absence of run-time
errors (which can be separated from contract checking), the absence of run-time
errors in contracts should also be proved, which requires the extension of
contracts with additional conjuncts in SPARK and Why. For example, the
following contract in Ada:

\begin{verbatim}
function Get (A : My_Array; X : Integer) return Element
   with Pre => A (X) /= Nil_Element;
\end{verbatim}

would become in SPARK:

\begin{verbatim}
function Get (A : My_Array; X : Integer) return Element;
--# pre X in My_Array'Range and then A (X) /= Nil_Element;
\end{verbatim}

\subsection{General Architecture}

The first requirement is to break the mutual dependencies between packages and
between subprograms in Ada, in order to 1) achieve modular verification at the
subprogram level and 2) prevent circular dependencies between units and between
elements of units, which are either not supported or supported with
restrictions in both SPARK and Why. These mutual dependencies come from
recursion between subprograms as well as cross calls between packages (P.F
calls Q.G which calls P.H) even without recursion. To that end, each
declarative part leads to the generation of two units: one for the data+types
of this declarative part, one for the subprogram specifications of this
declarative part.

As an example, a package P defining data and subprograms should lead to the
generation of a unit P\_Data for its data+types and P\_Spec for its subprogram
specifications. Then, a subprogram P.F in ALFA should be translated into the
only subprogram in unit P\_F, which manipulates data from P\_Data and calls
subprograms from P\_Spec (including potential calls to F in P\_Spec, which
correspond to recursive calls in the source program).

As another example, a subprogram F in ALFA defining local variables and local
subprograms should lead to the generation of a unit F\_Data for its local
variables and F\_Spec for its local subprogram specifications. Then, F's body
should be translated into the only subprogram in unit F, which manipulates data
from F\_Data and calls subprograms from F\_Spec.

Thus, the generated units should be layered in:
\begin{enumerate}
\item $<$data$>$: units which define global data in SPARK or Why, corresponding
  to either global or local variables in Ada. These units also define types.
\item $<$spec$>$: units which define subprogram specifications in SPARK or Why,
  corresponding to all subprograms specifications and definitions in Ada. These
  units also define parameterized expressions.
\item $<$body$>$: units which define a single subprogram specification and body
  in SPARK or Why from a subprogram in ALFA.
\end{enumerate}

\end{document}
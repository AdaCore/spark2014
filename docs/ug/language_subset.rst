.. _introduction to spark:

***********************
Introduction to |SPARK|
***********************

.. A lot of the material in this chapter is copied from the Introduction of
   SPARK 2014 RM.

|SPARK| is a programming language and a set of verification tools designed to
meet the needs of high-assurance software development.  |SPARK| is based on Ada
2012, both subsetting the language to remove features that defy verification,
but also extending the system of contracts and "aspects" to support modular,
formal verification.

|SPARK| is a much larger and more flexible language than its predecessor
SPARK 2005. The language can be configured to suit a number of application
domains and standards, from server-class high-assurance systems (such as
air-traffic management applications), to embedded, hard real-time, critical
systems (such as avionic systems complying with DO-178C Level A).

|SPARK| is supported by various tools in the |GNAT Pro| toolsuite:

* the GNAT compiler
* GNATtest tool for unit testing harness generation
* |GNATprove| tool for formal program verification

A user can specify in |SPARK| the functional behavior of a program, and get
the following results from the above tools:

* errors and warnings during compilation;
* exceptions being raised at run time when an assertion fails, if the program
  is compiled with appropriate switches;
* a unit testing harness taking into account subprogram contracts, generated by
  GNATtest;
* formal guarantees that a set of subprograms are free from run-time errors and
  respect their contracts, provided by |GNATprove|.

A crucial feature of |GNATprove| is that it interprets annotations exactly like
they are interpreted at run time during tests. In particular, their executable
semantics includes the verification of run-time checks, which can be verified
statically with |GNATprove|.  |GNATprove| can perform additional verifications
on the specification of the expected behavior itself, and its correspondence to
the code.

For more details, see the |SPARK| Reference Manual.

Principal Language Restrictions
-------------------------------

To facilitate formal verification, |SPARK| enforces a number of global
simplifications to Ada 2012. The most notable simplifications are:

- The use of access types and allocators is not permitted.

- All expressions (including function calls) are free of side-effects.

- Aliasing of names is not permitted.

- The goto statement is not permitted.

- The use of controlled types is not permitted.

- Tasking is not currently permitted.

- Raising and handling of exceptions is not permitted.

We describe a program unit or language feature as being "in |SPARK|" if it
complies with the restrictions required to permit formal verification.
Conversely, a program unit language feature is "not in |SPARK|" if it does not
meet these requirements, and so is not amenable to formal verification. Within
a single unit, features which are "in" and "not in" |SPARK| may be mixed at a
fine level. For example, the following combinations may be typical:

- Package specification in |SPARK|. Package body entirely not in |SPARK|.

- Visible part of package specification in |SPARK|. Private part and body not
  in |SPARK|.

- Package specification in |SPARK|. Package body almost entirely in |SPARK|,
  with a small number of subprogram bodies not in |SPARK|.

- Package specification in |SPARK|, with all bodies imported from another
  language.

- Package specification contains a mixture of declarations which are in |SPARK|
  and not in |SPARK|.  The latter declarations are only visible and usable from
  client units which are not in |SPARK|.

Such patterns are intended to allow for mixed-language programming, and the
development of programs that mix formal verification and more traditional
testing.

Constructive and Retrospective Verification Modes
-------------------------------------------------

SPARK 2005 strongly favoured the *constructive* verification style - where all
program units required contracts on their specifications.  These
contracts had to be designed and added at an early stage to assist modular
verification, and then maintained by the user as a program evolved.

In contrast, |SPARK| is designed to facilitate a more *retrospective* mode of
program construction and verification, where useful forms of verification can
be achieved with code that complies with the core |SPARK| restrictions, but
otherwise does not have any contracts.  In this mode, implicit contracts can be
computed from the bodies of units, and then used in the analysis of other
units, and so on.  These implicit contracts can be "promoted" by the user to
become part of the specification of a unit, allowing the designer to move from
the retrospective to the constructive mode as a project matures.  The
retrospective mode also allows for the verification of legacy code that was not
originally designed with the |SPARK| contracts in mind.

|GNATprove| supports both approaches. |GNATprove| can detect automatically that
a subprogram spec or body is in |SPARK|, and it can compute the data
dependences of subprograms both inside and outside of |SPARK|.

.. _project statistics:

Project Statistics
^^^^^^^^^^^^^^^^^^

Based on the automatic detection of which subprograms are in |SPARK|,
|GNATprove| generates global project statistics in file ``gnatprove.out``. The
statistics describe:

* what percentage and number of subprograms are in |SPARK|
* what percentage and number of |SPARK| subprograms are not yet supported
* what are the main reasons for subprograms not to be in |SPARK|
* what are the main reasons for subprograms not to be yet supported in |SPARK|
* units with the largest number of subprograms in |SPARK|
* units with the largest number of subprograms not in |SPARK|

.. _summary file:

Summary File
^^^^^^^^^^^^

The information of which subprogram specs and bodies are in |SPARK| is stored
in a file with extension ``.alfa`` for review by the user, and to produce
global :ref:`project statistics`. |GNATprove| outputs the reasons for which a
subprogram is not in |SPARK| (using parentheses):

* access: access types and dereferences;
* assembly language: assembly language;
* deallocation: unchecked deallocation;
* dynamic allocation: dynamic allocation;
* exception: raising and catching exceptions;
* forward reference: forward reference to an entity;
* goto: use of *goto*;
* indirect call: indirect call;
* tasking: tasking;
* unchecked conversion: use of ``Unchecked_Conversion``;
* impure function: functions which write to variables other than parameters;
* recursive call: forbidden types of recursive calls, e.g. in contracts;
* uninitialized logic expr: expression which should be fully initialized;
* unsupported construct: any other unsupported construct.

As an example, consider the following code:

.. code-block:: ada
   :linenos:

    package P is
       X : access Boolean;
       procedure P0;
    end P;

.. code-block:: ada
   :linenos:

    package body P is
       procedure Set is
       begin
	  X.all := True;
       end Set;

       procedure P0 is
	  Y : Boolean;

	  function Get return Boolean is
	  begin
	     return X.all;
	  end Get;

	  procedure P1 is
	  begin
	     if not Get then
		return;
	     end if;
	     Y := True;
	  end P1;
       begin
	  Set;
	  P1;
       end P0;
    end P;

On this code, |GNATprove| outputs the following information in file p.alfa::

   -+ set p.adb:2 (access)
   -+ get p.adb:10 (access)
   ++ p1 p.adb:15
   -+ p0 p.ads:3 (access)

The first character denotes whether the subprogram body is in |SPARK| (+), not
in |SPARK| (-) or not yet implemented (*). The second character follows the
same categories for the subprogram spec. The name that follows is a unique name
for the subprogram. The location of the subprogram is given next with its file
and line. Non-|SPARK| features used are given in parentheses. Features not yet
implemented are given in brackets.

In the example above, ``Set`` and ``Get`` have a spec in |SPARK|, but not their
body, because it contains a pointer dereference.  Since ``Set`` is a local
subprogram of ``P0``, the body of ``P0`` is not in |SPARK| either. ``P1`` body
is in |SPARK|.

User-specified Compliance
^^^^^^^^^^^^^^^^^^^^^^^^^

The user may require that the project only contains code in |SPARK|, by using
option ``--mode=force``. Any violation of |SPARK| is then reported as an error,
and any construct in |SPARK| not yet implemented is reported as a warning.

For a finer-grain control, the user may require that some subprograms are in
|SPARK| by inserting a specific pragma ``Annotate`` in the body of the
subprogram. He may also insert this pragma inside or before a package
declaration (spec or body) to require that all subprogram declarations in this
package are in |SPARK|.

On the following example:

.. code-block:: ada
   :linenos:

    package P is
       pragma Annotate (gnatprove, Force);
       X : access Boolean;
       procedure P0;
    end P;

.. code-block:: ada
   :linenos:

    package body P is
       procedure Set is
       begin
	  X.all := True;
       end Set;

       procedure P0 is
	  Y : Boolean;

	  function Get return Boolean is
	     pragma Annotate (gnatprove, Ignore);
	  begin
	     return X.all;
	  end Get;

	  procedure P1 is
	  begin
	     if not Get then
		return;
	     end if;
	     Y := True;
	  end P1;
       begin
	  Set;
	  P1;
       end P0;
    end P;

|GNATprove| outputs the following errors::

    p.adb:4:07: explicit dereference is not in SPARK
    p.ads:3:08: access type is not in SPARK

The error messages distinguish constructs not in |SPARK| (like a pointer
dereference) from constructs not yet implemented. Notice that no error is given
for the dereference in ``Get``, as another pragma ``Annotate`` in that
subprogram specifies that formal proof should not be done on this subprogram.

Combining Formal Verification and Testing
-----------------------------------------

There are common reasons for combining formal verification on some part
of a codebase and testing on the rest of the codebase:

#. Formal verification is only applicable to a part of the codebase. For
   example, it might not be possible to apply formal verification to Ada code
   that is not in |SPARK|.

#. Formal verification only gives strong enough results on a part of the
   codebase. This might be because the desired properties cannot be expressed
   formally, or because proof of these desired properties cannot be
   sufficiently automated.

#. Formal verification is only cost-effective on a part of the codebase. (And
   it may be more cost-effective than testing on this part of the codebase.)

For all these reasons, it is important to be able to combine the results of
formal verification and testing on different parts of a codebase.

Contracts on subprograms provide a natural boundary for this combination. If a
subprogram is proved to respect its contract, it should be possible to call it
from a tested subprogram. Conversely, formal verification of a subprogram
(including absence of run-time errors and contract checking) depends on called
subprograms respecting their own contracts, whether these are verified by
formal verification or testing.

Formal verification works by making some assumptions, and these assumptions
should be shown to hold even when formal verification and testing are
combined. Certainly, formal verification cannot guarantee the same
properties when part of a program is only tested, as when all of a program is
proved. The goal then, when combining formal verification and testing, is to
reach a level of confidence as good as the level reached by testing alone.

|GNAT Pro| proposes a combination of formal verification and testing for
|SPARK| based on |GNATprove| and GNATtest. See :ref:`proof and test` for
details.

Implementation-Defined Behavior
-------------------------------

A |SPARK| program is guaranteed to be unambiguous, so that formal verification
of properties is possible. However, some behaviors may depend on the compiler
used. By default, |GNATprove| adopts the same choices as the GNAT
compiler. |GNATprove| also supports other compilers by providing special
switches:

* ``-gnateT`` for specifying the target configuration
* ``--pedantic`` for warning about possible implementation-defined behavior

Target Parametrization
^^^^^^^^^^^^^^^^^^^^^^

Target parametrization consists in passing to |GNATprove| a file which defines
the parameters for the target on which the program will be run. These include
the size and alignment of standard integer types, endianness, the kinds of
floating-point numbers, etc. The format of this file should match the format of
the file generated by calling |GNAT Pro| with switch ``-gnatet``.

Target parametrization can be used:

* to specify a target different than the host on which |GNATprove| is run, when
  cross-compilation is used. If |GNAT Pro| is the cross compiler, the
  configuration file can be generated by calling it with the switch
  ``-gnatet=?``. Otherwise, the target file should be generated manually.
* to specify the parameters for a different compiler than |GNAT Pro|, even when
  the host and target are the same. In that case, the target file should be
  generated manually.

Parenthesized Arithmetic Operations
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In Ada, non-parenthesized arithmetic operations could be re-ordered by the
compiler, which may result in a failing computation (due to overflow checking)
becoming a successful one, and vice-versa. By default, |GNATprove| evaluates
allexpressions left-to-right, like GNAT. When the switch ``--pedantic`` is
used, a warning is emitted for every operation that could be re-ordered:

* any operand of a binary adding operation (+,-) that is itself a binary adding
  operation;
* any operand of a binary multiplying operation (\*,/,mod,rem) that is itself a
  binary multiplying operation.

Compiler Permissions
^^^^^^^^^^^^^^^^^^^^

Ada standard defines various ways in which a compiler is allowed to compute a
correct result for a computation instead of raising a run-time error. By
default, |GNATprove| adopts the choices made by GNAT on the platform.  When the
switch ``--pedantic`` is used, |GNATprove| interprets all computations with the
strictest meaning guaranteed by Ada Reference Manual.

For example, the bounds of base types for user-defined types, which define
which computations overflow, may vary depending on the compiler and host/target
architectures. With option ``--pedantic``, all bounds should be set to their
minimum range guaranteed by the Ada standard (worst case). For example, the
following type should have a base type ranging from -10 to 10 (standard
requires a symmetric range with a possible extra negative value)::

    type T is 1 .. 10;

This other type should have a base type ranging from -10 to 9::

    type T is -10 .. 1;

Language Features Not Yet Supported
-----------------------------------

The major features not yet supported are:

* OO programming: tagged types, dispatching
* formal containers
* invariants on types (invariants and predicates)

The prototype version of |GNATprove| outputs in the :ref:`summary file` which
features from |SPARK| are not yet supported and used in the program [using
brackets]:

* aggregate: aggregate extension;
* arithmetic operation: not yet implemented arithmetic operation;
* attribute: not yet implemented attribute;
* concatenation: array concatenation;
* container: formal container;
* dispatch: dispatching;
* expression with action: expression with action;
* multi dim array: multi-dimensional array of dimention > 4;
* pragma: not yet implemented pragma;
* representation clause: representation clause;
* tagged type: tagged type;
* type invariant;
* type predicate;
* operation on arrays: rarely used operation on arrays, such as boolean
  operators;
* iterators: loops with iterators;
* class wide types: class wide types;
* interfaces: interfaces;
* not yet implemented: any other not yet implemented construct.

The purpose of the additional information on features not yet supported is to
allow users to experiment and see which features are more beneficial in their
context, in order to prioritize efficiently their implementation.


Recommended Use
---------------

Formal verification can be greatly facilitated by the way the program and its
desired properties are expressed. In the following section, we give some advice
to get as many automatic proofs as possible.

.. _contract cases:

Subprogram Contracts
^^^^^^^^^^^^^^^^^^^^

Preconditions and Postconditions
""""""""""""""""""""""""""""""""

The proof of each subprogram is carried over independently of the
implementation of other subprograms, so the contract of a subprogram should be
strong enough to prove its callers. The contract of a subprogram is usually
expressed as a pair of a precondition and a postcondition:

.. code-block:: ada
   :linenos:

    procedure Incr_Threshold (X : in out Integer) with
      Pre  => X >= 0,
      Post => X = Integer'Min (X'Old + 1, Threshold);

The precondition states the obligation on the caller of the subprogram. For
example, all callers of ``Incr_Threshold`` should ensure that the value passed
in parameter is non-negative before calling ``Incr_Threshold``. The
postcondition states the obligation on the subprogram when it returns. For
example, ``Incr_Threshold`` should always return in a state where the value of
its parameter is the minimum between its value at entry (``X'Old``) incremented
by one, and a given threshold value. This expresses precisely the property of
incrementing until a threshold is reached.

|GNATprove| analyzes the behavior of a subprogram in all possible contexts
allowed by its precondition. It is in this context that it attempts to prove
that the implementation of the subprogram is free of run-time errors and
fulfills its postcondition.

At every call site, |GNATprove| replaces the called subprogram by its
contract. Therefore, it requires that the precondition of the called subprogram
is satisfied, and the only information available when the subprogram returns is
its postcondition.

Note that direct recursive subprograms or mutually recursive subprograms are
treated in this respect exactly like non-recursive ones. Provided the execution
of these subprograms always terminates (a property that is not verified by
|GNATprove|), then it is sound to use their contract at call-site to prove that
their contract hold.

Contract Cases
""""""""""""""

The contract of a subprogram can alternatively be specified as a set of
disjoint and complete contract cases:

.. code-block:: ada
   :linenos:

    procedure Incr_Threshold (X : in out Integer) with
      Contract_Cases => (X < Threshold  => X = X'Old + 1,
                         X >= Threshold => X = X'Old);

Each case in the list consists in a guard and a consequence separated by the
symbol ``=>``. All guards are evaluated on entry to the subprogram. For each
input, only one guard should evaluate to ``True``. The corresponding
consequence should evaluate to ``True`` when returning from the subprogram. For
example, the contract cases of ``Incr_Threshold`` expresses that the subprogram
should be called in two distinct cases only:

* on inputs that are strictly less than the value of a given threshold, in
  which case ``Incr_Threshold`` increments this value.
* on inputs whose value is equal to the given threshold, in which case
  ``Incr_Threshold`` does not modify this value.

Contract cases provide a convenient way to express complex contracts, which
would be cumbersome to express with a precondition and a postcondition. For
example, the contract cases of ``Incr_Threshold`` are equivalent to the
following precondition and postcondition:

.. code-block:: ada
   :linenos:

    procedure Incr_Threshold (X : in out Integer) with
      Pre  => (X < Threshold and not (X = Threshold))
               or else (not (X < Threshold) and X = Threshold),
      Post => (if X'Old < Threshold'Old then X = X'Old + 1
               elsif X'Old = Threshold'Old then X = X'Old);

Note that using contract cases or the equivalent (for run-time checking)
preconditions and postconditions is not equivalent for proof with |GNATprove|.
If contract cases are used, |GNATprove| attempts to prove that they are
disjoint and complete once and for all. If preconditions and postconditions are
used, |GNATprove| treats these properties as any other precondition, so they
must be verified at each call.

Contract cases can also be used in addition to preconditions and
postconditions. In that case, the cases should cover all inputs allowed by the
precondition. For example, the contract of ``Incr_Threshold`` can be written:

.. code-block:: ada
   :linenos:

    procedure Incr_Threshold (X : in out Integer) with
      Pre  => X in 0 .. Threshold,
      Post => X >= X'Old,
      Contract_Cases => (X < Threshold => X = X'Old + 1,
                         X = Threshold => X = X'Old);

Note that the completeness is automatically reached when the last guard is
``others``, denoting all cases not captured by any of the other guard.

Expression Functions
""""""""""""""""""""

Expression functions that do not have a user-defined postcondition are treated
specially by |GNATprove|, which generates an implicit postcondition stating
that their result is equal to the expression that defines them. For example,
the function ``Increment`` defined as an expression function:

.. code-block:: ada

   function Increment (X : Integer) return Integer is (X + 1);

is treated by |GNATprove| as if it had a postcondition:

.. code-block:: ada

   Post => Increment'Result = X + 1;

This postcondition is automatically satisfied, so |GNATprove| does not generate
VCs to check it. Expression functions that have a user-defined postcondition
are treated like regular functions.

Function Calls in Annotations
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The contracts of functions called in annotations are essential for automatic
proofs. Currently, the knowledge that a function call in an annotation respects
its postcondition (when called in a context where the precondition is
satisfied) is only available for expression functions. Thus, expression
functions should be used whenever possible for these functions called in
annotations.  The syntax of expression functions, introduced in Ada 2012,
allows defining functions whose implementation simply returns an expression,
such as ``Is_Even``, ``Is_Odd`` and ``Is_Prime`` below.

.. code-block:: ada
   :linenos:

    function Is_Even (X : Integer) return Boolean is (X mod 2 = 0);

    function Is_Odd (X : Integer) return Boolean is (not Even (X));

    function Is_Prime (X : Integer) with
      Pre => Is_Odd (X);

Calls to Standard Library Functions
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The standard library for the selected target is pre-analyzed, so that user code
can freely call standard library subprograms.

Loop Invariants
^^^^^^^^^^^^^^^

In order for |GNATprove| to prove formally the properties of interest on
subprograms with loops, the user should annotate these loops with loop
invariants. A loop invariant gives information on the state at entry to the
loop at each iteration. Loop invariants in |SPARK| are expressed with the
``Loop_Invariant`` pragma, which may appear anywhere in the main list of
statements in a loop body, or directly in a chain of nested block statements in
this main list of statements. Only the first ``Loop_Invariant`` pragmas are
used by |GNATprove| as a loop invariant during proof (they should be next to
each other, or separated only by ``Loop_Variant`` pragmas). Other
``Loop_Invariant`` pragmas are proved like regular assertions. Loop invariants
may have to be precise enough to prove the property of interest. For example,
in order to prove the postcondition of function ``Contains`` below, one has to
write a precise loop invariant such as the one given below:

.. code-block:: ada
   :linenos:

   function Contains (Table : IntArray; Value : Integer) return Boolean with
     Post => (if Contains'Result then
                (for some J in Table'Range => Table (J) = Value)
 	     else
                (for all J in Table'Range => Table (J) /= Value));

   function Contains (Table : IntArray; Value : Integer) return Boolean is
   begin
      for Index in Table'Range loop
         pragma Loop_Invariant (for all J in Table'First .. Index - 1 =>
                                 Table (J) /= Value);

         if Table(Index) = Value then
            return True;
         end if;
      end loop;

      return False;
   end Contains;

When the loop involves modifying a variable, it may be necessary to refer to
the value of the variable at loop entry. This can be done using the GNAT
attribute ``'Loop_Entry``. For example, in order to prove the postcondition of
function ``Move`` below, one has to write a loop invariant referring to
``Src'Loop_Entry`` such as the one given below:

.. code-block:: ada
   :linenos:

   procedure Move (Dest, Src : out IntArray) with
     Post => (for all J in Dest'Range => Dest (J) = Src'Old (J));

   procedure Move (Dest, Src : out IntArray) is
   begin
      for Index in Dest'Range loop
         pragma Loop_Invariant ((for all J in Dest'First .. Index - 1 =>
                                  Dest (J) = Src'Loop_Entry (J)) and
                                (for all J in Index .. Dest'Last =>
                                  Src (J) = Src'Loop_Entry (J)));

         Dest (Index) := Src (Index);
         Src (Index) := 0;
      end loop;
   end Move;

Loop Variants
^^^^^^^^^^^^^

Proofs of termination of loops rely on ``Loop_Variant`` pragmas. Proving one
loop variant is sufficient to prove that a loop terminates, even if the loop
contains multiple ``Loop_Variant`` pragmas, and others are not proved. Indeed,
it is sufficient to know that one bounded quantity decreases or increases
monotonically (or a mix of these, as loop invariants may have increasing and
decreasing parts, the order of which fixes the lexicographic combined order of
progress) to be assured that the loop terminates. Note that, in general, this
requires proving also that there are no run-time errors in the loop, to show
that the quantity stays within bounds. Otherwise, the code may still wrap
around at run time (if the code is compiled without checks), and the loop will
not necessarily exit.

The ``Loop_Variant`` pragmas that appear next to the first group of
``Loop_Invariant`` pragmas (or at the start of the loop body if there are no
``Loop_Invariant`` pragmas in the loop) are handled with the most precision by
|GNATprove|, as they become loop variants of the underlying intermediate
representation in Why3. Other ``Loop_Variant`` pragmas are proved by showing
that the quantity that should progress monotonically does so between the
program point where the first group of ``Loop_Invariant`` pragmas appears (or
the start of the loop if there is no such group) and the program point where
the ``Loop_Variant`` pragma appears, and that this quantity either stays the
same or progresses on the rest of the loop.

Quantified Expressions
^^^^^^^^^^^^^^^^^^^^^^

Ada 2012 quantified expressions are a special case with respect to run-time
errors: the enclosed expression must be run-time error free over the *entire
range* of the quantification, not only at points that would actually be
reached at execution. As an example, consider the following expression:

.. code-block:: ada

    (for all I in 1 .. 10 => 1 / (I - 3) > 0)

This quantified expression will never raise a run-time error, because the
test is already false for the first value of the range, ``I = 1``, and the
execution will stop, with the result value ``False``. However, |GNATprove|
requires the expression to be run-time error free over the entire range,
including ``I = 3``, so there will be an unproved VC for this case.

Pragma ``Assert_And_Cut``
^^^^^^^^^^^^^^^^^^^^^^^^^

|GNATprove| may need to consider many possible paths through a subprogram. If
this number of paths is too large, |GNATprove| will take a long time to prove
even trivial properties. To reduce the number of paths analyzed by |GNATprove|,
one may use the pragma ``Assert_And_Cut``, to mark program points where
|GNATprove| can *cut* paths, replacing precise knowledge about execution before
the program point by the assertion given. The effect of this pragma for
compilation is exactly the same as the one of pragma ``Assert``.

For example, in the procedure below, all that is needed to prove that the code
using ``X`` is free from run-time errors is that ``X`` is positive. Without the
pragma, |GNATprove| considers all execution paths through ``P``, which may be
many. With the pragma, |GNATprove| only needs to consider the paths from the
start of the procedure to the pragma, and the paths from the pragma to the end
of the procedure, hence many fewer paths.

.. code-block:: ada
   :linenos:

   procedure P is
      X : Integer;
   begin
      --  complex computation that sets X
      pragma Assert_And_Cut (X > 0);
      --  complex computation that uses X
   end P;

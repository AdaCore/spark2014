Combining GNATprove with GNATtest
=================================

Not all subprograms can be verified formally. Subprograms that cannot be
verified formally must be either verified by manual review, or by testing. The
tool GNATtest allows the user to easily develop unit tests for subprograms
declared in library-level package specifications.

Test Cases
----------

Although testing is not exhaustive by nature, contrary to proof, it is meant to
explore enough possibilities to gain confidence in the program. Safety and
security standards mandate which possibilities must be explored: functional
properties related to the low-level requirements, and robustness tests with
with boundary values.

A formal test-case is a GNAT extension to Ada, which is part of Alfa, meant to
facilitate the formalization of test cases. It can be expressed either as an
aspect in Ada 2012 or as a pragma in all Ada modes (83, 95, 2005, 2012). A
formal test-case is attached to a subprogram declaration for a subprogram
declared in a library-level package specification.  The syntax of test-case
pragmas is the following::

   pragma Test_Case (
      [Name     =>] static_string_Expression
     ,[Mode     =>] (Normal | Robustness)
    [, Requires =>  Boolean_Expression]
    [, Ensures  =>  Boolean_Expression]);

The compiler checks the validity of this pragma but its presence does not lead
to any modification of the code generated by the compiler. The compiler checks
that boolean expression given in ``Requires`` and ``Ensures`` are valid,
where the rules for ``Requires`` are the same as the rule for an expression
in ``Precondition`` and the rules for ``Ensures`` are the same as the
rule for an expression in ``Postcondition``. In particular, attributes
``'Old`` and ``'Result`` can only be used within the ``Ensures``
expression. The following is an example of use within a package spec::

   package Math_Functions is
      ...
      function Sqrt (Arg : Float) return Float;
      pragma Test_Case (Name     => "Test 1",
                        Mode     => Normal,
                        Requires => Arg < 100,
                        Ensures  => Sqrt'Result < 10);
      ...
   end Math_Functions;

The meaning of a test case is that, if the associated subprogram is
executed in a context where ``Requires`` holds, then ``Ensures``
should hold when the subprogram returns. Mode ``Normal`` indicates
that the input context should satisfy the normal precondition of the
subprogram, and the output context should then satisfy its
postcondition. Mode ``Robustness`` indicates that the normal pre- and
postcondition of the subprogram should be ignored for this test case.

Functional Behavior
-------------------

With ``Normal`` test-cases, the user can partition the input state space using
the ``Requires`` components. No ``Ensures`` component is necessary in that
case. Of course, the user can also strengthen the expected postcondition after
the subprogram executes on a certain test-case by adding a ``Requires``
component to the test-case.

GNATtest generates a test harness with individual test procedures for each
test-case in the source code. Initially, these test procedures are empty. The
user can then fill in the test procedures with the definition of proper inputs
for the test and a call to the subprogram under test. The harness takes care of
checking automatically at run-time that a test procedure correctly implements
the corresponding test-case, and that all assertions in contracts and
test-cases are valid.

GNATtest generates an executable in order to run the test suite. During the
run, this executable generates a report with successful and failing tests.

Absence of Run-Time Errors
--------------------------

With ``Robustness`` test-cases, the user can specify exceptional behavior in
case the precondition is not fulfilled. During all runs of both ``Normal`` and
``Robustness`` test-cases, run-time checks are performed to detect potential
run-time errors. Such errors are reported as failed tests in the final report.


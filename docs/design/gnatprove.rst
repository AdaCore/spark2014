The gnatprove Tool
==================

General description
-------------------

Gnatprove is the driver for the Hi-Lite tools. It is project aware. Gnatprove
covers the way from the Ada code to the discharging of the verification
conditions. More precisely, its input is an Ada project, defined by a project
file, and its output are the results of the proof attempts for each
verification conditions.

More precise description of the tool
------------------------------------

The input of gnatprove is an Ada project, which comprises the project file and
all source files.

.. figure:: gnatprove.png
   :scale: 80%

   The process of ``gnatprove``.

Gnatprove operates in four main steps:

#. Call ``gnatmake`` to generate ``.ali`` files for all compilation units of the
   project. The exact command line is::

      gnatmake -P <project file> --subdirs gnatprove -gnatc -gnatd.F

   *  ``-P <project file>`` to give the project file to gnatmake
   *  ``--subdirs gnatprove`` all work by gnatprove is done in a subdirectory of the object directory of the project,
   *  ``-gnatc`` to disable code generation (we only need the .ali files)
   *  ``-gnatd.F`` to enable the effects section of ``.ali`` files

   After this step, we change the working directory to the subdirectory
   ``gnatprove``, where the .ali files have been stored.

#. Call ``gnat2why`` on all compilation units of the project. The rule is to call
   gnat2why on all .adb files of the project that are not subunits
   (separates), and on all .ads files that do not have a corresponding .adb
   file. For each Ada file (say ``file.adb``), the inputs of this step are the
   source files the corresponding compilation unit (``file.ads`` and
   ``file.adb``) in the most common case) and all ``.ali`` files of Ada units that
   the current unit depends on.  The output of this step are a number of Why
   files ``.why``, a location file ``.loc`` and a labels file ``.labels`` (see
   the description of the ``gnat2why`` tool), among which is the principal Why
   file, ``file__package.why``. The exact command line is::

      gnat2why <file>

#. Call ``why`` on all main files that have been generated in the previous
   step, to obtain verification conditions (VCs)::

      why --multiwhy --explain --locs <file>.locs <file>.why

   * ``--multiwhy`` to put each generated VC in a different file
   * ``--locs <file>.locs`` to give to Why the Ada source locations that
     correspond to labels in the Why source

   This step not only depends on all Why files that have been generated by the
   call to ``gnat2why`` on ``file.adb``, but also on all Why files that
   correspond to Ada compilation units that are used by ``file.adb``. The
   output of this step is a context file ``file__package_ctx.why`` along with
   an arbitrary number of files of the form ``file__package_po<n>.why``. The
   first file is the logical context common to all VCs, while the rest of the
   files contains the actual VCs. For each VC, there is a companion file
   ``file_po<n>.xpl`` that contains the label and source location that has
   been associated to that VC by Why.

   Gnatprove tells Why where to find its library files, using the environment
   variable WHYLIB. This variable is set to ``prefix>/lib/why``, where <prefix>
   is the location of the gnatprove executable. If the variable WHYLIB is
   already set when calling gnatprove, we do not change its value.

#. Call ``alt-ergo`` on all VCs. To do this, we first concatenate the files
   ``file_ctx.why`` and ``file_po<n>.why`` for a given n to obtain a file ``new.why`` that
   is readable by ``alt-ergo``. We then call alt-ergo with a timeout, using
   the tool ``why-cpulimit`` that is provided with Why::

      why-cpulimit <timeout in seconds> alt-ergo new.why

   The output of this command is stored in a result file with name ``file_po<n>.rgo``.

#. TODO description of the collection and report of the VC results

Remarks about the design
------------------------

All the work of ``gnatprove`` takes place in a subdirectory special
subdirectory, so as to not disturb other compilation processes. In particular,
the first gnatmake process generates ``.ali`` files that may overwrite the
ones that are used for regular compilation. The concrete location of that
subdirectory depends on the configuration of the project and is identical to
the semantics of the ``--subdirs`` option of ``gnatmake``. If an
``object_dir`` is set in the project file, then the concrete directory is
``<object_dir>/gnatprove``, otherwise ``gnatprove`` (in the current dir) is
used.

The organisation of the steps is very "horizontal", i.e. each step must be
finished for the entire project before the next step can start. The only step
where this is not true is the last step, calling ``alt-ergo``, because the VCs
are standalone files, the associated context file contains all they refer to.
Part of the second step may need arbitrary ``.ali`` files generated in the first
one, part of the third step may need arbitrary  ``.why`` files generated in
the second step. The reason is that to generate correct Why files, we need to
compute the effects of a subprogram and this requires the effects of all
subprograms in the downward call graph.

Considerations for fast incremental compilation
-----------------------------------------------

To be done

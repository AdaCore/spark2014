\documentclass[a4paper,10pt]{article}

\usepackage[utf8x]{inputenc}
\usepackage{listings}
\usepackage{mathpartir}
\usepackage{amsmath}
\usepackage{xspace}
\usepackage{xcolor}
\usepackage{url}
\usepackage{amssymb}

\newcommand{\yannick}[1]{{\color{red} #1}}
\newcommand{\Virginia}[1]{{\color{blue} #1}}
\newcommand{\Pierre}[1]{{\color{violet} #1}}

\newcommand{\eg}{\textit{e.g.,}\xspace}
\newcommand{\etal}{\textit{et al.}\xspace}
\newcommand{\etc}{\textit{etc.}\xspace}
%\newcommand{\pr}[1]{{\mathit{#1}^{'}}}
\newcommand{\p}[1]{\ensuremath{#1^{'}}\xspace}

%Commands used for defining syntax
\newcommand{\prog}{\ensuremath{\mathcal{P}}\xspace}
\newcommand{\idx}{\ensuremath{i}\xspace}
\newcommand{\idxinitial}{\ensuremath{\mathit{initial}}\xspace}
\newcommand{\idxfinal}{\ensuremath{\mathit{final}}\xspace}
\newcommand{\KWloop}{\ensuremath{\mathrm{\textbf{loop}}~}}
\newcommand{\KWwhen}{\ensuremath{\mathrm{\textbf{when}}~}}
\newcommand{\KWdo}{\ensuremath{\mathrm{\textbf{do}}~}}
\newcommand{\KWend}{\ensuremath{\mathrm{\textbf{end}}~}}
\newcommand{\KWover}{\ensuremath{\mathrm{\textbf{over}}~}}
\newcommand{\KWin}{\ensuremath{~\mathrm{\textbf{in}}~}}
\newcommand{\KWexit}{\ensuremath{\mathrm{\textbf{exit}}~}}
\newcommand{\KWgroup}{\ensuremath{\mathrm{\textbf{group}}~}}
\newcommand{\groupassign}{\ensuremath{\mathit{groupassign}~}}
\newcommand{\guardassign}{\ensuremath{\mathit{guardassign}~}}
\newcommand{\guardexit}{\ensuremath{\mathit{guardexit~}}}
\newcommand{\gexit}{\ensuremath{\mathit{g_{exit}~}}}
\newcommand{\gassign}{\ensuremath{\mathit{g_{assign}~}}}
\newcommand{\gstatem}{\ensuremath{\mathit{gstatememt~}}}
\newcommand{\statem}{\ensuremath{\mathit{statement~}}}
\newcommand{\expr}{\ensuremath{\mathit{expr~}}}
\newcommand{\loc}{\ensuremath{\mathit{loc}~}}
\newcommand{\state}[1]{\ensuremath{\sigma({\mathit{#1})}\xspace}}
\newcommand{\vstate}[2]{\ensuremath{\sigma^{\mathit{#1}}_{\mathit{#2}}\xspace}}

%Commands used for defining loop-form
\newcommand{\loopform}{\textsc{loop-form}\xspace}
\newcommand{\Inv}[1]{\ensuremath{\mathit{Inv}(#1)\xspace}}
\newcommand{\inv}{\ensuremath{\textsc{inv}}\xspace}
\newcommand{\pat}{\ensuremath{\textsc{pat}}\xspace}
\newcommand{\writedisjoint}[2]{\ensuremath{\mathit{W_D}(#1,#2)}\xspace}
\newcommand{\var}[1]{\ensuremath{\mathit{Var}_{#1}}\xspace}
\newcommand{\grpassign}[2]{\ensuremath{grp^{\mathit{assign_#1}}_{\mathit{#2}}\xspace}}

\newcommand{\at}[1]{{(#1)}}
\newcommand{\N}{\ensuremath{N}\xspace}
\newcommand{\true}{\ensuremath{\mathit{true}}}
\newcommand{\impl}{\ensuremath{\Longrightarrow}}
\newcommand{\inbounds}[2]{\ensuremath{\mathit{inbounds}_{#1}(#2)}\xspace}
\newcommand{\Pinbounds}[1]{\ensuremath{\mathit{inbounds}_{#1}}\xspace}
\newcommand{\seen}[3]{\ensuremath{\mathit{seen}{(#1,#2,#3)}}\xspace}
\newcommand{\Pseen}{\ensuremath{\mathit{seen}}\xspace}
\newcommand{\tocount}[1]{\ensuremath{\mathit{tocount}(#1)}\xspace}
\newcommand{\Ftocount}{\ensuremath{\mathit{tocount}}\xspace}
\newcommand{\betweens}[3]{\ensuremath{\mathit{between}{(#1,#2,#3)}}\xspace}
\newcommand{\Pbetween}{\ensuremath{\mathit{between}}\xspace}
\newcommand{\loopinvariant}{\noindent\textit{Loop invariant:}\xspace}
\newcommand{\patterndef}{\noindent\textit{Definition:}\xspace}
\newcommand{\patternexample}{\noindent\textit{Example:}\xspace}
\newcommand{\patternnote}{\noindent\textit{Note:}\xspace}
\newcommand{\patternproof}{\noindent\textit{Proof:}\xspace}
\newcommand{\update}[3]{\ensuremath{\mathit{update}{(#1,#2,#3)}}\xspace}
\newcommand{\symdef}{\ensuremath{\overset{\mathit{def}}{=}}}

%Proof preliminaires
\newcommand{\vpp}{\textsc{vpp}\xspace}
\newcommand{\spexit}{\textsc{sp-exit}\xspace}
\newcommand{\spscalar}{\textsc{sp-scalar}\xspace}
\newcommand{\sparray}{\textsc{sp-array}\xspace}
\newcommand{\spseq}{\textsc{sp-seq}\xspace}
\newcommand{\sppar}{\textsc{sp-par}\xspace}
\newcommand{\mcdiff}{\textsc{mc-diff}\xspace}
\newcommand{\mcsame}{\textsc{mc-same}\xspace}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{hypothesis}[theorem]{Hypothesis}

\newcounter{proofnum} % proof numbering
\newcounter{subproofnum}[proofnum] % subproof numbering
\newcommand{\subproof}[1]{\refstepcounter{subproofnum}~\\\noindent\arabic{subproofnum}. #1\\}
\newcounter{subsubproofnum}[subproofnum] % subsubproof numbering
\newcommand{\subsubproof}[1]{\refstepcounter{subsubproofnum}~\\\noindent\arabic{subproofnum}.\arabic{subsubproofnum}. #1\\}

\newcounter{pc} % pattern counter
\newcommand{\curpattern}{\ensuremath{\textsc{pat}\mathrm{\arabic{pc}}}\xspace}
\newcommand{\curinv}{\ensuremath{\textsc{inv}\mathrm{\arabic{pc}}}\xspace}
\newcommand{\anyinv}{\ensuremath{\textsc{inv}\mathrm{x}}\xspace}

\newenvironment{proof}[1][Proof.]{\refstepcounter{proofnum}\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}
\newenvironment{definition}[1][Definition]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}
\newenvironment{example}[1][Example]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}
\newenvironment{remark}[1][Remark]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}

\newcommand{\qed}{\nobreak \ifvmode \relax \else
      \ifdim\lastskip<1.5em \hskip-\lastskip
      \hskip1.5em plus0em minus0.5em \fi \nobreak
      \vrule height0.75em width0.5em depth0.25em\fi}

\lstset{language=Ada}

\sloppy

%==================================================================================
%==================================================================================
\begin{document}

% Title Page
\title{Simple Loop Patterns and Rich Loop Invariants}
\author{Marc Sango and Maria-Virginia Aponte and \\ Pierre Courtieu and Yannick Moy}
\date{}

\maketitle

\begin{abstract}
  Most works in automatic generation of loop invariants are limited to simple
  forms of invariants without quantifiers. In this paper, we describe patterns
  of loops for which it is possible to generate rich loop invariants with
  quantifiers.
\end{abstract}

%==================================================================================
%==================================================================================
\section{Introduction}

In the following, we only consider techniques that generate loop invariants for
programs with scalar and array variables. There is a wealth of different
techniques that generate invariants regarding the shape of
dynamically-allocated data structures (shape analysis, separation logic) that
are irrelevant in our context. We also ignore all techniques for generating
invariants for hybrid programs, in which a program implements a control part
which is related to an outside world obeying continuous differential equations.

There have been two approaches to loop invariant generation: a
\textit{template} approach which takes only code as input and generates the
best loop invariants in some predefined template family; a \textit{directed}
approach which also takes as input a goal or some hint formulas, and generates
either a sufficient loop invariant to prove the goal or a loop invariant based
on the hints provided. Typically, template approaches are based on abstract
interpretation or algebraic techniques while lazy approaches are based on
theorem proving or model checking techniques.

%==================================================================================
%==================================================================================
\subsection{Simple Loop Invariants}

Most techniques generate loop invariants in the form of conjunctions of
(dis)equalities between polynomials in the program variables. The form of an
individual (dis)equality ranges from constant variable bounds for a variable
(sign, interval) to polynomial linear (dis)equalities of various complexity (2
or 3 variables, templates of polynomials) and non-linear polynomials.

Abstract interpretation~\cite{cousot:1978:popl, mine:2006:hosc} works on an
abstraction of the program using predefined domains which restrict the kind of
(dis)equalities we are aiming at. Non-relational domains such as intervals
define (dis)equalities between a single program variable and
constants. Relational domains such as octagons or polyhedra define
(dis)equalities between program variables. An abstract state represents all
known (dis)equalities in the abstract domain. Abstract interpretation simulates
execution over this abstract state to reach a fixpoint which defines invariants
at each program point.

Predicate abstraction~\cite{graf:1997:cav} applies abstract interpretation to a
domain of predefined base formulas, typically collected from guards present in
the program (tests in branch and loop statements). A theorem prover is used to
compute the transition function for each statement of the program. The final
invariants are conjunctions over the initial base formulas.

An obvious limitation of predicate abstraction is its dependency on the initial
base formulas. In a goal-directed approach where the invariant computed by
predicate abstraction is not sufficient to prove the goal, Craig's
interpolation~\cite{mcmillan:2003:cav, mcmillan:2006:cav} allows to generate
intermediate formulas from two inconsistent formulas. In the CEGAR
(Counter-Example Guided Abstraction Refinement) approach, these intermediate
formulas can then be fed to predicate abstraction until a sufficient invariant
is found.

Algebraic techniques~\cite{colon:2003:cav, sankaranarayanan:2004:popl,
  kovacs:2008:csr} first extract polynomial (dis)equalities over program
variables and unknown constants from a template loop invariant defining these
unknowns. Then, algebraic techniques such as Faskas lemma or Gröbner bases are
used to solve these (dis)equations and give values to unknowns.

%==================================================================================
%==================================================================================
\subsection{Richer Loop Invariants}

\subsubsection*{Disjunctions}

Various works have defined disjunctive abstract domains on top of base abstract
domains. The implication domain only deals with one disjunction at a time,
while disjunctive completion allows to treat larger disjuncts. The need to
define converging operators for these domains means that they are not very
precise.

\subsubsection*{Quantifiers}

A few works have targeted the generation of loop invariants with a richer
boolean structure and quantifiers, based on techniques for quantifier-free
invariants.

Halbwachs and Péron~\cite{halbwachs:2008:pldi} describe an abstract domain to
reason about array contents over \textit{simple programs} that they describe as
\textit{``one-dimensional arrays, traversed by simple for loops''}. They are
able to represent facts like $(\forall i)(2 \leq i \leq n \impl A[i] \geq
A[i−1]$, in which a pointwise relation is established between elements of array
slices, where the relation is one supported by a quantifier-free base abstract
domain.

Gulwani \etal~\cite{gulwani:2008:popl} describe a general lifting procedure
that creates a quantified disjunctive abstract domain from quantifier-free
domains. They are able to represent facts like $(\forall i)(0 \leq i < n \impl
a[i] = 0)$, in which the formula is universally quantified over an implication
between quantifier-free formulas of the base domains.

McMillan~\cite{mcmillan:2008:tacas} describes an instrumentation of a
resolution-based prover that generates quantified invariants describing facts
over simple arrays manipulating arrays. Using a similar technique, Kov\'acs and
Voronkov~\cite{kovacs:2009:fli} generate invariants containing quantifier
alternation.

%==================================================================================
%==================================================================================
\section{Preliminaries}

\subsection{Simple Loops}
\label{sec:simple-loops}
A loop program \prog consists in a loop over index \idx increasing between \idxinitial 
and \idxfinal, followed by conditional exit expressions \gexit, evaluated to \textit{true},
the control exits from the loop. The constant \idxinitial and \idxfinal represent 
respectively the intial value and final value of iteration range. The loop body consists
in a (possibly empty) unordered set of simultaneous group assignments \groupassign.
A group assignment is a set of guarded assignments \guardassign into a same location variable \loc. 
The following syntax give the abstract syntax of our simple loop programs. 
\subsubsection*{Syntax}
\begin{eqnarray*}
\prog & ::= & \begin{array}{l}
               \KWloop \KWover \idx \KWin \idxinitial ..\idxfinal ~ \KWwhen \neg \gexit \KWdo\\
               ~~~ \groupassign^*\\
               \KWend
              \end{array}\\
\groupassign & ::= & \KWgroup ~ \loc ~ \{\guardassign .. \guardassign \}\\
\guardassign  & ::= & \gassign \rightarrow \loc ~:=  \expr\\
\loc  & ::= & x ~|~ X[\expr] \\
\expr  & ::= & \loc  ~|~ \gexit ~|~ \gassign ~|~ \expr \bullet \expr  ~|~ f(\expr)
\end{eqnarray*}
$$\bullet \in \{+, -, *, / , <, \leq, >, \geq \}$$

If the guard \gassign of a guarded assignment evaluates to true, then the
assignment is performed. The guard is implicitly \textit{true} if not present.
A particularity of the loop bodies we consider is that group assignments
are performed in parallel, so all expressions in guards and assignments are
evaluated before all assignments take place.
   
\vspace{0.5cm}

We assume that there are no conflicting writes in the simultaneous assignments,
which amounts to the following conditions:
\begin{enumerate}
\item For any two assignments to scalar variable $a$, whose guards are $g_j$
  and $g_k$, then $g_j \land g_k$ is unsatisfiable.
\item For any two assignments to array variable $A$ at indexes $e_j$ and $e_k$,
  with guards $g_j$ and $g_k$, then $(e_j = e_k) \land g_j \land g_k$ is
  unsatisfiable.
\end{enumerate}

These conditions are essentially the same as the ones described by Kov\'acs and
Voronkov with a slightly different formalism~\cite{kovacs:2009:fli}.

\vspace{0.5cm}

Notice also that $\gexit \land \gassign $ is always unsatisfiable.
In addition to above imposed restrictions for simplicity we add  another restriction
to improved the modularity of a sub set of group assignments treatement in relation 
to others group assignment $S$ in the loop. We define \emph{Pattern} \pat a subset of 
group assignments from a loop body statements.
Let us denote by \var{\pat} the list of variables on the left-hand sides of the 
assignment-statements occuring in \pat and by \var{S} the list of all variables on 
the left-hand sides of group assign $S$ occurring in a loop program \prog. 
Thus we define the predicat  \emph{write-disjoint} as following: 
$$\writedisjoint{\pat}{S} \symdef \var{\pat} \land \var{S} = \o{}$$
This means that any variable on the left-hand of an assignment in the Pattern is 
nether used in others left-hand group assignments in the loop.

%==================================================================================
%==================================================================================
\subsection*{Operational Semantics}
\newcommand{\env}{\ensuremath{\sigma}\xspace}
\newcommand{\eval}[2]{<#1, #2>}
We define environment \env, the state of the set of instantaneous values ​​of
all variables in the program \prog. 
% the control environment $exit$ that contemplating the cases where abording the loop.


Given a program $p$ in \prog, the judgment are defined as following:
\begin{eqnarray*}
 &\eval{p}{\env} \rightsquigarrow \env'
\end{eqnarray*}

Verifying the following inference rule:
\begin{eqnarray*}
&
\inferrule{
\eval{ValideIndexRange(\idx)}{\env}\rightsquigarrow \{true\}\\
\eval{\neg \gexit}{\env} \rightsquigarrow \{true\}\\
\eval{\groupassign}{\env} \rightsquigarrow \env_1\\
\eval{p}{\env_1} \rightsquigarrow \env'\\
}{
\eval{p}{\env} \rightsquigarrow \env'
}\\
\end{eqnarray*}
We assume that loop iteration index \idx is well-typed and is the valide range
defined between \idxinitial and \idxfinal. With this assumption it remain another
inference rule:
\begin{eqnarray*}
&
\inferrule{
\eval{ValideIndexRange(\idx)}{\env}\rightsquigarrow \{true\}\\
\eval{\neg \gexit}{\env} \rightsquigarrow \{false\}\\
}{
\eval{p}{\env} \rightsquigarrow \env
}\\
\end{eqnarray*}

Given a group assignment $grp$ in \groupassign containing $n$ single assignments
to variable $a$ ($assign_{a1} .. assin_{an}$) in \guardassign with respectively 
the guarded $g_{a1}..g_{an}$ in \gassign the inference rule is following
\begin{eqnarray*}
&
\inferrule{
\eval{g_{a1}}{\env}  \rightsquigarrow \{false\} \\
..\\
\eval{g_{ak}}{\env} \rightsquigarrow \{true\} \\
..\\
\eval{g_{an}}{\env} \rightsquigarrow \{false\} \\
\eval{assin_{ak}}{\env} \rightsquigarrow \env_1\\
\eval{grp}{\env_1} \rightsquigarrow \env'\\
}{
\eval{grp}{\env} \rightsquigarrow \env'
}\\
\end{eqnarray*}

given a guarded assignment $assign_a$ to variable:
\begin{eqnarray*}
&
\inferrule{
\eval{g_{a}}{\env} \rightsquigarrow \{true\}\\
\eval{a:=e}{\env_1} \rightsquigarrow \env'\\
}{
\eval{assign_{a}}{\env} \rightsquigarrow \env'
}\\
&
\inferrule{
\eval{g_{a}}{false} \rightsquigarrow \{false\}\\
}{
\eval{assign_{a}}{\env} \rightsquigarrow \env
}\\
\end{eqnarray*}

Let two sets $Var_a$ and $Var_b$, we define the operators \textit{Overriding Union} 
$Var_a \overline{\cup} Var_b$ which replaces all pairs $<a,v_a>$ in $Var_a$ whose 
first member corresponds to a pair $<b,v_b>$ of $Var_b$ by  $<b,v_b>$, then, 
it adds in $Var_a$ all other pairs in $Var_b$. 
The inference rule of assignment in variable (scalar or array) becomes:
\begin{eqnarray*}
&
\inferrule{
\eval{e}{\env_1} \rightsquigarrow v
}{
\eval{a:=e}{\env_1} \rightsquigarrow \env' = \env_1 \overline{\cup} \{<a,v>\}
}\\
\end{eqnarray*}

Given an expression $e$ in \expr, we have following judgments
\begin{eqnarray*}
 &\eval{x}{\env} \rightsquigarrow \env(x)\\
 &\eval{X[e]}{\env} \rightsquigarrow \env(X)[\env(e)]\\
 &\eval{e_1 \bullet e_2}{\env}  \rightsquigarrow \env(e_1) \bullet \env(e_2)\\
 &\eval{\gassign}{\env} \rightsquigarrow \{true\} | \{false\}\\
 &\eval{\gexit}{\env} \rightsquigarrow \{true\} | \{false\}\\
 %&\eval{\gexit}{\env} \rightsquigarrow exit\\
 &\eval{f(e)}{\env} \rightsquigarrow \env(f)(\env(e))\\
\end{eqnarray*}

\subsubsection*{Invariant definition}
We are interested in generating the most precise loop invariant \inv for
a given loop in our loop form. The loop invariant we consider is not a Hoare-like loop
invariant, which would hold before and after the loop and at the start of each
run through the loop body. Our loop invariant placed before all statements
describes the loop behavior, it holds before loop and at each run through the loop body, 
keeping guarded assignments safe as long as we fall on the first test exiting to the
loop. 

Recursively, a formula \Inv{\idx} is a \emph{loop invariant} at loop iteration \idx if \Inv{\idx}
is a statement of the conditions that should be $\mathit{true}$ on entry into a loop (i.e at the
first iteration \idxinitial) and that are guaranteed to remain $\mathit{true}$ on each time the 
loop body is evaluates, essentially for the last execution of loop body at iteration \idx. 
If no variable is modified in the loop, the invariant is supposed to be $\mathit{true}$ at iteration
\idxinitial. If there are the variables modified in the loop, we start the loop with theirs initial
values. In addition since our invariant is placed before the loop body's group assignments, a loop boody 
execution at first iteration $\idxinitial$ is weel-evaluated with $\Inv{\idxinitial+1}$ at the 
iteration $\idxinitial +1$, recursivelly the loop body execution at iteration $\idx-1$ is 
well-evaluated with $\Inv{\idx}$ at iteration $\idx$. 

\subsubsection*{Example}
From a sequential program (return the the string corresponding to hexadecimal format) 
extracted in SPARK project ~\cite{sparkskein:url} 
\begin{lstlisting}
subtype String_6_Index is Positive range 1 .. 6;
subtype String_6 is String (String_6_Index);
\end{lstlisting}

\begin{lstlisting}
function T0_Image (T0 : in U64) return String_6
is
   Result : String_6 := "000000";
   C : String(1 .. 20); --enough for"16#aabbccddeeffgghh#"
   LSB_Index : Positive := 19;
begin
   U64_IO.Put (C, T0, 16);
   for I in reverse String_6_Index loop
      Result (I) := C (LSB_Index);
      LSB_Index := LSB_Index - 1;
      exit when C (LSB_Index) = '#';
   end loop;
   return Result;
end T0_Image;
\end{lstlisting}

we extract the loop and translate \footnote{The translation from sequential loop to our 
loop form will be futur Works} it to our loop form which must respects the different 
restrictions imposed.
$$\begin{array}{l}
  \KWloop \KWover \idx \KWin 1 .. 6 ~ \KWwhen ~ \neg (C (19-(\idx-1) = '\#') ~ \KWdo \\
  ~~~~ < \textrm{\Inv{\idx} of the patterns identified here} >\\
  ~~~~ \mathit{true} \rightarrow Result (\idx) := C (19-(\idx-1))\\
  ~~~~ \mathit{true} \rightarrow LSB\_Index := 19 - (\idx-1)\\
  \KWend
\end{array}$$

%==================================================================================
%==================================================================================
\subsection{Naming Conventions}
\label{sec:naming-conventions}

We use the following conventions: lower-case letters $a$, $b$, $c$, ... are integer
variables; \idx is the loop index, which is not a variable and cannot be
assigned; upper-case letters $A$, $B$, $C$, ... are array variables; $e$ is an
expression; $K$ is a constant expression; $f$ is a pure function (it does not
write to variables). The guards expressions of assignment to variable $x$ (scalar variable or
array variable) denoted by letters $g_x$. Subscripted variables $a_0$ and $A_0$ denote
respectively the initial values before the loop of variables $a$ and $A$.
For simplicity, if we have an array A that is never updated in the loop, we
treat such an array A as a constant and simply use $A$ instead of $A_0$. 
Expression $e_0$ denotes the expression $e$ where all variables have been replaced by their 
initial counterparts (this does not apply to the loop index \idx).  
The special expression $e^?$ denotes an unknown value, and expression. 
For simplicity, we denote the group assignment to $x$ \grpassign{x}{1..n} instead of 
$\KWgroup ~ x ~ \{g_{x1} \rightarrow x := e_{x1} .. g_{xn} \rightarrow x := e_{xn}\}$

Given an array $A$ with index bounds $\mathit{low}$ and $\mathit{up}$, we
define a predicate \Pinbounds{A} as follows:

$$\inbounds{A}{j} \equiv \mathit{low} \leq j \leq \mathit{up}$$

We define a predicate \Pseen which characterizes indexes which have already
been treated in the loop:

$$\seen{\idxinitial}{j}{\idx} \equiv \idxinitial \leq j <\idx$$

To treat the iteration monotonicity properties we define a predicate \Pbetween
and a logical function \Ftocount which count the number of loop round from increasing
loop, knowing that we can deduce the case of strictly decreasing by affine transformation.

\begin{eqnarray*}
&\betweens{j}{k}{\idx} \equiv j < k < \idx\\
\and
&\tocount{i} = i - \idxinitial + 1
\end{eqnarray*}

%==================================================================================
%==================================================================================
\subsection{Value-preserving Expressions}

We define \textit{value-preserving expressions} as those expressions whose
value at the program point before group assignments is such that ($e=e_0$) 
is a loop invariant. Let us call the corresponding property
\textit{value-preserving property}:
\begin{equation}
 e=e_0 \tag{\vpp}
\end{equation}
Given a loop index \idx, we denote a \textit{value-preserving expression} $e$
as $e^\at{\idx}$, so that we can express the same expression for differents
values of the loop index (\eg $e^\at{j}$, $e^\at{k}$, \etc). Such an expression
only depends on the number of iterations and initial values of variables
before the loop. Notice that ($e^\at{j} = e_0^\at{j}$) is not necessarily a
loop invariant for $j \neq i$.  For instance in the following example:
$$\begin{array}{l}
  \KWloop \KWover i \KWin 1 .. N \\
  ~~~~ \mathit{true} \rightarrow A[i] := 0\\
  \KWend
\end{array}$$
$e^\at{\idx} \symdef A[\idx]$ (with current index \idx) is a 
value-preserving expression, because ($A[\idx]=A_0[\idx]$) is a loop 
invariant. But ($A[0]=A_0[0]$) is not a loop invariant.

Sufficient conditions for an expression $e$ to be a value-preserving expression
are the following:
\begin{enumerate}
\item $e$ does not refer to scalar variables that are assigned in the loop;
\item $e$ may refer to (array or scalar) variables that are not modified in the loop;
\item $e$ may refer to an array variable $A$ that is modified in the loop,
  provided it does so at index \idx or indexes that are known to be greater
  than \idx (\eg $\idx + 1$), and all assignments to $A$ are at index \idx or
  indexes that are known to be less than \idx (\eg $\idx - 1$). This ordering
  can be more complex, and necessitate a special analysis, like in the case of
  array filtering where the array is assigned at index $v$ where $v$ is
  incremented less often than the loop index.
\end{enumerate}

%==================================================================================
%==================================================================================
\subsection{Proof Preliminaries}
\label{sec:Proof-Pre}

\newcommand{\spostsym}{\ensuremath{\mathcal{SP}}\xspace}
\newcommand{\spost}[2]{\ensuremath{\spostsym(#1,#2)}}
\newcommand{\subst}[3]{\ensuremath{#1[#2 \leftarrow #3]}}

\emph{Strongest Postcondition computation in parallel group assignments (SP-PAR)}
  We define an operator \spost{s}{P} which computes the strongest postcondition of
  property $P$ over statement $s$, where $s$ is a group assignments preceded by the
  exit condition from the loop. 
  The goal is to use the strongest postcondition to calculate the strongest postcondition 
  of $s$ at a given iteration of a loop.
\begin{eqnarray*}
    && \spost{\KWwhen \neg \gexit \KWdo \grpassign{a}{1..n_a} || .. || \grpassign{A}{1..n_A} || ..}{P} \symdef 
   (\neg \gexit) \land (\exists \p{a}..\p{B}..)\\
    &&~~~\\
    &&\begin{array}{cc}  
        \left(\begin{array}{cc}
                \p{P}\\
                \land\\                             
                \left(\begin{array}{cc}
                & \p{g_{a1}} \impl a = \p{e_{a1}} \\
                \land & ...\\
                \land & \p{g_{an_a}} \impl a = \p{e_{an_a}}\\
                \land & \neg \p{g_{a1}} ... \neg \p{g_{an_a}} \impl a = \p{a}\\
              \end{array}\right)\\
              \land\\
              ...\\
              ...\\
              \land\\ 
              \left(\begin{array}{cc}
                & \p{g_{A1}} \impl A[\p{\upsilon_{A1}}] = \p{e_{A1}} \\
                \land & ...\\
                \land & \p{g_{An_a}} \impl A[\p{\upsilon_{An_a}}] = \p{e_{An_a}}\\
                &~~~~~~~~~~~~~~~~\\
                \land & (\forall j)
              \left(\begin{array}{cc}
                &\inbounds{A}{j} \\
                \land & \neg (\p{g_{A1}} \land j =  \p{\upsilon_{A1}})\\
                ...\\
                \land & \neg (\p{g_{An_a}} \land j =  \p{\upsilon_{An_a}})\\
                \end{array}\right) \impl A[j] = \p{A}[j]
              \end{array}\right)\\   
              \land\\
              ...\\
              ...\\
        \end{array}\right)
    \end{array}
\end{eqnarray*}

\vspace{0.5cm}
In the second terms of the righ-hand side of the formulation any expression \p{e} 
represents the expression $e$ where all the occurence of variables modified 
occurring in $e$ are replaced by the existential variable \p{a}..\p{B} ...
Indeed, by notation $\p{e} = \subst{e}{a..A..}{\p{a}..\p{B}..}$

Notice that the rule $SP$ for seqential composition of statements is the
usual rule associated with a sequential execution semantics for statements.
As our semantics guarded assignments is parallel, we should start with proving
that rule \sppar indeed computes the desired strongest postcondition.  

\begin{lemma}
  \emph{(\spostsym Correctness over \loopform)} Operator \spostsym as defined in \sppar,
  computes the strongest postcondition over parallel group assignments in our loop model.
\label{lemma:sp-correctness}
\end{lemma}

\begin{proof}
 $\spost{s_1||s_2}{P} = \spost{s_2||s_1}{P}$ ???
\end{proof}

\newcommand{\capture}[2]{\ensuremath{\mathit{Capture}(#1,#2)}\xspace}
\newcommand{\sli}[1]{\ensuremath{\mathit{SLI}_{#1}}\xspace}

\begin{definition}
  \emph{(Pattern Capture)} An invariant \inv captures a pattern \pat \capture{\inv}{\pat} 
  if:
  \begin{enumerate}
   \item \inv is a \emph{stronguest loop invariant reduced to a Pattern \pat \sli{\pat}},
   i.e \inv is a stronguest loop invariant of a loop where the loop statements are reduced
   to a pattern \pat, starting from state $\mathit{true}$.
   \item \inv is a loop invariant of any loop where \pat occurs.
  \end{enumerate}
\label{def:pattern-capture}
\end{definition}

\begin{lemma}
  $\sli{\pat} \Rightarrow \capture{\inv}{\pat}$
\label{lem:proof-deduction}
\end{lemma}
\begin{proof}
  Let \Inv{\idx} the strongest loop invariant at iteration \idx starting from $\mathit{true}$ for a loop
  $L$ reduced to a given pattern \pat ($\KWloop \KWover \idx \KWin \idxinitial ..\idxfinal 
  ~ \pat ~ \KWend$). Let us prove that  then \Inv{\idx} is an invariant for
  any loop $L'=\KWloop \KWover \idx \KWin \idxinitial ..\idxfinal ~ \pat || \grpassign{x}{1..m} \KWend$.\\
  To be completed (...)\\
  Should be used the write-disjoints predicat between \pat and \grpassign{x}{1..m}???
  $$\writedisjoint{\pat}{\grpassign{x}{1..m}} \symdef \var{\pat} \land \var{\grpassign{x}{1..m}} = \o{}$$
\end{proof}

\patternnote Afterwards, to prove that a invariant suggested for each of our patterns 
  capture this specific pattern we proof only the stronguest loop invariant reduced 
  to this pattern, since the theorem \ref{lem:proof-deduction} give us the point 2 of 
  \emph{Pattern Capture} definition.

%==================================================================================
%==================================================================================
\section{Loop Patterns} 

A loop \emph{Pattern} \pat is defined as a subset of group assignments 
from a loop body statements.

\newcommand{\pattern}[3]{%
\refstepcounter{pc}
\patterndef #1
%
\begin{equation}
  \begin{array}{cccc} #2 \end{array} \tag{\curpattern}
\end{equation}
%
\loopinvariant
%
\begin{equation}
  \Inv{\idx} \symdef \begin{array}{cccc} #3 \end{array} \tag{\curinv}
\end{equation}
}

%==================================================================================
%==================================================================================
\subsection{Search Pattern}

\pattern{
  The group assignments is empty and the controlling \gexit 
  is a value-preserving expression.
}{
  \gexit = g^\at{\idx} 
}{
  (\forall j)(\seen{\idxinitial}{j}{\idx} \impl \neg g^\at{\idx})
}

\patternnote Notice that this pattern is particular to due it allows to control 
             the execution of the loop 

\patternexample

$\begin{array}{l}
  \KWloop \KWover i \KWin 1~..~N~ \KWwhen A[\idx] \neq 0~ \KWdo:\\
  ~~~~ \textit{invariant}: (\forall j)(1\leq j < i \impl A[j] \neq 0)\\
  ~~~~ \varepsilon \\
  \KWend
\end{array}$

\begin{theorem}
  \Inv{\idx} given by \curinv captures pattern \curpattern.
\label{theo:capture-search-pattern}
\end{theorem}

\begin{proof}
  The proof proceeds by induction on the number of iterations \idx.\\ 

  \noindent
  We start from invariant $\mathit{true}$ before the loop.
  %
  \begin{align*}
    \spost{\KWwhen \neg g^\at{\idxinitial} \KWdo}{\mathit{true}
    }  
    &=\neg g^\at{\idxinitial}    && \text{by \sppar}\\
    &=\neg g_0^\at{\idxinitial}  && \text{by \vpp}\\
    &=\Inv{\idxinitial}          && \text{by \curinv}
  \end{align*}
  %
  Now assume \Inv{\idx} at loop iteration \idx, and let us prove that \Inv{\idx+1} 
  at loop iteration $\idx+1$ is the strongest postcondition of \Inv{\idx} through 
  the loop body at iteration \idx. Notice that \Inv{\idx} does not mention any variable, 
  only initial values of variables and current value of the loop index.
  %
  \begin{align*}
    \spost{\KWwhen \neg g^\at{\idx} \KWdo}{\Inv{\idx}
    }  
    &=\neg g^\at{\idx} \land \Inv{\idx}                                                       && \text{by \sppar}\\
    &=\neg g_0^\at{\idx} \land (\forall j)(\seen{\idxinitial}{j}{\idx} \impl \neg g_{0}^\at{j}) && \text{by \vpp}\\
    &=(\forall j)(\seen{\idxinitial}{j}{\idx+1} \impl \neg g_{0}^\at{j})\\
    &=\Inv{\idx+1}                                                                            && \text{by \curinv}
  \end{align*}
  %
  This proves that \Inv{\idx} is the strongest loop invariant on the 
  loop reduced to the pattern. 
\end{proof}


%==================================================================================
%==================================================================================
\subsection{Update Patterns}

\subsubsection*{Certain Single Update Pattern}

\pattern{
  A scalar variable $a$ is modified in exactly a single assignment, whose
  guard is \textit{true}, and it receives a value-preserving expression.
}{
  \mathit{true} \rightarrow a := e^\at{\idx}
}{
  (\idx = \idxinitial \impl a = a_0) \land (\idx \neq \idxinitial \impl a = e_0^\at{\idx - 1})
}

\patternexample

$\begin{array}{l}
  a = \mathit{false}\\
  \KWloop \KWover i \KWin 1~..~N \\
  ~~~~ \textit{invariant}: (\idx = 1 \impl a = \mathit{false}) \land 
        (\idx \neq 1 \impl a = \mathit{true})\\
  ~~~~ true \rightarrow a := true\\
  \KWend
\end{array}$

\begin{theorem}
  \Inv{\idx} given by \curinv captures pattern \curpattern.
\end{theorem}

\begin{proof}
  The proof proceeds by induction on the number of iterations \idx.\\

  \noindent
  We start from precondition $(a = a_0)$ before the loop, because
  initially, the variable $a$ takes its initial value $a_0$.
  %
  \begin{align*}
    \spost{
    &\mathit{true} \rightarrow a := e^\at{\idxinitial}}{a = a_0}\\
    &=(\exists b) (a = e^\at{\idxinitial}[a\leftarrow b] \land b = a_0) && \text{by \sppar}\\
    &=(a = e_0^\at{\idxinitial}) \land (\exists b) (b = a_0)            && \text{by \vpp}\\ 
    &=(a = e_0^\at{\idxinitial}) \land \mathit{true} \\                                                          
    &=\Inv{\idxinitial+1}                                               && \text{by \curinv}
  \end{align*}
  %
  Now assume \Inv{\idx} at loop iteration \idx. Notice that \Inv{\idx} 
  does not mention any variables modified in the loop excepted $a$, 
  initial values of variables and current value of the loop index.
  %
  Let us prove that \Inv{\idx+1} at loop iteration $\idx+1$ is the strongest
  postcondition of \Inv{\idx} through the loop body at iteration \idx.
  %
  \begin{align*}
    \spost{
    &\mathit{true} \rightarrow a := e^\at{\idx}}{\Inv{\idx}}\\
    &=(\exists b) (a = e^\at{\idx}[a\leftarrow b] \land \Inv{\idx}[a\leftarrow b])    && \text{by \sppar}\\
    &=(a = e_0^\at{\idx}) \land (\exists b) (\Inv{\idx}[a\leftarrow b])               && \text{by \vpp on $e^\at{\idx}$}\\ 
    &=(a = e_0^\at{\idx}) \land \mathit{true} \\                                                          
    &=\Inv{\idx+1}                                                                    && \text{by \curinv}
  \end{align*}
  %
  This proves that \Inv{\idx} is the strongest loop invariant on the 
  loop reduced to the current pattern \curpattern.
  By deduction through the theorem \ref{lem:proof-deduction} we complete the proof.
\end{proof}

%==================================================================================
%==================================================================================
\subsubsection*{Known Single Update Pattern}

\pattern{
  A scalar variable is only modified in a single assignment, whose guard is
  a value-preserving expression, and it receives a value-preserving expression.
}{
  g^\at{\idx} \rightarrow a := e^\at{\idx}
}{
  &(a = a_0) \land (\forall j)(\seen{\idxinitial}{j}{\idx} \impl \neg g_0^\at{j})\\
  \lor 
  & (\exists j)(\seen{\idxinitial}{j}{\idx} \land g_0^\at{j} \land a = e_0^\at{j} \land (\forall k)(\betweens{j}{k}{\idx} \impl \neg g_0^\at{k}))
}

\patternexample

$\begin{array}{l}
  \KWloop \KWover i \KWin 1~..~N \\
  ~~~~ \textit{invariant}: (m = m_0) \land (\forall j)(1\leq j < i \impl A(j)-B(j)\neq0)\\
  ~~~~~~~~~~~~~~~~~~~ \lor (\exists j)(1\leq j < i \land A(j)-B(j)= 0 \land m = B(j) \land \\
  ~~~~~~~~~~~~~~~~~~~~~~~~~ (\forall k)(j < k < i \impl A(k)-B(k)\neq0))\\
  ~~~~ A(i)-B(i)=0 \rightarrow m := B(i)\\
  \KWend
\end{array}$

\begin{theorem}
  \Inv{\idx} given by \curinv captures pattern \curpattern.
\end{theorem}

\begin{proof}
  The proof proceeds by induction on the number of iterations \idx.\\

  \noindent
  We start from precondition $(a = a_0)$ before the loop, because
  initially, the variable $a$ takes its initial value $a_0$.
  %
  \begin{eqnarray*}
    &&\spost{g^\at{\idxinitial} \rightarrow a := e^\at{\idxinitial}}{a = a_0}\\
    &&= (\exists b)\left(\begin{array}{ll}
                     & (b = a_0) \\
                    \land & g^\at{\idxinitial}[a\leftarrow b] \impl a = e_0^\at{\idxinitial}[a\leftarrow b] \\
                    \land & \neg g^\at{\idxinitial}[a\leftarrow b] \impl a = a_0
                   \end{array}\right)\\
  \end{eqnarray*}
  %
  $g^\at{\idxinitial}[a\leftarrow b] =g^\at{\idxinitial}$ and $e^\at{\idxinitial} = e^\at{\idxinitial}$ 
  because $a$ not in $g^\at{\idxinitial}$ nor in $e^\at{\idxinitial}$ if any they should not be the value 
  preserving expressions. And by vpp we have the following equivalence:\\
  %
  \begin{eqnarray*}
    &&(\exists b)\left(\begin{array}{ll}
                     & (b = a_0) \\
                    \land & g^\at{\idxinitial}[a\leftarrow b] \impl a = e_0^\at{\idxinitial}[a\leftarrow b] \\
                    \land & \neg g^\at{\idxinitial}[a\leftarrow b] \impl a = a_0
                   \end{array}\right)\\
    &&\Leftrightarrow (\exists b)\left(\begin{array}{ll}
                     & (b = a_0) \\
                    \land & g_0^\at{\idxinitial} \impl a = e_0^\at{\idxinitial} \\
                    \land & \neg g_0^\at{\idxinitial} \impl a = a_0
                   \end{array}\right) \\
    &&\Leftrightarrow \begin{array}{ll}
                        & \neg g_0^\at{\idxinitial} \land a = a_0 \\
                        \lor & g_0^\at{\idxinitial} \land a = e_0^\at{\idxinitial}
                      \end{array} \\
    &&\Leftrightarrow \begin{array}{ll}
                        & a = a_0 \land \idxinitial \leq j < \idxinitial+1 \land \neg g_0^\at{j}  \\
                        \lor & \idxinitial \leq j < \idxinitial+1 \land g_0^\at{j} \land a = e_0^\at{\idxinitial}
                      \end{array} \\
    &&\Leftrightarrow \begin{array}{ll}
                        &(a = a_0) \land (\forall j)(\seen{\idxinitial}{j}{\idxinitial+1} \impl \neg g_0^\at{j})\\
                        \lor 
                        & (\exists j)(\seen{\idxinitial}{j}{\idxinitial+1} \land g_0^\at{j} \land a = e_0^\at{j} \\
                        & \land (\forall k)(\betweens{j}{k}{\idxinitial+1} \impl \neg g_0^\at{k}))
                     \end{array} \\
    &&\Leftrightarrow \Inv{\idxinitial+1}
  \end{eqnarray*}
  %
  Now assume \Inv{\idx} at loop iteration \idx. Notice that \Inv{\idx} 
  does not mention any variables modified in the loop excepted $a$, 
  initial values of variables and current value of the loop index.
  %
  Let us prove that \Inv{\idx+1} at loop iteration $\idx+1$ is the strongest
  postcondition of \Inv{\idx} through the loop body at iteration \idx.
  %
  %
  \begin{eqnarray*}
    &&\spost{g^\at{\idx} \rightarrow a := e^\at{\idx}}{\Inv{\idx}}\\
    &&= (\exists b)\left(\begin{array}{ll}
                     & \Inv{\idx}[a\leftarrow b] \\
                    \land & g^\at{\idx}[a\leftarrow b] \impl a = e_0^\at{\idx}[a\leftarrow b] \\
                    \land & \neg g^\at{\idx}[a\leftarrow b] \impl a = a_0
                   \end{array}\right)\\
  \end{eqnarray*}
  %
  By unfolding \Inv{\idx}, by using the fact that $a$ not in \Inv{\idx} 
  and by using vpp we have the following equivalence:\\
  %
  \begin{eqnarray*}
    &&\Leftrightarrow (\exists b)\left(\begin{array}{ll}
                    &(b = a_0) \land (\forall j)(\seen{\idxinitial}{j}{\idx} \impl \neg g_0^\at{j})\\
                    &\lor (\exists j)(\seen{\idxinitial}{j}{\idx} \land g_0^\at{j} \land b = e_0^\at{j} \\
                    &~~~~~~~~\land (\forall k)(\betweens{j}{k}{\idx} \impl \neg g_0^\at{k}))\\
                    \land & g_0^\at{\idx} \impl a = e_0^\at{\idx} \\
                    \land & \neg g_0^\at{\idx} \impl a = a_0
                   \end{array}\right) \\
    &&= (\exists b)\left(\begin{array}{ll}
                    &(b = a_0) \land (\forall j)(\seen{\idxinitial}{j}{\idx} \impl \neg g_0^\at{j})\\
                    \lor & \neg g_0^\at{\idx} \land a = a_0\\
                    \lor & (\exists j)(\seen{\idxinitial}{j}{\idx} \land g_0^\at{j} \land b = e_0^\at{j} \\
                    &\land (\forall k)(\betweens{j}{k}{\idx} \impl \neg g_0^\at{k}))\\
                    \lor & g_0^\at{\idx} \land a = e_0^\at{\idx} \\
                   \end{array}\right) \\
    &&= (\exists b)\left(\begin{array}{ll}
                    &(a = a_0) \land (\forall j)(\seen{\idxinitial}{j}{\idx+1} \impl \neg g_0^\at{j})\\
                    \lor & (\exists j)(\seen{\idxinitial}{j}{\idx+1} \land g_0^\at{j} \land b = e_0^\at{j} \\
                    &\land (\forall k)(\betweens{j}{k}{\idx+1} \impl \neg g_0^\at{k}))\\
                   \end{array}\right) \\
    &&\Leftrightarrow \Inv{\idx+1}
  \end{eqnarray*}
  %
  Since $g_0^\at{\idx}$ and $\neg g_0^\at{\idx}$ is multually independant we have two cases:
  %
  \begin{eqnarray*}
    &&\Leftrightarrow (\exists b)\left(\begin{array}{ll}
                    \left(\begin{array}{ll}
                            &(b = a_0) \land (\forall j)(\seen{\idxinitial}{j}{\idx} \impl \neg g_0^\at{j})\\
                            &\lor (\exists j)(\seen{\idxinitial}{j}{\idx} \land g_0^\at{j} \land b = e_0^\at{j} \\
                            &~~~~~~~~\land (\forall k)(\betweens{j}{k}{\idx} \impl \neg g_0^\at{k}))\\
                            \lor & g_0^\at{\idx} \land a = e_0^\at{\idx} \\
                    \end{array}\right)\\
                    \bigoplus\\
                    \left(\begin{array}{ll}
                            &(b = a_0) \land (\forall j)(\seen{\idxinitial}{j}{\idx} \impl \neg g_0^\at{j})\\
                            &\lor (\exists j)(\seen{\idxinitial}{j}{\idx} \land g_0^\at{j} \land b = e_0^\at{j} \\
                            &~~~~~~~~\land (\forall k)(\betweens{j}{k}{\idx} \impl \neg g_0^\at{k}))\\
                            \lor & \neg g_0^\at{\idx} \land a = a_0 \\
                    \end{array}\right)\\
                   \end{array}\right) \\
    &&\Leftrightarrow (\exists b)\left(\begin{array}{ll}
                    &(b = a_0) \land (\forall j)(\seen{\idxinitial}{j}{\idx} \impl \neg g_0^\at{j})\\
                    \lor & \neg g_0^\at{\idx} \land a = a_0\\
                    \lor & (\exists j)(\seen{\idxinitial}{j}{\idx} \land g_0^\at{j} \land b = e_0^\at{j} \\
                    &\land (\forall k)(\betweens{j}{k}{\idx} \impl \neg g_0^\at{k}))\\
                    \lor & g_0^\at{\idx} \land a = e_0^\at{\idx} \\
                   \end{array}\right) \\
    &&\Leftrightarrow (\exists b)\left(\begin{array}{ll}
                    &(a = a_0) \land (\forall j)(\seen{\idxinitial}{j}{\idx+1} \impl \neg g_0^\at{j})\\
                    \lor & (\exists j)(\seen{\idxinitial}{j}{\idx+1} \land g_0^\at{j} \land b = e_0^\at{j} \\
                    &\land (\forall k)(\betweens{j}{k}{\idx+1} \impl \neg g_0^\at{k}))\\
                   \end{array}\right) \\
    &&\Leftrightarrow \Inv{\idx+1}
  \end{eqnarray*}
  %
\end{proof}

%==================================================================================
%==================================================================================

\subsubsection*{Known Multiple Update Pattern}

\pattern{
  A scalar variable is modified in more than one assignment, all of
  whose guards are value-preserved, and it receives in each a value-preserving expression.
}{
  &g_1^\at{\idx} \rightarrow a := e_1^\at{\idx}\\
  &...\\
  &g_n^\at{\idx} \rightarrow a := e_n^\at{\idx}\\
}{
  &(a = a_0) \land (\forall j)(\forall r)(\seen{\idxinitial}{j}{\idx} \impl \neg g_{r0}^\at{j})\\
  \lor 
  & (\exists j)
   \left(\begin{array}{cl}
  &(\exists r)(\seen{\idxinitial}{j}{\idx} \land g_{r0}^\at{j} \land a = e_{r0}^\at{j})\\
   \land&  (\forall k)(\forall r) (\betweens{j}{k}{\idx} \impl \neg g_{r0}^\at{k})
   \end{array}\right)
}
%
\patternnote In this invariant and others multiple invariants patterns, 
existential and universal quantifier concern the implicit range of all 
guarded assignment considered, i.e : $1 \leq r \leq n$.

\patternexample

$\begin{array}{l}
  \KWloop \KWover i \KWin 1~..~N \\
  ~~~~ \textit{invariant}: (m = m_0) \land (\forall j)(1\leq j < i \impl A(j)-B(j)=0)\\
  ~~~~~~~~~~~~~~~~~~~ \lor (\exists j)(\seen{\idxinitial}{j}{\idx} \land ((A(j)-B(j) < 0 \land m = B_0(j)) \lor\\
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ (A(j)-B(j) > 0 \land m = A_0(j)))\\
  ~~~~~~~~~~~~~~~~~~~~~~~~~~ \land (\forall k)(j < k < i \impl (A(k)-B(k) = 0)))\\
  ~~~~ A(i)-B(i) < 0 \rightarrow m := B(i)\\
  ~~~~ A(i)-B(i) > 0 \rightarrow m := A(i)\\
  \KWend
\end{array}$

\begin{proof}
  The proof proceeds by induction on the number of iterations \idx.
  It's the generalizing of above proof. ???
 
\end{proof}

%==================================================================================
%==================================================================================
\subsubsection*{Unknown Single Update Pattern}

\pattern{
  A scalar variable $a$ is modified at most in a single assignment, whose
  guard is unknown, and it receives a value-preserving expression.
}{
  g^? \rightarrow a := e^\at{\idx}
}{
  (a = a_0) \lor (\exists j)(\seen{\idxinitial}{j}{\idx} \land a = e_0^\at{j})\\
}

\patternexample

$\begin{array}{l}
  \KWloop \KWover i \KWin 1~..~N \\
  ~~~~ \textit{invariant}: (m = m_0) \lor (\exists j)(1\leq j < i \land m = B_0(j))\\
  ~~~~ A(m)-B(m)=0 \rightarrow m := B(i)\\
  \KWend
\end{array}$

\begin{theorem}
  \Inv{\idx} given by \curinv captures pattern \curpattern.
\end{theorem}

\begin{proof}
  The proof proceeds by induction on the number of iterations \idx.\\

  \noindent
  We start from precondition $(a = a_0)$ before the loop, because
  initially, the variable $a$ takes its initial value $a_0$.
  %
  \begin{eqnarray*}
    &&\spost{g^? \rightarrow a := e^\at{\idxinitial}}{a = a_0}\\
    &&= (\exists b)\left(\begin{array}{ll}
                     & (b = a_0) \\
                    \lor & g_0^\at{\idxinitial} \land a = e_0^\at{\idxinitial} \\
                    \lor & \neg g_0^\at{\idxinitial} \land a = a_0
                   \end{array}\right) \\
    &&= (\exists b)\left(\begin{array}{ll}
                     & (b = a_0) \\
                    \lor & g_0^\at{\idxinitial} \land a = e_0^\at{\idxinitial} \\
                    \lor & \neg g_0^\at{\idxinitial} \land a = a_0
                   \end{array}\right) \\
    &&\Leftrightarrow \begin{array}{ll}
                        & \neg g_0^\at{\idxinitial} \land a = a_0 \\
                        \lor & g_0^\at{\idxinitial} \land a = e_0^\at{\idxinitial}
                      \end{array} \\
    &&\Leftrightarrow \begin{array}{ll}
                        & a = a_0 \land \idxinitial \leq j < \idxinitial+1 \land \neg g_0^\at{j}  \\
                        \lor & \idxinitial \leq j < \idxinitial+1 \land g_0^\at{j} \land a = e_0^\at{\idxinitial}
                      \end{array} \\
    &&\Leftrightarrow \begin{array}{ll}
                        &(a = a_0) \land (\forall j)(\seen{\idxinitial}{j}{\idxinitial+1} \impl \neg g_0^\at{j})\\
                        \lor 
                        & (\exists j)(\seen{\idxinitial}{j}{\idxinitial+1} \land g_0^\at{j} \land a = e_0^\at{j} \\
                        & \land (\forall k)(\betweens{j}{k}{\idxinitial+1} \impl \neg g_0^\at{k}))
                     \end{array} \\
    &&\Leftrightarrow \Inv{\idxinitial+1}
  \end{eqnarray*}
  %
  Now assume \Inv{\idx} at loop iteration \idx. Notice that \Inv{\idx} 
  does not mention any variables modified in the loop excepted $a$, 
  initial values of variables and current value of the loop index.
  %
  Let us prove that \Inv{\idx+1} at loop iteration $\idx+1$ is the strongest
  postcondition of \Inv{\idx} through the loop body at iteration \idx.
  %
  %
  \begin{eqnarray*}
    &&\spost{g^\at{\idx} \rightarrow a := e^\at{\idx}}{\Inv{\idx}}\\
    &&= (\exists b)\left(\begin{array}{ll}
                    &(b = a_0) \land (\forall j)(\seen{\idxinitial}{j}{\idx} \impl \neg g_0^\at{j})\\
                    \lor & (\exists j)(\seen{\idxinitial}{j}{\idx} \land g_0^\at{j} \land b = e_0^\at{j} \\
                    &\land (\forall k)(\betweens{j}{k}{\idx} \impl \neg g_0^\at{k}))\\
                    \lor & g_0^\at{\idx} \land a = e_0^\at{\idx} \\
                    \lor & \neg g_0^\at{\idx} \land a = a_0
                   \end{array}\right) \\
    &&= (\exists b)\left(\begin{array}{ll}
                    &(b = a_0) \land (\forall j)(\seen{\idxinitial}{j}{\idx} \impl \neg g_0^\at{j})\\
                    \lor & \neg g_0^\at{\idx} \land a = a_0\\
                    \lor & (\exists j)(\seen{\idxinitial}{j}{\idx} \land g_0^\at{j} \land b = e_0^\at{j} \\
                    &\land (\forall k)(\betweens{j}{k}{\idx} \impl \neg g_0^\at{k}))\\
                    \lor & g_0^\at{\idx} \land a = e_0^\at{\idx} \\
                   \end{array}\right) \\
    &&= (\exists b)\left(\begin{array}{ll}
                    &(a = a_0) \land (\forall j)(\seen{\idxinitial}{j}{\idx+1} \impl \neg g_0^\at{j})\\
                    \lor & (\exists j)(\seen{\idxinitial}{j}{\idx+1} \land g_0^\at{j} \land b = e_0^\at{j} \\
                    &\land (\forall k)(\betweens{j}{k}{\idx+1} \impl \neg g_0^\at{k}))\\
                   \end{array}\right) \\
    &&\Leftrightarrow \Inv{\idx+1}
  \end{eqnarray*}

\end{proof}



\subsubsection*{Single Min/Max Pattern}

\pattern{
  A scalar variable $a$ is only modified in a single assignment, whose
  guard is a comparison between the variable and a value-preserving expression, and
  it receives the same value-preserving expression.
}{
  (a \bullet e^\at{\idx}) \rightarrow a := e^\at{\idx}  \qquad \bullet \in \{<, \leq, >, \geq \}
}{
  & (a \circ a_0) \land (\forall k)(\seen{\idxinitial}{k}{\idx} \impl a \circ e_0^\at{k})\\
  \land & ((a = a_0) \lor (\exists j)(\seen{\idxinitial}{j}{\idx} \land a = e_0^\at{j})) 
}
%
where $\circ$ can be deduced from $\bullet$ as follows:
$\begin{array}{l|llll}
\bullet & <    & \leq & >    & \geq \\ \hline
\circ   & \geq & \geq & \leq & \leq
\end{array}$

\vspace{0.5cm}
\patternnote Above invariant is equivalent to its complex form:
\begin{eqnarray*}
&(a = a_0) \land (\forall j)(\seen{\idxinitial}{j}{\idx} \impl \neg (a_0 \bullet e_0^\at{j}))\\
\lor 
& ((\exists j)(\seen{\idxinitial}{j}{\idx} \land a = e_0^\at{j} \land (\forall k)(\betweens{j}{k}{i} \impl 
  \neg (a_0 \bullet e_0^\at{k}))) \land \\
&(\forall k)(\seen{\idxinitial}{k}{\idx} \impl a \circ e_0^\at{k}))\\
\end{eqnarray*}

\patternexample

$\begin{array}{l}
  \KWloop \KWover i \KWin 1~..~N \\
  ~~~~ \textit{invariant}: (m = m_0) \land (\forall j)(1\leq j < i \impl \neg (m_0 < A[j]))\\
  ~~~~~~~~~~~ \lor ((\exists j)(1\leq j < i \land m = A[j]) \land (\forall k)(1\leq k < i \impl m \geq A[k]))\\
  ~~~~ m < A(i) \rightarrow m := A(i)\\
  \KWend
\end{array}$

\begin{theorem}
  \Inv{\idx} given by \curinv captures pattern \curpattern.
\end{theorem}

\begin{proof}
  The proof proceeds by induction on the number of iterations \idx.\\

  \noindent
  We start from invariant $(a = a_0)$ before the loop, because
  initially, the variable $a$ take it initial value $a_0$.
  % 
  \begin{eqnarray*}
    &&\spost{(a \bullet e^\at{\idxinitial}) \rightarrow a := e^\at{\idxinitial}}{a = a_0}\\
    &&= (\exists b)\left(\begin{array}{ll}
                     & (b = a_0) \\
                    \land & (b \bullet e^\at{\idxinitial}[a\leftarrow b]) \impl a = e^\at{\idxinitial}[a\leftarrow b] \\
                    \land & \neg (b \bullet e^\at{\idxinitial}[a\leftarrow b]) \impl a = a_0
                   \end{array}\right) \\
    &&= (\exists b)\left(\begin{array}{ll}
                     & (b = a_0) \\
                    \land & (b \bullet e_0^\at{\idxinitial}) \impl a = e_0^\at{\idxinitial} \\
                    \land & \neg (b \bullet e_0^\at{\idxinitial}) \impl a = a_0
                   \end{array}\right) \\
    &&\Leftrightarrow \begin{array}{ll}
                        &(\exists b) ( b = a_0) \land\\
                        & (\neg (a_0 \bullet e_0^\at{\idxinitial}) \lor a = e_0^\at{\idxinitial})
                        \land ((a_0 \bullet e_0^\at{\idxinitial}) \lor a = a_0)\\ 
                      \end{array} \\
  \end{eqnarray*}
  %
  By developping : 
  \begin{eqnarray*}
    &&\Leftrightarrow \begin{array}{ll}
                        & (\neg (a_0 \bullet e_0^\at{\idxinitial}) \land (a_0 \bullet e_0^\at{\idxinitial}))  
                        \lor (\neg (a_0 \bullet e_0^\at{\idxinitial}) \land (a = a_0)) \\ 
                        &\lor (a = e_0^\at{\idxinitial}) \land (\neg (a_0 \bullet e_0^\at{\idxinitial})
                        \lor ((a = e_0^\at{\idxinitial}) \land a = a_0)\\ 
                      \end{array} \\
    &&\Leftrightarrow \begin{array}{ll}
                        & (a \circ a_0) \land (\forall j)(\seen{\idxinitial}{j}{\idxinitial+1} \impl a \circ e_0^\at{j})\\
                        \land & ((a = a_0) \lor (\exists j)(\seen{\idxinitial}{j}{\idxinitial+1} \land a = e_0^\at{j})) 
                      \end{array} \\
    &&\Leftrightarrow \Inv{\idxinitial+1}                                               ~~~ \text{by \curinv}
  \end{eqnarray*}
  %
  Now assume \Inv{\idx} at loop iteration \idx. Notice that \Inv{\idx} does not
  mention any variable, only initial values of variables and current value of
  the loop index.
  Let us prove that \Inv{\idx+1} at loop iteration $\idx+1$ is the strongest
  postcondition of \Inv{\idx} through the loop body at iteration \idx.
  % 
  \begin{align*}
    \spost{
    &(a \bullet e^\at{\idx}) \rightarrow a := e^\at{\idx}}{\Inv{\idx}}\\
    &=\begin{array}{ll}
           & \neg (a \bullet e^\at{\idx}) \land \Inv{\idx} \\
      \lor & (\exists b) ((a \bullet e^\at{\idx})[a\leftarrow b] \land 
      a = e^\at{\idx}[a\leftarrow b] \land \Inv{\idx}[a\leftarrow b])
      \end{array} && \text{by \spscalar}\\
    &=\begin{array}{ll}
           & \neg (a \bullet e_0^\at{\idx}) \land \Inv{\idx} \\
      \lor & (\exists b) ((a \bullet e_0^\at{\idx})[a\leftarrow b] \land 
      a = e_0^\at{\idx}[a\leftarrow b] \land \Inv{\idx}[a\leftarrow b])
      \end{array}  && \text{by \vpp}\\
    &=\begin{array}{ll}
           & \neg (a \bullet e_0^\at{\idx}) \land \Inv{\idx} \\
      \lor & (a = e_0^\at{\idx}) \land (\exists b) ((b \bullet e_0^\at{\idx}) 
      \land \Inv{\idx}[a\leftarrow b])
      \end{array}
  \end{align*}
  %
  Let us denote:
  %
  \begin{align*}
    A &\symdef\neg (a \bullet e_0^\at{\idx}) \land \Inv{\idx} \\
    B &\symdef(a = e_0^\at{\idx}) \land (\exists b) ((b \bullet e_0^\at{\idx}) \land \Inv{\idx}[a\leftarrow b])) \\
  \end{align*}

  \subproof{Case $\bullet \in \{<, >\}$}
  \subproof{Case $\bullet \in \{\leq, \geq\}$}
\end{proof}

%==================================================================================
%==================================================================================
\subsubsection*{Single Min/Max Index Pattern}

\pattern{
  A scalar variable $a$ is only modified in a single assignment, whose
  guard is a comparison between a value-preserving expression and the same expression
  where the loop index is replaced by the variable, and it receives the value of
  the loop index.
}{
  (e^\at{a} \bullet e^\at{\idx}) \rightarrow a := \idx  \qquad \bullet \in \{<, \leq, >, \geq \}
}{
  &(a = a_0) \land (\forall j)(\seen{\idxinitial}{j}{\idx} \impl \neg (e_0^\at{a_0} \bullet e_0^\at{j})) \\
  \lor 
  & ((\exists j)(\seen{\idxinitial}{j}{\idx} \land a = j) \land (\forall k)(\seen{\idxinitial}{k}{\idx} \impl e_0^\at{a} \circ e_0^\at{k}))
}
%
where $\circ$ can be deduced from $\bullet$ as follows:
$\begin{array}{l|llll}
\bullet & <    & \leq & >    & \geq \\ \hline
\circ   & \geq & \geq & \leq & \leq
\end{array}$

\patternexample

$\begin{array}{l}
  \KWloop \KWover i \KWin 1~..~N \\
  ~~~~ \textit{invariant}: (m = m_0) \land (\forall j)(1\leq j < i \impl \neg (A(m_0) < A[j]))\\
  ~~~~~~~~~~ \lor ((\exists j)(1\leq j < i \land m = j) \land (\forall k)(1\leq k < i \impl A(m) \geq A[k]))\\
  ~~~~ A(m) < A(i) \rightarrow m := i\\
  \KWend
\end{array}$

\subsection{Integrate Patterns}

\subsubsection*{Certain Single Add-Up Pattern}

\pattern{
  A scalar variable $a$ is modified at most in a single assignment, whose
  guard is \textit{true}, and it receives its own previous value plus a constant.
}{
  \mathit{true} \rightarrow a := a + K
}{
  a = a_0 + K * (i-1)
}
%
\patternnote The change of $a$ follows a geometric serie because by reason of $K$ 
             and the first term $a_0$\\

\patternexample

$\begin{array}{l}
  \KWloop \KWover i \KWin 1~..~N \\
  ~~~~ \textit{invariant}: m = m_0 + (i-1)\\
  ~~~~ true \rightarrow m := m+1\\
  \KWend
\end{array}$

\begin{proof}
  The proof proceeds by induction on the number of iterations \idx.\\
  

  \noindent
  We start from invariant $(a = a_0)$ before the loop, because
  initially, the variable $a$ take it initial value $a_0$.
  Notice that the pattern is not yet reached.
  %
  \begin{align*}
     (a = a_0) = \Inv{\idxinitial}      && \text{by \curinv}\\
  \end{align*}
  %
  Now assume \Inv{\idx} at loop iteration \idx, and let us prove that \Inv{\idx+1} 
  at loop iteration $\idx+1$ is the strongest postcondition of \Inv{\idx} through 
  the loop body at iteration \idx. Notice that \Inv{\idx} does not mention any variable, 
  only initial values of variables and current value of the loop index.
  %

\bigskip
1. reduced case: $\grpassign{exit}{1..n} = \o{} \land \grpassign{assign}{1..m} = \o{}$   
  %
  \begin{align*}
    \spost{
    & \mathit{true} \rightarrow a := a + K}{\Inv{\idx}\\
    }
    &=\Inv{\idx} \lor (\exists b) (b = b + K \land \Inv{\idx}[a\leftarrow b])   && \text{by \spscalar}\\
    &=\Inv{\idx} \lor (\exists b) (b = b + K \land b = a_0 + K * (i-1))   && \text{by \spscalar}\\
    &=\Inv{\idx} \lor (\exists b) (b = b + K \land b + K = a_0 + K * (i-1))   && \text{by \spscalar}\\
  \end{align*}
  %
  This proves that \Inv{\idx} is the strongest loop invariant on the 
  loop reduced to the pattern. 

\bigskip
2. general case : there may be others guarded exit and guarded assignment statements
                  in addition to the current pattern \curpattern.\\
  %
%   \begin{align*}
%     \spost{
%       &\gst{exit}{1..n};\\
%       &\mathit{true} \rightarrow a := e^\at{\idx}}{\Inv{\idx};\\
%       &\grpassign{assign}{1..m}\\
%     }
%     &= \spost{\grpassign{assign}{1..m}}{\spost{\mathit{true} \rightarrow a := e^\at{\idx}}
%         {\spost{\grpassign{exit}{1..n}}{\Inv{\idx}}}} && \text{by \spseq} \\ 
%     &\Rightarrow \spost{\grpassign{assign}{1..m}}
%         {\spost{\mathit{true} \rightarrow a := e^\at{\idx}}{\Inv{\idx}}} && \text{by lemma \ref{lemma:sp-g-exits}} \\ 
%     &= \spost{\grpassign{assign}{1..m}}{\Inv{\idx+1}} && \text{by reduce case} \\ 
%     &\Rightarrow \Inv{\idx+1} && \text{by lemma \ref{lemma:sp-g-assignments}}
%   \end{align*}
  % 
  This proves that \Inv{\idx} is a loop invariant of every loop where pattern
  \curpattern occurs.
\end{proof}

\subsubsection*{Known Single Add-Up Pattern}

\patterndef A scalar variable $a$ is modified at most in a single assignment, whose
guard is a value-preserving expression, and it receives its own previous value plus a constant $k$.
%
$$g^\at{\idx} \rightarrow a := a + K$$
%
\loopinvariant
%
\begin{eqnarray*}
&(a = a_0) \land (\forall j)(\seen{\idxinitial}{j}{\idx} \impl \neg g_0^\at{j})) \\
\lor 
& (\exists j)
\left(\begin{array}{cl}
&\seen{\idxinitial}{j}{\idx} \land g_0^\at{j}\\
 \land& (\exists k)(1 \leq k \leq \tocount{j} \land a = a_0 + K * k) \\
\land& (\forall k)(\betweens{j}{k}{\idx} \impl \neg g_0^\at{k})
\end{array}\right)
\end{eqnarray*}

\bigskip
\patternexample

\medskip
$\begin{array}{l}
  \KWloop \KWover i \KWin 1~..~N \\
  ~~~~ \textit{invariant}: (m = m_0) \land (\forall j)(1\leq j < i \impl A(j)-B(j)\neq0)\\
  ~~~~~~~~~~~~~~~~~~~ \lor (\exists j)(\seen{\idxinitial}{j}{\idx} \land A(j)-B(j)= 0 \land \\
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ (\exists k)(1 \leq k \leq j \land m = m_0 + k) \land\\
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ (\forall k)(j < k < i \impl A(k)-B(k)\neq0))\\
  ~~~~ A(i)-B(i)=0 \rightarrow m := m+1\\
  \KWend
\end{array}$

\subsubsection*{Known Multiple Add-Up Pattern}

\patterndef A scalar variable is modified in more than one assignment, all of
whose guards are value-preserved, and it receives in each its own previous value
plus a constant.
%
\begin{eqnarray*}
&g_1^\at{\idx} \rightarrow a := a + K_1\\
&...\\
&g_n^\at{\idx} \rightarrow a := a + K_n\\
\end{eqnarray*}
%
\loopinvariant
%
\begin{eqnarray*}
&(a = a_0) \land (\forall j)(\forall r)( \seen{\idxinitial}{j}{\idx} \impl \neg g_{r0}^\at{j})) \\
\lor 
& (\exists j)
\left(\begin{array}{cl}
&(\exists r)(\seen{\idxinitial}{j}{\idx} \land g_{r0}^\at{j}) \\
\land& (\exists k)(1 \leq k \leq \tocount{j} \land a_0 + \mathit{min}(K_r) * k \leq a \leq a_0 + \mathit{max}(K_r) * k) \\
\land& (\forall k)(\forall r)(\betweens{j}{k}{\idx} \impl \neg g_{r0}^\at{k})
\end{array}\right)
\end{eqnarray*}

\bigskip
\patternexample

\medskip
$\begin{array}{l}
  \KWloop \KWover i \KWin 1~..~N \\
  ~~~~ \textit{invariant}: (m = m_0) \land (\forall j)(1\leq j < i \impl A(j)-B(j) = 0)\\
  ~~~~~~~~~~~~~~~~~~~ \lor (\exists j)(\seen{\idxinitial}{j}{\idx} \land (A(j)-B(j) < 0 \lor A(j)-B(j) > 0) \\
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ \land (\exists k)(1 \leq k \leq j \land m_0-k \leq m \leq m_0 +k) \\
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ \land (\forall k)(j < k < i \impl A(j)-B(j) = 0))\\
  ~~~~ A(i)-B(i) < 0 \rightarrow m := m+1\\
  ~~~~ A(i)-B(i) > 0 \rightarrow m := m-1\\
  \KWend
\end{array}$

\subsubsection*{Unknown Single Add-Up Pattern}

\patterndef A scalar variable $a$ is modified at most in a single assignment, whose
guard is unknown, and it receives its own previous value plus a constant.
%
$$g^? \rightarrow a := a + K$$
%
\loopinvariant
%
$$(a = a_0) \lor (\exists j)(\seen{\idxinitial}{j}{\idx} \land (\exists k)(1 \leq k \leq \tocount{j} \land a = a_0 + K * k))$$

\bigskip
\patternexample

\medskip
$\begin{array}{l}
  \KWloop \KWover i \KWin 1~..~N \\
  ~~~~ \textit{invariant}: (m = m_0) \lor \\
  ~~~~~~~~~~~~~~~~~~ (\exists j)(1 \leq j < i \land (\exists k)(1 \leq k \leq j \land m = m_0+10*k))\\
  ~~~~ F(m)=0 \rightarrow m := m+10\\
  \KWend
\end{array}$

\subsubsection*{Unknown Multiple Add-Up Pattern}

\patterndef A scalar variable is modified in more than one assignment, all of
whose guards are unknown, and it receives in each its own previous value
plus a constant.
%
\begin{eqnarray*}
&g^? \rightarrow a := a + K_1\\
&...\\
&g^? \rightarrow a := a + K_n\\
\end{eqnarray*}
%
\loopinvariant
%
\begin{eqnarray*}
&(a = a_0) \lor\\
&(\exists j)(\seen{\idxinitial}{j}{\idx} \land (\exists k)(1 \leq k \leq \tocount{j} \land a_0 + \mathit{min}(K_r)*k \leq a \leq a_0 + \mathit{max}(K_r)*k))\\
\end{eqnarray*}

\bigskip
\patternexample

\medskip
$\begin{array}{l}
  \KWloop \KWover i \KWin 1~..~N \\
  ~~~~ \textit{invariant}: (m = m_0) \lor \\
  ~~~~~~~ (\exists j)(1 \leq j < i \land (\exists k)(1 \leq k \leq j \land m_0+10*k \leq m \leq m_0 +20*k))\\
  ~~~~ F(m)=0 \rightarrow m := m+10\\
  ~~~~ G(m)=0 \rightarrow m := m+20\\
  \KWend
\end{array}$

\subsubsection*{Certain Single Mult-Up Pattern}

\patterndef A scalar variable is only modified in a single assignment, whose
guard is \textit{true}, and it receives its own previous value times
(resp. divided by) a constant.
%
$$\mathit{true} \rightarrow a := a \bullet K \qquad \bullet \in \{*, / \}$$
%
\loopinvariant
%
$$a = a_0 \bullet K^{i-1}$$

\bigskip
\patternexample

\medskip
$\begin{array}{l}
  \KWloop \KWover i \KWin 1~..~N \\
  ~~~~ \textit{invariant}: m = m_0 * 2^{i-1}\\
  ~~~~ true \rightarrow m := m*2\\
  \KWend
\end{array}$

\subsubsection*{Known Single Mult-Up Pattern}

\patterndef A scalar variable is only modified in a single assignment, whose
guard is a value-preserving expression, and it receives its own previous value times
(resp. divided by) a constant.

$$g^\at{\idx} \rightarrow a := a \bullet K  \qquad \bullet \in \{*, / \}$$

\loopinvariant

\begin{eqnarray*}
&(a = a_0) \land (\forall j)(\seen{\idxinitial}{j}{\idx} \impl \neg g_0^\at{j})) \\
\lor 
& (\exists j)
\left(\begin{array}{cl}
& \seen{\idxinitial}{j}{\idx} \land g_0^\at{j} \\
\land& (\exists k)(1 \leq k \leq \tocount{j} \land a = a_0 \bullet K^k)\\
\land& (\forall k)(\betweens{j}{k}{\idx} \impl \neg g_0^\at{k})
\end{array}\right)
\end{eqnarray*}

\bigskip
\patternexample

\medskip
$\begin{array}{l}
  \KWloop \KWover i \KWin 1~..~N \\
  ~~~~ \textit{invariant}: (m = m_0) \land (\forall j)(1 \leq j < i \impl A(j)-B(j)\neq0)\\
  ~~~~~~~~~~~~~~~~~~~ \lor (\exists j)(\seen{\idxinitial}{j}{\idx} \land (A(j)-B(j)= 0 \land \\
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ (\exists k)(1 \leq k \leq j \land m = m_0 * 2^k) \land\\
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ (\forall k)(j < k < i \impl A(k)-B(k)\neq0))\\
  ~~~~ A(i)-B(i)=0 \rightarrow m := m*2\\
  \KWend
\end{array}$

\subsubsection*{Unknown Single Mult-Up Pattern}

\patterndef A scalar variable $a$ is modified at most in a single assignment, whose
guard is unknown, and it receives its own previous value times
(resp. divided by) a constant.
%
$$g^? \rightarrow a := a \bullet K  \qquad \bullet \in \{*, / \}$$
%
\loopinvariant
%
$$(a = a_0) \lor (\exists j)(\seen{\idxinitial}{j}{\idx} \land (\exists k)(1 \leq k \leq \tocount{j} \land a = a_0 \bullet K^k))$$

\bigskip
\patternexample

\medskip
$\begin{array}{l}
  \KWloop \KWover i \KWin 1~..~N \\
  ~~~~ \textit{invariant}: (m = m_0) \lor \\
  ~~~~~~~~~~~~~~~~~~~ (\exists j)(1 \leq j < i \land (\exists k)(1 \leq k \leq j \land m = m_0+10^k))\\
  ~~~~ F(m)=0 \rightarrow m := m*10\\
  \KWend
\end{array}$

\subsection{Map Patterns}

\subsubsection*{Certain Single Map Pattern}

\patterndef An array variable is modified at index \idx, in at most single assignment, whose
guard is \textit{true} and it receives a value-preserving expression.
%
$$\mathit{true} \rightarrow A[\idx] := e^\at{\idx}$$
%
\loopinvariant
%
\begin{eqnarray*}
&(\forall j)(\seen{\idxinitial}{j}{\idx} \impl A[j] = e_0^\at{j}) \\
\land& (\forall j)(\neg \seen{\idxinitial}{j}{\idx} \land \inbounds{A}{j} \impl A[j] = A_0[j])
\end{eqnarray*}
%
\patternnote This pattern corresponds in particular to an array copy.

\bigskip
\patternexample

\medskip
$\begin{array}{l}
  \KWloop \KWover i \KWin 1~..~N \\
  ~~~~ \textit{invariant}: (\forall j)(1\leq j< i \impl A[j] = B[j]) \land\\
  ~~~~~~~~~~~~~~~~~~~ (\forall j)(1 > j \land j \geq i \land \inbounds{A}{j} \impl A[j] = A_0[j])\\
  ~~~~ true \rightarrow A[i] := B[i]\\
  \KWend
\end{array}$

\subsubsection*{Certain Shifted Single Map Pattern}

\patterndef An array variable is modified at index \idx plus a constant $k$, in at most single assignment, 
whose guard is \textit{true}, and it receives a value-preserving expression.
%
$$\mathit{true} \rightarrow A[\idx + K] := e^\at{\idx}$$
%
\loopinvariant
%
\begin{eqnarray*}
&(\forall j)(\seen{\idxinitial}{j}{\idx} \impl A[j + K] = e_0^\at{j}) \\
\land& (\forall j)(\neg \seen{\idxinitial}{j}{\idx} \land \inbounds{A}{j + K} \impl A[j + K] = A_0[j + K])
\end{eqnarray*}
%
\patternnote All map patterns can be shifted like the above.

\bigskip
\patternexample

\medskip
$\begin{array}{l}
  \KWloop \KWover i \KWin 1~..~N \\
  ~~~~ \textit{invariant}: (\forall j)(1 \leq j < i \impl A[j+1] = B[j]) \land\\
  ~~~~~~~~~~~~ (\forall j)(1 > j \land j \geq i \land \inbounds{A}{j+1} \impl A[j+1] = A_0[j+1])\\
  ~~~~ true \rightarrow A[i+1] := B[i]\\
  \KWend
\end{array}$

\subsubsection*{Known Single Map Pattern}

\patterndef An array variable is modified at index \idx in at most single assignment, whose
guard is a value-preserving expression, and it receives a value-preserving expression.
%
$$g^\at{\idx} \rightarrow A[\idx] := e^\at{\idx}$$
%
\loopinvariant
%
\begin{eqnarray*}
&(\forall j)(\seen{\idxinitial}{j}{\idx} \land g_0^\at{j} \impl A[j] = e_0^\at{j}) \\
\land&(\forall j)(\seen{\idxinitial}{j}{\idx} \land \neg g_0^\at{j} \impl A[j] = A_0[j]) \\
\land&
 (\forall j)(\neg \seen{\idxinitial}{j}{\idx} \land \inbounds{A}{j} \impl A[j] = A_0[j])\\
\end{eqnarray*}

\bigskip
\patternexample

\medskip
$\begin{array}{l}
  \KWloop \KWover i \KWin 1~..~N \\
  ~~~~ \textit{invariant}: (\forall j)(1 \leq j < i \land A_0[j] \neq 0 \impl A[j] = 0) \land\\
  ~~~~~~~~~~~~~~~~~~~ (\forall j)(1 \leq j < i \land A_0[j] = 0 \impl A[j] = A_0[j]) \land\\
  ~~~~~~~~~~~~~~~~~~~ (\forall j)(1 > j \land j \geq i \land \inbounds{A}{j} \impl A[j] = A_0[j])\\
  ~~~~ A[i] \neq 0 \rightarrow A[i] := 0\\
  \KWend
\end{array}$

\subsubsection*{Known Multiple Map Pattern}

\patterndef An array variable is modified in more than one assignment, all
of whose guards are value-preserving expressions, at index \idx, and it receives in each a
value-preserving expression.
%
\begin{eqnarray*}
&g_1^\at{\idx} \rightarrow A[\idx] := e_1^\at{\idx}\\
&...\\
&g_n^\at{\idx} \rightarrow A[\idx] := e_n^\at{\idx}\\
\end{eqnarray*}
%
\loopinvariant
%
\begin{eqnarray*}
&(\forall j)(\forall r)(\seen{\idxinitial}{j}{\idx} \land g_{r0}^\at{j} \impl A[j] = e_{r0}^\at{j}) \\
\land&(\forall j)(\seen{\idxinitial}{j}{\idx} \land (\forall r) (\neg g_{r0}^\at{j})) \impl A[j] = A_0[j]) \\
\land&
 (\forall j)(\neg \seen{\idxinitial}{j}{\idx} \land \inbounds{A}{j} \impl A[j] = A_0[j])\\
\end{eqnarray*}

\bigskip
\patternexample

\medskip
$\begin{array}{l}
  \KWloop \KWover i \KWin 1~..~N \\
  ~~~~ \textit{invariant}: (\forall j)(1 \leq j < i \land (A_0[j] < 0 \impl A[j] = -1\\
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ \land (A_0[j] > 0 \impl A[j] = +1)\\
  ~~~~~~~~~~~~~~~~~~~ \land (\forall j)(1 \leq j < i \land A_0[j] = 0 \impl A[j] = A_0[j])\\
  ~~~~~~~~~~~~~~~~~~~ \land (\forall j)(1 > j \land j \geq i \land \inbounds{A}{j} \impl A[j] = A_0[j])\\
  ~~~~ A[i] < 0 \rightarrow A[i] := -1\\
  ~~~~ A[i] > 0 \rightarrow A[i] := +1\\
  \KWend
\end{array}$

\subsubsection*{Unknown Single Map Pattern}

\patterndef An array variable is only modified in a single assignment, whose
guard is unknown, at index \idx, and it receives a value-preserving expression.
%
$$g^? \rightarrow A[\idx] := e^\at{\idx}$$
%
\loopinvariant
%
\begin{eqnarray*}
&(\forall j)(\seen{\idxinitial}{j}{\idx} \impl A[j] = e_0^\at{j} \lor A[j] = A_0[j]) \\
\land&
 (\forall j)(\neg \seen{\idxinitial}{j}{\idx} \land \inbounds{A}{j} \impl A[j] = A_0[j])\\
\end{eqnarray*}

\bigskip
\patternexample

\medskip
$\begin{array}{l}
  \KWloop \KWover i \KWin 1~..~N \\
  ~~~~ \textit{invariant}: (\forall j)(1 \leq j < i \impl A[j] = 0 \lor A[j]=A_0[j])\\
  ~~~~~~~~~~~~~~~~~~~ \land (\forall j)(1 > j \land j \geq i \land \inbounds{A}{j} \impl A[j] = A_0[j])\\
  ~~~~ A[i/2] \rightarrow A[i] := 0\\
  \KWend
\end{array}$

\subsubsection*{Unknown Multiple Map Pattern}

\patterndef An array variable is modified in more than one assignment, all
of whose guards are unknown, at index \idx, and it receives in each a
value-preserving expression.
%
\begin{eqnarray*}
&g^? \rightarrow A[\idx] := e_1^\at{\idx}\\
&...\\
&g^? \rightarrow A[\idx] := e_n^\at{\idx}\\
\end{eqnarray*}
%
\loopinvariant
%
\begin{eqnarray*}
&(\forall j)(\seen{\idxinitial}{j}{\idx} \impl (\exists r)(A[j] = e_{r0}^\at{j}) \lor A[j] = A_0[j]) \\
\land&
 (\forall j)(\neg \seen{\idxinitial}{j}{\idx} \land \inbounds{A}{j} \impl A[j] = A_0[j])\\
\end{eqnarray*}

\bigskip
\patternexample

\medskip
$\begin{array}{l}
  \KWloop \KWover i \KWin 1~..~N \\
  ~~~~ \textit{invariant}: (\forall j)(1 \leq j < i \impl (A[j] = -1 \lor A[j] = +1 \lor A[j] = A_0[j])\\
  ~~~~~~~~~~~~~~~~~~~ \land (\forall j)(1 > j \land j \geq i \land \inbounds{A}{j}\impl A[j] = A_0[j])\\
  ~~~~ A[i-1] < A[i-2] \rightarrow A[i] := -1\\
  ~~~~ A[i-1] > A[i-2] \rightarrow A[i] := +1\\
  \KWend
\end{array}$

\subsubsection*{Filter Pattern}

\patterndef An array variable is only modified in a single assignment, whose
guard is a value-preserving expression, at index $v$, and it receives in each a 
value-preserving expression. Scalar variable $v$ is incremented in a single assignment, 
whose guard is the same as the one above.
%
\begin{eqnarray*}
g^\at{\idx} &\rightarrow& A[v] := e^\at{\idx}\\
g^\at{\idx} &\rightarrow& v := v + 1\\
\end{eqnarray*}
%
\loopinvariant
%
\begin{eqnarray*}
&(\forall j)(\seen{\idxinitial}{j}{\idx} \land g_0^\at{j} \impl (\exists k)(v_0 \leq k < v \land A[k] = e_0^\at{j}))  \\
\land&
(\forall k)(v_0 \leq k < v \impl (\exists j)(\seen{\idxinitial}{j}{\idx} \land g_0^\at{j} \land A[k] = e_0^\at{j}))  \\
\land&
(\forall k)(k > v \land \inbounds{A}{k} \impl A[k] = A_0[k])
\end{eqnarray*}
%
\patternnote This pattern corresponds in particular to an array filter, in
which elements satisfying a certain condition are copied to the front of the
array.

\bigskip
\patternexample

\medskip
$\begin{array}{l}
  \KWloop \KWover i \KWin 1~..~N \\
  ~~~~ \textit{invariant}: (\forall j)(1 \leq j < i \land A_0[j] > 0 \impl (\exists k)(\upsilon_0 \leq k < \upsilon \land B[k] = A_0[j]))\\
  ~~~~~~~~~~~~~~~ \land (\forall k)(\upsilon_0 \leq k < \upsilon \impl (\exists j)(1 \leq j < i \land  A_0[j] > 0 \land B[k] = A_0[j]))\\
  ~~~~~~~~~~~~~~~ \land (\forall k)(k > \upsilon \land \inbounds{A}{k} \impl B[k] = B_0[k])\\
  ~~~~ A[i] > 0 \rightarrow B[\upsilon] := A[i]\\
  ~~~~ A[i] > 0 \rightarrow \upsilon := \upsilon + 1\\
  \KWend
\end{array}$

\subsection{Exchange Patterns}

\subsubsection*{Known Exchange Pattern}

\patterndef An array variable is only modified in a single assignment,
whose guard is a value-preserving expression, at some unkown index, 
and it receives a value-preserving expression.
%
\begin{eqnarray*}
g^\at{\idx} \rightarrow A[e^?] := e^\at{\idx}\\
\end{eqnarray*}

%
\patternnote This pattern includes the case where the index of A is value-preserving but different from $i$.

\medskip
%
\loopinvariant
%
$$(\forall j)(\inbounds{A}{j} \impl A[j] = A_0[j] \lor (\exists k)(\seen{\idxinitial}{k}{\idx} \land g_0^\at{k} \land A[j] = e_0^\at{k}))$$

\bigskip
\patternexample

\medskip
$\begin{array}{l}
  \KWloop \KWover i \KWin 1~..~N \\
  ~~~~ \textit{invariant}: (\forall j)(\inbounds{A}{j} \impl A[j] = A_0[j] \lor \\ 
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ (\exists k)(1 \leq k < i \land B[k] > 0 \land A[j] = B[k]))\\
  ~~~~ B[i] > 0 \rightarrow A[B[i]] := B[i]\\
  \KWend
\end{array}$

\subsubsection*{Unknown Exchange Pattern}

\patterndef An array variable is only modified in a single assignment,
whose guard is unknown, at some unkown index, and it receives a value-preserving expression.
%
\begin{eqnarray*}
&g^? \rightarrow A[e^?] := e^\at{\idx}\\
\end{eqnarray*}
%
\loopinvariant
%
$$(\forall j)(\inbounds{A}{j} \impl A[j] = A_0[j] \lor (\exists k)(\seen{\idxinitial}{k}{\idx} \land A[j] = e_0^\at{k}))$$

\bigskip
\patternexample

\medskip
$\begin{array}{l}
  \KWloop \KWover i \KWin 1~..~N \\
  ~~~~ \textit{invariant}: (\forall j)(\inbounds{A}{j} \impl A[j] = A_0[j] \lor \\
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ (\exists k)(1 \leq k < i \land A[j] = B_0[k]))\\
  ~~~~ B[i/2] > 0 \rightarrow A[i/2] := B[i]\\
  \KWend
\end{array}$

\subsubsection*{Known Interchange Pattern}

\patterndef An array variable is modified in possibly more than one assignment,
all of whose guards are unknown, at index \idx, and it receives in each
its own value at some unknown index.
%
\begin{eqnarray*}
&g^? \rightarrow A[\idx] := A[e^?]\\
&...\\
&g^? \rightarrow A[\idx] := A[e^?]\\
\end{eqnarray*}

\patternnote Also for guard value-preserving.

\medskip
\loopinvariant
%
\begin{eqnarray*}
&(\forall j)(\seen{\idxinitial}{j}{\idx} \impl (\exists k)(\inbounds{A}{k} \land A[j] = A_0[k])) \\
\land&
(\forall j)(\neg \seen{\idxinitial}{j}{\idx} \land \inbounds{A}{j} \impl A[j] = A_0[j])
\end{eqnarray*}

\bigskip
\patternexample

\medskip
$\begin{array}{l}
  \KWloop \KWover i \KWin 1~..~N \\
  ~~~~ \textit{invariant}: (\forall j)(1 \leq j < i \impl (\exists k)(\inbounds{A}{k} \land A[j] = A_0[k]))\\
  ~~~~~~~~~~~~~~~~~~~ \land (\forall j)(1 > j \land j \geq i \land \inbounds{A}{j} \impl A[j] = A_0[j])\\
  ~~~~ B[i] > 0 \rightarrow A[i] := A[i/2]\\
  ~~~~ B[i] < 0 \rightarrow A[i] := A[i/2+1]\\
  \KWend
\end{array}$

\subsubsection*{Unknown Interchange Pattern}

\patterndef An array variable is modified in possibly more than one assignment,
all of whose guards are unknown, at some unkown index, and it receives in each
its own value at some unknown index.
%
\begin{eqnarray*}
&g^? \rightarrow A[e^?] := A[e^?]\\
&...\\
&g^? \rightarrow A[e^?] := A[e^?]\\
\end{eqnarray*}

\patternnote Also for guard value-preserving and index in right-hand-side value-preserving.

\medskip
\loopinvariant
%
$$(\forall j)(\inbounds{A}{j} \impl (\exists k)(\inbounds{A}{k} \land A[j] = A_0[k])) $$

\bigskip
\patternexample

\medskip
$\begin{array}{l}
  \KWloop \KWover i \KWin 1~..~N \\
  ~~~~ \textit{invariant}: (\forall j)(\inbounds{A}{k} \impl (\exists k)(\inbounds{A}{k} \land A[j] = A_0[k]))\\
  ~~~~ B[i] > 0 \rightarrow A[i\%3] := A[A[i]]\\
  ~~~~ B[i] < 0 \rightarrow A[i\%3] := A[-A[y]]\\
  \KWend
\end{array}$

\section{Pre-Transformation Tactic}
When our code fall into the above patterns nothing to do, just apply the corresponding invariant patterns. 
Contrariwise, in some cases we will need a pre-processing them to bring into our patterns. 
This pre-processing mainly to reorganize our code in order to transform the expression 
which used others variables updates in the loop to a \textit{value-preserving expression}  
define in section~\ref{sec:naming-conventions}. For example in the following code 

$$\begin{array}{l}
  \KWloop \KWover i \KWin 1 .. N \\
  ~~~~ True \rightarrow A[i] := B[Index]\\
  ~~~~ True \rightarrow Index := Index + 1\\
  \KWend
\end{array}$$

The last statement is Certain Single Add-Up Pattern but the first statement is not Certain Single Map Pattern
because $B[Index]$ use a update variable $Index$ (therefore it's not value-preserving expression). 
If we transform it as below we have Certain Single Map Pattern and Certain Single Add-Up Pattern. 
Thus, the full invariant is the conjonction of the two corresponding invariants.

$$\begin{array}{l}
  \KWloop \KWover i \KWin 1 .. N \\
  ~~~~ True \rightarrow A[i]   := B[Index0 + I-1]\\
  ~~~~ True \rightarrow Index := Index + 1\\
  \KWend
\end{array}$$
%
\loopinvariant
%
\begin{eqnarray*}
&(\forall j)(\seen{\idxinitial}{j}{\idx} \impl A[j] = B_0[Index0 + j-1]) \\
\land& (\forall j)(\neg \seen{\idxinitial}{j}{\idx} \land \inbounds{A}{j} \impl A[j] = A_0[j])\\
&\land& \\
&Index = Index_0 + 1 * (i-1)&
\end{eqnarray*}

\bibliographystyle{abbrv}
\bibliography{loop_patterns}
\end{document}          

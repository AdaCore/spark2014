\documentclass[a4paper,10pt]{article}

\usepackage[utf8x]{inputenc}
\usepackage{listings}
\usepackage{mathpartir}
\usepackage{amsmath}
\usepackage{xspace}
\usepackage{xcolor}

\newcommand{\yannick}[1]{{\color{red} #1}}

\newcommand{\eg}{\textit{e.g.,}\xspace}
\newcommand{\etal}{\textit{et al.}\xspace}
\newcommand{\etc}{\textit{etc.}\xspace}

\newcommand{\prog}{\ensuremath{\mathcal{P}}\xspace}
\newcommand{\idx}{\ensuremath{i}\xspace}
\newcommand{\idxinitial}{\ensuremath{\mathit{initial}}\xspace}
\newcommand{\idxfinal}{\ensuremath{\mathit{final}}\xspace}
\newcommand{\at}[1]{{(#1)}}
\newcommand{\N}{\ensuremath{N}\xspace}
\newcommand{\KWloop}{\ensuremath{\mathrm{loop}~}}
\newcommand{\KWend}{\ensuremath{\mathrm{end}~}}
\newcommand{\KWover}{\ensuremath{\mathrm{over}~}}
\newcommand{\KWin}{\ensuremath{~\mathrm{in}~}}
\newcommand{\KWexit}{\ensuremath{\mathrm{exit}}}
\newcommand{\true}{\ensuremath{\mathit{true}}}
\newcommand{\impl}{\ensuremath{\Longrightarrow}}
\newcommand{\inbounds}[2]{\ensuremath{\mathit{inbounds}_{#1}(#2)}\xspace}
\newcommand{\Pinbounds}[1]{\ensuremath{\mathit{inbounds}_{#1}}\xspace}
\newcommand{\seen}[1]{\ensuremath{\mathit{seen}(#1)}\xspace}
\newcommand{\Pseen}{\ensuremath{\mathit{seen}}\xspace}
\newcommand{\tocount}[1]{\ensuremath{\mathit{tocount}(#1)}\xspace}
\newcommand{\Ftocount}{\ensuremath{\mathit{tocount}}\xspace}
\newcommand{\between}[3]{\ensuremath{\mathit{between}{(#1,#2,#3)}}\xspace}
\newcommand{\Pbetween}{\ensuremath{\mathit{between}}\xspace}
\newcommand{\loopinvariant}{\noindent\textit{Loop invariant:}\xspace}
\newcommand{\patterndef}{\noindent\textit{Definition:}\xspace}
\newcommand{\patternexample}{\noindent\textit{Example:}\xspace}
\newcommand{\patternnote}{\noindent\textit{Note:}\xspace}
\newcommand{\patternproof}{\noindent\textit{Proof:}\xspace}
\newcommand{\update}[3]{\ensuremath{\mathit{update}{(#1,#2,#3)}}\xspace}
\newcommand{\symdef}{\ensuremath{\overset{\mathit{def}}{=}}}
\newcommand{\Inv}[1]{\ensuremath{\mathit{Inv}(#1)\xspace}}

\newcommand{\loopmodel}{\textsc{loop-model}\xspace}
\newcommand{\state}[1]{\ensuremath{\sigma_{\mathit{#1}}\xspace}}
\newcommand{\vstate}[2]{\ensuremath{\sigma^{\mathit{#1}}_{\mathit{#2}}\xspace}}
\newcommand{\gstatement}[2]{\ensuremath{s^{\mathit{#1}}_{\mathit{#2}}\xspace}}
\newcommand{\vpp}{\textsc{vpp}\xspace}
\newcommand{\spexit}{\textsc{sp-exit}\xspace}
\newcommand{\spscalar}{\textsc{sp-scalar}\xspace}
\newcommand{\sparray}{\textsc{sp-array}\xspace}
\newcommand{\spseq}{\textsc{sp-seq}\xspace}
\newcommand{\mcdiff}{\textsc{mc-diff}\xspace}
\newcommand{\mcsame}{\textsc{mc-same}\xspace}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{hypothesis}[theorem]{Hypothesis}

\newenvironment{proof}[1][Proof.]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}
\newenvironment{definition}[1][Definition]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}
\newenvironment{example}[1][Example]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}
\newenvironment{remark}[1][Remark]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}

\newcommand{\qed}{\nobreak \ifvmode \relax \else
      \ifdim\lastskip<1.5em \hskip-\lastskip
      \hskip1.5em plus0em minus0.5em \fi \nobreak
      \vrule height0.75em width0.5em depth0.25em\fi}

\lstset{language=Ada}

\sloppy

\begin{document}

% Title Page
\title{Simple Loop Patterns and Rich Loop Invariants}
\author{Marc Sango and Yannick Moy}
\date{}

\maketitle

\begin{abstract}
  Most works in automatic generation of loop invariants are limited to simple
  forms of invariants without quantifiers. In this paper, we describe patterns
  of loops for which it is possible to generate rich loop invariants with
  quantifiers.
\end{abstract}

\section{Introduction}

In the following, we only consider techniques that generate loop invariants for
programs with scalar and array variables. There is a wealth of different
techniques that generate invariants regarding the shape of
dynamically-allocated data structures (shape analysis, separation logic) that
are irrelevant in our context. We also ignore all techniques for generating
invariants for hybrid programs, in which a program implements a control part
which is related to an outside world obeying continuous differential equations.

There have been two approaches to loop invariant generation: a
\textit{template} approach which takes only code as input and generates the
best loop invariants in some predefined template family; a \textit{directed}
approach which also takes as input a goal or some hint formulas, and generates
either a sufficient loop invariant to prove the goal or a loop invariant based
on the hints provided. Typically, template approaches are based on abstract
interpretation or algebraic techniques while lazy approaches are based on
theorem proving or model checking techniques.

\subsection{Simple Loop Invariants}

Most techniques generate loop invariants in the form of conjunctions of
(dis)equalities between polynomials in the program variables. The form of an
individual (dis)equality ranges from constant variable bounds for a variable
(sign, interval) to polynomial linear (dis)equalities of various complexity (2
or 3 variables, templates of polynomials) and non-linear polynomials.

Abstract interpretation~\cite{cousot:1978:popl, mine:2006:hosc} works on an
abstraction of the program using predefined domains which restrict the kind of
(dis)equalities we are aiming at. Non-relational domains such as intervals
define (dis)equalities between a single program variable and
constants. Relational domains such as octagons or polyhedra define
(dis)equalities between program variables. An abstract state represents all
known (dis)equalities in the abstract domain. Abstract interpretation simulates
execution over this abstract state to reach a fixpoint which defines invariants
at each program point.

Predicate abstraction~\cite{graf:1997:cav} applies abstract interpretation to a
domain of predefined base formulas, typically collected from guards present in
the program (tests in branch and loop statements). A theorem prover is used to
compute the transition function for each statement of the program. The final
invariants are conjunctions over the initial base formulas.

An obvious limitation of predicate abstraction is its dependency on the initial
base formulas. In a goal-directed approach where the invariant computed by
predicate abstraction is not sufficient to prove the goal, Craig's
interpolation~\cite{mcmillan:2003:cav, mcmillan:2006:cav} allows to generate
intermediate formulas from two inconsistent formulas. In the CEGAR
(Counter-Example Guided Abstraction Refinement) approach, these intermediate
formulas can then be fed to predicate abstraction until a sufficient invariant
is found.

Algebraic techniques~\cite{colon:2003:cav, sankaranarayanan:2004:popl,
  kovacs:2008:csr} first extract polynomial (dis)equalities over program
variables and unknown constants from a template loop invariant defining these
unknowns. Then, algebraic techniques such as Faskas lemma or Gröbner bases are
used to solve these (dis)equations and give values to unknowns.

\subsection{Richer Loop Invariants}

\subsubsection*{Disjunctions}

Various works have defined disjunctive abstract domains on top of base abstract
domains. The implication domain only deals with one disjunction at a time,
while disjunctive completion allows to treat larger disjuncts. The need to
define converging operators for these domains means that they are not very
precise.

\subsubsection*{Quantifiers}

A few works have targeted the generation of loop invariants with a richer
boolean structure and quantifiers, based on techniques for quantifier-free
invariants.

Halbwachs and Péron~\cite{halbwachs:2008:pldi} describe an abstract domain to
reason about array contents over \textit{simple programs} that they describe as
\textit{``one-dimensional arrays, traversed by simple for loops''}. They are
able to represent facts like $(\forall i)(2 \leq i \leq n \impl A[i] \geq
A[i−1]$, in which a pointwise relation is established between elements of array
slices, where the relation is one supported by a quantifier-free base abstract
domain.

Gulwani \etal~\cite{gulwani:2008:popl} describe a general lifting procedure
that creates a quantified disjunctive abstract domain from quantifier-free
domains. They are able to represent facts like $(\forall i)(0 \leq i < n \impl
a[i] = 0)$, in which the formula is universally quantified over an implication
between quantifier-free formulas of the base domains.

McMillan~\cite{mcmillan:2008:tacas} describes an instrumentation of a
resolution-based prover that generates quantified invariants describing facts
over simple arrays manipulating arrays. Using a similar technique, Kov\'acs and
Voronkov~\cite{kovacs:2009:fli} generate invariants containing quantifier
alternation.

\section{Preliminaries}

\subsection{Simple Loops}
\label{sec:simple-loops}
A program \prog consists in a loop over index \idx between \idxinitial and
\idxfinal.  The constant \idxinitial and \idxfinal represent respectively the
intial value and final value of iteration range. The loop body consists in a
(possibly empty) unordered set of simultaneous \textit{guarded exit} statements,
followed by a (possibly empty) unordered set of simultaneous \textit{guarded
assignment} statements.

\newcommand{\expr}{\ensuremath{\mathit{expr}}}
\newcommand{\assign}{\ensuremath{\mathit{assign}}}
\newcommand{\gexit}{\ensuremath{\mathit{guardexit}}}
\newcommand{\gassign}{\ensuremath{\mathit{guardassign}}}
\newcommand{\location}{\ensuremath{\mathit{location}}}

\vspace{0.5cm}
\begin{tabular}{rcl}
\prog & ::= &  \KWloop \KWover \idx \KWin \idxinitial ..\idxfinal \gexit$*$ \gassign$*$ \KWend \\
\gexit  & ::= & \expr ~$\rightarrow$ \KWexit \\
\gassign  & ::= & \expr ~$\rightarrow$ \assign \\
\assign  & ::= & \location ~$:=$  \expr\\
\location  & ::= & $v ~|~ V[\expr]$ \\
\expr  & ::= & $\location  ~|~ \expr \bullet \expr  ~|~ f(\expr) ~~\bullet \in \{+, -, *, / , <, \leq, >, \geq \}$\\
\end{tabular}
\vspace{0.5cm}

If the guard $t$ of a guarded exit evaluates to true, then control exits from
the loop. If the guard $g$ of a guarded assignment evaluates to true, then the
assignment is performed. The guard is implicitly \textit{true} if not present.
A particularity of the loop bodies we consider is that assignments are
performed in parallel, so all expressions in guards and assignments are
evaluated before all assignments take place.

As an example, here is a loop which rotates the values in an array $A$ of size
$\N + 1$ to the left, so that the value at index 1 ends up at index $\N+1$, and
all other values are moved down one index:

$$\begin{array}{l}
  \KWloop \KWover i \KWin 1 .. N \\
  ~~~~ A[i]   := A[i+1]\\
  ~~~~ A[i+1] := A[i]\\
  \KWend
\end{array}$$

We assume that there are no conflicting writes in the simultaneous assignments,
which amounts to the following conditions:

\begin{enumerate}
\item For any two assignments to scalar variable $a$, whose guards are $g_j$
  and $g_k$, then $g_j \land g_k$ is unsatisfiable.
\item For any two assignments to array variable $A$ at indexes $e_j$ and $e_k$,
  with guards $g_j$ and $g_k$, then $(e_j = e_k) \land g_j \land g_k$ is
  unsatisfiable.
\end{enumerate}

These conditions are essentially the same as the ones described by Kov\'acs and
Voronkov with a slightly different formalism~\cite{kovacs:2009:fli}.

We are interested in generating the most precise loop invariant \Inv{\idx} for
a given loop. The loop invariant we consider is not a Hoare-like loop
invariant, which would hold before and after the loop and at the start of each
run through the loop body. Instead, our loop invariant placed before all statements
describes the loop behavior but it is not necessarily true at the end of the loop.
This is because we treat the exit statements, hardly captured by Hoare-like loop. 
Thus, our invariant holds before loop and at each run through the loop body, 
keeping guarded assignments safe as long as we fall on the first guarded exit statment,
The loop below represents the general form of our loop model.

\begin{align*}
\begin{array}{l}
  \KWloop \KWover i \KWin \idxinitial ..\idxfinal \\
  ~~~~ < \textrm{\Inv{\idx} holds at this point} >\\
  ~~~~ t_1 \rightarrow \KWexit \\
  ~~~~ ... \\
  ~~~~ t_m \rightarrow \KWexit \\
  ~~~~ g_1 \rightarrow \alpha_1 \\
  ~~~~ ... \\
  ~~~~ g_n \rightarrow \alpha_n \\
  \KWend
\end{array}
 \tag{\loopmodel}\\
\end{align*}

\subsection{Naming Conventions}
\label{sec:naming-conventions}

We use the following conventions: lower-case letters $a$, $b$, $c$, ... are integer
variables; \idx is the loop index, which is not a variable and cannot be
assigned; upper-case letters $A$, $B$, $C$, ... are array variables; $e$ is an
expression; $K$ is a constant expression; $f$ is a pure function (it does not
write to variables). Tests and guards are expressions denoted by letters $t$ and
$g$ respectively for readability. Subscripted variables $a_0$ and $A_0$ denote
respectively the initial values before the loop of variables $a$ and
$A$. Expression $e_0$ denotes the expression $e$ where all variables have been
replaced by their initial counterparts (this does not apply to the loop index
\idx).  The special expression $e^?$ denotes an unknown value, and expression.
For simplicity, if we have an array A that is never updated in the loop, we
treat such an array A as a constant and simply use $A$ instead of $A_0$.

Given an array $A$ with index bounds $\mathit{low}$ and $\mathit{up}$, we
define a predicate \Pinbounds{A} as follows:

$$\inbounds{A}{j} \equiv \mathit{low} \leq j \leq \mathit{up}$$

To treat the iteration monotonicity properties we define a predicate \Pbetween
and a logical function \Ftocount which count the number of loop round.

If the loop is strictly increasing then:
\begin{eqnarray*}
&\between{j}{k}{\idx} \equiv j < k < \idx\\
\and
&\tocount{i} = i - \idxinitial + 1
\end{eqnarray*}

If the loop is strictly decreasing then:
\begin{eqnarray*}
&\between{j}{k}{\idx} \equiv j > k > \idx\\
\and
&\tocount{i} = \idxinitial -i + 1
\end{eqnarray*}

We can now define a predicate \Pseen which characterizes indexes which have already
been treated in the loop:

$$\seen{j} \equiv (j = \idxinitial) \lor \between{\idxinitial}{j}{\idx}$$

\subsection{Value-preserving Expressions}

We define \textit{value-preserving expressions} as those expressions whose
value at the program point between guarded exits and guarded assignments is
such that ($e=e_0$) is a loop invariant. Let us call the corresponding property
\textit{value-preserving property}:
\begin{equation}
 e=e_0 \tag{\vpp}
\end{equation}
Given a loop index \idx, we denote a \textit{value-preserving expression} $e$
as $e^\at{\idx}$, so that we can express the same expression for differents
values of the loop index (\eg $e^\at{j}$, $e^\at{k}$, \etc). Such an expression
only depends on the number of iterations and initial values of variables
before the loop. Notice that ($e^\at{j} = e_0^\at{j}$) is not necessarily a
loop invariant for $j \neq i$.  For instance in the following example:
$$\begin{array}{l}
  \KWloop \KWover i \KWin 1 .. N \\
  ~~~~ \mathit{true} \rightarrow A[i] := 0\\
  \KWend
\end{array}$$
$e^\at{\idx} \symdef A[\idx]$ (with current index \idx) is a 
value-preserving expression, because ($A[\idx]=A_0[\idx]$) is a loop 
invariant. But ($A[0]=A_0[0]$) is not a loop invariant.

Sufficient conditions for an expression $e$ to be a value-preserving expression
are the following:
\begin{enumerate}
\item $e$ does not refer to scalar variables that are assigned in the loop;
\item $e$ may refer to (array or scalar) variables that are not modified in the loop;
\item $e$ may refer to an array variable $A$ that is modified in the loop,
  provided it does so at index \idx or indexes that are known to be greater
  than \idx (\eg $\idx + 1$), and all assignments to $A$ are at index \idx or
  indexes that are known to be less than \idx (\eg $\idx - 1$). This ordering
  can be more complex, and necessitate a special analysis, like in the case of
  array filtering where the array is assigned at index $v$ where $v$ is
  incremented less often than the loop index.
\end{enumerate}

\subsection{Proof Preliminaries}

\newcommand{\spostsym}{\ensuremath{\mathcal{SP}}\xspace}
\newcommand{\spost}[2]{\ensuremath{\spostsym(#1,#2)}}
\newcommand{\subst}[3]{\ensuremath{#1[#2 \leftarrow #3]}}

\begin{definition}
  \emph{(Pattern)} A pattern is a subset of guarded exits or guarded assignments
  from a loop body.
\end{definition}

We define an operator \spost{s}{P} which computes the strongest postcondition of
property $P$ over statement $s$, where $s$ is either a guarded
exit or a guarded assignment.

\begin{align*}
\spost{t \rightarrow \KWexit}{P} &\symdef \neg t \land P \tag{\spexit}\\
\spost{g \rightarrow a:=e}{P} &\symdef (\exists b) (\subst{g}{a}{b} 
    \land a = \subst{e}{a}{b} \land \subst{P}{a}{b}) \tag{\spscalar}\\
\spost{g \rightarrow A[e_1]:=e_2}{P} &\symdef (\exists B)
\left(\begin{array}{cl}
&\subst{g}{A}{B}\\
\land& A = \update{B}{\subst{e_1}{A}{B}}{\subst{e_2}{A}{B}}\\
\land& \subst{P}{A}{B}\\
\end{array}\right)
 \tag{\sparray}\\
\spost{s_1; s_2}{P} &\symdef \spost{s_2}{\spost{s_1}{P}} \tag{\spseq}
\end{align*}

Notice that the rule \sparray is simply a special case of \spscalar for an
array variable, with an assignment of the form $A := \update{A}{e_1}{e_2}$,
where $\mathit{update}$ is the functional update of array $A$ at index $e_1$
with value $e_2$.

We recall McCarthy's axioms:
\begin{equation}
(\forall i)(\forall j)(\forall v)(i \neq j \impl \update{A}{i}{v}[j] = A[j])
\tag{\mcdiff}
\end{equation}
\begin{equation}
(\forall i)(\forall v)(\update{A}{i}{v}[i] = v) \tag{\mcsame}
\end{equation}

Notice also that the rule \spseq for seqential composition of statements is the
usual rule associated with a sequential execution semantics for statements. As
our semantics of guarded exits and guarded assignments is parallel, we should
start with proving that rule \spseq indeed computes the desired strongest
postcondition. 

We recall that the loop body consists in a (possibly empty) unordered set of 
simultaneous guarded exits, followed by a (possibly empty) unordered set of 
simultaneous guarded assignments. There are thus only three actual program points 
of interest: before the loop body, at the loop invariant program point, after the loop body. 
Let us denote the invariant point \state{inv}. Since the guarded exits set is unordered and 
simultaneous, we can put a pattern (extacted in this set) before any others guarded exits, 
and denote this virtual point \vstate{exit}{1..n}. The same way, we define a virtual point 
\vstate{assign}{1..m} for a pattern extracted in the set of simultaneous guarded assignments. 


\begin{lemma}
  \emph{(\spostsym Correctness over \loopmodel)} Operator \spostsym as defined in \spexit,
  \spscalar, \sparray and \spseq computes the strongest postcondition over
  parallel guarded exits and parallel guarded assigns.
\label{lemma:sp-correctness}
\end{lemma}

\begin{proof}
  \yannick{To be completed.}
\end{proof}

\begin{lemma}
  \emph{(\spostsym over Guarded Exits)} The strongest postcondition only
  strengthens a property $P$ over guarded exits.
\label{lemma:sp-g-exits}
\end{lemma}

\begin{proof}
  The proof proceeds by induction on the number of guarded exits. Suppose there
  is a single guarded exit $s \symdef t \rightarrow \KWexit$.
  \begin{align*}
    \spost{t \rightarrow \KWexit}{P} 
    &= \neg t \land P && \text{by \spexit}\\
    &\impl P
  \end{align*}
  Suppose that the property holds over all sets of guarded exits of size $n$,
  and consider a set of guarded exits $s_{1..n+1}$ of size $n+1$.
  \begin{align*}
    \spost{s_{1..n+1}}{P} 
    &= \spost{s_{2..n+1}}{\spost{s_1}{P}}  && \text{by \spseq}\\
    &\impl \spost{s_{2..n+1}}{P}           && \text{by the proof above}\\
    &\impl P                             && \text{by induction hypothesis}\\
  \end{align*}
\end{proof}

\begin{lemma}
  \emph{(\spostsym over Guarded Assignments)} The strongest postcondition of a
  property $P$ over guarded assignments which do not assign to variables in $P$
  only strengthens $P$.
\label{lemma:sp-g-assignments}
\end{lemma}

\begin{proof}
  The proof proceeds by induction on the number of guarded assignments. Suppose there
  is a single simple guarded assignment (by reminding that the rule \sparray is simply 
  a special case of \spscalar for an array variable) $s \symdef g \rightarrow a := e$.
  \begin{align*}
    \spost{g \rightarrow a:=e}{P} 
    &= (\exists b) (\subst{g}{a}{b} 
    \land a = \subst{e}{a}{b} \land \subst{P}{a}{b}) && \text{by \spscalar}\\
    &= (\exists b) (\subst{g}{a}{b} 
    \land a = \subst{e}{a}{b}) \land P && \text{a is not in P}\\
    &\impl P
  \end{align*}
  Suppose that the property holds over all sets of guarded assignment of size $n$,
  and consider a set of guarded exits $s_{1..n+1}$ of size $n+1$.
  \begin{align*}
    \spost{s_{1..n+1}}{P} 
    &= \spost{s_{2..n+1}}{\spost{s_1}{P}}  && \text{by \spseq}\\
    &\impl \spost{s_{2..n+1}}{P}           && \text{by the proof above}\\
    &\impl P                             && \text{by induction hypothesis}\\
  \end{align*}
\end{proof}

\begin{definition}
  \emph{(Pattern Capture)} A formula $P$ captures a pattern if (1) $P$ is a
  loop invariant of every loop where the pattern occurs and (2) P is the 
  strongest loop invariant on the loop reduced to the pattern only, starting
  from state $\mathit{true}$.
\label{def:pattern-capture}
\end{definition}


\section{Loop Patterns} 

\newcounter{pc} % pattern counter
\newcommand{\curpattern}{\ensuremath{\textsc{pat}\mathrm{\arabic{pc}}}\xspace}
\newcommand{\curinv}{\ensuremath{\textsc{inv}\mathrm{\arabic{pc}}}\xspace}
\newcommand{\anyinv}{\ensuremath{\textsc{inv}\mathrm{x}}\xspace}

\newcommand{\pattern}[3]{%
\refstepcounter{pc}
\patterndef #1
%
\begin{equation}
  #2 \tag{\curpattern}
\end{equation}
%
\loopinvariant
%
\begin{equation}
  \Inv{\idx} \symdef #3 \tag{\curinv}
\end{equation}
}

\subsection{Search Pattern}

\pattern{
  The test of a guarded exit is a value-preserving expression.
}{
  t^\at{\idx} \rightarrow \KWexit
}{
  (\forall j)(\seen{j} \impl \neg t_{0}^\at{j})
}

\patternnote There are a more precis invariant than \curinv if \curpattern occurs 
only in the loop and if the invariant point \state{\Inv{\idx}} is placed after the pattern:
$$(\forall j)(\seen{j} \lor j = i \impl \neg t_{0}^\at{j})$$

\patternexample

$\begin{array}{l}
  \KWloop \KWover i \KWin 1~..~N \\
  ~~~~ \textit{invariant}: (\forall j)(1\leq j < i \impl A[j] \neq 0)\\
  ~~~~ A[\idx] = 0 \rightarrow \KWexit\\
  \KWend
\end{array}$

\begin{theorem}
  \Inv{\idx} given by \curinv captures pattern \curpattern.
\label{theo:capture-search-pattern}
\end{theorem}

\begin{proof}
  The proof proceeds by induction on the number of iterations \idx.\\ 

1. reduced case: $\gstatement{exit}{1..n} = \o{} \land \gstatement{assign}{1..m} = \o{}$\\

  \noindent
  We start from invariant $\mathit{true}$ before the loop.
  %
  \begin{align*}
    \spost{t^\at{\idxinitial} \rightarrow \KWexit}{\mathit{true}
    }  
    &= \neg t^\at{\idxinitial}    && \text{by \spexit}\\
    &= \neg t_0^\at{\idxinitial}  && \text{by \vpp}\\
    &= \Inv{\idxinitial}      && \text{by \curinv}
  \end{align*}
  %
  Now assume \Inv{\idx} at loop iteration \idx, and let us prove that
  \Inv{\idx+1} is the strongest postcondition of \Inv{\idx} through the loop
  body at loop iteration $\idx+1$. Notice that \Inv{\idx} does not mention 
  any variable, only initial values of variables and current value of the loop index.
  %
  \begin{align*}
    \spost{t^\at{\idx} \rightarrow \KWexit}{\Inv{\idx}
    }  
    &= \neg t^\at{\idx+1} \land \Inv{\idx}    && \text{by \spexit}\\
    &=\neg t_0^\at{\idx+1} \land \Inv{\idx}  && \text{by \vpp}\\
    &= \Inv{\idx+1}          && \text{by \curinv}
  \end{align*}
  %
  This proves that \Inv{\idx} is the strongest loop invariant on the 
  loop reduced to the pattern. 

\bigskip
2. general case : in addition to the current pattern \curpattern, there 
  may be others guarded exit and guarded assignment statements.\\

  \noindent
  We start from invariant $\mathit{true}$ before the loop.
  %
  \begin{align*}
    \spost{
      &t^\at{\idxinitial} \rightarrow \KWexit}{\mathit{true};\\
      &\gstatement{exit}{1..n};\\
      &\gstatement{assign}{1..m}\\
    }
    &= \spost{\gstatement{assign}{1..m}}{\spost{\gstatement{exit}{1..n}}
              {\spost{t^\at{\idxinitial} \rightarrow \KWexit}{\mathit{true}}}} && \text{by \spseq} \\ 
    &= \spost{\gstatement{assign}{1..m}}{\spost{\gstatement{exit}{1..n}}
              {\neg t_0^\at{initial}}} && \text{by \spexit \& \vpp} \\ 
    &\Rightarrow \spost{\gstatement{assign}{1..m}}{\neg t_0^\at{initial}} && \text{by lemma \ref{lemma:sp-g-exits}}\\
    &\Rightarrow \neg t_0^\at{initial}          && \text{by lemma \ref{lemma:sp-g-assignments}} \\
    &= \Inv{\idxinitial}      && \text{by \curinv}
  \end{align*}
  %
  Now assume \Inv{\idx} at loop iteration \idx, and let us prove that
  \Inv{\idx+1} is the strongest postcondition of \Inv{\idx} through the loop
  body at loop iteration $\idx+1$. Notice that \Inv{\idx} does not mention 
  any variable, only initial values of variables and current value of the loop index.
  %
  \begin{align*}
    \spost{
      &t^\at{\idx+1} \rightarrow \KWexit}{\Inv{\idx};\\
      &\gstatement{exit}{1..n};\\
      &\gstatement{assign}{1..m}\\
    }
    &= \spost{\gstatement{assign}{1..m}}{\spost{\gstatement{exit}{1..n}}
              {\spost{t^\at{\idx+1} \rightarrow \KWexit}{\Inv{\idx}}}} && \text{by \spseq} \\ 
    &= \spost{\gstatement{assign}{1..m}}{\spost{\gstatement{exit}{1..n}}{\Inv{\idx+1}}} 
              && \text{by 1. reduced case}\\
    &\Rightarrow \spost{\gstatement{assign}{1..m}}{\Inv{\idx+1}} && \text{by lemma \ref{lemma:sp-g-exits}}\\
    &\Rightarrow \Inv{\idx+1}          && \text{by lemma \ref{lemma:sp-g-assignments}}
  \end{align*}
  % 
  This proves that \Inv{\idx} is a loop invariant of every loop where pattern
  \curpattern occurs.
\end{proof}

\subsection{Update Patterns}

\subsubsection*{Certain Single Update Pattern}

\pattern{
  A scalar variable $a$ is modified in exactly a single assignment, whose
  guard is \textit{true}, and it receives a value-preserving expression.
}{
  \mathit{true} \rightarrow a := e^\at{\idx}
}{
  (\idx = \idxinitial \impl a = a_0) \land (\idx \neq \idxinitial \impl a = e_0^\at{\idx - 1})
}

\patternexample

$\begin{array}{l}
  \KWloop \KWover i \KWin 1~..~N \\
  ~~~~ \textit{invariant}: (\idx = 1 \impl \mathit{flag} = \mathit{flag}_0) \land (\idx \neq 1 \impl flag = true)\\
  ~~~~ true \rightarrow \mathit{flag} := true\\
  \KWend
\end{array}$

\begin{theorem}
  \Inv{\idx} given by \curinv captures pattern \curpattern.
\end{theorem}

\begin{proof}
  The proof proceeds by induction on the number of iterations \idx.\\

  \noindent
  We start from invariant $(a = a_0)$ before the loop, because
  initially, the variable $a$ take it initial value $a_0$.
  Note that the pattern is not yet reached.
  %
  \begin{align*}
     (a = a_0) = \Inv{\idxinitial}      && \text{by \curinv}\\
  \end{align*}
  %
  Now assume \Inv{\idx} at loop iteration \idx, and let us prove that
  \Inv{\idx+1} is the strongest postcondition of \Inv{\idx} through 
  the loop body at loop iteration $\idx+1$. Notice that \Inv{\idx} does 
  not mention any variable, only initial values of variables and current 
  value of the loop index.
  %

\bigskip
1. reduced case: $\gstatement{exit}{1..n} = \o{} \land \gstatement{assign}{1..m} = \o{}$
  %
  \begin{align*}
    \spost{
    &\mathit{true} \rightarrow a := e^\at{\idx}}{\Inv{\idx}
    }\\   
    &= (\exists b) (a = e^\at{\idx}[a\leftarrow b] \land \Inv{\idx}[a\leftarrow b])  && \text{by \spscalar}\\
    &= (\exists b) (a = e_0^\at{\idx}[a \leftarrow b] \land \Inv{\idx}[a\leftarrow b]) && \text{by \vpp}\\ 
    &= (a = e_0^\at{\idx}) \land (\exists b) (\Inv{\idx}[a\leftarrow b])  && \text{$a$ not in $e_0^\at{\idx}$}\\
    &= (a = e_0^\at{\idx}) \land \mathit{true} \\                                                          
    &= \Inv{\idx+1}        && \text{by \curinv}
  \end{align*}
  %
  This proves that \Inv{\idx} is the strongest loop invariant on the 
  loop reduced to the pattern. 

\bigskip
2. general case : in addition to the current pattern \curpattern, there 
  may be others guarded exit and guarded assignment statements.\\
  %
  \begin{align*}
    \spost{
      &\gstatement{exit}{1..n};\\
      &\mathit{true} \rightarrow a := e^\at{\idx}}{\Inv{\idx};\\
      &\gstatement{assign}{1..m}\\
    }\\
    &= \spost{\gstatement{assign}{1..m}}{\spost{\mathit{true} \rightarrow a := e^\at{\idx}}
        {\spost{\gstatement{exit}{1..n}}{\Inv{\idx}}}} && \text{by \spseq} \\ 
    &\Rightarrow \spost{\gstatement{assign}{1..m}}
        {\spost{\mathit{true} \rightarrow a := e^\at{\idx}}{\Inv{\idx}}} && \text{by lemma \ref{lemma:sp-g-exits}} \\ 
    &= \spost{\gstatement{assign}{1..m}}{\Inv{\idx+1}} && \text{by reduce case} \\ 
    &\Rightarrow \Inv{\idx+1} && \text{by lemma \ref{lemma:sp-g-assignments}}
  \end{align*}
  % 
  This proves that \Inv{\idx} is a loop invariant of every loop where pattern
  \curpattern occurs.
\end{proof}

\subsubsection*{Single Min/Max Pattern}

\patterndef A scalar variable $a$ is only modified in a single assignment, whose
guard is a comparison between the variable and a value-preserving expression, and
it receives the same value-preserving expression.
%
$$(a \bullet e^\at{\idx}) \rightarrow a := e^\at{\idx}  \qquad \bullet \in \{<, \leq, >, \geq \}$$
%
\loopinvariant
%
\begin{eqnarray*}
&(a = a_0) \land (\forall j)(\seen{j} \impl \neg (a_0 \bullet e_0^\at{j}))\\
\lor 
& ((\exists j)(\seen{j} \land a = e_0^\at{j}) \land (\forall k)(\seen{k} \impl a \circ e_0^\at{k}))
\end{eqnarray*}
where $\circ$ can be deduced from $\bullet$ as follows:
$\begin{array}{l|llll}
\bullet & <    & \leq & >    & \geq \\ \hline
\circ   & \geq & \geq & \leq & \leq
\end{array}$

\bigskip
\patternnote Above invariant is equivalent to its complex form:
\begin{eqnarray*}
&(a = a_0) \land (\forall j)(\seen{j} \impl \neg (a_0 \bullet e_0^\at{j}))\\
\lor 
& ((\exists j)(\seen{j} \land a = e_0^\at{j} \land (\forall k)(\between{j}{k}{i} \impl \neg (a_0 \bullet e_0^\at{k}))) \land \\
&(\forall k)(\seen{k} \impl a \circ e_0^\at{k}))\\
\end{eqnarray*}

\bigskip
\patternexample

\medskip
$\begin{array}{l}
  \KWloop \KWover i \KWin 1~..~N \\
  ~~~~ \textit{invariant}: (m = m_0) \land (\forall j)(1\leq j < i \impl \neg (m_0 < A[j]))\\
  ~~~~~~~~~~~~~ \lor ((\exists j)(1\leq j < i \land m = A[j]) \land (\forall k)(1\leq k < i \impl m \geq A[k]))\\
  ~~~~ m < A(i) \rightarrow m := A(i)\\
  \KWend
\end{array}$

\subsubsection*{Single Min/Max Index Pattern}

\patterndef A scalar variable is only modified in a single assignment, whose
guard is a comparison between a value-preserving expression and the same expression
where the loop index is replaced by the variable, and it receives the value of
the loop index.
%
$$(e^\at{a} \bullet e^\at{\idx}) \rightarrow a := \idx  \qquad \bullet \in \{<, \leq, >, \geq \}$$
%
\loopinvariant
%
\begin{eqnarray*}
&(a = a_0) \land (\forall j)(\seen{j} \impl \neg (e_0^\at{a_0} \bullet e_0^\at{j}))\\
\lor 
& ((\exists j)(\seen{j} \land a = j) \land (\forall k)(\seen{k} \impl e_0^\at{a} \circ e_0^\at{k}))
\end{eqnarray*}
where $\circ$ can be deduced from $\bullet$ as follows:
$\begin{array}{l|llll}
\bullet & <    & \leq & >    & \geq \\ \hline
\circ   & \geq & \geq & \leq & \leq
\end{array}$

\bigskip
\patternexample

\medskip
$\begin{array}{l}
  \KWloop \KWover i \KWin 1~..~N \\
  ~~~~ \textit{invariant}: (m = m_0) \land (\forall j)(1\leq j < i \impl \neg (A(m_0) < A[j]))\\
  ~~~~~~~~~~ \lor ((\exists j)(1\leq j < i \land m = j) \land (\forall k)(1\leq k < i \impl A(m) \geq A[k]))\\
  ~~~~ A(m) < A(i) \rightarrow m := i\\
  \KWend
\end{array}$

\subsubsection*{Known Single Update Pattern}

\patterndef A scalar variable is only modified in a single assignment, whose
guard is a value-preserving expression, and it receives a value-preserving expression.
%
$$g^\at{\idx} \rightarrow a := e^\at{\idx}$$
%
\loopinvariant
%
\begin{eqnarray*}
&(a = a_0) \land (\forall j)(\seen{j} \impl \neg g_0^\at{j})\\
\lor 
& (\exists j)(\seen{j} \land g_0^\at{j} \land a = e_0^\at{j} \land (\forall k)(\between{j}{k}{\idx} \impl \neg g_0^\at{k}))
\end{eqnarray*}

\bigskip
\patternexample

\medskip
$\begin{array}{l}
  \KWloop \KWover i \KWin 1~..~N \\
  ~~~~ \textit{invariant}: (m = m_0) \land (\forall j)(1\leq j < i \impl A(j)-B(j)\neq0)\\
  ~~~~~~~~~~~~~~~~~~~ \lor (\exists j)(1\leq j < i \land A(j)-B(j)= 0 \land m = B(j) \land \\
  ~~~~~~~~~~~~~~~~~~~~~~~~~ (\forall k)(j < k < i \impl A(k)-B(k)\neq0))\\
  ~~~~ A(i)-B(i)=0 \rightarrow m := B(i)\\
  \KWend
\end{array}$

\subsubsection*{Unknown Single Update Pattern}

\patterndef A scalar variable $a$ is modified at most in a single assignment, whose
guard is unknown, and it receives a value-preserving expression.
%
$$g^? \rightarrow a := e^\at{\idx}$$
%
\loopinvariant
%
$$(a = a_0) \lor (\exists j)(\seen{j} \land a = e_0^\at{j})$$

\bigskip
\patternexample

\medskip
$\begin{array}{l}
  \KWloop \KWover i \KWin 1~..~N \\
  ~~~~ \textit{invariant}: (m = m_0) \lor (\exists j)(1\leq j < i \land m = B_0(j))\\
  ~~~~ A(m)-B(m)=0 \rightarrow m := B(i)\\
  \KWend
\end{array}$

\subsubsection*{Known Multiple Update Pattern}

\patterndef A scalar variable is modified in more than one assignment, all of
whose guards are value-preserved, and it receives in each a value-preserving expression.
%
\begin{eqnarray*}
&g_1^\at{\idx} \rightarrow a := e_1^\at{\idx}\\
&...\\
&g_n^\at{\idx} \rightarrow a := e_n^\at{\idx}\\
\end{eqnarray*}
%
\loopinvariant
%
\begin{eqnarray*}
&(a = a_0) \land (\forall j)(\forall r)(\seen{j} \impl \neg g_{r0}^\at{j})\\
\lor 
& (\exists j)
\left(\begin{array}{cl}
&(\exists r)(\seen{j} \land g_{r0}^\at{j} \land a = e_{r0}^\at{j})\\
\land&  (\forall k)(\forall r) (\between{j}{k}{\idx} \impl \neg g_{r0}^\at{k})
\end{array}\right)
\end{eqnarray*}
%
\patternnote In this invariant and others multiple invariants patterns, 
existential and universal quantifier concern the implicit range of all 
guarded assignment considered, i.e : $1 \leq r \leq n$.

\bigskip
\patternexample

\medskip
$\begin{array}{l}
  \KWloop \KWover i \KWin 1~..~N \\
  ~~~~ \textit{invariant}: (m = m_0) \land (\forall j)(1\leq j < i \impl A(j)-B(j)=0)\\
  ~~~~~~~~~~~~~~~~~~~ \lor (\exists j)(\seen{j} \land ((A(j)-B(j) < 0 \land m = B_0(j)) \lor\\
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ (A(j)-B(j) > 0 \land m = A_0(j)))\\
  ~~~~~~~~~~~~~~~~~~~~~~~~~~ \land (\forall k)(j < k < i \impl (A(k)-B(k) = 0)))\\
  ~~~~ A(i)-B(i) < 0 \rightarrow m := B(i)\\
  ~~~~ A(i)-B(i) > 0 \rightarrow m := A(i)\\
  \KWend
\end{array}$

\subsection{Integrate Patterns}

\subsubsection*{Certain Single Add-Up Pattern}

\patterndef A scalar variable $a$ is modified at most in a single assignment, whose
guard is \textit{true}, and it receives its own previous value plus a constant.
%
$$\mathit{true} \rightarrow a := a + K$$
%
\loopinvariant
%
$$a = a_0 + K * (i-1)$$

\bigskip
\patternexample

\medskip
$\begin{array}{l}
  \KWloop \KWover i \KWin 1~..~N \\
  ~~~~ \textit{invariant}: m = m_0 + (i-1)\\
  ~~~~ true \rightarrow m := m+1\\
  \KWend
\end{array}$

\subsubsection*{Known Single Add-Up Pattern}

\patterndef A scalar variable $a$ is modified at most in a single assignment, whose
guard is a value-preserving expression, and it receives its own previous value plus a constant $k$.
%
$$g^\at{\idx} \rightarrow a := a + K$$
%
\loopinvariant
%
\begin{eqnarray*}
&(a = a_0) \land (\forall j)(\seen{j} \impl \neg g_0^\at{j})) \\
\lor 
& (\exists j)
\left(\begin{array}{cl}
&\seen{j} \land g_0^\at{j}\\
 \land& (\exists k)(1 \leq k \leq \tocount{j} \land a = a_0 + K * k) \\
\land& (\forall k)(\between{j}{k}{\idx} \impl \neg g_0^\at{k})
\end{array}\right)
\end{eqnarray*}

\bigskip
\patternexample

\medskip
$\begin{array}{l}
  \KWloop \KWover i \KWin 1~..~N \\
  ~~~~ \textit{invariant}: (m = m_0) \land (\forall j)(1\leq j < i \impl A(j)-B(j)\neq0)\\
  ~~~~~~~~~~~~~~~~~~~ \lor (\exists j)(\seen{j} \land A(j)-B(j)= 0 \land \\
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ (\exists k)(1 \leq k \leq j \land m = m_0 + k) \land\\
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ (\forall k)(j < k < i \impl A(k)-B(k)\neq0))\\
  ~~~~ A(i)-B(i)=0 \rightarrow m := m+1\\
  \KWend
\end{array}$

\subsubsection*{Known Multiple Add-Up Pattern}

\patterndef A scalar variable is modified in more than one assignment, all of
whose guards are value-preserved, and it receives in each its own previous value
plus a constant.
%
\begin{eqnarray*}
&g_1^\at{\idx} \rightarrow a := a + K_1\\
&...\\
&g_n^\at{\idx} \rightarrow a := a + K_n\\
\end{eqnarray*}
%
\loopinvariant
%
\begin{eqnarray*}
&(a = a_0) \land (\forall j)(\forall r)( \seen{j} \impl \neg g_{r0}^\at{j})) \\
\lor 
& (\exists j)
\left(\begin{array}{cl}
&(\exists r)(\seen{j} \land g_{r0}^\at{j}) \\
\land& (\exists k)(1 \leq k \leq \tocount{j} \land a_0 + \mathit{min}(K_r) * k \leq a \leq a_0 + \mathit{max}(K_r) * k) \\
\land& (\forall k)(\forall r)(\between{j}{k}{\idx} \impl \neg g_{r0}^\at{k})
\end{array}\right)
\end{eqnarray*}

\bigskip
\patternexample

\medskip
$\begin{array}{l}
  \KWloop \KWover i \KWin 1~..~N \\
  ~~~~ \textit{invariant}: (m = m_0) \land (\forall j)(1\leq j < i \impl A(j)-B(j) = 0)\\
  ~~~~~~~~~~~~~~~~~~~ \lor (\exists j)(\seen{j} \land (A(j)-B(j) < 0 \lor A(j)-B(j) > 0) \\
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ \land (\exists k)(1 \leq k \leq j \land m_0-k \leq m \leq m_0 +k) \\
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ \land (\forall k)(j < k < i \impl A(j)-B(j) = 0))\\
  ~~~~ A(i)-B(i) < 0 \rightarrow m := m+1\\
  ~~~~ A(i)-B(i) > 0 \rightarrow m := m-1\\
  \KWend
\end{array}$

\subsubsection*{Unknown Single Add-Up Pattern}

\patterndef A scalar variable $a$ is modified at most in a single assignment, whose
guard is unknown, and it receives its own previous value plus a constant.
%
$$g^? \rightarrow a := a + K$$
%
\loopinvariant
%
$$(a = a_0) \lor (\exists j)(\seen{j} \land (\exists k)(1 \leq k \leq \tocount{j} \land a = a_0 + K * k))$$

\bigskip
\patternexample

\medskip
$\begin{array}{l}
  \KWloop \KWover i \KWin 1~..~N \\
  ~~~~ \textit{invariant}: (m = m_0) \lor \\
  ~~~~~~~~~~~~~~~~~~ (\exists j)(1 \leq j < i \land (\exists k)(1 \leq k \leq j \land m = m_0+10*k))\\
  ~~~~ F(m)=0 \rightarrow m := m+10\\
  \KWend
\end{array}$

\subsubsection*{Unknown Multiple Add-Up Pattern}

\patterndef A scalar variable is modified in more than one assignment, all of
whose guards are unknown, and it receives in each its own previous value
plus a constant.
%
\begin{eqnarray*}
&g^? \rightarrow a := a + K_1\\
&...\\
&g^? \rightarrow a := a + K_n\\
\end{eqnarray*}
%
\loopinvariant
%
\begin{eqnarray*}
&(a = a_0) \lor\\
&(\exists j)(\seen{j} \land (\exists k)(1 \leq k \leq \tocount{j} \land a_0 + \mathit{min}(K_r)*k \leq a \leq a_0 + \mathit{max}(K_r)*k))\\
\end{eqnarray*}

\bigskip
\patternexample

\medskip
$\begin{array}{l}
  \KWloop \KWover i \KWin 1~..~N \\
  ~~~~ \textit{invariant}: (m = m_0) \lor \\
  ~~~~~~~ (\exists j)(1 \leq j < i \land (\exists k)(1 \leq k \leq j \land m_0+10*k \leq m \leq m_0 +20*k))\\
  ~~~~ F(m)=0 \rightarrow m := m+10\\
  ~~~~ G(m)=0 \rightarrow m := m+20\\
  \KWend
\end{array}$

\subsubsection*{Certain Single Mult-Up Pattern}

\patterndef A scalar variable is only modified in a single assignment, whose
guard is \textit{true}, and it receives its own previous value times
(resp. divided by) a constant.
%
$$\mathit{true} \rightarrow a := a \bullet K \qquad \bullet \in \{*, / \}$$
%
\loopinvariant
%
$$a = a_0 \bullet K^{i-1}$$

\bigskip
\patternexample

\medskip
$\begin{array}{l}
  \KWloop \KWover i \KWin 1~..~N \\
  ~~~~ \textit{invariant}: m = m_0 * 2^{i-1}\\
  ~~~~ true \rightarrow m := m*2\\
  \KWend
\end{array}$

\subsubsection*{Known Single Mult-Up Pattern}

\patterndef A scalar variable is only modified in a single assignment, whose
guard is a value-preserving expression, and it receives its own previous value times
(resp. divided by) a constant.

$$g^\at{\idx} \rightarrow a := a \bullet K  \qquad \bullet \in \{*, / \}$$

\loopinvariant

\begin{eqnarray*}
&(a = a_0) \land (\forall j)(\seen{j} \impl \neg g_0^\at{j})) \\
\lor 
& (\exists j)
\left(\begin{array}{cl}
& \seen{j} \land g_0^\at{j} \\
\land& (\exists k)(1 \leq k \leq \tocount{j} \land a = a_0 \bullet K^k)\\
\land& (\forall k)(\between{j}{k}{\idx} \impl \neg g_0^\at{k})
\end{array}\right)
\end{eqnarray*}

\bigskip
\patternexample

\medskip
$\begin{array}{l}
  \KWloop \KWover i \KWin 1~..~N \\
  ~~~~ \textit{invariant}: (m = m_0) \land (\forall j)(1 \leq j < i \impl A(j)-B(j)\neq0)\\
  ~~~~~~~~~~~~~~~~~~~ \lor (\exists j)(\seen{j} \land (A(j)-B(j)= 0 \land \\
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ (\exists k)(1 \leq k \leq j \land m = m_0 * 2^k) \land\\
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ (\forall k)(j < k < i \impl A(k)-B(k)\neq0))\\
  ~~~~ A(i)-B(i)=0 \rightarrow m := m*2\\
  \KWend
\end{array}$

\subsubsection*{Unknown Single Mult-Up Pattern}

\patterndef A scalar variable $a$ is modified at most in a single assignment, whose
guard is unknown, and it receives its own previous value times
(resp. divided by) a constant.
%
$$g^? \rightarrow a := a \bullet K  \qquad \bullet \in \{*, / \}$$
%
\loopinvariant
%
$$(a = a_0) \lor (\exists j)(\seen{j} \land (\exists k)(1 \leq k \leq \tocount{j} \land a = a_0 \bullet K^k))$$

\bigskip
\patternexample

\medskip
$\begin{array}{l}
  \KWloop \KWover i \KWin 1~..~N \\
  ~~~~ \textit{invariant}: (m = m_0) \lor \\
  ~~~~~~~~~~~~~~~~~~~ (\exists j)(1 \leq j < i \land (\exists k)(1 \leq k \leq j \land m = m_0+10^k))\\
  ~~~~ F(m)=0 \rightarrow m := m*10\\
  \KWend
\end{array}$

\subsection{Map Patterns}

\subsubsection*{Certain Single Map Pattern}

\patterndef An array variable is modified at index \idx, in at most single assignment, whose
guard is \textit{true} and it receives a value-preserving expression.
%
$$\mathit{true} \rightarrow A[\idx] := e^\at{\idx}$$
%
\loopinvariant
%
\begin{eqnarray*}
&(\forall j)(\seen{j} \impl A[j] = e_0^\at{j}) \\
\land& (\forall j)(\neg \seen{j} \land \inbounds{A}{j} \impl A[j] = A_0[j])
\end{eqnarray*}
%
\patternnote This pattern corresponds in particular to an array copy.

\bigskip
\patternexample

\medskip
$\begin{array}{l}
  \KWloop \KWover i \KWin 1~..~N \\
  ~~~~ \textit{invariant}: (\forall j)(1\leq j< i \impl A[j] = B[j]) \land\\
  ~~~~~~~~~~~~~~~~~~~ (\forall j)(1 > j \land j \geq i \land \inbounds{A}{j} \impl A[j] = A_0[j])\\
  ~~~~ true \rightarrow A[i] := B[i]\\
  \KWend
\end{array}$

\subsubsection*{Certain Shifted Single Map Pattern}

\patterndef An array variable is modified at index \idx plus a constant $k$, in at most single assignment, 
whose guard is \textit{true}, and it receives a value-preserving expression.
%
$$\mathit{true} \rightarrow A[\idx + K] := e^\at{\idx}$$
%
\loopinvariant
%
\begin{eqnarray*}
&(\forall j)(\seen{j} \impl A[j + K] = e_0^\at{j}) \\
\land& (\forall j)(\neg \seen{j} \land \inbounds{A}{j + K} \impl A[j + K] = A_0[j + K])
\end{eqnarray*}
%
\patternnote All map patterns can be shifted like the above.

\bigskip
\patternexample

\medskip
$\begin{array}{l}
  \KWloop \KWover i \KWin 1~..~N \\
  ~~~~ \textit{invariant}: (\forall j)(1 \leq j < i \impl A[j+1] = B[j]) \land\\
  ~~~~~~~~~~~~ (\forall j)(1 > j \land j \geq i \land \inbounds{A}{j+1} \impl A[j+1] = A_0[j+1])\\
  ~~~~ true \rightarrow A[i+1] := B[i]\\
  \KWend
\end{array}$

\subsubsection*{Known Single Map Pattern}

\patterndef An array variable is modified at index \idx in at most single assignment, whose
guard is a value-preserving expression, and it receives a value-preserving expression.
%
$$g^\at{\idx} \rightarrow A[\idx] := e^\at{\idx}$$
%
\loopinvariant
%
\begin{eqnarray*}
&(\forall j)(\seen{j} \land g_0^\at{j} \impl A[j] = e_0^\at{j}) \\
\land&(\forall j)(\seen{j} \land \neg g_0^\at{j} \impl A[j] = A_0[j]) \\
\land&
 (\forall j)(\neg \seen{j} \land \inbounds{A}{j} \impl A[j] = A_0[j])\\
\end{eqnarray*}

\bigskip
\patternexample

\medskip
$\begin{array}{l}
  \KWloop \KWover i \KWin 1~..~N \\
  ~~~~ \textit{invariant}: (\forall j)(1 \leq j < i \land A_0[j] \neq 0 \impl A[j] = 0) \land\\
  ~~~~~~~~~~~~~~~~~~~ (\forall j)(1 \leq j < i \land A_0[j] = 0 \impl A[j] = A_0[j]) \land\\
  ~~~~~~~~~~~~~~~~~~~ (\forall j)(1 > j \land j \geq i \land \inbounds{A}{j} \impl A[j] = A_0[j])\\
  ~~~~ A[i] \neq 0 \rightarrow A[i] := 0\\
  \KWend
\end{array}$

\subsubsection*{Known Multiple Map Pattern}

\patterndef An array variable is modified in more than one assignment, all
of whose guards are value-preserving expressions, at index \idx, and it receives in each a
value-preserving expression.
%
\begin{eqnarray*}
&g_1^\at{\idx} \rightarrow A[\idx] := e_1^\at{\idx}\\
&...\\
&g_n^\at{\idx} \rightarrow A[\idx] := e_n^\at{\idx}\\
\end{eqnarray*}
%
\loopinvariant
%
\begin{eqnarray*}
&(\forall j)(\forall r)(\seen{j} \land g_{r0}^\at{j} \impl A[j] = e_{r0}^\at{j}) \\
\land&(\forall j)(\seen{j} \land (\forall r) (\neg g_{r0}^\at{j})) \impl A[j] = A_0[j]) \\
\land&
 (\forall j)(\neg \seen{j} \land \inbounds{A}{j} \impl A[j] = A_0[j])\\
\end{eqnarray*}

\bigskip
\patternexample

\medskip
$\begin{array}{l}
  \KWloop \KWover i \KWin 1~..~N \\
  ~~~~ \textit{invariant}: (\forall j)(1 \leq j < i \land (A_0[j] < 0 \impl A[j] = -1\\
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ \land (A_0[j] > 0 \impl A[j] = +1)\\
  ~~~~~~~~~~~~~~~~~~~ \land (\forall j)(1 \leq j < i \land A_0[j] = 0 \impl A[j] = A_0[j])\\
  ~~~~~~~~~~~~~~~~~~~ \land (\forall j)(1 > j \land j \geq i \land \inbounds{A}{j} \impl A[j] = A_0[j])\\
  ~~~~ A[i] < 0 \rightarrow A[i] := -1\\
  ~~~~ A[i] > 0 \rightarrow A[i] := +1\\
  \KWend
\end{array}$

\subsubsection*{Unknown Single Map Pattern}

\patterndef An array variable is only modified in a single assignment, whose
guard is unknown, at index \idx, and it receives a value-preserving expression.
%
$$g^? \rightarrow A[\idx] := e^\at{\idx}$$
%
\loopinvariant
%
\begin{eqnarray*}
&(\forall j)(\seen{j} \impl A[j] = e_0^\at{j} \lor A[j] = A_0[j]) \\
\land&
 (\forall j)(\neg \seen{j} \land \inbounds{A}{j} \impl A[j] = A_0[j])\\
\end{eqnarray*}

\bigskip
\patternexample

\medskip
$\begin{array}{l}
  \KWloop \KWover i \KWin 1~..~N \\
  ~~~~ \textit{invariant}: (\forall j)(1 \leq j < i \impl A[j] = 0 \lor A[j]=A_0[j])\\
  ~~~~~~~~~~~~~~~~~~~ \land (\forall j)(1 > j \land j \geq i \land \inbounds{A}{j} \impl A[j] = A_0[j])\\
  ~~~~ A[i/2] \rightarrow A[i] := 0\\
  \KWend
\end{array}$

\subsubsection*{Unknown Multiple Map Pattern}

\patterndef An array variable is modified in more than one assignment, all
of whose guards are unknown, at index \idx, and it receives in each a
value-preserving expression.
%
\begin{eqnarray*}
&g^? \rightarrow A[\idx] := e_1^\at{\idx}\\
&...\\
&g^? \rightarrow A[\idx] := e_n^\at{\idx}\\
\end{eqnarray*}
%
\loopinvariant
%
\begin{eqnarray*}
&(\forall j)(\seen{j} \impl (\exists r)(A[j] = e_{r0}^\at{j}) \lor A[j] = A_0[j]) \\
\land&
 (\forall j)(\neg \seen{j} \land \inbounds{A}{j} \impl A[j] = A_0[j])\\
\end{eqnarray*}

\bigskip
\patternexample

\medskip
$\begin{array}{l}
  \KWloop \KWover i \KWin 1~..~N \\
  ~~~~ \textit{invariant}: (\forall j)(1 \leq j < i \impl (A[j] = -1 \lor A[j] = +1 \lor A[j] = A_0[j])\\
  ~~~~~~~~~~~~~~~~~~~ \land (\forall j)(1 > j \land j \geq i \land \inbounds{A}{j}\impl A[j] = A_0[j])\\
  ~~~~ A[i-1] < A[i-2] \rightarrow A[i] := -1\\
  ~~~~ A[i-1] > A[i-2] \rightarrow A[i] := +1\\
  \KWend
\end{array}$

\subsubsection*{Filter Pattern}

\patterndef An array variable is only modified in a single assignment, whose
guard is a value-preserving expression, at index $v$, and it receives in each a 
value-preserving expression. Scalar variable $v$ is incremented in a single assignment, 
whose guard is the same as the one above.
%
\begin{eqnarray*}
g^\at{\idx} &\rightarrow& A[v] := e^\at{\idx}\\
g^\at{\idx} &\rightarrow& v := v + 1\\
\end{eqnarray*}
%
\loopinvariant
%
\begin{eqnarray*}
&(\forall j)(\seen{j} \land g_0^\at{j} \impl (\exists k)(v_0 \leq k < v \land A[k] = e_0^\at{j}))  \\
\land&
(\forall k)(v_0 \leq k < v \impl (\exists j)(\seen{j} \land g_0^\at{j} \land A[k] = e_0^\at{j}))  \\
\land&
(\forall k)(k > v \land \inbounds{A}{k} \impl A[k] = A_0[k])
\end{eqnarray*}
%
\patternnote This pattern corresponds in particular to an array filter, in
which elements satisfying a certain condition are copied to the front of the
array.

\bigskip
\patternexample

\medskip
$\begin{array}{l}
  \KWloop \KWover i \KWin 1~..~N \\
  ~~~~ \textit{invariant}: (\forall j)(1 \leq j < i \land A_0[j] > 0 \impl (\exists k)(\upsilon_0 \leq k < \upsilon \land B[k] = A_0[j]))\\
  ~~~~~~~~~~~~~~~ \land (\forall k)(\upsilon_0 \leq k < \upsilon \impl (\exists j)(1 \leq j < i \land  A_0[j] > 0 \land B[k] = A_0[j]))\\
  ~~~~~~~~~~~~~~~ \land (\forall k)(k > \upsilon \land \inbounds{A}{k} \impl B[k] = B_0[k])\\
  ~~~~ A[i] > 0 \rightarrow B[\upsilon] := A[i]\\
  ~~~~ A[i] > 0 \rightarrow \upsilon := \upsilon + 1\\
  \KWend
\end{array}$

\subsection{Exchange Patterns}

\subsubsection*{Known Exchange Pattern}

\patterndef An array variable is only modified in a single assignment,
whose guard is a value-preserving expression, at some unkown index, 
and it receives a value-preserving expression.
%
\begin{eqnarray*}
g^\at{\idx} \rightarrow A[e^?] := e^\at{\idx}\\
\end{eqnarray*}

%
\patternnote This pattern includes the case where the index of A is value-preserving but different from $i$.

\medskip
%
\loopinvariant
%
$$(\forall j)(\inbounds{A}{j} \impl A[j] = A_0[j] \lor (\exists k)(\seen{k} \land g_0^\at{k} \land A[j] = e_0^\at{k}))$$

\bigskip
\patternexample

\medskip
$\begin{array}{l}
  \KWloop \KWover i \KWin 1~..~N \\
  ~~~~ \textit{invariant}: (\forall j)(\inbounds{A}{j} \impl A[j] = A_0[j] \lor \\ 
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ (\exists k)(1 \leq k < i \land B[k] > 0 \land A[j] = B[k]))\\
  ~~~~ B[i] > 0 \rightarrow A[B[i]] := B[i]\\
  \KWend
\end{array}$

\subsubsection*{Unknown Exchange Pattern}

\patterndef An array variable is only modified in a single assignment,
whose guard is unknown, at some unkown index, and it receives a value-preserving expression.
%
\begin{eqnarray*}
&g^? \rightarrow A[e^?] := e^\at{\idx}\\
\end{eqnarray*}
%
\loopinvariant
%
$$(\forall j)(\inbounds{A}{j} \impl A[j] = A_0[j] \lor (\exists k)(\seen{k} \land A[j] = e_0^\at{k}))$$

\bigskip
\patternexample

\medskip
$\begin{array}{l}
  \KWloop \KWover i \KWin 1~..~N \\
  ~~~~ \textit{invariant}: (\forall j)(\inbounds{A}{j} \impl A[j] = A_0[j] \lor \\
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ (\exists k)(1 \leq k < i \land A[j] = B_0[k]))\\
  ~~~~ B[i/2] > 0 \rightarrow A[i/2] := B[i]\\
  \KWend
\end{array}$

\subsubsection*{Known Interchange Pattern}

\patterndef An array variable is modified in possibly more than one assignment,
all of whose guards are unknown, at index \idx, and it receives in each
its own value at some unknown index.
%
\begin{eqnarray*}
&g^? \rightarrow A[\idx] := A[e^?]\\
&...\\
&g^? \rightarrow A[\idx] := A[e^?]\\
\end{eqnarray*}

\patternnote Also for guard value-preserving.

\medskip
\loopinvariant
%
\begin{eqnarray*}
&(\forall j)(\seen{j} \impl (\exists k)(\inbounds{A}{k} \land A[j] = A_0[k])) \\
\land&
(\forall j)(\neg \seen{j} \land \inbounds{A}{j} \impl A[j] = A_0[j])
\end{eqnarray*}

\bigskip
\patternexample

\medskip
$\begin{array}{l}
  \KWloop \KWover i \KWin 1~..~N \\
  ~~~~ \textit{invariant}: (\forall j)(1 \leq j < i \impl (\exists k)(\inbounds{A}{k} \land A[j] = A_0[k]))\\
  ~~~~~~~~~~~~~~~~~~~ \land (\forall j)(1 > j \land j \geq i \land \inbounds{A}{j} \impl A[j] = A_0[j])\\
  ~~~~ B[i] > 0 \rightarrow A[i] := A[i/2]\\
  ~~~~ B[i] < 0 \rightarrow A[i] := A[i/2+1]\\
  \KWend
\end{array}$

\subsubsection*{Unknown Interchange Pattern}

\patterndef An array variable is modified in possibly more than one assignment,
all of whose guards are unknown, at some unkown index, and it receives in each
its own value at some unknown index.
%
\begin{eqnarray*}
&g^? \rightarrow A[e^?] := A[e^?]\\
&...\\
&g^? \rightarrow A[e^?] := A[e^?]\\
\end{eqnarray*}

\patternnote Also for guard value-preserving and index in right-hand-side value-preserving.

\medskip
\loopinvariant
%
$$(\forall j)(\inbounds{A}{j} \impl (\exists k)(\inbounds{A}{k} \land A[j] = A_0[k])) $$

\bigskip
\patternexample

\medskip
$\begin{array}{l}
  \KWloop \KWover i \KWin 1~..~N \\
  ~~~~ \textit{invariant}: (\forall j)(\inbounds{A}{k} \impl (\exists k)(\inbounds{A}{k} \land A[j] = A_0[k]))\\
  ~~~~ B[i] > 0 \rightarrow A[i\%3] := A[A[i]]\\
  ~~~~ B[i] < 0 \rightarrow A[i\%3] := A[-A[y]]\\
  \KWend
\end{array}$

\section{Pre-Transformation Tactic}
When our code fall into the above patterns nothing to do, just apply the corresponding invariant patterns. 
Contrariwise, in some cases we will need a pre-processing them to bring into our patterns. 
This pre-processing mainly to reorganize our code in order to transform the expression 
which used others variables updates in the loop to a \textit{value-preserving expression}  
define in section~\ref{sec:naming-conventions}. For example in the following code 

$$\begin{array}{l}
  \KWloop \KWover i \KWin 1 .. N \\
  ~~~~ True \rightarrow A[i] := B[Index]\\
  ~~~~ True \rightarrow Index := Index + 1\\
  \KWend
\end{array}$$

The last statement is Certain Single Add-Up Pattern but the first statement is not Certain Single Map Pattern
because $B[Index]$ use a update variable $Index$ (therefore it's not value-preserving expression). 
If we transform it as below we have Certain Single Map Pattern and Certain Single Add-Up Pattern. 
Thus, the full invariant is the conjonction of the two corresponding invariants.

$$\begin{array}{l}
  \KWloop \KWover i \KWin 1 .. N \\
  ~~~~ True \rightarrow A[i]   := B[Index0 + I-1]\\
  ~~~~ True \rightarrow Index := Index + 1\\
  \KWend
\end{array}$$
%
\loopinvariant
%
\begin{eqnarray*}
&(\forall j)(\seen{j} \impl A[j] = B_0[Index0 + j-1]) \\
\land& (\forall j)(\neg \seen{j} \land \inbounds{A}{j} \impl A[j] = A_0[j])\\
&\land& \\
&Index = Index_0 + 1 * (i-1)&
\end{eqnarray*}

\bibliographystyle{abbrv}
\bibliography{loop_patterns}
\end{document}          

include "arrays.why"

(*********************)
(* Var.Decision_Kind *)
(*********************)

type var__decision_kind =
 | var__condition_kind
 | var__not_kind
 | var__or_else_kind
 | var__and_then_kind

function integer_of___var__decision_kind (x : var__decision_kind) : int =
 match x with
  | var__condition_kind -> 0
  | var__not_kind       -> 1
  | var__or_else_kind   -> 2
  | var__and_then_kind  -> 3
 end

predicate eq___var__decision_kind (left : var__decision_kind, right : var__decision_kind) =
 integer_of___var__decision_kind (left) = integer_of___var__decision_kind (right)

predicate le___var__decision_kind (left : var__decision_kind, right : var__decision_kind) =
 integer_of___var__decision_kind (left) <= integer_of___var__decision_kind (right)

predicate var__decision_kind___in_range (x : int) =
 let first = 0 in
 let last = 3 in
  first <= x <= last

logic var__decision_kind___of_integer : int -> var__decision_kind

axiom var__decision_kind___coerce :
 (forall x : int.
   var__decision_kind___in_range (x) ->
    integer_of___var__decision_kind (var__decision_kind___of_integer (x)) = x)

parameter any___var__decision_kind : unit -> { } var__decision_kind { true }

parameter var__decision_kind___of_integer_ :
 x : int ->
  { var__decision_kind___in_range (x) }
   var__decision_kind
  { integer_of___var__decision_kind (result) = x }

parameter safe___var__decision_kind___of_integer_ :
 x : int ->
  { }
   var__decision_kind
  { integer_of___var__decision_kind (result) = x }

parameter eq___var__decision_kind_ :
 left : var__decision_kind -> right : var__decision_kind ->
{ }
 bool
{ result = true <-> eq___var__decision_kind (left, right) }

(***************)
(* Var.Node_Id *)
(***************)

type var__node_id

logic integer_of___var__node_id : var__node_id -> int

predicate eq___var__node_id
(x : var__node_id,
 y : var__node_id) =
 integer_of___var__node_id (x) = integer_of___var__node_id (y)

predicate var__node_id___in_range (x : int) =
 let first = 1 in
 let last = 1000 in
  first <= x <= last

logic var__node_id___of_integer : int -> var__node_id

axiom var__node_id___coerce :
 (forall x : int.
  var__node_id___in_range (x) ->
   integer_of___var__node_id (var__node_id___of_integer (x)) = x)

axiom var__node_id___range :
 forall x : var__node_id.
  var__node_id___in_range (integer_of___var__node_id (x))

axiom var__node_id___unicity :
 forall x, y : var__node_id.
  integer_of___var__node_id (x) = integer_of___var__node_id (y)
   -> x = y

parameter any___var__node_id : unit -> { } var__node_id { true }

parameter var__node_id___of_integer_ :
 x : int ->
  { var__node_id___in_range (x) }
   var__node_id
  { integer_of___var__node_id (result) = x }

parameter safe___var__node_id___of_integer_ :
 x : int ->
  { }
   var__node_id
  { integer_of___var__node_id (result) = x }

(****************)
(* Var.Decision *)
(****************)

type var__decision

logic integer_of___var__decision : var__decision -> int

logic var__decision___of_integer : int -> var__decision

predicate eq___var__decision (x : var__decision, y : var__decision) =
 integer_of___var__decision (x) = integer_of___var__decision (y)

axiom var__decision___coerce :
 (forall x : int.
   integer_of___var__decision (var__decision___of_integer (x)) = x)

axiom var__decision___unicity :
 forall x, y : var__decision.
  integer_of___var__decision (x) = integer_of___var__decision (y) -> x = y

function var__decision___get
 (field_values : 'a farray,
  x : var__decision)
 : 'a =
  access (field_values, integer_of___var__decision (x))

function var__decision___set
 (field_values : 'a farray,
  x            : var__decision,
  v            : 'a)
 : 'a farray =
  update (field_values, integer_of___var__decision (x), v)

predicate eq_extension___var__decision
(x                : var__decision,
 y                : var__decision,
 kind___values    : var__decision_kind farray,
 id___values      : var__node_id farray,
 operand___values : var__node_id farray,
 left___values    : var__node_id farray,
 right___values   : var__node_id farray) =
 var__decision___get (id___values, x) = var__decision___get (id___values, y)
 and match var__decision___get (kind___values, x) with
  | var__condition_kind ->
    var__decision___get (id___values, x) = var__decision___get (id___values, y)
  | var__not_kind ->
   var__decision___get (operand___values, x) =
   var__decision___get (operand___values, y)
  | var__or_else_kind ->
   var__decision___get (left___values, x) =
   var__decision___get (left___values, y) and
   var__decision___get (right___values, x) =
   var__decision___get (right___values, y)
  | var__and_then_kind ->
   var__decision___get (left___values, x) =
   var__decision___get (left___values, y) and
   var__decision___get (right___values, x) =
   var__decision___get (right___values, y)
 end

parameter var__decision___get_ :
 field__values : 'a array -> x : var__decision ->
{ }
 'a reads field__values
{ result = var__decision___get (field__values, x) }

parameter var__decision___set_ :
 field__values : 'a array -> x : var__decision -> value : 'a ->
{ }
 unit writes field__values
{ field__values = var__decision___set (field__values, x, value) }


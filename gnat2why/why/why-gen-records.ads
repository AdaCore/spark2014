------------------------------------------------------------------------------
--                                                                          --
--                            GNAT2WHY COMPONENTS                           --
--                                                                          --
--                      W H Y - G E N - R E C O R D S                       --
--                                                                          --
--                                 S p e c                                  --
--                                                                          --
--                       Copyright (C) 2010-2014, AdaCore                   --
--                                                                          --
-- gnat2why is  free  software;  you can redistribute  it and/or  modify it --
-- under terms of the  GNU General Public License as published  by the Free --
-- Software  Foundation;  either version 3,  or (at your option)  any later --
-- version.  gnat2why is distributed  in the hope that  it will be  useful, --
-- but WITHOUT ANY WARRANTY; without even the implied warranty of  MERCHAN- --
-- TABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public --
-- License for  more details.  You should have  received  a copy of the GNU --
-- General  Public License  distributed with  gnat2why;  see file COPYING3. --
-- If not,  go to  http://www.gnu.org/licenses  for a complete  copy of the --
-- license.                                                                 --
--                                                                          --
-- gnat2why is maintained by AdaCore (http://www.adacore.com)               --
--                                                                          --
------------------------------------------------------------------------------

with Atree;              use Atree;
with Einfo;              use Einfo;
with SPARK_Util;         use SPARK_Util;
with Types;              use Types;
with Why.Gen.Binders;    use Why.Gen.Binders;
with Why.Ids;            use Why.Ids;
with Why.Sinfo;          use Why.Sinfo;
with Gnat2Why.Util;      use Gnat2Why.Util;

package Why.Gen.Records is
   --  This package encapsulates the encoding of Ada records into Why. This
   --  also includes records with variant parts.

   procedure Declare_Ada_Record
     (P       : Why_Section;
      Theory  : W_Theory_Declaration_Id;
      E       : Entity_Id);
   --  Emit all necessary Why3 declarations to support Ada records. This also
   --  supports variant records.

   procedure Declare_Private_Type
     (Theory : W_Theory_Declaration_Id;
      E      : Entity_Id);
   --  Make the necessary declarations for a private type

   function New_Ada_Record_Access
     (Ada_Node : Node_Id;
      Domain   : EW_Domain;
      Name     : W_Expr_Id;
      Field    : Entity_Id;
      Ty       : Entity_Id)
      return W_Expr_Id;
   --  Generate a Why3 expression that corresponds to the access to an Ada
   --  record field. Emit all necessary checks.

   function New_Ada_Record_Check_For_Field
     (Ada_Node : Node_Id := Empty;
      Domain   : EW_Domain;
      Name     : W_Expr_Id;
      Field    : Entity_Id;
      Ty       : Entity_Id) return W_Expr_Id;
   --  Generate a Why3 expression that corresponds to the cases where a record
   --  field is present in an Ada record.

   function New_Ada_Record_Update
     (Ada_Node : Node_Id;
      Domain   : EW_Domain;
      Name     : W_Expr_Id;
      Field    : Entity_Id;
      Value    : W_Expr_Id) return W_Expr_Id;
   --  Generate a Why3 expression that corresponds to the update to an Ada
   --  record field. Emit all necessary checks.
   --  Note that this function does not generate an assignment, instead it
   --  returns a functional update. In the case of simple records, it will look
   --  like
   --    { name with field = value }
   --  The assignment, if required, needs to be generated by the caller.

   function New_Ada_Record_Update
     (Ada_Node : Node_Id := Empty;
      Domain   : EW_Domain;
      Name     : W_Expr_Id;
      Updates  : W_Field_Association_Array)
      return W_Expr_Id;
   --  Generate an update to an array. The associations in Updates should only
   --  modify normal fields (not discrimiants).

   function New_Ada_Record_Aggregate
     (Ada_Node     : Node_Id := Empty;
      Domain       : EW_Domain;
      Discr_Assocs : W_Field_Association_Array;
      Field_Assocs : W_Field_Association_Array;
      Ty           : Entity_Id)
      return W_Expr_Id;
   --  Generate a record aggregate of ada type Ty from the association in
   --  Discr_Assocs and Field_Assocs.

   procedure Generate_Associations_From_Ancestor
     (Ada_Node     : Node_Id := Empty;
      Domain       : EW_Domain;
      Expr         : W_Expr_Id;
      Anc_Ty       : Entity_Id;
      Ty           : Entity_Id;
      Discr_Assocs : out W_Field_Association_Array;
      Field_Assocs : out W_Field_Association_Array);
   --  Generate the part of a record aggregate that comes from the ancestor
   --  part Expr.

   function New_Is_Constrained_Access
     (Ada_Node : Node_Id := Empty;
      Domain   : EW_Domain;
      Name     : W_Expr_Id;
      Ty       : Entity_Id)
      return W_Expr_Id;
   --  Generate a Why3 expression that corresponds to an access to the
   --  additional field introduced in records for the 'Constrained attribute.

   function New_Is_Constrained_Update
     (Ada_Node : Node_Id := Empty;
      Domain   : EW_Domain;
      Name     : W_Expr_Id;
      Value    : W_Expr_Id;
      Ty       : Entity_Id)
      return W_Expr_Id;
   --  Generate a Why3 expression that corresponds to an update to the
   --  additional field introduced in records for the 'Constrained attribute.

   function New_Discriminants_Access
     (Ada_Node : Node_Id := Empty;
      Domain   : EW_Domain;
      Name     : W_Expr_Id;
      Ty       : Entity_Id)
      return W_Expr_Id;
   --  Generate a Why3 expression that corresponds to an access to the
   --  top-level field for discriminants.

   function New_Discriminants_Update
     (Ada_Node : Node_Id := Empty;
      Domain   : EW_Domain;
      Name     : W_Expr_Id;
      Value    : W_Expr_Id;
      Ty       : Entity_Id)
      return W_Expr_Id;
   --  Generate a Why3 expression that corresponds to an update of the
   --  top-level field for discriminants.

   function New_Fields_Access
     (Ada_Node : Node_Id := Empty;
      Domain   : EW_Domain;
      Name     : W_Expr_Id;
      Ty       : Entity_Id)
      return W_Expr_Id;
   --  Generate a Why3 expression that corresponds to an access to the
   --  top-level field for fields.

   function New_Fields_Update
     (Ada_Node : Node_Id := Empty;
      Domain   : EW_Domain;
      Name     : W_Expr_Id;
      Value    : W_Expr_Id;
      Ty       : Entity_Id)
      return W_Expr_Id;
   --  Generate a Why3 expression that corresponds to an update of the
   --  top-level field for fields.

   function New_Tag_Access
     (Ada_Node : Node_Id := Empty;
      Domain   : EW_Domain;
      Name     : W_Expr_Id;
      Ty       : Entity_Id)
      return W_Expr_Id;
   --  Generate a Why3 expression that corresponds to an access to the
   --  additional field introduced for records' tag.

   function Insert_Subtype_Discriminant_Check
     (Ada_Node : Node_Id;
      Check_Ty : Entity_Id;
      Expr     : W_Prog_Id) return W_Prog_Id;
   --  Given a record subtype and an expression, add a call to the subtype
   --  discriminant check function, to generate a discriminant check.

   function Prepare_Args_For_Subtype_Check
     (Check_Ty : Entity_Id;
      Expr     : W_Expr_Id) return W_Expr_Array;
   --  Given a record type, compute the argument array that can be used
   --  together with its subtype check predicate of program function. The
   --  last argument is actually the given expression itself.

   function Record_From_Split_Form (I : Item_Type; Ref_Allowed : Boolean)
                                    return W_Expr_Id
   with
       Pre => I.Kind = DRecord;
   --  Reconstructs a complete record from an item in split form.

   function Record_From_Split_Form
     (A : W_Expr_Array; Ty  : Entity_Id)
      return W_Expr_Id;
   --  Reconstructs a complete record of type Ty from an array of expressions
   --  representing a split form. A should contain first the fields, then the
   --  discriminants, the 'Constrained attribute and the 'Tag attribute.

   function Field_Type_For_Discriminants (E : Entity_Id) return W_Type_Id with
     Pre => Ekind (E) in Type_Kind and then Number_Discriminants (E) > 0;
   --  Type of the top-level Why3 field for discriminants of E.

   function Field_Type_For_Fields (E : Entity_Id) return W_Type_Id with
     Pre => Ekind (E) in Type_Kind and then
     (Count_Fields (E) > 0 or else Is_Tagged_Type (E));
   --  Type of the top-level Why3 field for fields of E.

end Why.Gen.Records;

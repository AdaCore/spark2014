
This describes the representations of record types in Why.

Each field of a record type is represented by an array which is
meant to contain all the values of the field for any instance of
the record. A sort of memory pool for this field, if you like.
Then, an instance of a record is an index in these tables.

The advantage of the peculiar slicing is that it allows to change one
field of a record without invalidating the whole record. Say, if you
have A : array (1 .. 2) of Rec_Type, changing A(1).Field will not
force you to update the whole A(1), which would significantly
complicate the proof.

Of course, this complicates slightly the signatures of functions that
use these records in the program space. Although these field arrays could
be defined in a global scope in Why, this is quite imprecise, as it creates
potential aliasing between variables of record type, whereas we know 
there is no such aliasing in our SPARK-like programs. So a better solution
should be to pass variable-specific field arrays as parameter in any 
function that has a record amongst its parameters.

rec.ads, rec.why and rec_test.why show how this works in the case of
"regular" records.

var.ads, var.why and var_test.why shows how this works in the case of
variant records; this is roughly the same thing; some fields are just
not valid for some indices. Discriminants are treated just like fields.
(Note this is only valid if we're not checking run-time errors.)

var_test.ad? and tristate.ad? give an (informal) Ada equivalent for
var_test.why, in the hope that it would help in understanding this test.

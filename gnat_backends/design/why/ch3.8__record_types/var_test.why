
include "var.why"

type tristate = T_True | T_False | T_Unknown

logic tristate_not : tristate -> tristate
logic tristate_or : tristate, tristate -> tristate
logic tristate_and : tristate, tristate -> tristate

axiom tristate_not_def1 :
 tristate_not (T_True) = T_False

axiom tristate_not_def2 :
 tristate_not (T_False) = T_True

axiom tristate_not_def3 :
 tristate_not (T_Unknown) = T_Unknown

axiom tristate_or_def1 :
 forall x : tristate.
  tristate_or (T_True, x) = T_True

axiom tristate_or_def2 :
 forall x : tristate.
  tristate_or (T_False, x) = x

axiom tristate_or_def3 :
 forall x : tristate.
  tristate_or (T_Unknown, x) = T_Unknown
  
axiom tristate_and_def1 :
 forall x : tristate.
  tristate_and (T_True, x) = T_True

axiom tristate_and_def2 :
 forall x : tristate.
  tristate_and (T_False, x) = x

axiom tristate_and_def3 :
 forall x : tristate.
  tristate_and (T_Unknown, x) = T_Unknown
  

parameter tristate_not_ :
 op : tristate ->
{ }
 tristate
{ result = tristate_not (op) }

parameter tristate_or_ :
 left  : tristate ->
 right : tristate ->
{ }
 tristate
{ result = tristate_or (left, right) }


parameter tristate_and_ :
 left  : tristate ->
 right : tristate ->
{ }
 tristate
{ result = tristate_and (left, right) }

parameter decision_eval :
 root_id          : var__node_id ->
 decision_table   : var__decision array ->
 condition_values : tristate array ->
 kind___values    : var__decision_kind array ->
 id___values      : var__node_id array ->
 operand___values : var__node_id array ->
 left___values    : var__node_id array ->
 right___values   : var__node_id array ->
{ forall x : int. condition_values[x] <> T_Unknown
  and array_length (decision_table) > 1000 }
 tristate
  reads decision_table,
        condition_values,
        kind___values,
        id___values,
        left___values,
        right___values
{ result <> T_Unknown }

logic is_condition : var__decision_kind -> bool
logic is_not : var__decision_kind -> bool
logic is_and_then : var__decision_kind -> bool
logic is_or_else : var__decision_kind -> bool

axiom is_condition_def :
 forall d : var__decision_kind.
  match d with
   | var__condition_kind ->
    is_condition (d) = true
   | var__not_kind ->
    is_condition (d) = false
   | var__or_else_kind ->
    is_condition (d) = false
   | var__and_then_kind ->
    is_condition (d) = false
  end

axiom is_not_def :
 forall d : var__decision_kind.
  match d with
   | var__condition_kind ->
    is_not (d) = false
   | var__not_kind ->
    is_not (d) = true
   | var__or_else_kind ->
    is_not (d) = false
   | var__and_then_kind ->
    is_not (d) = false
  end

axiom is_or_else_def :
 forall d : var__decision_kind.
  match d with
   | var__condition_kind ->
    is_or_else (d) = false
   | var__not_kind ->
    is_or_else (d) = false
   | var__or_else_kind ->
    is_or_else (d) = true
   | var__and_then_kind ->
    is_or_else (d) = false
  end

axiom is_and_then_def :
 forall d : var__decision_kind.
  match d with
   | var__condition_kind ->
    is_and_then (d) = false
   | var__not_kind ->
    is_and_then (d) = false
   | var__or_else_kind ->
    is_and_then (d) = false
   | var__and_then_kind ->
    is_and_then (d) = true
  end

let decision_eval_proof
(root_id          : var__node_id)
(decision_table   : var__decision array)
(condition_values : tristate array)
(kind___values    : var__decision_kind array)
(id___values      : var__node_id array)
(operand___values : var__node_id array)
(left___values    : var__node_id array)
(right___values   : var__node_id array) =
{ (forall x : int. condition_values[x] <> T_Unknown)
  and 1000 < array_length (decision_table)
  and 1000 < array_length (condition_values) }
 let int_root_id = integer_of___var__node_id (root_id) in
 let d = decision_table [int_root_id] in
 let kind = (var__decision___get_ kind___values d) in
  if is_condition (kind) = true then
   let condition_id = (var__decision___get_ id___values d) in
   let int_cond_id  = integer_of___var__node_id (condition_id) in
     condition_values [int_cond_id]
  else if is_not (kind) = true then
   let operand_id = (var__decision___get_ operand___values d) in
   let int_op_id  = integer_of___var__node_id (operand_id) in
    tristate_not_ (decision_eval
                    operand_id
                    decision_table
                    condition_values
                    kind___values
                    id___values
                    operand___values
                    left___values
                    right___values)
  else if is_or_else (kind) = true then
   let left_id  = (var__decision___get_ left___values d) in
   let right_id = (var__decision___get_ right___values d) in
   let left_val  = (decision_eval
                    left_id
                    decision_table
                    condition_values
                    kind___values
                    id___values
                    operand___values
                    left___values
                    right___values) in
   let right_val = (decision_eval
                    right_id
                    decision_table
                    condition_values
                    kind___values
                    id___values
                    operand___values
                    left___values
                    right___values) in
    begin
     tristate_or_ left_val right_val
    end
  else if is_and_then (kind) = true then
   let left_id   = (var__decision___get_ left___values d) in
   let right_id  = (var__decision___get_ right___values d) in
   let left_val  = (decision_eval
                    left_id
                    decision_table
                    condition_values
                    kind___values
                    id___values
                    operand___values
                    left___values
                    right___values) in
   let right_val = (decision_eval
                    right_id
                    decision_table
                    condition_values
                    kind___values
                    id___values
                    operand___values
                    left___values
                    right___values) in
    tristate_and_ left_val right_val
  else absurd
{ result <> T_Unknown }



(* Several simple tests that illustrate how modular__byte could be used
   in why. *)

(************)
(* byte_mod *)
(************)

(* Convert an int to a mod *)

(* Invalid *) (* Range check fails *)

let byte_mod1 =
 fun (x : int) ->
  { }
  (modular__byte___of_integer_ (x))
  {eq_int (integer_of___modular__byte (result), mod_int (x, 260))}

(* OK *)

let byte_mod2 =
 fun (x : int) ->
  {modular__byte___in_range (x)}
  (modular__byte___of_integer_ (x))
  {eq_int (integer_of___modular__byte (result), mod_int (x, 260))}

(*************)
(* succ_byte *)
(*************)

(* Given a modular__byte, returns its successor *)

(* OK *)

let succ___modular__byte =
 fun (x : modular__byte) ->
  { }
   (modular__byte___of_integer (integer_of___modular__byte (x) + 1))
  {(eq_int ((integer_of___modular__byte (x)), 255)
    and eq_int(integer_of___modular__byte(result), 0))
   or (lt_int ((integer_of___modular__byte (x)), 255)
       and eq_int (integer_of___modular__byte(result),
                   integer_of___modular__byte(x) + 1))}

(**************)
(* unit tests *)
(**************)

(* Check succ_modular__byte for different values *)

(* OK *)

let succ___modular__byte0 =
 fun (x : modular__byte) ->
  {(eq_int (integer_of___modular__byte (x), 0)) }
   (succ___modular__byte (x))
  {(eq_int (integer_of___modular__byte (result), 1))}

(* OK *)

let succ___modular__byte5 =
 fun (x : modular__byte) ->
  {(eq_int (integer_of___modular__byte (x), 5)) }
   (succ___modular__byte (x))
  {(eq_int (integer_of___modular__byte (result), 6))}

(* OK *)

let succ___modular__byte254 =
 fun (x : modular__byte) ->
  {(eq_int (integer_of___modular__byte (x), 254)) }
   (succ___modular__byte (x))
  {(eq_int (integer_of___modular__byte (result), 255))}

(* OK *)

let succ___modular__byte255 =
 fun (x : modular__byte) ->
  {(eq_int (integer_of___modular__byte (x), 255)) }
   (succ___modular__byte (x))
  {(eq_int (integer_of___modular__byte (result), 0))}

(* OK *)

let succ___modular__byte258 =
 fun (x : int) ->
  {(eq_int (x, 258)) }
   (succ___modular__byte (modular__byte___mod (x)))
  {(eq_int (integer_of___modular__byte (result), 3))}


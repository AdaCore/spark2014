
type modular__byte

logic integer_of___modular__byte : modular__byte -> int

predicate eq___modular__byte (x : modular__byte, y : modular__byte) =
 integer_of___modular__byte (x) = integer_of___modular__byte (y)

predicate modular__byte___in_range (x : int) =
 let first = 0 in
 let last = 255 in
  first <= x <= last

logic modular__byte___of_integer : int -> modular__byte

axiom modular__byte___coerce :
 let modulo = 256 in
  (forall x : int.
    integer_of___modular__byte (modular__byte___of_integer (x)) = x % modulo
  )

axiom modular__byte_coerce___in_range :
 (forall x : int.
   modular__byte___in_range (x) ->
    integer_of___modular__byte (modular__byte___of_integer (x)) = x
 )

axiom modular__byte___range :
 (forall x : modular__byte.
   modular__byte___in_range (integer_of___modular__byte (x)))

axiom modular__byte___unicity :
 (forall x, y : modular__byte. eq___modular__byte (x, y) -> x = y)

parameter any___modular__byte : unit -> { } modular__byte { true }

parameter modular__byte___of_integer_ :
 x : int ->
 { modular__byte___in_range (x) }
  modular__byte
 { eq_int(integer_of___modular__byte(result), x) }

parameter safe___modular__byte___of_integer_ :
 x : int ->
 { }
  modular__byte
 { integer_of___modular__byte (result) = x }

parameter eq___modular__byte_ :
 x : modular__byte -> y : modular__byte ->
{ }
 bool
{ result = true <-> eq___modular__byte (x, y) }



type signed__int8

logic integer_of___signed__int8 : signed__int8 -> int

predicate eq___signed__int8 (x : signed__int8, y : signed__int8) =
 integer_of___signed__int8 (x) = integer_of___signed__int8 (y)

predicate signed__int8___in_range (x : int) =
 let first = -128 in
 let last = 127 in
  first <= x <= last

logic signed__int8___of_integer : int -> signed__int8

axiom signed__int8___coerce :
 (forall x : int.
  signed__int8___in_range (x) ->
   integer_of___signed__int8 (signed__int8___of_integer (x)) = x)

axiom signed__int8___range :
 (forall x : signed__int8.
  signed__int8___in_range (integer_of___signed__int8 (x)))

axiom signed__int8___unicity :
 forall x, y : signed__int8.
  integer_of___signed__int8 (x) = integer_of___signed__int8 (y) -> x = y
(* YM: equivalence is not strictly needed. Implication -> would be sufficient, 
   and may help automatic provers(?)

   JG: I got the same result for the two possibilities; so I implemented
   your suggestion (applying occam's razor).
*)

parameter any___signed__int8 : unit -> { } signed__int8 { true }

parameter signed__int8___of_integer_ :
 x : int ->
  { signed__int8___in_range (x) }
   signed__int8
  { integer_of___signed__int8 (result) = x }

parameter safe___signed__int8___of_integer_ :
 x : int ->
  { }
   signed__int8
  { integer_of___signed__int8 (result) = x }

parameter eq___signed__int8_ :
 x : signed__int8 -> y : signed__int8 ->
{ }
 bool
{ result = true <-> eq___signed__int8 (x, y) }


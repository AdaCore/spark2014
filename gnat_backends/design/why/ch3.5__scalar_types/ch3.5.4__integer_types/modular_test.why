
(* Several simple tests that illustrate how modular__byte could be used
   in why. *)

(************)
(* byte_mod *)
(************)

(* Convert an int to a mod *)

(* Invalid *) (* Range check fails *)

let byte_mod1 =
 fun (x : int) ->
  { }
   modular__byte___of_integer_ (x)
  { integer_of___modular__byte (result) = x % 260 }

(* OK *)

let byte_mod2 =
 fun (x : int) ->
  { modular__byte___in_range (x) }
   modular__byte___of_integer_ (x)
  { integer_of___modular__byte (result) = x % 260 }

(*************)
(* succ_byte *)
(*************)

(* Given a modular__byte, returns its successor *)

(* OK *)

let succ___modular__byte =
 fun (x : modular__byte) ->
  { }
    modular__byte___of_integer (integer_of___modular__byte (x) + 1)
  { ((integer_of___modular__byte (x) = 255)
     and (integer_of___modular__byte (result) = 0))
    or ((integer_of___modular__byte (x) < 255)
        and (integer_of___modular__byte (result) =
             integer_of___modular__byte(x) + 1)) }

(**************)
(* unit tests *)
(**************)

(* Check succ_modular__byte for different values *)

(* OK *)

let succ___modular__byte0 =
 fun (x : modular__byte) ->
  { integer_of___modular__byte (x) = 0 }
   succ___modular__byte (x)
  { integer_of___modular__byte (result) = 1 }

(* OK *)

let succ___modular__byte5 =
 fun (x : modular__byte) ->
  { integer_of___modular__byte (x) = 5 }
   succ___modular__byte (x)
  { integer_of___modular__byte (result) = 6 }

(* OK *)

let succ___modular__byte254 =
 fun (x : modular__byte) ->
  { integer_of___modular__byte (x) = 254 }
   succ___modular__byte (x)
  { integer_of___modular__byte (result) = 255 }

(* OK *)

let succ___modular__byte255 =
 fun (x : modular__byte) ->
  { integer_of___modular__byte (x) = 255 }
   succ___modular__byte (x)
  { integer_of___modular__byte (result) = 0 }


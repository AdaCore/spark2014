
type enum__day =
  | enum__mon
  | enum__tue
  | enum__wed
  | enum__thu
  | enum__fri
  | enum__sat
  | enum__sun

logic integer_of___enum__day : enum__day -> int
(* YM: could be simply a "function", i.e. a defined logic function, defined
   with a match like axiom enum__day___ordering below, which would make 
   this axiom useless *)

predicate eq___enum__day (left : enum__day, right : enum__day) =
 integer_of___enum__day (left) = integer_of___enum__day (right)

predicate le___enum__day (left : enum__day, right : enum__day) =
 integer_of___enum__day (left) <= integer_of___enum__day (right)

(* YM: why have a special eq___enum__day and le___enum__day instead of 
   doing directly the operations on integers? *)

predicate enum__day___in_range (x : int) =
 let first = 0 in
 let last = 6 in
  first <= x <= last

logic enum__day___of_integer : int -> enum__day

axiom enum__day___coerce :
 (forall x : int.
   enum__day___in_range (x) ->
    integer_of___enum__day (enum__day___of_integer (x)) = x)

axiom enum__day___ordering :
 (forall x : enum__day.
   match x with
    | enum__mon -> integer_of___enum__day (x) = 0
    | enum__tue -> integer_of___enum__day (x) = 1
    | enum__wed -> integer_of___enum__day (x) = 2
    | enum__thu -> integer_of___enum__day (x) = 3
    | enum__fri -> integer_of___enum__day (x) = 4
    | enum__sat -> integer_of___enum__day (x) = 5
    | enum__sun -> integer_of___enum__day (x) = 6
   end)

parameter any___enum__day : unit -> { } enum__day { true }

parameter enum__day___of_integer_ :
 x : int ->
  { enum__day___in_range (x) }
   enum__day
  { integer_of___enum__day (result) = x }

parameter safe___enum__day___of_integer_ :
 x : int ->
  { }
   enum__day
  { integer_of___enum__day (result) = x }

parameter eq___enum__day_ :
 left : enum__day -> right : enum__day ->
{ }
 bool
{ result = true <-> eq___enum__day (left, right) }


type enum__some_a =
  | enum__QU41
  | enum__a

(* ... snip axioms, predicates, parameters: similar to enum__day... *)

type enum__name_clash =
  | enum__mon__2
  | enum__a__2

(* ... snip axioms, predicates, parameters, for the same reason... *)

type enum__weekday

logic enum__day___of___enum__weekday : enum__weekday -> enum__day

predicate eq___enum__weekday (left : enum__weekday, right : enum__weekday) =
 eq___enum__day (enum__day___of___enum__weekday (left),
                 enum__day___of___enum__weekday (right))

predicate le___enum__weekday (left : enum__weekday, right : enum__weekday) =
 le___enum__day (enum__day___of___enum__weekday (left),
                 enum__day___of___enum__weekday (right))

predicate enum__weekday___in_range (s : enum__day) =
 (le___enum__day (enum__mon, s) and le___enum__day (s, enum__fri))

logic enum__weekday___of___enum__day : enum__day -> enum__weekday

(* YM: beware of possible inconsistencies here in the model. 
       Why only deals with total logic functions, so that 
       enum__weekday___of___enum__day should be defined for any day, so
       refrain from using this function directly. It should only be used
       in axiom enum__weekday___coerce below.
 *)

axiom enum__weekday___coerce :
 (forall x : enum__day.
  (enum__weekday___in_range (x)) ->
   eq___enum__day (enum__day___of___enum__weekday
                   (enum__weekday___of___enum__day (x)), x))

axiom enum__weekday___range :
 (forall x : enum__weekday.
  enum__weekday___in_range (enum__day___of___enum__weekday (x)))

axiom enum__weekday___unicity :
 forall x, y : enum__weekday.
  enum__day___of___enum__weekday (x) = enum__day___of___enum__weekday (y)
   <-> x = y

(* ...snip parameters, similar to enum__day... *)

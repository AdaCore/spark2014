
This details how fixed points would be represented in Why.

For these types, the best representation would probably be an integer
representation; still, conversion functions to/from mathematical reals
could be provided. This is showed in fixed.why.

Note that the expander does most of the conversion real/fixed conversion
job for us; e.g.

  function My_Round (My_F : FP) return Money is
  begin
     return Money'Round (My_F);
  end My_Round;

Would be expanded as:

  fixed__TmoneyB?^(universal_real(my_f) * 100.0)

Note that the division by delta (i.e. "* 100.0") is already done at
this point; all we would need then is to have the appropriate real/int
conversion (away from zero). This is defined in real.why.

fixed.why does not show the case of decimal fixed point types; the
computation of the bounds is different, but the generated code ends up
being quite similar, so there is no substantial difference for gnat2why.



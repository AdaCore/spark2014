
type floats__fp

logic real_of___floats__fp : floats__fp -> real

predicate eq___floats__fp (x : floats__fp, y : floats__fp) =
 real_of___floats__fp (x) = real_of___floats__fp (y)

predicate floats__fp___in_range (x : real) =
 let first = -1.0 in
 let last = 1.0 in
  first <= x <= last

logic floats__fp___of_real : real -> floats__fp

axiom floats__fp___coerce :
 (forall x : real.
  floats__fp___in_range (x) ->
   real_of___floats__fp (floats__fp___of_real (x)) = x)

axiom floats__fp___range :
 (forall x : floats__fp.
  floats__fp___in_range (real_of___floats__fp (x)))

axiom floats__fp___unicity :
 forall x, y : floats__fp.
  real_of___floats__fp (x) = real_of___floats__fp (y) -> x = y

parameter any___floats__fp : unit -> { } floats__fp { true }

parameter floats__fp___of_real_ :
 x : real ->
  { floats__fp___in_range (x) }
   floats__fp
  { real_of___floats__fp (result) = x }

parameter safe___floats__fp___of_real_ :
 x : real ->
  { }
   floats__fp
  { real_of___floats__fp (result) = x }

parameter eq___floats__fp_ :
 left : floats__fp -> right : floats__fp ->
{ }
 bool
{ result = true <-> eq___floats__fp (left, right) }

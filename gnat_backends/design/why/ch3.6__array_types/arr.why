include "arrays.why"
include "standard.why"

(*************)
(* Arr.Index *)
(*************)

(* How such a scalar type is encoded in detailed in chapter 3.5.4. Here
   we just gives the necessary axioms for Arr.Index in order to use this
   abstract in the definition of the array type (Arr.Table) afterwards. *)

type arr__index

logic integer_of___arr__index : arr__index -> int

logic eq___arr__index : arr__index, arr__index -> bool

axiom eq___arr__index___def :
 forall x, y : arr__index.
  eq___arr__index (x, y) = true <->
   integer_of___arr__index (x) = integer_of___arr__index (y)

logic arr__index___in_range : int -> bool

axiom arr__index___in_range___def :
 let first = 1 in
 let last = 10 in
  forall x : int.
   arr__index___in_range (x) = true <-> first <= x <= last

logic arr__index___of_integer : int -> arr__index

axiom arr__index___coerce :
 forall x : int.
  arr__index___in_range (x) = true ->
   integer_of___arr__index (arr__index___of_integer (x)) = x

axiom arr__index___range :
 forall x : arr__index.
  arr__index___in_range (integer_of___arr__index (x)) = true

parameter arr__index___of_integer_ :
 x : int ->
  { arr__index___in_range (x) = true }
   arr__index
  { integer_of___arr__index (result) = x }


(*************)
(* Arr.Table *)
(*************)

type arr__table

logic array_of___arr__table : arr__table -> standard__integer farray

logic arr__table___of_array : standard__integer farray -> arr__table

logic arr__table___in_range : standard__integer farray -> bool

axiom arr__table___in_range___def :
 forall x : standard__integer farray.
  arr__table___in_range (x) = true <-> array_length (x) = 10

logic eq___arr__table : arr__table, arr__table -> bool

axiom eq___arr__table___def :
 forall x, y : arr__table.
  eq___arr__table (x, y) = true <->
   array_of___arr__table (x) = array_of___arr__table (y)

axiom arr__table___coerce :
 forall x : standard__integer farray.
  arr__table___in_range (x) = true ->
   array_of___arr__table (arr__table___of_array (x)) = x

axiom arr__table___range :
 forall x : arr__table.
  arr__table___in_range (array_of___arr__table (x)) = true

logic arr__table___first : arr__table -> arr__index

logic arr__table___last : arr__table -> arr__index

logic arr__table___range_eq : arr__table, arr__table -> bool

axiom arr__table___range_eq :
 forall x, y : arr__table.
  arr__table___range_eq (x, y) = true <->
  (integer_of___arr__index (arr__table___first (x))
    = integer_of___arr__index (arr__table___first (y)))
  and (integer_of___arr__index (arr__table___last (x))
       = integer_of___arr__index (arr__table___last (y)))

logic eq___arr__table___strict : arr__table, arr__table -> bool

axiom eq___arr__table___strict___def :
 forall x, y : arr__table.
  eq___arr__table___strict (x, y) = true <->
   (array_of___arr__table (x) = array_of___arr__table (y)
    and arr__table___range_eq (x, y) = true)

logic arr__table___index_check : arr__table, arr__index -> bool

axiom arr__table___index_check___def :
 forall a : arr__table.
 forall i : arr__index.
  arr__table___index_check (a, i) = true <->
   (integer_of___arr__index (arr__table___first (a))
     <= integer_of___arr__index (i) <=
    integer_of___arr__index (arr__table___last (a)))

axiom arr__table___first_value :
 forall x : arr__table.
  arr__table___first (x) = arr__index___of_integer (1)

axiom arr__table___last_value :
 forall x : arr__table.
  arr__table___last (x) = arr__index___of_integer (10)

logic arr__table___get :
 arr__table, arr__index -> standard__integer

logic arr__table___set :
 arr__table, arr__index, standard__integer -> arr__table

axiom arr__table___get_definition :
 forall x : arr__table.
  forall y : arr__index.
   arr__table___get (x, y) = access (array_of___arr__table (x),
                                     integer_of___arr__index (y))

axiom arr__table___set_definition :
 forall x : arr__table.
 forall y : arr__index.
 forall z : standard__integer.
  let result = arr__table___set (x, y, z) in
   array_of___arr__table (result) = update (array_of___arr__table (x),
                                            integer_of___arr__index (y),
                                            z)
   and x = result

parameter arr__table___get_ :
 a : arr__table -> i : arr__index ->
  { arr__table___index_check (a, i) = true }
   standard__integer
  { result = arr__table___get (a, i) }

parameter arr__table___set_ : 
 a : arr__table ref -> i : arr__index -> v : standard__integer -> 
  { arr__table___index_check (a, i) = true }
   unit writes a
  { a = arr__table___set (a@, i, v) }

parameter arr__table___first_ :
 a : arr__table ->
  { }
   arr__index
  { result = arr__table___first (a) }

parameter arr__table___last_ :
 a : arr__table ->
  { }
   arr__index
  { result = arr__table___last (a) }

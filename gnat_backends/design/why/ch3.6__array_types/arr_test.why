

include "arrays.why"
include "arr.why"

let check_index
(table : arr__table)
(value : standard__integer)
(index : arr__index) =
 { }
  (integer_of___standard__integer (arr__table___get_ table index)
   = integer_of___standard__integer (value))
 { result = true <-> value = arr__table___get (table, index) }

exception Return

let linear_search
(table : arr__table)
(value : standard__integer)
(found : bool ref)
(index : standard__integer ref) =
 { }
 try
  begin
   found := false;
   index := standard__integer___of_integer_
             (integer_of___arr__index
              (arr__table___first_ (table)) - 1);
   let i = ref integer_of___arr__index (arr__table___first_ (table)) in
    while !i <= integer_of___arr__index (arr__table___last_ (table)) do
     { invariant ((integer_of___arr__index (arr__table___first (table))
                   <= i <=
                   (integer_of___arr__index (arr__table___last (table)) + 1))
                  and (found = false))
       variant integer_of___arr__index (arr__table___last (table)) + 1 - i }
     begin
      if (integer_of___standard__integer
           (arr__table___get_ table (arr__index___of_integer_ (!i)))
            = integer_of___standard__integer (value))
      then begin
       found := true;
       index := standard__integer___of_integer (!i);
       raise Return
      end;
      i := !i + 1
     end
    done;
    assert { found = false
             and i = integer_of___arr__index (arr__table___last (table)) + 1 };
    1
   end
  with Return ->
   assert {
    found = true
     and value = access (array_of___arr__table (table),
                         integer_of___standard__integer (index))
    };
   2
  end
 { found = true -> value = access (array_of___arr__table (table),
                                   integer_of___standard__integer (index)) }

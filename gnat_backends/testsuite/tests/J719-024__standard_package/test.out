type standard__boolean

type standard__integer

parameter any___standard__integer :
 unit ->
  standard__integer
 { true }

predicate standard__integer___in_range (x : int) =
 let first = -2147483648 in
 let last = 2147483647 in
  first <= x <= last

logic integer_of___standard__integer :
 standard__integer -> int

logic standard__integer___of_integer :
 int -> standard__integer

parameter standard__integer___of_integer_ :
 n : int ->
 { standard__integer___in_range (n) }
  standard__integer
 { integer_of___standard__integer (result) = n }

parameter safe___standard__integer___of_integer_ :
 n : int ->
  standard__integer
 { integer_of___standard__integer (result) = n }

predicate eq___standard__integer (x : standard__integer, y : standard__integer) =
 integer_of___standard__integer (x) = integer_of___standard__integer (y)

axiom standard__integer___range :
 forall x : standard__integer.
  standard__integer___in_range (integer_of___standard__integer (x))

axiom standard__integer___coerce :
 forall x : int.
  standard__integer___in_range (x) -> integer_of___standard__integer (standard__integer___of_integer (x)) = x

axiom standard__integer___unicity :
 forall x, y : standard__integer.
  integer_of___standard__integer (x) = integer_of___standard__integer (y) -> x = y

type standard__natural

parameter any___standard__natural :
 unit ->
  standard__natural
 { true }

predicate standard__natural___in_range (x : int) =
 let first = 0 in
 let last = 2147483647 in
  first <= x <= last

logic integer_of___standard__natural :
 standard__natural -> int

logic standard__natural___of_integer :
 int -> standard__natural

parameter standard__natural___of_integer_ :
 n : int ->
 { standard__natural___in_range (n) }
  standard__natural
 { integer_of___standard__natural (result) = n }

parameter safe___standard__natural___of_integer_ :
 n : int ->
  standard__natural
 { integer_of___standard__natural (result) = n }

predicate eq___standard__natural (x : standard__natural, y : standard__natural) =
 integer_of___standard__natural (x) = integer_of___standard__natural (y)

axiom standard__natural___range :
 forall x : standard__natural.
  standard__natural___in_range (integer_of___standard__natural (x))

axiom standard__natural___coerce :
 forall x : int.
  standard__natural___in_range (x) -> integer_of___standard__natural (standard__natural___of_integer (x)) = x

axiom standard__natural___unicity :
 forall x, y : standard__natural.
  integer_of___standard__natural (x) = integer_of___standard__natural (y) -> x = y

type standard__positive

parameter any___standard__positive :
 unit ->
  standard__positive
 { true }

predicate standard__positive___in_range (x : int) =
 let first = 1 in
 let last = 2147483647 in
  first <= x <= last

logic integer_of___standard__positive :
 standard__positive -> int

logic standard__positive___of_integer :
 int -> standard__positive

parameter standard__positive___of_integer_ :
 n : int ->
 { standard__positive___in_range (n) }
  standard__positive
 { integer_of___standard__positive (result) = n }

parameter safe___standard__positive___of_integer_ :
 n : int ->
  standard__positive
 { integer_of___standard__positive (result) = n }

predicate eq___standard__positive (x : standard__positive, y : standard__positive) =
 integer_of___standard__positive (x) = integer_of___standard__positive (y)

axiom standard__positive___range :
 forall x : standard__positive.
  standard__positive___in_range (integer_of___standard__positive (x))

axiom standard__positive___coerce :
 forall x : int.
  standard__positive___in_range (x) -> integer_of___standard__positive (standard__positive___of_integer (x)) = x

axiom standard__positive___unicity :
 forall x, y : standard__positive.
  integer_of___standard__positive (x) = integer_of___standard__positive (y) -> x = y

type standard__short_short_integer

parameter any___standard__short_short_integer :
 unit ->
  standard__short_short_integer
 { true }

predicate standard__short_short_integer___in_range (x : int) =
 let first = -128 in
 let last = 127 in
  first <= x <= last

logic integer_of___standard__short_short_integer :
 standard__short_short_integer -> int

logic standard__short_short_integer___of_integer :
 int -> standard__short_short_integer

parameter standard__short_short_integer___of_integer_ :
 n : int ->
 { standard__short_short_integer___in_range (n) }
  standard__short_short_integer
 { integer_of___standard__short_short_integer (result) = n }

parameter safe___standard__short_short_integer___of_integer_ :
 n : int ->
  standard__short_short_integer
 { integer_of___standard__short_short_integer (result) = n }

predicate eq___standard__short_short_integer (x : standard__short_short_integer, y : standard__short_short_integer) =
 integer_of___standard__short_short_integer (x) = integer_of___standard__short_short_integer (y)

axiom standard__short_short_integer___range :
 forall x : standard__short_short_integer.
  standard__short_short_integer___in_range (integer_of___standard__short_short_integer (x))

axiom standard__short_short_integer___coerce :
 forall x : int.
  standard__short_short_integer___in_range (x) -> integer_of___standard__short_short_integer (standard__short_short_integer___of_integer (x)) = x

axiom standard__short_short_integer___unicity :
 forall x, y : standard__short_short_integer.
  integer_of___standard__short_short_integer (x) = integer_of___standard__short_short_integer (y) -> x = y

type standard__short_integer

parameter any___standard__short_integer :
 unit ->
  standard__short_integer
 { true }

predicate standard__short_integer___in_range (x : int) =
 let first = -32768 in
 let last = 32767 in
  first <= x <= last

logic integer_of___standard__short_integer :
 standard__short_integer -> int

logic standard__short_integer___of_integer :
 int -> standard__short_integer

parameter standard__short_integer___of_integer_ :
 n : int ->
 { standard__short_integer___in_range (n) }
  standard__short_integer
 { integer_of___standard__short_integer (result) = n }

parameter safe___standard__short_integer___of_integer_ :
 n : int ->
  standard__short_integer
 { integer_of___standard__short_integer (result) = n }

predicate eq___standard__short_integer (x : standard__short_integer, y : standard__short_integer) =
 integer_of___standard__short_integer (x) = integer_of___standard__short_integer (y)

axiom standard__short_integer___range :
 forall x : standard__short_integer.
  standard__short_integer___in_range (integer_of___standard__short_integer (x))

axiom standard__short_integer___coerce :
 forall x : int.
  standard__short_integer___in_range (x) -> integer_of___standard__short_integer (standard__short_integer___of_integer (x)) = x

axiom standard__short_integer___unicity :
 forall x, y : standard__short_integer.
  integer_of___standard__short_integer (x) = integer_of___standard__short_integer (y) -> x = y

type standard__long_integer

parameter any___standard__long_integer :
 unit ->
  standard__long_integer
 { true }

predicate standard__long_integer___in_range (x : int) =
 let first = -9223372036854775808 in
 let last = 9223372036854775807 in
  first <= x <= last

logic integer_of___standard__long_integer :
 standard__long_integer -> int

logic standard__long_integer___of_integer :
 int -> standard__long_integer

parameter standard__long_integer___of_integer_ :
 n : int ->
 { standard__long_integer___in_range (n) }
  standard__long_integer
 { integer_of___standard__long_integer (result) = n }

parameter safe___standard__long_integer___of_integer_ :
 n : int ->
  standard__long_integer
 { integer_of___standard__long_integer (result) = n }

predicate eq___standard__long_integer (x : standard__long_integer, y : standard__long_integer) =
 integer_of___standard__long_integer (x) = integer_of___standard__long_integer (y)

axiom standard__long_integer___range :
 forall x : standard__long_integer.
  standard__long_integer___in_range (integer_of___standard__long_integer (x))

axiom standard__long_integer___coerce :
 forall x : int.
  standard__long_integer___in_range (x) -> integer_of___standard__long_integer (standard__long_integer___of_integer (x)) = x

axiom standard__long_integer___unicity :
 forall x, y : standard__long_integer.
  integer_of___standard__long_integer (x) = integer_of___standard__long_integer (y) -> x = y

type standard__long_long_integer

parameter any___standard__long_long_integer :
 unit ->
  standard__long_long_integer
 { true }

predicate standard__long_long_integer___in_range (x : int) =
 let first = -9223372036854775808 in
 let last = 9223372036854775807 in
  first <= x <= last

logic integer_of___standard__long_long_integer :
 standard__long_long_integer -> int

logic standard__long_long_integer___of_integer :
 int -> standard__long_long_integer

parameter standard__long_long_integer___of_integer_ :
 n : int ->
 { standard__long_long_integer___in_range (n) }
  standard__long_long_integer
 { integer_of___standard__long_long_integer (result) = n }

parameter safe___standard__long_long_integer___of_integer_ :
 n : int ->
  standard__long_long_integer
 { integer_of___standard__long_long_integer (result) = n }

predicate eq___standard__long_long_integer (x : standard__long_long_integer, y : standard__long_long_integer) =
 integer_of___standard__long_long_integer (x) = integer_of___standard__long_long_integer (y)

axiom standard__long_long_integer___range :
 forall x : standard__long_long_integer.
  standard__long_long_integer___in_range (integer_of___standard__long_long_integer (x))

axiom standard__long_long_integer___coerce :
 forall x : int.
  standard__long_long_integer___in_range (x) -> integer_of___standard__long_long_integer (standard__long_long_integer___of_integer (x)) = x

axiom standard__long_long_integer___unicity :
 forall x, y : standard__long_long_integer.
  integer_of___standard__long_long_integer (x) = integer_of___standard__long_long_integer (y) -> x = y


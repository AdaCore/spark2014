type short_short_integer

parameter any___short_short_integer :
 unit ->
  { } short_short_integer
 { true }

predicate short_short_integer___in_range (x : int) =
 let first = -128 in
 let last = 127 in
  first <= x <= last

logic integer_of___short_short_integer :
 short_short_integer -> int

logic short_short_integer___of_integer :
 int -> short_short_integer

parameter short_short_integer___of_integer_ :
 n : int ->
 { short_short_integer___in_range (n) }
  short_short_integer
 { integer_of___short_short_integer (result) = n }

parameter safe___short_short_integer___of_integer_ :
 n : int ->
  { } short_short_integer
 { integer_of___short_short_integer (result) = n }

predicate eq___short_short_integer (x : short_short_integer, y : short_short_integer) =
 integer_of___short_short_integer (x) = integer_of___short_short_integer (y)

axiom short_short_integer___range :
 forall x : short_short_integer.
  short_short_integer___in_range (integer_of___short_short_integer (x))

axiom short_short_integer___coerce :
 forall x : int.
  short_short_integer___in_range (x) -> integer_of___short_short_integer (short_short_integer___of_integer (x)) = x

axiom short_short_integer___unicity :
 forall x, y : short_short_integer.
  integer_of___short_short_integer (x) = integer_of___short_short_integer (y) -> x = y

parameter eq_bool___short_short_integer :
 m : short_short_integer -> n : short_short_integer ->
  { } bool
 { if result then
  n = m else
  n <> m }

type short_integer

parameter any___short_integer :
 unit ->
  { } short_integer
 { true }

predicate short_integer___in_range (x : int) =
 let first = -32768 in
 let last = 32767 in
  first <= x <= last

logic integer_of___short_integer :
 short_integer -> int

logic short_integer___of_integer :
 int -> short_integer

parameter short_integer___of_integer_ :
 n : int ->
 { short_integer___in_range (n) }
  short_integer
 { integer_of___short_integer (result) = n }

parameter safe___short_integer___of_integer_ :
 n : int ->
  { } short_integer
 { integer_of___short_integer (result) = n }

predicate eq___short_integer (x : short_integer, y : short_integer) =
 integer_of___short_integer (x) = integer_of___short_integer (y)

axiom short_integer___range :
 forall x : short_integer.
  short_integer___in_range (integer_of___short_integer (x))

axiom short_integer___coerce :
 forall x : int.
  short_integer___in_range (x) -> integer_of___short_integer (short_integer___of_integer (x)) = x

axiom short_integer___unicity :
 forall x, y : short_integer.
  integer_of___short_integer (x) = integer_of___short_integer (y) -> x = y

parameter eq_bool___short_integer :
 m : short_integer -> n : short_integer ->
  { } bool
 { if result then
  n = m else
  n <> m }

type integer

parameter any___integer :
 unit ->
  { } integer
 { true }

predicate integer___in_range (x : int) =
 let first = -2147483648 in
 let last = 2147483647 in
  first <= x <= last

logic integer_of___integer :
 integer -> int

logic integer___of_integer :
 int -> integer

parameter integer___of_integer_ :
 n : int ->
 { integer___in_range (n) }
  integer
 { integer_of___integer (result) = n }

parameter safe___integer___of_integer_ :
 n : int ->
  { } integer
 { integer_of___integer (result) = n }

predicate eq___integer (x : integer, y : integer) =
 integer_of___integer (x) = integer_of___integer (y)

axiom integer___range :
 forall x : integer.
  integer___in_range (integer_of___integer (x))

axiom integer___coerce :
 forall x : int.
  integer___in_range (x) -> integer_of___integer (integer___of_integer (x)) = x

axiom integer___unicity :
 forall x, y : integer.
  integer_of___integer (x) = integer_of___integer (y) -> x = y

parameter eq_bool___integer :
 m : integer -> n : integer ->
  { } bool
 { if result then
  n = m else
  n <> m }

type long_integer

parameter any___long_integer :
 unit ->
  { } long_integer
 { true }

predicate long_integer___in_range (x : int) =
 let first = -9223372036854775808 in
 let last = 9223372036854775807 in
  first <= x <= last

logic integer_of___long_integer :
 long_integer -> int

logic long_integer___of_integer :
 int -> long_integer

parameter long_integer___of_integer_ :
 n : int ->
 { long_integer___in_range (n) }
  long_integer
 { integer_of___long_integer (result) = n }

parameter safe___long_integer___of_integer_ :
 n : int ->
  { } long_integer
 { integer_of___long_integer (result) = n }

predicate eq___long_integer (x : long_integer, y : long_integer) =
 integer_of___long_integer (x) = integer_of___long_integer (y)

axiom long_integer___range :
 forall x : long_integer.
  long_integer___in_range (integer_of___long_integer (x))

axiom long_integer___coerce :
 forall x : int.
  long_integer___in_range (x) -> integer_of___long_integer (long_integer___of_integer (x)) = x

axiom long_integer___unicity :
 forall x, y : long_integer.
  integer_of___long_integer (x) = integer_of___long_integer (y) -> x = y

parameter eq_bool___long_integer :
 m : long_integer -> n : long_integer ->
  { } bool
 { if result then
  n = m else
  n <> m }

type long_long_integer

parameter any___long_long_integer :
 unit ->
  { } long_long_integer
 { true }

predicate long_long_integer___in_range (x : int) =
 let first = -9223372036854775808 in
 let last = 9223372036854775807 in
  first <= x <= last

logic integer_of___long_long_integer :
 long_long_integer -> int

logic long_long_integer___of_integer :
 int -> long_long_integer

parameter long_long_integer___of_integer_ :
 n : int ->
 { long_long_integer___in_range (n) }
  long_long_integer
 { integer_of___long_long_integer (result) = n }

parameter safe___long_long_integer___of_integer_ :
 n : int ->
  { } long_long_integer
 { integer_of___long_long_integer (result) = n }

predicate eq___long_long_integer (x : long_long_integer, y : long_long_integer) =
 integer_of___long_long_integer (x) = integer_of___long_long_integer (y)

axiom long_long_integer___range :
 forall x : long_long_integer.
  long_long_integer___in_range (integer_of___long_long_integer (x))

axiom long_long_integer___coerce :
 forall x : int.
  long_long_integer___in_range (x) -> integer_of___long_long_integer (long_long_integer___of_integer (x)) = x

axiom long_long_integer___unicity :
 forall x, y : long_long_integer.
  integer_of___long_long_integer (x) = integer_of___long_long_integer (y) -> x = y

parameter eq_bool___long_long_integer :
 m : long_long_integer -> n : long_long_integer ->
  { } bool
 { if result then
  n = m else
  n <> m }

type character

logic character___of_integer :
 int -> character

predicate character___in_range (x : int) =
 let first = 1 in
 let last = 0 in
  first <= x <= last

type wide_character

logic wide_character___of_integer :
 int -> wide_character

predicate wide_character___in_range (x : int) =
 let first = 1 in
 let last = 0 in
  first <= x <= last

type wide_wide_character

logic wide_wide_character___of_integer :
 int -> wide_wide_character

predicate wide_wide_character___in_range (x : int) =
 let first = 1 in
 let last = 0 in
  first <= x <= last

type enum__day = 
 | enum__mon
 | enum__tue
 | enum__wed
 | enum__thu
 | enum__fri
 | enum__sat
 | enum__sun


logic enum__day___of_integer :
 int -> enum__day

predicate enum__day___in_range (x : int) =
 let first = 1 in
 let last = 7 in
  first <= x <= last

function integer_of___enum__day (x : enum__day) : int =
 match x with 
  | enum__mon -> 
   1
  | enum__tue -> 
   2
  | enum__wed -> 
   3
  | enum__thu -> 
   4
  | enum__fri -> 
   5
  | enum__sat -> 
   6
  | enum__sun -> 
   7
 end


axiom enum__day___coerce :
 forall x : int.
  enum__day___in_range (x) -> integer_of___enum__day (enum__day___of_integer (x)) = x

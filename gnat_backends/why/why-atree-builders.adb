------------------------------------------------------------------------------
--                                                                          --
--                            GNAT2WHY COMPONENTS                           --
--                                                                          --
--                   W H Y - A T R E E - B U I L D E R S                    --
--                                                                          --
--                                 B o d y                                  --
--                                                                          --
--                       Copyright (C) 2010-2011, AdaCore                   --
--                                                                          --
-- gnat2why is  free  software;  you can redistribute it and/or modify it   --
-- under terms of the  GNU General Public License as published  by the Free --
-- Software Foundation;  either version  2,  or  (at your option) any later --
-- version. gnat2why is distributed in the hope that it will  be  useful,   --
-- but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHAN-  --
-- TABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public --
-- License  for more details. You  should  have  received a copy of the GNU --
-- General Public License  distributed with GNAT; see file COPYING. If not, --
-- write to the Free Software Foundation,  51 Franklin Street, Fifth Floor, --
-- Boston,                                                                  --
--                                                                          --
-- gnat2why is maintained by AdaCore (http://www.adacore.com)               --
--                                                                          --
------------------------------------------------------------------------------
--  This package is automatically generated by xtree. Do not edit manually.

with Why.Atree.Tables;    use Why.Atree.Tables;
with Why.Atree.Accessors; use Why.Atree.Accessors;
with Why.Kind_Validity;   use Why.Kind_Validity;
with Why.Atree.Validity;  use Why.Atree.Validity;

package body Why.Atree.Builders is

   --------------------
   -- New_Identifier --
   --------------------

   function New_Identifier
     (Ada_Node : Node_Id := Empty;
      Symbol   : Name_Id;
      Entity   : Why_Node_Id := Why_Empty)
     return W_Identifier_Valid_Id
   is
      Result : Why_Node (W_Identifier);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Identifier);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Symbol :=
        Symbol;
      Result.Entity :=
        Entity;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Identifier;

   -------------------
   -- New_Type_Prop --
   -------------------

   function New_Type_Prop
     (Ada_Node : Node_Id := Empty)
     return W_Type_Prop_Valid_Id
   is
      Result : Why_Node (W_Type_Prop);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Type_Prop);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Type_Prop;

   ------------------
   -- New_Type_Int --
   ------------------

   function New_Type_Int
     (Ada_Node : Node_Id := Empty)
     return W_Type_Int_Valid_Id
   is
      Result : Why_Node (W_Type_Int);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Type_Int);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Type_Int;

   -------------------
   -- New_Type_Bool --
   -------------------

   function New_Type_Bool
     (Ada_Node : Node_Id := Empty)
     return W_Type_Bool_Valid_Id
   is
      Result : Why_Node (W_Type_Bool);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Type_Bool);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Type_Bool;

   -------------------
   -- New_Type_Real --
   -------------------

   function New_Type_Real
     (Ada_Node : Node_Id := Empty)
     return W_Type_Real_Valid_Id
   is
      Result : Why_Node (W_Type_Real);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Type_Real);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Type_Real;

   -------------------
   -- New_Type_Unit --
   -------------------

   function New_Type_Unit
     (Ada_Node : Node_Id := Empty)
     return W_Type_Unit_Valid_Id
   is
      Result : Why_Node (W_Type_Unit);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Type_Unit);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Type_Unit;

   -----------------------
   -- New_Abstract_Type --
   -----------------------

   function New_Abstract_Type
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Valid_Id)
     return W_Abstract_Type_Valid_Id
   is
      Result : Why_Node (W_Abstract_Type);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Abstract_Type);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.AT_Name :=
        Name;
      Set_Link (Result.AT_Name, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Abstract_Type;

   -----------------------------
   -- New_Generic_Formal_Type --
   -----------------------------

   function New_Generic_Formal_Type
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Valid_Id)
     return W_Generic_Formal_Type_Valid_Id
   is
      Result : Why_Node (W_Generic_Formal_Type);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Generic_Formal_Type);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.GFT_Name :=
        Name;
      Set_Link (Result.GFT_Name, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Generic_Formal_Type;

   -----------------------------------
   -- New_Generic_Actual_Type_Chain --
   -----------------------------------

   function New_Generic_Actual_Type_Chain
     (Ada_Node   : Node_Id := Empty;
      Type_Chain : W_Primitive_Type_V_Array;
      Name       : W_Identifier_Valid_Id)
     return W_Generic_Actual_Type_Chain_Valid_Id
   is
      Result : Why_Node (W_Generic_Actual_Type_Chain);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Generic_Actual_Type_Chain);
   begin
      Result.Ada_Node :=
        Ada_Node;
      pragma Assert (Type_Chain'Length > 0);
      Result.GATC_Type_Chain := New_List;
      for J in Type_Chain'Range loop
         pragma Assert
           (Primitive_Type_Id_Kind_Valid
            (Type_Chain (J)));
         pragma Assert
           (Primitive_Type_Id_Valid
            (Type_Chain (J)));
         Append
           (Result.GATC_Type_Chain,
            Type_Chain (J));
      end loop;
      Set_Link (Result.GATC_Type_Chain, New_Id);
      Result.GATC_Name :=
        Name;
      Set_Link (Result.GATC_Name, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Generic_Actual_Type_Chain;

   --------------------
   -- New_Array_Type --
   --------------------

   function New_Array_Type
     (Ada_Node       : Node_Id := Empty;
      Component_Type : W_Primitive_Type_Valid_Id)
     return W_Array_Type_Valid_Id
   is
      Result : Why_Node (W_Array_Type);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Array_Type);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.AT_Component_Type :=
        Component_Type;
      Set_Link (Result.AT_Component_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Array_Type;

   ------------------
   -- New_Ref_Type --
   ------------------

   function New_Ref_Type
     (Ada_Node     : Node_Id := Empty;
      Aliased_Type : W_Primitive_Type_Valid_Id)
     return W_Ref_Type_Valid_Id
   is
      Result : Why_Node (W_Ref_Type);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Ref_Type);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.RT_Aliased_Type :=
        Aliased_Type;
      Set_Link (Result.RT_Aliased_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Ref_Type;

   --------------------------
   -- New_Computation_Type --
   --------------------------

   function New_Computation_Type
     (Ada_Node      : Node_Id := Empty;
      Binders       : W_Binder_V_Array := (2 .. 1 => <>);
      Precondition  : W_Precondition_Valid_OId := Why_Empty;
      Result_Name   : W_Identifier_Valid_OId := Why_Empty;
      Return_Type   : W_Primitive_Type_Valid_Id;
      Effects       : W_Effects_Valid_Id;
      Postcondition : W_Postcondition_Valid_OId := Why_Empty)
     return W_Computation_Type_Valid_Id
   is
      Result : Why_Node (W_Computation_Type);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Computation_Type);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.CS_Binders := New_List;
      for J in Binders'Range loop
         pragma Assert
           (Binder_Id_Kind_Valid
            (Binders (J)));
         pragma Assert
           (Binder_Id_Valid
            (Binders (J)));
         Append
           (Result.CS_Binders,
            Binders (J));
      end loop;
      Set_Link (Result.CS_Binders, New_Id);
      Result.CS_Precondition :=
        Precondition;
      Set_Link (Result.CS_Precondition, New_Id);
      Result.CS_Result_Name :=
        Result_Name;
      Set_Link (Result.CS_Result_Name, New_Id);
      Result.CS_Return_Type :=
        Return_Type;
      Set_Link (Result.CS_Return_Type, New_Id);
      Result.CS_Effects :=
        Effects;
      Set_Link (Result.CS_Effects, New_Id);
      Result.CS_Postcondition :=
        Postcondition;
      Set_Link (Result.CS_Postcondition, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Computation_Type;

   --------------------------
   -- New_Integer_Constant --
   --------------------------

   function New_Integer_Constant
     (Ada_Node : Node_Id := Empty;
      Value    : Uint)
     return W_Integer_Constant_Valid_Id
   is
      Result : Why_Node (W_Integer_Constant);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Integer_Constant);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.IC_Value :=
        Value;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Integer_Constant;

   -----------------------
   -- New_Real_Constant --
   -----------------------

   function New_Real_Constant
     (Ada_Node : Node_Id := Empty;
      Value    : Ureal)
     return W_Real_Constant_Valid_Id
   is
      Result : Why_Node (W_Real_Constant);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Real_Constant);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.RC_Value :=
        Value;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Real_Constant;

   ----------------------
   -- New_True_Literal --
   ----------------------

   function New_True_Literal
     (Ada_Node : Node_Id := Empty)
     return W_True_Literal_Valid_Id
   is
      Result : Why_Node (W_True_Literal);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_True_Literal);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_True_Literal;

   -----------------------
   -- New_False_Literal --
   -----------------------

   function New_False_Literal
     (Ada_Node : Node_Id := Empty)
     return W_False_Literal_Valid_Id
   is
      Result : Why_Node (W_False_Literal);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_False_Literal);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_False_Literal;

   ----------------------
   -- New_Void_Literal --
   ----------------------

   function New_Void_Literal
     (Ada_Node : Node_Id := Empty)
     return W_Void_Literal_Valid_Id
   is
      Result : Why_Node (W_Void_Literal);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Void_Literal);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Void_Literal;

   -------------------------
   -- New_Arith_Operation --
   -------------------------

   function New_Arith_Operation
     (Ada_Node : Node_Id := Empty;
      Left     : W_Term_Valid_Id;
      Op       : W_Arith_Op_Valid_Id;
      Right    : W_Term_Valid_Id)
     return W_Arith_Operation_Valid_Id
   is
      Result : Why_Node (W_Arith_Operation);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Arith_Operation);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.AO_Left :=
        Left;
      Set_Link (Result.AO_Left, New_Id);
      Result.AO_Op :=
        Op;
      Set_Link (Result.AO_Op, New_Id);
      Result.AO_Right :=
        Right;
      Set_Link (Result.AO_Right, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Arith_Operation;

   -----------------------
   -- New_Negative_Term --
   -----------------------

   function New_Negative_Term
     (Ada_Node : Node_Id := Empty;
      Operand  : W_Term_Valid_Id)
     return W_Negative_Term_Valid_Id
   is
      Result : Why_Node (W_Negative_Term);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Negative_Term);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.NT_Operand :=
        Operand;
      Set_Link (Result.NT_Operand, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Negative_Term;

   -------------------------
   -- New_Term_Identifier --
   -------------------------

   function New_Term_Identifier
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Valid_Id;
      Label    : W_Identifier_Valid_OId := Why_Empty)
     return W_Term_Identifier_Valid_Id
   is
      Result : Why_Node (W_Term_Identifier);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Term_Identifier);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.TIL_Name :=
        Name;
      Set_Link (Result.TIL_Name, New_Id);
      Result.TIL_Label :=
        Label;
      Set_Link (Result.TIL_Label, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Term_Identifier;

   -------------------
   -- New_Operation --
   -------------------

   function New_Operation
     (Ada_Node   : Node_Id := Empty;
      Name       : W_Identifier_Valid_Id;
      Parameters : W_Term_V_Array)
     return W_Operation_Valid_Id
   is
      Result : Why_Node (W_Operation);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Operation);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.O_Name :=
        Name;
      Set_Link (Result.O_Name, New_Id);
      pragma Assert (Parameters'Length > 0);
      Result.O_Parameters := New_List;
      for J in Parameters'Range loop
         pragma Assert
           (Term_Id_Kind_Valid
            (Parameters (J)));
         pragma Assert
           (Term_Id_Valid
            (Parameters (J)));
         Append
           (Result.O_Parameters,
            Parameters (J));
      end loop;
      Set_Link (Result.O_Parameters, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Operation;

   --------------------
   -- New_Named_Term --
   --------------------

   function New_Named_Term
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Valid_Id;
      Term     : W_Term_Valid_Id)
     return W_Named_Term_Valid_Id
   is
      Result : Why_Node (W_Named_Term);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Named_Term);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.NT_Name :=
        Name;
      Set_Link (Result.NT_Name, New_Id);
      Result.NT_Term :=
        Term;
      Set_Link (Result.NT_Term, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Named_Term;

   --------------------------
   -- New_Conditional_Term --
   --------------------------

   function New_Conditional_Term
     (Ada_Node  : Node_Id := Empty;
      Condition : W_Term_Valid_Id;
      Then_Part : W_Term_Valid_Id;
      Else_Part : W_Term_Valid_Id)
     return W_Conditional_Term_Valid_Id
   is
      Result : Why_Node (W_Conditional_Term);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Conditional_Term);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.CT_Condition :=
        Condition;
      Set_Link (Result.CT_Condition, New_Id);
      Result.CT_Then_Part :=
        Then_Part;
      Set_Link (Result.CT_Then_Part, New_Id);
      Result.CT_Else_Part :=
        Else_Part;
      Set_Link (Result.CT_Else_Part, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Conditional_Term;

   -----------------------
   -- New_Matching_Term --
   -----------------------

   function New_Matching_Term
     (Ada_Node : Node_Id := Empty;
      Term     : W_Term_Valid_Id;
      Branches : W_Match_Case_V_Array)
     return W_Matching_Term_Valid_Id
   is
      Result : Why_Node (W_Matching_Term);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Matching_Term);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.MT_Term :=
        Term;
      Set_Link (Result.MT_Term, New_Id);
      pragma Assert (Branches'Length > 0);
      Result.MT_Branches := New_List;
      for J in Branches'Range loop
         pragma Assert
           (Match_Case_Id_Kind_Valid
            (Branches (J)));
         pragma Assert
           (Match_Case_Id_Valid
            (Branches (J)));
         Append
           (Result.MT_Branches,
            Branches (J));
      end loop;
      Set_Link (Result.MT_Branches, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Matching_Term;

   ----------------------
   -- New_Binding_Term --
   ----------------------

   function New_Binding_Term
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Valid_Id;
      Def      : W_Term_Valid_Id;
      Context  : W_Term_Valid_Id)
     return W_Binding_Term_Valid_Id
   is
      Result : Why_Node (W_Binding_Term);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Binding_Term);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.BT_Name :=
        Name;
      Set_Link (Result.BT_Name, New_Id);
      Result.BT_Def :=
        Def;
      Set_Link (Result.BT_Def, New_Id);
      Result.BT_Context :=
        Context;
      Set_Link (Result.BT_Context, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Binding_Term;

   ------------------------
   -- New_Protected_Term --
   ------------------------

   function New_Protected_Term
     (Ada_Node : Node_Id := Empty;
      Term     : W_Term_Valid_Id)
     return W_Protected_Term_Valid_Id
   is
      Result : Why_Node (W_Protected_Term);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Protected_Term);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.BT_Term :=
        Term;
      Set_Link (Result.BT_Term, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Protected_Term;

   ----------------
   -- New_Op_Add --
   ----------------

   function New_Op_Add
     (Ada_Node : Node_Id := Empty)
     return W_Op_Add_Valid_Id
   is
      Result : Why_Node (W_Op_Add);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Add);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Op_Add;

   ----------------------
   -- New_Op_Substract --
   ----------------------

   function New_Op_Substract
     (Ada_Node : Node_Id := Empty)
     return W_Op_Substract_Valid_Id
   is
      Result : Why_Node (W_Op_Substract);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Substract);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Op_Substract;

   ---------------------
   -- New_Op_Multiply --
   ---------------------

   function New_Op_Multiply
     (Ada_Node : Node_Id := Empty)
     return W_Op_Multiply_Valid_Id
   is
      Result : Why_Node (W_Op_Multiply);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Multiply);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Op_Multiply;

   -------------------
   -- New_Op_Divide --
   -------------------

   function New_Op_Divide
     (Ada_Node : Node_Id := Empty)
     return W_Op_Divide_Valid_Id
   is
      Result : Why_Node (W_Op_Divide);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Divide);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Op_Divide;

   -------------------
   -- New_Op_Modulo --
   -------------------

   function New_Op_Modulo
     (Ada_Node : Node_Id := Empty)
     return W_Op_Modulo_Valid_Id
   is
      Result : Why_Node (W_Op_Modulo);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Modulo);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Op_Modulo;

   ---------------------------
   -- New_True_Literal_Pred --
   ---------------------------

   function New_True_Literal_Pred
     (Ada_Node : Node_Id := Empty)
     return W_True_Literal_Pred_Valid_Id
   is
      Result : Why_Node (W_True_Literal_Pred);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_True_Literal_Pred);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_True_Literal_Pred;

   ----------------------------
   -- New_False_Literal_Pred --
   ----------------------------

   function New_False_Literal_Pred
     (Ada_Node : Node_Id := Empty)
     return W_False_Literal_Pred_Valid_Id
   is
      Result : Why_Node (W_False_Literal_Pred);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_False_Literal_Pred);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_False_Literal_Pred;

   ------------------------------
   -- New_Predicate_Identifier --
   ------------------------------

   function New_Predicate_Identifier
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Valid_Id)
     return W_Predicate_Identifier_Valid_Id
   is
      Result : Why_Node (W_Predicate_Identifier);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Predicate_Identifier);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.PID_Name :=
        Name;
      Set_Link (Result.PID_Name, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Predicate_Identifier;

   ----------------------------
   -- New_Predicate_Instance --
   ----------------------------

   function New_Predicate_Instance
     (Ada_Node   : Node_Id := Empty;
      Name       : W_Identifier_Valid_Id;
      Parameters : W_Term_V_Array)
     return W_Predicate_Instance_Valid_Id
   is
      Result : Why_Node (W_Predicate_Instance);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Predicate_Instance);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.PIN_Name :=
        Name;
      Set_Link (Result.PIN_Name, New_Id);
      pragma Assert (Parameters'Length > 0);
      Result.PIN_Parameters := New_List;
      for J in Parameters'Range loop
         pragma Assert
           (Term_Id_Kind_Valid
            (Parameters (J)));
         pragma Assert
           (Term_Id_Valid
            (Parameters (J)));
         Append
           (Result.PIN_Parameters,
            Parameters (J));
      end loop;
      Set_Link (Result.PIN_Parameters, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Predicate_Instance;

   -----------------------
   -- New_Related_Terms --
   -----------------------

   function New_Related_Terms
     (Ada_Node : Node_Id := Empty;
      Left     : W_Term_Valid_Id;
      Op       : W_Relation_Valid_Id;
      Right    : W_Term_Valid_Id;
      Op2      : W_Relation_Valid_OId := Why_Empty;
      Right2   : W_Term_Valid_OId := Why_Empty)
     return W_Related_Terms_Valid_Id
   is
      Result : Why_Node (W_Related_Terms);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Related_Terms);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.RT_Left :=
        Left;
      Set_Link (Result.RT_Left, New_Id);
      Result.RT_Op :=
        Op;
      Set_Link (Result.RT_Op, New_Id);
      Result.RT_Right :=
        Right;
      Set_Link (Result.RT_Right, New_Id);
      Result.RT_Op2 :=
        Op2;
      Set_Link (Result.RT_Op2, New_Id);
      Result.RT_Right2 :=
        Right2;
      Set_Link (Result.RT_Right2, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Related_Terms;

   ---------------------
   -- New_Implication --
   ---------------------

   function New_Implication
     (Ada_Node : Node_Id := Empty;
      Left     : W_Predicate_Valid_Id;
      Right    : W_Predicate_Valid_Id)
     return W_Implication_Valid_Id
   is
      Result : Why_Node (W_Implication);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Implication);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.ITOC_Left :=
        Left;
      Set_Link (Result.ITOC_Left, New_Id);
      Result.ITOC_Right :=
        Right;
      Set_Link (Result.ITOC_Right, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Implication;

   ---------------------
   -- New_Equivalence --
   ---------------------

   function New_Equivalence
     (Ada_Node : Node_Id := Empty;
      Left     : W_Predicate_Valid_Id;
      Right    : W_Predicate_Valid_Id)
     return W_Equivalence_Valid_Id
   is
      Result : Why_Node (W_Equivalence);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Equivalence);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.ITOC_Left :=
        Left;
      Set_Link (Result.ITOC_Left, New_Id);
      Result.ITOC_Right :=
        Right;
      Set_Link (Result.ITOC_Right, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Equivalence;

   ---------------------
   -- New_Disjunction --
   ---------------------

   function New_Disjunction
     (Ada_Node : Node_Id := Empty;
      Left     : W_Predicate_Valid_Id;
      Right    : W_Predicate_Valid_Id)
     return W_Disjunction_Valid_Id
   is
      Result : Why_Node (W_Disjunction);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Disjunction);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.ITOC_Left :=
        Left;
      Set_Link (Result.ITOC_Left, New_Id);
      Result.ITOC_Right :=
        Right;
      Set_Link (Result.ITOC_Right, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Disjunction;

   ---------------------
   -- New_Conjunction --
   ---------------------

   function New_Conjunction
     (Ada_Node : Node_Id := Empty;
      Left     : W_Predicate_Valid_Id;
      Right    : W_Predicate_Valid_Id)
     return W_Conjunction_Valid_Id
   is
      Result : Why_Node (W_Conjunction);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Conjunction);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.ITOC_Left :=
        Left;
      Set_Link (Result.ITOC_Left, New_Id);
      Result.ITOC_Right :=
        Right;
      Set_Link (Result.ITOC_Right, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Conjunction;

   ------------------
   -- New_Negation --
   ------------------

   function New_Negation
     (Ada_Node : Node_Id := Empty;
      Operand  : W_Predicate_Valid_Id)
     return W_Negation_Valid_Id
   is
      Result : Why_Node (W_Negation);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Negation);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.N_Operand :=
        Operand;
      Set_Link (Result.N_Operand, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Negation;

   --------------------------
   -- New_Conditional_Pred --
   --------------------------

   function New_Conditional_Pred
     (Ada_Node  : Node_Id := Empty;
      Condition : W_Term_Valid_Id;
      Then_Part : W_Predicate_Valid_Id;
      Else_Part : W_Predicate_Valid_Id)
     return W_Conditional_Pred_Valid_Id
   is
      Result : Why_Node (W_Conditional_Pred);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Conditional_Pred);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.CPD_Condition :=
        Condition;
      Set_Link (Result.CPD_Condition, New_Id);
      Result.CPD_Then_Part :=
        Then_Part;
      Set_Link (Result.CPD_Then_Part, New_Id);
      Result.CPD_Else_Part :=
        Else_Part;
      Set_Link (Result.CPD_Else_Part, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Conditional_Pred;

   ----------------------
   -- New_Binding_Pred --
   ----------------------

   function New_Binding_Pred
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Valid_Id;
      Def      : W_Term_Valid_Id;
      Context  : W_Predicate_Valid_Id)
     return W_Binding_Pred_Valid_Id
   is
      Result : Why_Node (W_Binding_Pred);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Binding_Pred);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.BPD_Name :=
        Name;
      Set_Link (Result.BPD_Name, New_Id);
      Result.BPD_Def :=
        Def;
      Set_Link (Result.BPD_Def, New_Id);
      Result.BPD_Context :=
        Context;
      Set_Link (Result.BPD_Context, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Binding_Pred;

   ---------------------------
   -- New_Universal_Quantif --
   ---------------------------

   function New_Universal_Quantif
     (Ada_Node  : Node_Id := Empty;
      Variables : W_Identifier_V_Array;
      Var_Type  : W_Primitive_Type_Valid_Id;
      Triggers  : W_Triggers_Valid_OId := Why_Empty;
      Pred      : W_Predicate_Valid_Id)
     return W_Universal_Quantif_Valid_Id
   is
      Result : Why_Node (W_Universal_Quantif);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Universal_Quantif);
   begin
      Result.Ada_Node :=
        Ada_Node;
      pragma Assert (Variables'Length > 0);
      Result.UQ_Variables := New_List;
      for J in Variables'Range loop
         pragma Assert
           (Identifier_Id_Kind_Valid
            (Variables (J)));
         pragma Assert
           (Identifier_Id_Valid
            (Variables (J)));
         Append
           (Result.UQ_Variables,
            Variables (J));
      end loop;
      Set_Link (Result.UQ_Variables, New_Id);
      Result.UQ_Var_Type :=
        Var_Type;
      Set_Link (Result.UQ_Var_Type, New_Id);
      Result.UQ_Triggers :=
        Triggers;
      Set_Link (Result.UQ_Triggers, New_Id);
      Result.UQ_Pred :=
        Pred;
      Set_Link (Result.UQ_Pred, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Universal_Quantif;

   -----------------------------
   -- New_Existential_Quantif --
   -----------------------------

   function New_Existential_Quantif
     (Ada_Node  : Node_Id := Empty;
      Variables : W_Identifier_V_Array;
      Var_Type  : W_Primitive_Type_Valid_Id;
      Pred      : W_Predicate_Valid_Id)
     return W_Existential_Quantif_Valid_Id
   is
      Result : Why_Node (W_Existential_Quantif);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Existential_Quantif);
   begin
      Result.Ada_Node :=
        Ada_Node;
      pragma Assert (Variables'Length > 0);
      Result.EQ_Variables := New_List;
      for J in Variables'Range loop
         pragma Assert
           (Identifier_Id_Kind_Valid
            (Variables (J)));
         pragma Assert
           (Identifier_Id_Valid
            (Variables (J)));
         Append
           (Result.EQ_Variables,
            Variables (J));
      end loop;
      Set_Link (Result.EQ_Variables, New_Id);
      Result.EQ_Var_Type :=
        Var_Type;
      Set_Link (Result.EQ_Var_Type, New_Id);
      Result.EQ_Pred :=
        Pred;
      Set_Link (Result.EQ_Pred, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Existential_Quantif;

   -------------------------
   -- New_Named_Predicate --
   -------------------------

   function New_Named_Predicate
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Valid_Id;
      Pred     : W_Predicate_Valid_Id)
     return W_Named_Predicate_Valid_Id
   is
      Result : Why_Node (W_Named_Predicate);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Named_Predicate);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.NP_Name :=
        Name;
      Set_Link (Result.NP_Name, New_Id);
      Result.NP_Pred :=
        Pred;
      Set_Link (Result.NP_Pred, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Named_Predicate;

   -----------------------------
   -- New_Protected_Predicate --
   -----------------------------

   function New_Protected_Predicate
     (Ada_Node : Node_Id := Empty;
      Pred     : W_Predicate_Valid_Id)
     return W_Protected_Predicate_Valid_Id
   is
      Result : Why_Node (W_Protected_Predicate);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Protected_Predicate);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.PP_Pred :=
        Pred;
      Set_Link (Result.PP_Pred, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Protected_Predicate;

   -----------------
   -- New_Pattern --
   -----------------

   function New_Pattern
     (Ada_Node : Node_Id := Empty;
      Constr   : W_Identifier_Valid_Id;
      Args     : W_Identifier_V_Array := (2 .. 1 => <>))
     return W_Pattern_Valid_Id
   is
      Result : Why_Node (W_Pattern);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Pattern);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.PAT_Constr :=
        Constr;
      Set_Link (Result.PAT_Constr, New_Id);
      Result.PAT_Args := New_List;
      for J in Args'Range loop
         pragma Assert
           (Identifier_Id_Kind_Valid
            (Args (J)));
         pragma Assert
           (Identifier_Id_Valid
            (Args (J)));
         Append
           (Result.PAT_Args,
            Args (J));
      end loop;
      Set_Link (Result.PAT_Args, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Pattern;

   --------------------
   -- New_Match_Case --
   --------------------

   function New_Match_Case
     (Ada_Node : Node_Id := Empty;
      Pattern  : W_Pattern_Valid_Id;
      Term     : W_Term_Valid_Id)
     return W_Match_Case_Valid_Id
   is
      Result : Why_Node (W_Match_Case);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Match_Case);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.MC_Pattern :=
        Pattern;
      Set_Link (Result.MC_Pattern, New_Id);
      Result.MC_Term :=
        Term;
      Set_Link (Result.MC_Term, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Match_Case;

   ------------------
   -- New_Triggers --
   ------------------

   function New_Triggers
     (Ada_Node : Node_Id := Empty;
      Triggers : W_Trigger_V_Array)
     return W_Triggers_Valid_Id
   is
      Result : Why_Node (W_Triggers);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Triggers);
   begin
      Result.Ada_Node :=
        Ada_Node;
      pragma Assert (Triggers'Length > 0);
      Result.TRS_Triggers := New_List;
      for J in Triggers'Range loop
         pragma Assert
           (Trigger_Id_Kind_Valid
            (Triggers (J)));
         pragma Assert
           (Trigger_Id_Valid
            (Triggers (J)));
         Append
           (Result.TRS_Triggers,
            Triggers (J));
      end loop;
      Set_Link (Result.TRS_Triggers, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Triggers;

   -----------------
   -- New_Trigger --
   -----------------

   function New_Trigger
     (Ada_Node : Node_Id := Empty;
      Terms    : W_Term_V_Array)
     return W_Trigger_Valid_Id
   is
      Result : Why_Node (W_Trigger);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Trigger);
   begin
      Result.Ada_Node :=
        Ada_Node;
      pragma Assert (Terms'Length > 0);
      Result.TRI_Terms := New_List;
      for J in Terms'Range loop
         pragma Assert
           (Term_Id_Kind_Valid
            (Terms (J)));
         pragma Assert
           (Term_Id_Valid
            (Terms (J)));
         Append
           (Result.TRI_Terms,
            Terms (J));
      end loop;
      Set_Link (Result.TRI_Terms, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Trigger;

   ----------------
   -- New_Rel_Eq --
   ----------------

   function New_Rel_Eq
     (Ada_Node : Node_Id := Empty)
     return W_Rel_Eq_Valid_Id
   is
      Result : Why_Node (W_Rel_Eq);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Rel_Eq);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Rel_Eq;

   ----------------
   -- New_Rel_Ne --
   ----------------

   function New_Rel_Ne
     (Ada_Node : Node_Id := Empty)
     return W_Rel_Ne_Valid_Id
   is
      Result : Why_Node (W_Rel_Ne);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Rel_Ne);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Rel_Ne;

   ----------------
   -- New_Rel_Lt --
   ----------------

   function New_Rel_Lt
     (Ada_Node : Node_Id := Empty)
     return W_Rel_Lt_Valid_Id
   is
      Result : Why_Node (W_Rel_Lt);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Rel_Lt);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Rel_Lt;

   ----------------
   -- New_Rel_Le --
   ----------------

   function New_Rel_Le
     (Ada_Node : Node_Id := Empty)
     return W_Rel_Le_Valid_Id
   is
      Result : Why_Node (W_Rel_Le);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Rel_Le);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Rel_Le;

   ----------------
   -- New_Rel_Gt --
   ----------------

   function New_Rel_Gt
     (Ada_Node : Node_Id := Empty)
     return W_Rel_Gt_Valid_Id
   is
      Result : Why_Node (W_Rel_Gt);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Rel_Gt);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Rel_Gt;

   ----------------
   -- New_Rel_Ge --
   ----------------

   function New_Rel_Ge
     (Ada_Node : Node_Id := Empty)
     return W_Rel_Ge_Valid_Id
   is
      Result : Why_Node (W_Rel_Ge);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Rel_Ge);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Rel_Ge;

   --------------
   -- New_Type --
   --------------

   function New_Type
     (Ada_Node        : Node_Id := Empty;
      External        : W_External_Valid_OId := Why_Empty;
      Type_Parameters : W_Identifier_V_Array := (2 .. 1 => <>);
      Name            : W_Identifier_Valid_Id;
      Definition      : W_Type_Definition_Valid_OId := Why_Empty)
     return W_Type_Valid_Id
   is
      Result : Why_Node (W_Type);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Type);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.T_External :=
        External;
      Set_Link (Result.T_External, New_Id);
      Result.T_Type_Parameters := New_List;
      for J in Type_Parameters'Range loop
         pragma Assert
           (Identifier_Id_Kind_Valid
            (Type_Parameters (J)));
         pragma Assert
           (Identifier_Id_Valid
            (Type_Parameters (J)));
         Append
           (Result.T_Type_Parameters,
            Type_Parameters (J));
      end loop;
      Set_Link (Result.T_Type_Parameters, New_Id);
      Result.T_Name :=
        Name;
      Set_Link (Result.T_Name, New_Id);
      Result.T_Definition :=
        Definition;
      Set_Link (Result.T_Definition, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Type;

   ---------------
   -- New_Logic --
   ---------------

   function New_Logic
     (Ada_Node   : Node_Id := Empty;
      External   : W_External_Valid_OId := Why_Empty;
      Names      : W_Identifier_V_Array;
      Logic_Type : W_Logic_Type_Valid_Id)
     return W_Logic_Valid_Id
   is
      Result : Why_Node (W_Logic);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Logic);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.L_External :=
        External;
      Set_Link (Result.L_External, New_Id);
      pragma Assert (Names'Length > 0);
      Result.L_Names := New_List;
      for J in Names'Range loop
         pragma Assert
           (Identifier_Id_Kind_Valid
            (Names (J)));
         pragma Assert
           (Identifier_Id_Valid
            (Names (J)));
         Append
           (Result.L_Names,
            Names (J));
      end loop;
      Set_Link (Result.L_Names, New_Id);
      Result.L_Logic_Type :=
        Logic_Type;
      Set_Link (Result.L_Logic_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Logic;

   ------------------
   -- New_Function --
   ------------------

   function New_Function
     (Ada_Node    : Node_Id := Empty;
      Name        : W_Identifier_Valid_Id;
      Binders     : W_Logic_Binder_V_Array;
      Return_Type : W_Primitive_Type_Valid_Id;
      Def         : W_Term_Valid_Id)
     return W_Function_Valid_Id
   is
      Result : Why_Node (W_Function);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Function);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.F_Name :=
        Name;
      Set_Link (Result.F_Name, New_Id);
      pragma Assert (Binders'Length > 0);
      Result.F_Binders := New_List;
      for J in Binders'Range loop
         pragma Assert
           (Logic_Binder_Id_Kind_Valid
            (Binders (J)));
         pragma Assert
           (Logic_Binder_Id_Valid
            (Binders (J)));
         Append
           (Result.F_Binders,
            Binders (J));
      end loop;
      Set_Link (Result.F_Binders, New_Id);
      Result.F_Return_Type :=
        Return_Type;
      Set_Link (Result.F_Return_Type, New_Id);
      Result.F_Def :=
        Def;
      Set_Link (Result.F_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Function;

   ------------------------------
   -- New_Predicate_Definition --
   ------------------------------

   function New_Predicate_Definition
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Valid_Id;
      Binders  : W_Logic_Binder_V_Array;
      Def      : W_Predicate_Valid_Id)
     return W_Predicate_Definition_Valid_Id
   is
      Result : Why_Node (W_Predicate_Definition);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Predicate_Definition);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.P_Name :=
        Name;
      Set_Link (Result.P_Name, New_Id);
      pragma Assert (Binders'Length > 0);
      Result.P_Binders := New_List;
      for J in Binders'Range loop
         pragma Assert
           (Logic_Binder_Id_Kind_Valid
            (Binders (J)));
         pragma Assert
           (Logic_Binder_Id_Valid
            (Binders (J)));
         Append
           (Result.P_Binders,
            Binders (J));
      end loop;
      Set_Link (Result.P_Binders, New_Id);
      Result.P_Def :=
        Def;
      Set_Link (Result.P_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Predicate_Definition;

   -------------------
   -- New_Inductive --
   -------------------

   function New_Inductive
     (Ada_Node   : Node_Id := Empty;
      Name       : W_Identifier_Valid_Id;
      Logic_Type : W_Logic_Type_Valid_Id;
      Def        : W_Inductive_Case_V_Array)
     return W_Inductive_Valid_Id
   is
      Result : Why_Node (W_Inductive);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Inductive);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.I_Name :=
        Name;
      Set_Link (Result.I_Name, New_Id);
      Result.I_Logic_Type :=
        Logic_Type;
      Set_Link (Result.I_Logic_Type, New_Id);
      pragma Assert (Def'Length > 0);
      Result.I_Def := New_List;
      for J in Def'Range loop
         pragma Assert
           (Inductive_Case_Id_Kind_Valid
            (Def (J)));
         pragma Assert
           (Inductive_Case_Id_Valid
            (Def (J)));
         Append
           (Result.I_Def,
            Def (J));
      end loop;
      Set_Link (Result.I_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Inductive;

   ---------------
   -- New_Axiom --
   ---------------

   function New_Axiom
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Valid_Id;
      Def      : W_Predicate_Valid_Id)
     return W_Axiom_Valid_Id
   is
      Result : Why_Node (W_Axiom);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Axiom);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.AX_Name :=
        Name;
      Set_Link (Result.AX_Name, New_Id);
      Result.AX_Def :=
        Def;
      Set_Link (Result.AX_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Axiom;

   --------------
   -- New_Goal --
   --------------

   function New_Goal
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Valid_Id;
      Def      : W_Predicate_Valid_Id)
     return W_Goal_Valid_Id
   is
      Result : Why_Node (W_Goal);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Goal);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.G_Name :=
        Name;
      Set_Link (Result.G_Name, New_Id);
      Result.G_Def :=
        Def;
      Set_Link (Result.G_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Goal;

   ------------------
   -- New_External --
   ------------------

   function New_External
     (Ada_Node : Node_Id := Empty)
     return W_External_Valid_Id
   is
      Result : Why_Node (W_External);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_External);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_External;

   --------------------
   -- New_Logic_Type --
   --------------------

   function New_Logic_Type
     (Ada_Node    : Node_Id := Empty;
      Arg_Types   : W_Logic_Arg_Type_V_Array := (2 .. 1 => <>);
      Return_Type : W_Logic_Return_Type_Valid_Id)
     return W_Logic_Type_Valid_Id
   is
      Result : Why_Node (W_Logic_Type);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Logic_Type);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.LT_Arg_Types := New_List;
      for J in Arg_Types'Range loop
         pragma Assert
           (Logic_Arg_Type_Id_Kind_Valid
            (Arg_Types (J)));
         pragma Assert
           (Logic_Arg_Type_Id_Valid
            (Arg_Types (J)));
         Append
           (Result.LT_Arg_Types,
            Arg_Types (J));
      end loop;
      Set_Link (Result.LT_Arg_Types, New_Id);
      Result.LT_Return_Type :=
        Return_Type;
      Set_Link (Result.LT_Return_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Logic_Type;

   ----------------------
   -- New_Logic_Binder --
   ----------------------

   function New_Logic_Binder
     (Ada_Node   : Node_Id := Empty;
      Name       : W_Identifier_Valid_Id;
      Param_Type : W_Primitive_Type_Valid_Id)
     return W_Logic_Binder_Valid_Id
   is
      Result : Why_Node (W_Logic_Binder);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Logic_Binder);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.LB_Name :=
        Name;
      Set_Link (Result.LB_Name, New_Id);
      Result.LB_Param_Type :=
        Param_Type;
      Set_Link (Result.LB_Param_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Logic_Binder;

   ------------------------
   -- New_Inductive_Case --
   ------------------------

   function New_Inductive_Case
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Valid_Id;
      Pred     : W_Predicate_Valid_Id)
     return W_Inductive_Case_Valid_Id
   is
      Result : Why_Node (W_Inductive_Case);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Inductive_Case);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.IC_Name :=
        Name;
      Set_Link (Result.IC_Name, New_Id);
      Result.IC_Pred :=
        Pred;
      Set_Link (Result.IC_Pred, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Inductive_Case;

   -------------------------------------
   -- New_Transparent_Type_Definition --
   -------------------------------------

   function New_Transparent_Type_Definition
     (Ada_Node        : Node_Id := Empty;
      Type_Definition : W_Primitive_Type_Valid_Id)
     return W_Transparent_Type_Definition_Valid_Id
   is
      Result : Why_Node (W_Transparent_Type_Definition);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Transparent_Type_Definition);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Tr_Type_Definition :=
        Type_Definition;
      Set_Link (Result.Tr_Type_Definition, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Transparent_Type_Definition;

   ------------------------
   -- New_Adt_Definition --
   ------------------------

   function New_Adt_Definition
     (Ada_Node     : Node_Id := Empty;
      Constructors : W_Constr_Decl_V_Array)
     return W_Adt_Definition_Valid_Id
   is
      Result : Why_Node (W_Adt_Definition);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Adt_Definition);
   begin
      Result.Ada_Node :=
        Ada_Node;
      pragma Assert (Constructors'Length > 0);
      Result.Adt_Constructors := New_List;
      for J in Constructors'Range loop
         pragma Assert
           (Constr_Decl_Id_Kind_Valid
            (Constructors (J)));
         pragma Assert
           (Constr_Decl_Id_Valid
            (Constructors (J)));
         Append
           (Result.Adt_Constructors,
            Constructors (J));
      end loop;
      Set_Link (Result.Adt_Constructors, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Adt_Definition;

   ---------------------
   -- New_Constr_Decl --
   ---------------------

   function New_Constr_Decl
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Valid_Id;
      Arg_List : W_Primitive_Type_V_Array := (2 .. 1 => <>))
     return W_Constr_Decl_Valid_Id
   is
      Result : Why_Node (W_Constr_Decl);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Constr_Decl);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.C_Name :=
        Name;
      Set_Link (Result.C_Name, New_Id);
      Result.C_Arg_List := New_List;
      for J in Arg_List'Range loop
         pragma Assert
           (Primitive_Type_Id_Kind_Valid
            (Arg_List (J)));
         pragma Assert
           (Primitive_Type_Id_Valid
            (Arg_List (J)));
         Append
           (Result.C_Arg_List,
            Arg_List (J));
      end loop;
      Set_Link (Result.C_Arg_List, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Constr_Decl;

   -----------------
   -- New_Effects --
   -----------------

   function New_Effects
     (Ada_Node : Node_Id := Empty;
      Reads    : W_Identifier_V_Array := (2 .. 1 => <>);
      Writes   : W_Identifier_V_Array := (2 .. 1 => <>);
      Raises   : W_Identifier_V_Array := (2 .. 1 => <>))
     return W_Effects_Valid_Id
   is
      Result : Why_Node (W_Effects);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Effects);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.E_Reads := New_List;
      for J in Reads'Range loop
         pragma Assert
           (Identifier_Id_Kind_Valid
            (Reads (J)));
         pragma Assert
           (Identifier_Id_Valid
            (Reads (J)));
         Append
           (Result.E_Reads,
            Reads (J));
      end loop;
      Set_Link (Result.E_Reads, New_Id);
      Result.E_Writes := New_List;
      for J in Writes'Range loop
         pragma Assert
           (Identifier_Id_Kind_Valid
            (Writes (J)));
         pragma Assert
           (Identifier_Id_Valid
            (Writes (J)));
         Append
           (Result.E_Writes,
            Writes (J));
      end loop;
      Set_Link (Result.E_Writes, New_Id);
      Result.E_Raises := New_List;
      for J in Raises'Range loop
         pragma Assert
           (Identifier_Id_Kind_Valid
            (Raises (J)));
         pragma Assert
           (Identifier_Id_Valid
            (Raises (J)));
         Append
           (Result.E_Raises,
            Raises (J));
      end loop;
      Set_Link (Result.E_Raises, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Effects;

   ----------------------
   -- New_Precondition --
   ----------------------

   function New_Precondition
     (Ada_Node : Node_Id := Empty;
      Pred     : W_Predicate_Valid_Id)
     return W_Precondition_Valid_Id
   is
      Result : Why_Node (W_Precondition);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Precondition);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.PRE_Pred :=
        Pred;
      Set_Link (Result.PRE_Pred, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Precondition;

   -----------------------
   -- New_Postcondition --
   -----------------------

   function New_Postcondition
     (Ada_Node : Node_Id := Empty;
      Pred     : W_Predicate_Valid_Id;
      Handlers : W_Exn_Condition_V_Array := (2 .. 1 => <>))
     return W_Postcondition_Valid_Id
   is
      Result : Why_Node (W_Postcondition);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Postcondition);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.POST_Pred :=
        Pred;
      Set_Link (Result.POST_Pred, New_Id);
      Result.POST_Handlers := New_List;
      for J in Handlers'Range loop
         pragma Assert
           (Exn_Condition_Id_Kind_Valid
            (Handlers (J)));
         pragma Assert
           (Exn_Condition_Id_Valid
            (Handlers (J)));
         Append
           (Result.POST_Handlers,
            Handlers (J));
      end loop;
      Set_Link (Result.POST_Handlers, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Postcondition;

   -----------------------
   -- New_Exn_Condition --
   -----------------------

   function New_Exn_Condition
     (Ada_Node : Node_Id := Empty;
      Exn_Case : W_Identifier_Valid_Id;
      Pred     : W_Predicate_Valid_Id)
     return W_Exn_Condition_Valid_Id
   is
      Result : Why_Node (W_Exn_Condition);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Exn_Condition);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.EC_Exn_Case :=
        Exn_Case;
      Set_Link (Result.EC_Exn_Case, New_Id);
      Result.EC_Pred :=
        Pred;
      Set_Link (Result.EC_Pred, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Exn_Condition;

   -----------------------
   -- New_Prog_Constant --
   -----------------------

   function New_Prog_Constant
     (Ada_Node : Node_Id := Empty;
      Def      : W_Constant_Valid_Id)
     return W_Prog_Constant_Valid_Id
   is
      Result : Why_Node (W_Prog_Constant);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Prog_Constant);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.PC_Def :=
        Def;
      Set_Link (Result.PC_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Prog_Constant;

   -------------------------
   -- New_Prog_Identifier --
   -------------------------

   function New_Prog_Identifier
     (Ada_Node : Node_Id := Empty;
      Def      : W_Identifier_Valid_Id)
     return W_Prog_Identifier_Valid_Id
   is
      Result : Why_Node (W_Prog_Identifier);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Prog_Identifier);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.PI_Def :=
        Def;
      Set_Link (Result.PI_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Prog_Identifier;

   ------------------
   -- New_Any_Expr --
   ------------------

   function New_Any_Expr
     (Ada_Node : Node_Id := Empty;
      Any_Type : W_Computation_Type_Valid_Id)
     return W_Any_Expr_Valid_Id
   is
      Result : Why_Node (W_Any_Expr);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Any_Expr);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.AE_Any_Type :=
        Any_Type;
      Set_Link (Result.AE_Any_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Any_Expr;

   ---------------
   -- New_Deref --
   ---------------

   function New_Deref
     (Ada_Node : Node_Id := Empty;
      Ref      : W_Identifier_Valid_Id)
     return W_Deref_Valid_Id
   is
      Result : Why_Node (W_Deref);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Deref);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.D_Ref :=
        Ref;
      Set_Link (Result.D_Ref, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Deref;

   --------------------
   -- New_Assignment --
   --------------------

   function New_Assignment
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Valid_Id;
      Value    : W_Prog_Valid_Id)
     return W_Assignment_Valid_Id
   is
      Result : Why_Node (W_Assignment);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Assignment);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.A_Name :=
        Name;
      Set_Link (Result.A_Name, New_Id);
      Result.A_Value :=
        Value;
      Set_Link (Result.A_Value, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Assignment;

   ----------------------
   -- New_Array_Access --
   ----------------------

   function New_Array_Access
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Valid_Id;
      Index    : W_Prog_Valid_Id)
     return W_Array_Access_Valid_Id
   is
      Result : Why_Node (W_Array_Access);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Array_Access);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.AA_Name :=
        Name;
      Set_Link (Result.AA_Name, New_Id);
      Result.AA_Index :=
        Index;
      Set_Link (Result.AA_Index, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Array_Access;

   ----------------------
   -- New_Array_Update --
   ----------------------

   function New_Array_Update
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Valid_Id;
      Index    : W_Prog_Valid_Id;
      Value    : W_Prog_Valid_Id)
     return W_Array_Update_Valid_Id
   is
      Result : Why_Node (W_Array_Update);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Array_Update);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.AU_Name :=
        Name;
      Set_Link (Result.AU_Name, New_Id);
      Result.AU_Index :=
        Index;
      Set_Link (Result.AU_Index, New_Id);
      Result.AU_Value :=
        Value;
      Set_Link (Result.AU_Value, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Array_Update;

   --------------------
   -- New_Infix_Call --
   --------------------

   function New_Infix_Call
     (Ada_Node : Node_Id := Empty;
      Left     : W_Prog_Valid_Id;
      Infix    : W_Infix_Valid_Id;
      Right    : W_Prog_Valid_Id)
     return W_Infix_Call_Valid_Id
   is
      Result : Why_Node (W_Infix_Call);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Infix_Call);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.IC_Left :=
        Left;
      Set_Link (Result.IC_Left, New_Id);
      Result.IC_Infix :=
        Infix;
      Set_Link (Result.IC_Infix, New_Id);
      Result.IC_Right :=
        Right;
      Set_Link (Result.IC_Right, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Infix_Call;

   ---------------------
   -- New_Prefix_Call --
   ---------------------

   function New_Prefix_Call
     (Ada_Node : Node_Id := Empty;
      Prefix   : W_Prefix_Valid_Id;
      Operand  : W_Prog_Valid_Id)
     return W_Prefix_Call_Valid_Id
   is
      Result : Why_Node (W_Prefix_Call);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Prefix_Call);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.PC_Prefix :=
        Prefix;
      Set_Link (Result.PC_Prefix, New_Id);
      Result.PC_Operand :=
        Operand;
      Set_Link (Result.PC_Operand, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Prefix_Call;

   ----------------------
   -- New_Binding_Prog --
   ----------------------

   function New_Binding_Prog
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Valid_Id;
      Def      : W_Prog_Valid_Id;
      Context  : W_Prog_Valid_Id)
     return W_Binding_Prog_Valid_Id
   is
      Result : Why_Node (W_Binding_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Binding_Prog);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.BPG_Name :=
        Name;
      Set_Link (Result.BPG_Name, New_Id);
      Result.BPG_Def :=
        Def;
      Set_Link (Result.BPG_Def, New_Id);
      Result.BPG_Context :=
        Context;
      Set_Link (Result.BPG_Context, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Binding_Prog;

   ---------------------
   -- New_Binding_Ref --
   ---------------------

   function New_Binding_Ref
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Valid_Id;
      Def      : W_Prog_Valid_Id;
      Context  : W_Prog_Valid_Id)
     return W_Binding_Ref_Valid_Id
   is
      Result : Why_Node (W_Binding_Ref);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Binding_Ref);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.BPG_Name :=
        Name;
      Set_Link (Result.BPG_Name, New_Id);
      Result.BPG_Def :=
        Def;
      Set_Link (Result.BPG_Def, New_Id);
      Result.BPG_Context :=
        Context;
      Set_Link (Result.BPG_Context, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Binding_Ref;

   --------------------------
   -- New_Conditional_Prog --
   --------------------------

   function New_Conditional_Prog
     (Ada_Node  : Node_Id := Empty;
      Condition : W_Prog_Valid_Id;
      Then_Part : W_Prog_Valid_Id;
      Else_Part : W_Prog_Valid_OId := Why_Empty)
     return W_Conditional_Prog_Valid_Id
   is
      Result : Why_Node (W_Conditional_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Conditional_Prog);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.CPG_Condition :=
        Condition;
      Set_Link (Result.CPG_Condition, New_Id);
      Result.CPG_Then_Part :=
        Then_Part;
      Set_Link (Result.CPG_Then_Part, New_Id);
      Result.CPG_Else_Part :=
        Else_Part;
      Set_Link (Result.CPG_Else_Part, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Conditional_Prog;

   --------------------
   -- New_While_Loop --
   --------------------

   function New_While_Loop
     (Ada_Node     : Node_Id := Empty;
      Condition    : W_Prog_Valid_Id;
      Annotation   : W_Loop_Annot_Valid_Id;
      Loop_Content : W_Prog_Valid_Id)
     return W_While_Loop_Valid_Id
   is
      Result : Why_Node (W_While_Loop);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_While_Loop);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.WL_Condition :=
        Condition;
      Set_Link (Result.WL_Condition, New_Id);
      Result.WL_Annotation :=
        Annotation;
      Set_Link (Result.WL_Annotation, New_Id);
      Result.WL_Loop_Content :=
        Loop_Content;
      Set_Link (Result.WL_Loop_Content, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_While_Loop;

   ----------------------------
   -- New_Statement_Sequence --
   ----------------------------

   function New_Statement_Sequence
     (Ada_Node   : Node_Id := Empty;
      Statements : W_Prog_V_Array)
     return W_Statement_Sequence_Valid_Id
   is
      Result : Why_Node (W_Statement_Sequence);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Statement_Sequence);
   begin
      Result.Ada_Node :=
        Ada_Node;
      pragma Assert (Statements'Length > 0);
      Result.SS_Statements := New_List;
      for J in Statements'Range loop
         pragma Assert
           (Prog_Id_Kind_Valid
            (Statements (J)));
         pragma Assert
           (Prog_Id_Valid
            (Statements (J)));
         Append
           (Result.SS_Statements,
            Statements (J));
      end loop;
      Set_Link (Result.SS_Statements, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Statement_Sequence;

   ---------------
   -- New_Label --
   ---------------

   function New_Label
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Valid_Id;
      Def      : W_Prog_Valid_Id)
     return W_Label_Valid_Id
   is
      Result : Why_Node (W_Label);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Label);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.L_Name :=
        Name;
      Set_Link (Result.L_Name, New_Id);
      Result.L_Def :=
        Def;
      Set_Link (Result.L_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Label;

   ----------------
   -- New_Assert --
   ----------------

   function New_Assert
     (Ada_Node : Node_Id := Empty;
      Preds    : W_Predicate_V_Array;
      Prog     : W_Prog_Valid_Id)
     return W_Assert_Valid_Id
   is
      Result : Why_Node (W_Assert);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Assert);
   begin
      Result.Ada_Node :=
        Ada_Node;
      pragma Assert (Preds'Length > 0);
      Result.AS_Preds := New_List;
      for J in Preds'Range loop
         pragma Assert
           (Predicate_Id_Kind_Valid
            (Preds (J)));
         pragma Assert
           (Predicate_Id_Valid
            (Preds (J)));
         Append
           (Result.AS_Preds,
            Preds (J));
      end loop;
      Set_Link (Result.AS_Preds, New_Id);
      Result.AS_Prog :=
        Prog;
      Set_Link (Result.AS_Prog, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Assert;

   ------------------------
   -- New_Post_Assertion --
   ------------------------

   function New_Post_Assertion
     (Ada_Node : Node_Id := Empty;
      Prog     : W_Prog_Valid_Id;
      Post     : W_Postcondition_Valid_Id)
     return W_Post_Assertion_Valid_Id
   is
      Result : Why_Node (W_Post_Assertion);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Post_Assertion);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.PA_Prog :=
        Prog;
      Set_Link (Result.PA_Prog, New_Id);
      Result.PA_Post :=
        Post;
      Set_Link (Result.PA_Post, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Post_Assertion;

   --------------------------
   -- New_Opaque_Assertion --
   --------------------------

   function New_Opaque_Assertion
     (Ada_Node : Node_Id := Empty;
      Prog     : W_Prog_Valid_Id;
      Post     : W_Postcondition_Valid_Id)
     return W_Opaque_Assertion_Valid_Id
   is
      Result : Why_Node (W_Opaque_Assertion);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Opaque_Assertion);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.PA_Prog :=
        Prog;
      Set_Link (Result.PA_Prog, New_Id);
      Result.PA_Post :=
        Post;
      Set_Link (Result.PA_Post, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Opaque_Assertion;

   -----------------
   -- New_Fun_Def --
   -----------------

   function New_Fun_Def
     (Ada_Node : Node_Id := Empty;
      Binders  : W_Binder_V_Array;
      Pre      : W_Precondition_Valid_Id;
      Def      : W_Prog_Valid_Id)
     return W_Fun_Def_Valid_Id
   is
      Result : Why_Node (W_Fun_Def);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Fun_Def);
   begin
      Result.Ada_Node :=
        Ada_Node;
      pragma Assert (Binders'Length > 0);
      Result.FD_Binders := New_List;
      for J in Binders'Range loop
         pragma Assert
           (Binder_Id_Kind_Valid
            (Binders (J)));
         pragma Assert
           (Binder_Id_Valid
            (Binders (J)));
         Append
           (Result.FD_Binders,
            Binders (J));
      end loop;
      Set_Link (Result.FD_Binders, New_Id);
      Result.FD_Pre :=
        Pre;
      Set_Link (Result.FD_Pre, New_Id);
      Result.FD_Def :=
        Def;
      Set_Link (Result.FD_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Fun_Def;

   ---------------------
   -- New_Binding_Fun --
   ---------------------

   function New_Binding_Fun
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Valid_Id;
      Binders  : W_Binder_V_Array;
      Pre      : W_Precondition_Valid_Id;
      Def      : W_Prog_Valid_Id;
      Context  : W_Prog_Valid_Id)
     return W_Binding_Fun_Valid_Id
   is
      Result : Why_Node (W_Binding_Fun);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Binding_Fun);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.BF_Name :=
        Name;
      Set_Link (Result.BF_Name, New_Id);
      pragma Assert (Binders'Length > 0);
      Result.BF_Binders := New_List;
      for J in Binders'Range loop
         pragma Assert
           (Binder_Id_Kind_Valid
            (Binders (J)));
         pragma Assert
           (Binder_Id_Valid
            (Binders (J)));
         Append
           (Result.BF_Binders,
            Binders (J));
      end loop;
      Set_Link (Result.BF_Binders, New_Id);
      Result.BF_Pre :=
        Pre;
      Set_Link (Result.BF_Pre, New_Id);
      Result.BF_Def :=
        Def;
      Set_Link (Result.BF_Def, New_Id);
      Result.BF_Context :=
        Context;
      Set_Link (Result.BF_Context, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Binding_Fun;

   ---------------------
   -- New_Binding_Rec --
   ---------------------

   function New_Binding_Rec
     (Ada_Node : Node_Id := Empty;
      Recfun   : W_Recfun_Valid_Id;
      Context  : W_Prog_Valid_Id)
     return W_Binding_Rec_Valid_Id
   is
      Result : Why_Node (W_Binding_Rec);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Binding_Rec);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.BR_Recfun :=
        Recfun;
      Set_Link (Result.BR_Recfun, New_Id);
      Result.BR_Context :=
        Context;
      Set_Link (Result.BR_Context, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Binding_Rec;

   -------------------
   -- New_Prog_Call --
   -------------------

   function New_Prog_Call
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Valid_Id;
      Progs    : W_Prog_V_Array)
     return W_Prog_Call_Valid_Id
   is
      Result : Why_Node (W_Prog_Call);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Prog_Call);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.PS_Name :=
        Name;
      Set_Link (Result.PS_Name, New_Id);
      pragma Assert (Progs'Length > 0);
      Result.PS_Progs := New_List;
      for J in Progs'Range loop
         pragma Assert
           (Prog_Id_Kind_Valid
            (Progs (J)));
         pragma Assert
           (Prog_Id_Valid
            (Progs (J)));
         Append
           (Result.PS_Progs,
            Progs (J));
      end loop;
      Set_Link (Result.PS_Progs, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Prog_Call;

   -------------------------
   -- New_Raise_Statement --
   -------------------------

   function New_Raise_Statement
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Valid_Id;
      Exn_Type : W_Simple_Value_Type_Valid_OId := Why_Empty)
     return W_Raise_Statement_Valid_Id
   is
      Result : Why_Node (W_Raise_Statement);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Raise_Statement);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.RS_Name :=
        Name;
      Set_Link (Result.RS_Name, New_Id);
      Result.RS_Exn_Type :=
        Exn_Type;
      Set_Link (Result.RS_Exn_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Raise_Statement;

   -----------------------------------------
   -- New_Raise_Statement_With_Parameters --
   -----------------------------------------

   function New_Raise_Statement_With_Parameters
     (Ada_Node  : Node_Id := Empty;
      Name      : W_Identifier_Valid_Id;
      Parameter : W_Term_Valid_Id;
      Exn_Type  : W_Simple_Value_Type_Valid_OId := Why_Empty)
     return W_Raise_Statement_With_Parameters_Valid_Id
   is
      Result : Why_Node (W_Raise_Statement_With_Parameters);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Raise_Statement_With_Parameters);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.RSWP_Name :=
        Name;
      Set_Link (Result.RSWP_Name, New_Id);
      Result.RSWP_Parameter :=
        Parameter;
      Set_Link (Result.RSWP_Parameter, New_Id);
      Result.RSWP_Exn_Type :=
        Exn_Type;
      Set_Link (Result.RSWP_Exn_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Raise_Statement_With_Parameters;

   -------------------
   -- New_Try_Block --
   -------------------

   function New_Try_Block
     (Ada_Node : Node_Id := Empty;
      Prog     : W_Prog_Valid_Id;
      Handler  : W_Handler_V_Array)
     return W_Try_Block_Valid_Id
   is
      Result : Why_Node (W_Try_Block);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Try_Block);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.TB_Prog :=
        Prog;
      Set_Link (Result.TB_Prog, New_Id);
      pragma Assert (Handler'Length > 0);
      Result.TB_Handler := New_List;
      for J in Handler'Range loop
         pragma Assert
           (Handler_Id_Kind_Valid
            (Handler (J)));
         pragma Assert
           (Handler_Id_Valid
            (Handler (J)));
         Append
           (Result.TB_Handler,
            Handler (J));
      end loop;
      Set_Link (Result.TB_Handler, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Try_Block;

   --------------------------
   -- New_Unreachable_Code --
   --------------------------

   function New_Unreachable_Code
     (Ada_Node : Node_Id := Empty;
      Exn_Type : W_Simple_Value_Type_Valid_OId := Why_Empty)
     return W_Unreachable_Code_Valid_Id
   is
      Result : Why_Node (W_Unreachable_Code);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Unreachable_Code);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.UC_Exn_Type :=
        Exn_Type;
      Set_Link (Result.UC_Exn_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unreachable_Code;

   ---------------------
   -- New_Begin_Block --
   ---------------------

   function New_Begin_Block
     (Ada_Node : Node_Id := Empty;
      Prog     : W_Prog_Valid_Id)
     return W_Begin_Block_Valid_Id
   is
      Result : Why_Node (W_Begin_Block);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Begin_Block);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.BB_Prog :=
        Prog;
      Set_Link (Result.BB_Prog, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Begin_Block;

   ------------------------
   -- New_Protected_Prog --
   ------------------------

   function New_Protected_Prog
     (Ada_Node : Node_Id := Empty;
      Prog     : W_Prog_Valid_Id)
     return W_Protected_Prog_Valid_Id
   is
      Result : Why_Node (W_Protected_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Protected_Prog);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.BB_Prog :=
        Prog;
      Set_Link (Result.BB_Prog, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Protected_Prog;

   ---------------------
   -- New_Op_Add_Prog --
   ---------------------

   function New_Op_Add_Prog
     (Ada_Node : Node_Id := Empty)
     return W_Op_Add_Prog_Valid_Id
   is
      Result : Why_Node (W_Op_Add_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Add_Prog);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Op_Add_Prog;

   ---------------------------
   -- New_Op_Substract_Prog --
   ---------------------------

   function New_Op_Substract_Prog
     (Ada_Node : Node_Id := Empty)
     return W_Op_Substract_Prog_Valid_Id
   is
      Result : Why_Node (W_Op_Substract_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Substract_Prog);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Op_Substract_Prog;

   --------------------------
   -- New_Op_Multiply_Prog --
   --------------------------

   function New_Op_Multiply_Prog
     (Ada_Node : Node_Id := Empty)
     return W_Op_Multiply_Prog_Valid_Id
   is
      Result : Why_Node (W_Op_Multiply_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Multiply_Prog);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Op_Multiply_Prog;

   ------------------------
   -- New_Op_Divide_Prog --
   ------------------------

   function New_Op_Divide_Prog
     (Ada_Node : Node_Id := Empty)
     return W_Op_Divide_Prog_Valid_Id
   is
      Result : Why_Node (W_Op_Divide_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Divide_Prog);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Op_Divide_Prog;

   ---------------------
   -- New_Op_Mod_Prog --
   ---------------------

   function New_Op_Mod_Prog
     (Ada_Node : Node_Id := Empty)
     return W_Op_Mod_Prog_Valid_Id
   is
      Result : Why_Node (W_Op_Mod_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Mod_Prog);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Op_Mod_Prog;

   --------------------
   -- New_Op_Eq_Prog --
   --------------------

   function New_Op_Eq_Prog
     (Ada_Node : Node_Id := Empty)
     return W_Op_Eq_Prog_Valid_Id
   is
      Result : Why_Node (W_Op_Eq_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Eq_Prog);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Op_Eq_Prog;

   --------------------
   -- New_Op_Ne_Prog --
   --------------------

   function New_Op_Ne_Prog
     (Ada_Node : Node_Id := Empty)
     return W_Op_Ne_Prog_Valid_Id
   is
      Result : Why_Node (W_Op_Ne_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Ne_Prog);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Op_Ne_Prog;

   --------------------
   -- New_Op_Lt_Prog --
   --------------------

   function New_Op_Lt_Prog
     (Ada_Node : Node_Id := Empty)
     return W_Op_Lt_Prog_Valid_Id
   is
      Result : Why_Node (W_Op_Lt_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Lt_Prog);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Op_Lt_Prog;

   --------------------
   -- New_Op_Le_Prog --
   --------------------

   function New_Op_Le_Prog
     (Ada_Node : Node_Id := Empty)
     return W_Op_Le_Prog_Valid_Id
   is
      Result : Why_Node (W_Op_Le_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Le_Prog);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Op_Le_Prog;

   --------------------
   -- New_Op_Gt_Prog --
   --------------------

   function New_Op_Gt_Prog
     (Ada_Node : Node_Id := Empty)
     return W_Op_Gt_Prog_Valid_Id
   is
      Result : Why_Node (W_Op_Gt_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Gt_Prog);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Op_Gt_Prog;

   --------------------
   -- New_Op_Ge_Prog --
   --------------------

   function New_Op_Ge_Prog
     (Ada_Node : Node_Id := Empty)
     return W_Op_Ge_Prog_Valid_Id
   is
      Result : Why_Node (W_Op_Ge_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Ge_Prog);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Op_Ge_Prog;

   -------------------------
   -- New_Op_Or_Else_Prog --
   -------------------------

   function New_Op_Or_Else_Prog
     (Ada_Node : Node_Id := Empty)
     return W_Op_Or_Else_Prog_Valid_Id
   is
      Result : Why_Node (W_Op_Or_Else_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Or_Else_Prog);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Op_Or_Else_Prog;

   --------------------------
   -- New_Op_And_Then_Prog --
   --------------------------

   function New_Op_And_Then_Prog
     (Ada_Node : Node_Id := Empty)
     return W_Op_And_Then_Prog_Valid_Id
   is
      Result : Why_Node (W_Op_And_Then_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_And_Then_Prog);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Op_And_Then_Prog;

   -----------------------
   -- New_Op_Minus_Prog --
   -----------------------

   function New_Op_Minus_Prog
     (Ada_Node : Node_Id := Empty)
     return W_Op_Minus_Prog_Valid_Id
   is
      Result : Why_Node (W_Op_Minus_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Minus_Prog);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Op_Minus_Prog;

   ---------------------
   -- New_Op_Not_Prog --
   ---------------------

   function New_Op_Not_Prog
     (Ada_Node : Node_Id := Empty)
     return W_Op_Not_Prog_Valid_Id
   is
      Result : Why_Node (W_Op_Not_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Not_Prog);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Op_Not_Prog;

   ----------------
   -- New_Binder --
   ----------------

   function New_Binder
     (Ada_Node : Node_Id := Empty;
      Names    : W_Identifier_V_Array;
      Arg_Type : W_Simple_Value_Type_Valid_Id)
     return W_Binder_Valid_Id
   is
      Result : Why_Node (W_Binder);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Binder);
   begin
      Result.Ada_Node :=
        Ada_Node;
      pragma Assert (Names'Length > 0);
      Result.B_Names := New_List;
      for J in Names'Range loop
         pragma Assert
           (Identifier_Id_Kind_Valid
            (Names (J)));
         pragma Assert
           (Identifier_Id_Valid
            (Names (J)));
         Append
           (Result.B_Names,
            Names (J));
      end loop;
      Set_Link (Result.B_Names, New_Id);
      Result.B_Arg_Type :=
        Arg_Type;
      Set_Link (Result.B_Arg_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Binder;

   ----------------
   -- New_Recfun --
   ----------------

   function New_Recfun
     (Ada_Node    : Node_Id := Empty;
      Name        : W_Identifier_Valid_Id;
      Binders     : W_Binder_V_Array;
      Return_Type : W_Prog_Valid_Id;
      Variant     : W_Wf_Arg_Valid_Id;
      Pre         : W_Precondition_Valid_Id;
      Def         : W_Prog_Valid_Id)
     return W_Recfun_Valid_Id
   is
      Result : Why_Node (W_Recfun);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Recfun);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.RF_Name :=
        Name;
      Set_Link (Result.RF_Name, New_Id);
      pragma Assert (Binders'Length > 0);
      Result.RF_Binders := New_List;
      for J in Binders'Range loop
         pragma Assert
           (Binder_Id_Kind_Valid
            (Binders (J)));
         pragma Assert
           (Binder_Id_Valid
            (Binders (J)));
         Append
           (Result.RF_Binders,
            Binders (J));
      end loop;
      Set_Link (Result.RF_Binders, New_Id);
      Result.RF_Return_Type :=
        Return_Type;
      Set_Link (Result.RF_Return_Type, New_Id);
      Result.RF_Variant :=
        Variant;
      Set_Link (Result.RF_Variant, New_Id);
      Result.RF_Pre :=
        Pre;
      Set_Link (Result.RF_Pre, New_Id);
      Result.RF_Def :=
        Def;
      Set_Link (Result.RF_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Recfun;

   --------------------
   -- New_Loop_Annot --
   --------------------

   function New_Loop_Annot
     (Ada_Node  : Node_Id := Empty;
      Invariant : W_Predicate_Valid_OId := Why_Empty;
      Variant   : W_Wf_Arg_Valid_OId := Why_Empty)
     return W_Loop_Annot_Valid_Id
   is
      Result : Why_Node (W_Loop_Annot);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Loop_Annot);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.LA_Invariant :=
        Invariant;
      Set_Link (Result.LA_Invariant, New_Id);
      Result.LA_Variant :=
        Variant;
      Set_Link (Result.LA_Variant, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Loop_Annot;

   ----------------
   -- New_Wf_Arg --
   ----------------

   function New_Wf_Arg
     (Ada_Node : Node_Id := Empty;
      Def      : W_Term_Valid_Id;
      For_Id   : W_Identifier_Valid_OId := Why_Empty)
     return W_Wf_Arg_Valid_Id
   is
      Result : Why_Node (W_Wf_Arg);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Wf_Arg);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.WA_Def :=
        Def;
      Set_Link (Result.WA_Def, New_Id);
      Result.WA_For_Id :=
        For_Id;
      Set_Link (Result.WA_For_Id, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Wf_Arg;

   -----------------
   -- New_Handler --
   -----------------

   function New_Handler
     (Ada_Node  : Node_Id := Empty;
      Name      : W_Identifier_Valid_Id;
      Parameter : W_Prog_Valid_OId := Why_Empty;
      Def       : W_Prog_Valid_Id)
     return W_Handler_Valid_Id
   is
      Result : Why_Node (W_Handler);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Handler);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.H_Name :=
        Name;
      Set_Link (Result.H_Name, New_Id);
      Result.H_Parameter :=
        Parameter;
      Set_Link (Result.H_Parameter, New_Id);
      Result.H_Def :=
        Def;
      Set_Link (Result.H_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Handler;

   --------------
   -- New_File --
   --------------

   function New_File
     (Ada_Node     : Node_Id := Empty;
      Declarations : W_Declaration_V_Array := (2 .. 1 => <>))
     return W_File_Valid_Id
   is
      Result : Why_Node (W_File);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_File);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.F_Declarations := New_List;
      for J in Declarations'Range loop
         pragma Assert
           (Declaration_Id_Kind_Valid
            (Declarations (J)));
         pragma Assert
           (Declaration_Id_Valid
            (Declarations (J)));
         Append
           (Result.F_Declarations,
            Declarations (J));
      end loop;
      Set_Link (Result.F_Declarations, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_File;

   ------------------------
   -- New_Global_Binding --
   ------------------------

   function New_Global_Binding
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Valid_Id;
      Binders  : W_Binder_V_Array := (2 .. 1 => <>);
      Pre      : W_Precondition_Valid_Id;
      Def      : W_Prog_Valid_Id)
     return W_Global_Binding_Valid_Id
   is
      Result : Why_Node (W_Global_Binding);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Global_Binding);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.GB_Name :=
        Name;
      Set_Link (Result.GB_Name, New_Id);
      Result.GB_Binders := New_List;
      for J in Binders'Range loop
         pragma Assert
           (Binder_Id_Kind_Valid
            (Binders (J)));
         pragma Assert
           (Binder_Id_Valid
            (Binders (J)));
         Append
           (Result.GB_Binders,
            Binders (J));
      end loop;
      Set_Link (Result.GB_Binders, New_Id);
      Result.GB_Pre :=
        Pre;
      Set_Link (Result.GB_Pre, New_Id);
      Result.GB_Def :=
        Def;
      Set_Link (Result.GB_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Global_Binding;

   ----------------------------
   -- New_Global_Rec_Binding --
   ----------------------------

   function New_Global_Rec_Binding
     (Ada_Node : Node_Id := Empty;
      Name     : W_Recfun_Valid_Id)
     return W_Global_Rec_Binding_Valid_Id
   is
      Result : Why_Node (W_Global_Rec_Binding);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Global_Rec_Binding);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.GRB_Name :=
        Name;
      Set_Link (Result.GRB_Name, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Global_Rec_Binding;

   -------------------------------
   -- New_Parameter_Declaration --
   -------------------------------

   function New_Parameter_Declaration
     (Ada_Node       : Node_Id := Empty;
      External       : W_External_Valid_OId := Why_Empty;
      Names          : W_Identifier_V_Array;
      Parameter_Type : W_Computation_Type_Valid_Id)
     return W_Parameter_Declaration_Valid_Id
   is
      Result : Why_Node (W_Parameter_Declaration);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Parameter_Declaration);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.PD_External :=
        External;
      Set_Link (Result.PD_External, New_Id);
      pragma Assert (Names'Length > 0);
      Result.PD_Names := New_List;
      for J in Names'Range loop
         pragma Assert
           (Identifier_Id_Kind_Valid
            (Names (J)));
         pragma Assert
           (Identifier_Id_Valid
            (Names (J)));
         Append
           (Result.PD_Names,
            Names (J));
      end loop;
      Set_Link (Result.PD_Names, New_Id);
      Result.PD_Parameter_Type :=
        Parameter_Type;
      Set_Link (Result.PD_Parameter_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Parameter_Declaration;

   --------------------------------
   -- New_Global_Ref_Declaration --
   --------------------------------

   function New_Global_Ref_Declaration
     (Ada_Node       : Node_Id := Empty;
      Name           : W_Identifier_Valid_Id;
      Parameter_Type : W_Primitive_Type_Valid_Id)
     return W_Global_Ref_Declaration_Valid_Id
   is
      Result : Why_Node (W_Global_Ref_Declaration);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Global_Ref_Declaration);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.GR_Name :=
        Name;
      Set_Link (Result.GR_Name, New_Id);
      Result.GR_Parameter_Type :=
        Parameter_Type;
      Set_Link (Result.GR_Parameter_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Global_Ref_Declaration;

   -------------------------------
   -- New_Exception_Declaration --
   -------------------------------

   function New_Exception_Declaration
     (Ada_Node  : Node_Id := Empty;
      Name      : W_Identifier_Valid_Id;
      Parameter : W_Primitive_Type_Valid_OId := Why_Empty)
     return W_Exception_Declaration_Valid_Id
   is
      Result : Why_Node (W_Exception_Declaration);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Exception_Declaration);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.ED_Name :=
        Name;
      Set_Link (Result.ED_Name, New_Id);
      Result.ED_Parameter :=
        Parameter;
      Set_Link (Result.ED_Parameter, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Exception_Declaration;

   ---------------------------
   -- New_Logic_Declaration --
   ---------------------------

   function New_Logic_Declaration
     (Ada_Node : Node_Id := Empty;
      Decl     : W_Logic_Declaration_Class_Valid_Id)
     return W_Logic_Declaration_Valid_Id
   is
      Result : Why_Node (W_Logic_Declaration);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Logic_Declaration);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.LD_Decl :=
        Decl;
      Set_Link (Result.LD_Decl, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Logic_Declaration;

   -----------------------------
   -- New_Include_Declaration --
   -----------------------------

   function New_Include_Declaration
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Valid_Id)
     return W_Include_Declaration_Valid_Id
   is
      Result : Why_Node (W_Include_Declaration);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Include_Declaration);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.ID_Name :=
        Name;
      Set_Link (Result.ID_Name, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Include_Declaration;

   ------------------------------
   -- New_Unchecked_Identifier --
   ------------------------------

   function New_Unchecked_Identifier
     (Symbol : Name_Id)
     return W_Identifier_Unchecked_Id
   is
      Result : Why_Node (W_Identifier);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Identifier);
   begin
      Result.Ada_Node :=
        Empty;
      Result.Symbol :=
        Symbol;
      Result.Entity :=
        Why_Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Identifier;

   -----------------------------
   -- New_Unchecked_Type_Prop --
   -----------------------------

   function New_Unchecked_Type_Prop
     return W_Type_Prop_Unchecked_Id
   is
      Result : Why_Node (W_Type_Prop);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Type_Prop);
   begin
      Result.Ada_Node :=
        Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Type_Prop;

   ----------------------------
   -- New_Unchecked_Type_Int --
   ----------------------------

   function New_Unchecked_Type_Int
     return W_Type_Int_Unchecked_Id
   is
      Result : Why_Node (W_Type_Int);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Type_Int);
   begin
      Result.Ada_Node :=
        Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Type_Int;

   -----------------------------
   -- New_Unchecked_Type_Bool --
   -----------------------------

   function New_Unchecked_Type_Bool
     return W_Type_Bool_Unchecked_Id
   is
      Result : Why_Node (W_Type_Bool);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Type_Bool);
   begin
      Result.Ada_Node :=
        Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Type_Bool;

   -----------------------------
   -- New_Unchecked_Type_Real --
   -----------------------------

   function New_Unchecked_Type_Real
     return W_Type_Real_Unchecked_Id
   is
      Result : Why_Node (W_Type_Real);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Type_Real);
   begin
      Result.Ada_Node :=
        Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Type_Real;

   -----------------------------
   -- New_Unchecked_Type_Unit --
   -----------------------------

   function New_Unchecked_Type_Unit
     return W_Type_Unit_Unchecked_Id
   is
      Result : Why_Node (W_Type_Unit);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Type_Unit);
   begin
      Result.Ada_Node :=
        Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Type_Unit;

   ---------------------------------
   -- New_Unchecked_Abstract_Type --
   ---------------------------------

   function New_Unchecked_Abstract_Type
     return W_Abstract_Type_Unchecked_Id
   is
      Result : Why_Node (W_Abstract_Type);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Abstract_Type);
   begin
      Result.Ada_Node :=
        Empty;
      Result.AT_Name :=
        Why_Empty;
      Set_Link (Result.AT_Name, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Abstract_Type;

   ---------------------------------------
   -- New_Unchecked_Generic_Formal_Type --
   ---------------------------------------

   function New_Unchecked_Generic_Formal_Type
     return W_Generic_Formal_Type_Unchecked_Id
   is
      Result : Why_Node (W_Generic_Formal_Type);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Generic_Formal_Type);
   begin
      Result.Ada_Node :=
        Empty;
      Result.GFT_Name :=
        Why_Empty;
      Set_Link (Result.GFT_Name, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Generic_Formal_Type;

   ---------------------------------------------
   -- New_Unchecked_Generic_Actual_Type_Chain --
   ---------------------------------------------

   function New_Unchecked_Generic_Actual_Type_Chain
     return W_Generic_Actual_Type_Chain_Unchecked_Id
   is
      Result : Why_Node (W_Generic_Actual_Type_Chain);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Generic_Actual_Type_Chain);
   begin
      Result.Ada_Node :=
        Empty;
      Result.GATC_Type_Chain :=
        New_List;
      Set_Link (Result.GATC_Type_Chain, New_Id);
      Result.GATC_Name :=
        Why_Empty;
      Set_Link (Result.GATC_Name, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Generic_Actual_Type_Chain;

   ------------------------------
   -- New_Unchecked_Array_Type --
   ------------------------------

   function New_Unchecked_Array_Type
     return W_Array_Type_Unchecked_Id
   is
      Result : Why_Node (W_Array_Type);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Array_Type);
   begin
      Result.Ada_Node :=
        Empty;
      Result.AT_Component_Type :=
        Why_Empty;
      Set_Link (Result.AT_Component_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Array_Type;

   ----------------------------
   -- New_Unchecked_Ref_Type --
   ----------------------------

   function New_Unchecked_Ref_Type
     return W_Ref_Type_Unchecked_Id
   is
      Result : Why_Node (W_Ref_Type);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Ref_Type);
   begin
      Result.Ada_Node :=
        Empty;
      Result.RT_Aliased_Type :=
        Why_Empty;
      Set_Link (Result.RT_Aliased_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Ref_Type;

   ------------------------------------
   -- New_Unchecked_Computation_Type --
   ------------------------------------

   function New_Unchecked_Computation_Type
     return W_Computation_Type_Unchecked_Id
   is
      Result : Why_Node (W_Computation_Type);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Computation_Type);
   begin
      Result.Ada_Node :=
        Empty;
      Result.CS_Binders :=
        New_List;
      Set_Link (Result.CS_Binders, New_Id);
      Result.CS_Precondition :=
        Why_Empty;
      Set_Link (Result.CS_Precondition, New_Id);
      Result.CS_Result_Name :=
        Why_Empty;
      Set_Link (Result.CS_Result_Name, New_Id);
      Result.CS_Return_Type :=
        Why_Empty;
      Set_Link (Result.CS_Return_Type, New_Id);
      Result.CS_Effects :=
        Why_Empty;
      Set_Link (Result.CS_Effects, New_Id);
      Result.CS_Postcondition :=
        Why_Empty;
      Set_Link (Result.CS_Postcondition, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Computation_Type;

   ------------------------------------
   -- New_Unchecked_Integer_Constant --
   ------------------------------------

   function New_Unchecked_Integer_Constant
     (Value : Uint)
     return W_Integer_Constant_Unchecked_Id
   is
      Result : Why_Node (W_Integer_Constant);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Integer_Constant);
   begin
      Result.Ada_Node :=
        Empty;
      Result.IC_Value :=
        Value;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Integer_Constant;

   ---------------------------------
   -- New_Unchecked_Real_Constant --
   ---------------------------------

   function New_Unchecked_Real_Constant
     (Value : Ureal)
     return W_Real_Constant_Unchecked_Id
   is
      Result : Why_Node (W_Real_Constant);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Real_Constant);
   begin
      Result.Ada_Node :=
        Empty;
      Result.RC_Value :=
        Value;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Real_Constant;

   --------------------------------
   -- New_Unchecked_True_Literal --
   --------------------------------

   function New_Unchecked_True_Literal
     return W_True_Literal_Unchecked_Id
   is
      Result : Why_Node (W_True_Literal);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_True_Literal);
   begin
      Result.Ada_Node :=
        Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_True_Literal;

   ---------------------------------
   -- New_Unchecked_False_Literal --
   ---------------------------------

   function New_Unchecked_False_Literal
     return W_False_Literal_Unchecked_Id
   is
      Result : Why_Node (W_False_Literal);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_False_Literal);
   begin
      Result.Ada_Node :=
        Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_False_Literal;

   --------------------------------
   -- New_Unchecked_Void_Literal --
   --------------------------------

   function New_Unchecked_Void_Literal
     return W_Void_Literal_Unchecked_Id
   is
      Result : Why_Node (W_Void_Literal);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Void_Literal);
   begin
      Result.Ada_Node :=
        Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Void_Literal;

   -----------------------------------
   -- New_Unchecked_Arith_Operation --
   -----------------------------------

   function New_Unchecked_Arith_Operation
     return W_Arith_Operation_Unchecked_Id
   is
      Result : Why_Node (W_Arith_Operation);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Arith_Operation);
   begin
      Result.Ada_Node :=
        Empty;
      Result.AO_Left :=
        Why_Empty;
      Set_Link (Result.AO_Left, New_Id);
      Result.AO_Op :=
        Why_Empty;
      Set_Link (Result.AO_Op, New_Id);
      Result.AO_Right :=
        Why_Empty;
      Set_Link (Result.AO_Right, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Arith_Operation;

   ---------------------------------
   -- New_Unchecked_Negative_Term --
   ---------------------------------

   function New_Unchecked_Negative_Term
     return W_Negative_Term_Unchecked_Id
   is
      Result : Why_Node (W_Negative_Term);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Negative_Term);
   begin
      Result.Ada_Node :=
        Empty;
      Result.NT_Operand :=
        Why_Empty;
      Set_Link (Result.NT_Operand, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Negative_Term;

   -----------------------------------
   -- New_Unchecked_Term_Identifier --
   -----------------------------------

   function New_Unchecked_Term_Identifier
     return W_Term_Identifier_Unchecked_Id
   is
      Result : Why_Node (W_Term_Identifier);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Term_Identifier);
   begin
      Result.Ada_Node :=
        Empty;
      Result.TIL_Name :=
        Why_Empty;
      Set_Link (Result.TIL_Name, New_Id);
      Result.TIL_Label :=
        Why_Empty;
      Set_Link (Result.TIL_Label, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Term_Identifier;

   -----------------------------
   -- New_Unchecked_Operation --
   -----------------------------

   function New_Unchecked_Operation
     return W_Operation_Unchecked_Id
   is
      Result : Why_Node (W_Operation);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Operation);
   begin
      Result.Ada_Node :=
        Empty;
      Result.O_Name :=
        Why_Empty;
      Set_Link (Result.O_Name, New_Id);
      Result.O_Parameters :=
        New_List;
      Set_Link (Result.O_Parameters, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Operation;

   ------------------------------
   -- New_Unchecked_Named_Term --
   ------------------------------

   function New_Unchecked_Named_Term
     return W_Named_Term_Unchecked_Id
   is
      Result : Why_Node (W_Named_Term);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Named_Term);
   begin
      Result.Ada_Node :=
        Empty;
      Result.NT_Name :=
        Why_Empty;
      Set_Link (Result.NT_Name, New_Id);
      Result.NT_Term :=
        Why_Empty;
      Set_Link (Result.NT_Term, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Named_Term;

   ------------------------------------
   -- New_Unchecked_Conditional_Term --
   ------------------------------------

   function New_Unchecked_Conditional_Term
     return W_Conditional_Term_Unchecked_Id
   is
      Result : Why_Node (W_Conditional_Term);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Conditional_Term);
   begin
      Result.Ada_Node :=
        Empty;
      Result.CT_Condition :=
        Why_Empty;
      Set_Link (Result.CT_Condition, New_Id);
      Result.CT_Then_Part :=
        Why_Empty;
      Set_Link (Result.CT_Then_Part, New_Id);
      Result.CT_Else_Part :=
        Why_Empty;
      Set_Link (Result.CT_Else_Part, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Conditional_Term;

   ---------------------------------
   -- New_Unchecked_Matching_Term --
   ---------------------------------

   function New_Unchecked_Matching_Term
     return W_Matching_Term_Unchecked_Id
   is
      Result : Why_Node (W_Matching_Term);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Matching_Term);
   begin
      Result.Ada_Node :=
        Empty;
      Result.MT_Term :=
        Why_Empty;
      Set_Link (Result.MT_Term, New_Id);
      Result.MT_Branches :=
        New_List;
      Set_Link (Result.MT_Branches, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Matching_Term;

   --------------------------------
   -- New_Unchecked_Binding_Term --
   --------------------------------

   function New_Unchecked_Binding_Term
     return W_Binding_Term_Unchecked_Id
   is
      Result : Why_Node (W_Binding_Term);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Binding_Term);
   begin
      Result.Ada_Node :=
        Empty;
      Result.BT_Name :=
        Why_Empty;
      Set_Link (Result.BT_Name, New_Id);
      Result.BT_Def :=
        Why_Empty;
      Set_Link (Result.BT_Def, New_Id);
      Result.BT_Context :=
        Why_Empty;
      Set_Link (Result.BT_Context, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Binding_Term;

   ----------------------------------
   -- New_Unchecked_Protected_Term --
   ----------------------------------

   function New_Unchecked_Protected_Term
     return W_Protected_Term_Unchecked_Id
   is
      Result : Why_Node (W_Protected_Term);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Protected_Term);
   begin
      Result.Ada_Node :=
        Empty;
      Result.BT_Term :=
        Why_Empty;
      Set_Link (Result.BT_Term, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Protected_Term;

   --------------------------
   -- New_Unchecked_Op_Add --
   --------------------------

   function New_Unchecked_Op_Add
     return W_Op_Add_Unchecked_Id
   is
      Result : Why_Node (W_Op_Add);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Add);
   begin
      Result.Ada_Node :=
        Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Op_Add;

   --------------------------------
   -- New_Unchecked_Op_Substract --
   --------------------------------

   function New_Unchecked_Op_Substract
     return W_Op_Substract_Unchecked_Id
   is
      Result : Why_Node (W_Op_Substract);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Substract);
   begin
      Result.Ada_Node :=
        Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Op_Substract;

   -------------------------------
   -- New_Unchecked_Op_Multiply --
   -------------------------------

   function New_Unchecked_Op_Multiply
     return W_Op_Multiply_Unchecked_Id
   is
      Result : Why_Node (W_Op_Multiply);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Multiply);
   begin
      Result.Ada_Node :=
        Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Op_Multiply;

   -----------------------------
   -- New_Unchecked_Op_Divide --
   -----------------------------

   function New_Unchecked_Op_Divide
     return W_Op_Divide_Unchecked_Id
   is
      Result : Why_Node (W_Op_Divide);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Divide);
   begin
      Result.Ada_Node :=
        Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Op_Divide;

   -----------------------------
   -- New_Unchecked_Op_Modulo --
   -----------------------------

   function New_Unchecked_Op_Modulo
     return W_Op_Modulo_Unchecked_Id
   is
      Result : Why_Node (W_Op_Modulo);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Modulo);
   begin
      Result.Ada_Node :=
        Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Op_Modulo;

   -------------------------------------
   -- New_Unchecked_True_Literal_Pred --
   -------------------------------------

   function New_Unchecked_True_Literal_Pred
     return W_True_Literal_Pred_Unchecked_Id
   is
      Result : Why_Node (W_True_Literal_Pred);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_True_Literal_Pred);
   begin
      Result.Ada_Node :=
        Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_True_Literal_Pred;

   --------------------------------------
   -- New_Unchecked_False_Literal_Pred --
   --------------------------------------

   function New_Unchecked_False_Literal_Pred
     return W_False_Literal_Pred_Unchecked_Id
   is
      Result : Why_Node (W_False_Literal_Pred);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_False_Literal_Pred);
   begin
      Result.Ada_Node :=
        Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_False_Literal_Pred;

   ----------------------------------------
   -- New_Unchecked_Predicate_Identifier --
   ----------------------------------------

   function New_Unchecked_Predicate_Identifier
     return W_Predicate_Identifier_Unchecked_Id
   is
      Result : Why_Node (W_Predicate_Identifier);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Predicate_Identifier);
   begin
      Result.Ada_Node :=
        Empty;
      Result.PID_Name :=
        Why_Empty;
      Set_Link (Result.PID_Name, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Predicate_Identifier;

   --------------------------------------
   -- New_Unchecked_Predicate_Instance --
   --------------------------------------

   function New_Unchecked_Predicate_Instance
     return W_Predicate_Instance_Unchecked_Id
   is
      Result : Why_Node (W_Predicate_Instance);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Predicate_Instance);
   begin
      Result.Ada_Node :=
        Empty;
      Result.PIN_Name :=
        Why_Empty;
      Set_Link (Result.PIN_Name, New_Id);
      Result.PIN_Parameters :=
        New_List;
      Set_Link (Result.PIN_Parameters, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Predicate_Instance;

   ---------------------------------
   -- New_Unchecked_Related_Terms --
   ---------------------------------

   function New_Unchecked_Related_Terms
     return W_Related_Terms_Unchecked_Id
   is
      Result : Why_Node (W_Related_Terms);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Related_Terms);
   begin
      Result.Ada_Node :=
        Empty;
      Result.RT_Left :=
        Why_Empty;
      Set_Link (Result.RT_Left, New_Id);
      Result.RT_Op :=
        Why_Empty;
      Set_Link (Result.RT_Op, New_Id);
      Result.RT_Right :=
        Why_Empty;
      Set_Link (Result.RT_Right, New_Id);
      Result.RT_Op2 :=
        Why_Empty;
      Set_Link (Result.RT_Op2, New_Id);
      Result.RT_Right2 :=
        Why_Empty;
      Set_Link (Result.RT_Right2, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Related_Terms;

   -------------------------------
   -- New_Unchecked_Implication --
   -------------------------------

   function New_Unchecked_Implication
     return W_Implication_Unchecked_Id
   is
      Result : Why_Node (W_Implication);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Implication);
   begin
      Result.Ada_Node :=
        Empty;
      Result.ITOC_Left :=
        Why_Empty;
      Set_Link (Result.ITOC_Left, New_Id);
      Result.ITOC_Right :=
        Why_Empty;
      Set_Link (Result.ITOC_Right, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Implication;

   -------------------------------
   -- New_Unchecked_Equivalence --
   -------------------------------

   function New_Unchecked_Equivalence
     return W_Equivalence_Unchecked_Id
   is
      Result : Why_Node (W_Equivalence);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Equivalence);
   begin
      Result.Ada_Node :=
        Empty;
      Result.ITOC_Left :=
        Why_Empty;
      Set_Link (Result.ITOC_Left, New_Id);
      Result.ITOC_Right :=
        Why_Empty;
      Set_Link (Result.ITOC_Right, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Equivalence;

   -------------------------------
   -- New_Unchecked_Disjunction --
   -------------------------------

   function New_Unchecked_Disjunction
     return W_Disjunction_Unchecked_Id
   is
      Result : Why_Node (W_Disjunction);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Disjunction);
   begin
      Result.Ada_Node :=
        Empty;
      Result.ITOC_Left :=
        Why_Empty;
      Set_Link (Result.ITOC_Left, New_Id);
      Result.ITOC_Right :=
        Why_Empty;
      Set_Link (Result.ITOC_Right, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Disjunction;

   -------------------------------
   -- New_Unchecked_Conjunction --
   -------------------------------

   function New_Unchecked_Conjunction
     return W_Conjunction_Unchecked_Id
   is
      Result : Why_Node (W_Conjunction);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Conjunction);
   begin
      Result.Ada_Node :=
        Empty;
      Result.ITOC_Left :=
        Why_Empty;
      Set_Link (Result.ITOC_Left, New_Id);
      Result.ITOC_Right :=
        Why_Empty;
      Set_Link (Result.ITOC_Right, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Conjunction;

   ----------------------------
   -- New_Unchecked_Negation --
   ----------------------------

   function New_Unchecked_Negation
     return W_Negation_Unchecked_Id
   is
      Result : Why_Node (W_Negation);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Negation);
   begin
      Result.Ada_Node :=
        Empty;
      Result.N_Operand :=
        Why_Empty;
      Set_Link (Result.N_Operand, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Negation;

   ------------------------------------
   -- New_Unchecked_Conditional_Pred --
   ------------------------------------

   function New_Unchecked_Conditional_Pred
     return W_Conditional_Pred_Unchecked_Id
   is
      Result : Why_Node (W_Conditional_Pred);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Conditional_Pred);
   begin
      Result.Ada_Node :=
        Empty;
      Result.CPD_Condition :=
        Why_Empty;
      Set_Link (Result.CPD_Condition, New_Id);
      Result.CPD_Then_Part :=
        Why_Empty;
      Set_Link (Result.CPD_Then_Part, New_Id);
      Result.CPD_Else_Part :=
        Why_Empty;
      Set_Link (Result.CPD_Else_Part, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Conditional_Pred;

   --------------------------------
   -- New_Unchecked_Binding_Pred --
   --------------------------------

   function New_Unchecked_Binding_Pred
     return W_Binding_Pred_Unchecked_Id
   is
      Result : Why_Node (W_Binding_Pred);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Binding_Pred);
   begin
      Result.Ada_Node :=
        Empty;
      Result.BPD_Name :=
        Why_Empty;
      Set_Link (Result.BPD_Name, New_Id);
      Result.BPD_Def :=
        Why_Empty;
      Set_Link (Result.BPD_Def, New_Id);
      Result.BPD_Context :=
        Why_Empty;
      Set_Link (Result.BPD_Context, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Binding_Pred;

   -------------------------------------
   -- New_Unchecked_Universal_Quantif --
   -------------------------------------

   function New_Unchecked_Universal_Quantif
     return W_Universal_Quantif_Unchecked_Id
   is
      Result : Why_Node (W_Universal_Quantif);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Universal_Quantif);
   begin
      Result.Ada_Node :=
        Empty;
      Result.UQ_Variables :=
        New_List;
      Set_Link (Result.UQ_Variables, New_Id);
      Result.UQ_Var_Type :=
        Why_Empty;
      Set_Link (Result.UQ_Var_Type, New_Id);
      Result.UQ_Triggers :=
        Why_Empty;
      Set_Link (Result.UQ_Triggers, New_Id);
      Result.UQ_Pred :=
        Why_Empty;
      Set_Link (Result.UQ_Pred, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Universal_Quantif;

   ---------------------------------------
   -- New_Unchecked_Existential_Quantif --
   ---------------------------------------

   function New_Unchecked_Existential_Quantif
     return W_Existential_Quantif_Unchecked_Id
   is
      Result : Why_Node (W_Existential_Quantif);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Existential_Quantif);
   begin
      Result.Ada_Node :=
        Empty;
      Result.EQ_Variables :=
        New_List;
      Set_Link (Result.EQ_Variables, New_Id);
      Result.EQ_Var_Type :=
        Why_Empty;
      Set_Link (Result.EQ_Var_Type, New_Id);
      Result.EQ_Pred :=
        Why_Empty;
      Set_Link (Result.EQ_Pred, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Existential_Quantif;

   -----------------------------------
   -- New_Unchecked_Named_Predicate --
   -----------------------------------

   function New_Unchecked_Named_Predicate
     return W_Named_Predicate_Unchecked_Id
   is
      Result : Why_Node (W_Named_Predicate);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Named_Predicate);
   begin
      Result.Ada_Node :=
        Empty;
      Result.NP_Name :=
        Why_Empty;
      Set_Link (Result.NP_Name, New_Id);
      Result.NP_Pred :=
        Why_Empty;
      Set_Link (Result.NP_Pred, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Named_Predicate;

   ---------------------------------------
   -- New_Unchecked_Protected_Predicate --
   ---------------------------------------

   function New_Unchecked_Protected_Predicate
     return W_Protected_Predicate_Unchecked_Id
   is
      Result : Why_Node (W_Protected_Predicate);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Protected_Predicate);
   begin
      Result.Ada_Node :=
        Empty;
      Result.PP_Pred :=
        Why_Empty;
      Set_Link (Result.PP_Pred, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Protected_Predicate;

   ---------------------------
   -- New_Unchecked_Pattern --
   ---------------------------

   function New_Unchecked_Pattern
     return W_Pattern_Unchecked_Id
   is
      Result : Why_Node (W_Pattern);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Pattern);
   begin
      Result.Ada_Node :=
        Empty;
      Result.PAT_Constr :=
        Why_Empty;
      Set_Link (Result.PAT_Constr, New_Id);
      Result.PAT_Args :=
        New_List;
      Set_Link (Result.PAT_Args, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Pattern;

   ------------------------------
   -- New_Unchecked_Match_Case --
   ------------------------------

   function New_Unchecked_Match_Case
     return W_Match_Case_Unchecked_Id
   is
      Result : Why_Node (W_Match_Case);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Match_Case);
   begin
      Result.Ada_Node :=
        Empty;
      Result.MC_Pattern :=
        Why_Empty;
      Set_Link (Result.MC_Pattern, New_Id);
      Result.MC_Term :=
        Why_Empty;
      Set_Link (Result.MC_Term, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Match_Case;

   ----------------------------
   -- New_Unchecked_Triggers --
   ----------------------------

   function New_Unchecked_Triggers
     return W_Triggers_Unchecked_Id
   is
      Result : Why_Node (W_Triggers);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Triggers);
   begin
      Result.Ada_Node :=
        Empty;
      Result.TRS_Triggers :=
        New_List;
      Set_Link (Result.TRS_Triggers, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Triggers;

   ---------------------------
   -- New_Unchecked_Trigger --
   ---------------------------

   function New_Unchecked_Trigger
     return W_Trigger_Unchecked_Id
   is
      Result : Why_Node (W_Trigger);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Trigger);
   begin
      Result.Ada_Node :=
        Empty;
      Result.TRI_Terms :=
        New_List;
      Set_Link (Result.TRI_Terms, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Trigger;

   --------------------------
   -- New_Unchecked_Rel_Eq --
   --------------------------

   function New_Unchecked_Rel_Eq
     return W_Rel_Eq_Unchecked_Id
   is
      Result : Why_Node (W_Rel_Eq);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Rel_Eq);
   begin
      Result.Ada_Node :=
        Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Rel_Eq;

   --------------------------
   -- New_Unchecked_Rel_Ne --
   --------------------------

   function New_Unchecked_Rel_Ne
     return W_Rel_Ne_Unchecked_Id
   is
      Result : Why_Node (W_Rel_Ne);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Rel_Ne);
   begin
      Result.Ada_Node :=
        Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Rel_Ne;

   --------------------------
   -- New_Unchecked_Rel_Lt --
   --------------------------

   function New_Unchecked_Rel_Lt
     return W_Rel_Lt_Unchecked_Id
   is
      Result : Why_Node (W_Rel_Lt);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Rel_Lt);
   begin
      Result.Ada_Node :=
        Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Rel_Lt;

   --------------------------
   -- New_Unchecked_Rel_Le --
   --------------------------

   function New_Unchecked_Rel_Le
     return W_Rel_Le_Unchecked_Id
   is
      Result : Why_Node (W_Rel_Le);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Rel_Le);
   begin
      Result.Ada_Node :=
        Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Rel_Le;

   --------------------------
   -- New_Unchecked_Rel_Gt --
   --------------------------

   function New_Unchecked_Rel_Gt
     return W_Rel_Gt_Unchecked_Id
   is
      Result : Why_Node (W_Rel_Gt);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Rel_Gt);
   begin
      Result.Ada_Node :=
        Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Rel_Gt;

   --------------------------
   -- New_Unchecked_Rel_Ge --
   --------------------------

   function New_Unchecked_Rel_Ge
     return W_Rel_Ge_Unchecked_Id
   is
      Result : Why_Node (W_Rel_Ge);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Rel_Ge);
   begin
      Result.Ada_Node :=
        Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Rel_Ge;

   ------------------------
   -- New_Unchecked_Type --
   ------------------------

   function New_Unchecked_Type
     return W_Type_Unchecked_Id
   is
      Result : Why_Node (W_Type);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Type);
   begin
      Result.Ada_Node :=
        Empty;
      Result.T_External :=
        Why_Empty;
      Set_Link (Result.T_External, New_Id);
      Result.T_Type_Parameters :=
        New_List;
      Set_Link (Result.T_Type_Parameters, New_Id);
      Result.T_Name :=
        Why_Empty;
      Set_Link (Result.T_Name, New_Id);
      Result.T_Definition :=
        Why_Empty;
      Set_Link (Result.T_Definition, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Type;

   -------------------------
   -- New_Unchecked_Logic --
   -------------------------

   function New_Unchecked_Logic
     return W_Logic_Unchecked_Id
   is
      Result : Why_Node (W_Logic);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Logic);
   begin
      Result.Ada_Node :=
        Empty;
      Result.L_External :=
        Why_Empty;
      Set_Link (Result.L_External, New_Id);
      Result.L_Names :=
        New_List;
      Set_Link (Result.L_Names, New_Id);
      Result.L_Logic_Type :=
        Why_Empty;
      Set_Link (Result.L_Logic_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Logic;

   ----------------------------
   -- New_Unchecked_Function --
   ----------------------------

   function New_Unchecked_Function
     return W_Function_Unchecked_Id
   is
      Result : Why_Node (W_Function);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Function);
   begin
      Result.Ada_Node :=
        Empty;
      Result.F_Name :=
        Why_Empty;
      Set_Link (Result.F_Name, New_Id);
      Result.F_Binders :=
        New_List;
      Set_Link (Result.F_Binders, New_Id);
      Result.F_Return_Type :=
        Why_Empty;
      Set_Link (Result.F_Return_Type, New_Id);
      Result.F_Def :=
        Why_Empty;
      Set_Link (Result.F_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Function;

   ----------------------------------------
   -- New_Unchecked_Predicate_Definition --
   ----------------------------------------

   function New_Unchecked_Predicate_Definition
     return W_Predicate_Definition_Unchecked_Id
   is
      Result : Why_Node (W_Predicate_Definition);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Predicate_Definition);
   begin
      Result.Ada_Node :=
        Empty;
      Result.P_Name :=
        Why_Empty;
      Set_Link (Result.P_Name, New_Id);
      Result.P_Binders :=
        New_List;
      Set_Link (Result.P_Binders, New_Id);
      Result.P_Def :=
        Why_Empty;
      Set_Link (Result.P_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Predicate_Definition;

   -----------------------------
   -- New_Unchecked_Inductive --
   -----------------------------

   function New_Unchecked_Inductive
     return W_Inductive_Unchecked_Id
   is
      Result : Why_Node (W_Inductive);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Inductive);
   begin
      Result.Ada_Node :=
        Empty;
      Result.I_Name :=
        Why_Empty;
      Set_Link (Result.I_Name, New_Id);
      Result.I_Logic_Type :=
        Why_Empty;
      Set_Link (Result.I_Logic_Type, New_Id);
      Result.I_Def :=
        New_List;
      Set_Link (Result.I_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Inductive;

   -------------------------
   -- New_Unchecked_Axiom --
   -------------------------

   function New_Unchecked_Axiom
     return W_Axiom_Unchecked_Id
   is
      Result : Why_Node (W_Axiom);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Axiom);
   begin
      Result.Ada_Node :=
        Empty;
      Result.AX_Name :=
        Why_Empty;
      Set_Link (Result.AX_Name, New_Id);
      Result.AX_Def :=
        Why_Empty;
      Set_Link (Result.AX_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Axiom;

   ------------------------
   -- New_Unchecked_Goal --
   ------------------------

   function New_Unchecked_Goal
     return W_Goal_Unchecked_Id
   is
      Result : Why_Node (W_Goal);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Goal);
   begin
      Result.Ada_Node :=
        Empty;
      Result.G_Name :=
        Why_Empty;
      Set_Link (Result.G_Name, New_Id);
      Result.G_Def :=
        Why_Empty;
      Set_Link (Result.G_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Goal;

   ----------------------------
   -- New_Unchecked_External --
   ----------------------------

   function New_Unchecked_External
     return W_External_Unchecked_Id
   is
      Result : Why_Node (W_External);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_External);
   begin
      Result.Ada_Node :=
        Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_External;

   ------------------------------
   -- New_Unchecked_Logic_Type --
   ------------------------------

   function New_Unchecked_Logic_Type
     return W_Logic_Type_Unchecked_Id
   is
      Result : Why_Node (W_Logic_Type);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Logic_Type);
   begin
      Result.Ada_Node :=
        Empty;
      Result.LT_Arg_Types :=
        New_List;
      Set_Link (Result.LT_Arg_Types, New_Id);
      Result.LT_Return_Type :=
        Why_Empty;
      Set_Link (Result.LT_Return_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Logic_Type;

   --------------------------------
   -- New_Unchecked_Logic_Binder --
   --------------------------------

   function New_Unchecked_Logic_Binder
     return W_Logic_Binder_Unchecked_Id
   is
      Result : Why_Node (W_Logic_Binder);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Logic_Binder);
   begin
      Result.Ada_Node :=
        Empty;
      Result.LB_Name :=
        Why_Empty;
      Set_Link (Result.LB_Name, New_Id);
      Result.LB_Param_Type :=
        Why_Empty;
      Set_Link (Result.LB_Param_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Logic_Binder;

   ----------------------------------
   -- New_Unchecked_Inductive_Case --
   ----------------------------------

   function New_Unchecked_Inductive_Case
     return W_Inductive_Case_Unchecked_Id
   is
      Result : Why_Node (W_Inductive_Case);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Inductive_Case);
   begin
      Result.Ada_Node :=
        Empty;
      Result.IC_Name :=
        Why_Empty;
      Set_Link (Result.IC_Name, New_Id);
      Result.IC_Pred :=
        Why_Empty;
      Set_Link (Result.IC_Pred, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Inductive_Case;

   -----------------------------------------------
   -- New_Unchecked_Transparent_Type_Definition --
   -----------------------------------------------

   function New_Unchecked_Transparent_Type_Definition
     return W_Transparent_Type_Definition_Unchecked_Id
   is
      Result : Why_Node (W_Transparent_Type_Definition);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Transparent_Type_Definition);
   begin
      Result.Ada_Node :=
        Empty;
      Result.Tr_Type_Definition :=
        Why_Empty;
      Set_Link (Result.Tr_Type_Definition, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Transparent_Type_Definition;

   ----------------------------------
   -- New_Unchecked_Adt_Definition --
   ----------------------------------

   function New_Unchecked_Adt_Definition
     return W_Adt_Definition_Unchecked_Id
   is
      Result : Why_Node (W_Adt_Definition);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Adt_Definition);
   begin
      Result.Ada_Node :=
        Empty;
      Result.Adt_Constructors :=
        New_List;
      Set_Link (Result.Adt_Constructors, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Adt_Definition;

   -------------------------------
   -- New_Unchecked_Constr_Decl --
   -------------------------------

   function New_Unchecked_Constr_Decl
     return W_Constr_Decl_Unchecked_Id
   is
      Result : Why_Node (W_Constr_Decl);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Constr_Decl);
   begin
      Result.Ada_Node :=
        Empty;
      Result.C_Name :=
        Why_Empty;
      Set_Link (Result.C_Name, New_Id);
      Result.C_Arg_List :=
        New_List;
      Set_Link (Result.C_Arg_List, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Constr_Decl;

   ---------------------------
   -- New_Unchecked_Effects --
   ---------------------------

   function New_Unchecked_Effects
     return W_Effects_Unchecked_Id
   is
      Result : Why_Node (W_Effects);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Effects);
   begin
      Result.Ada_Node :=
        Empty;
      Result.E_Reads :=
        New_List;
      Set_Link (Result.E_Reads, New_Id);
      Result.E_Writes :=
        New_List;
      Set_Link (Result.E_Writes, New_Id);
      Result.E_Raises :=
        New_List;
      Set_Link (Result.E_Raises, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Effects;

   --------------------------------
   -- New_Unchecked_Precondition --
   --------------------------------

   function New_Unchecked_Precondition
     return W_Precondition_Unchecked_Id
   is
      Result : Why_Node (W_Precondition);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Precondition);
   begin
      Result.Ada_Node :=
        Empty;
      Result.PRE_Pred :=
        Why_Empty;
      Set_Link (Result.PRE_Pred, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Precondition;

   ---------------------------------
   -- New_Unchecked_Postcondition --
   ---------------------------------

   function New_Unchecked_Postcondition
     return W_Postcondition_Unchecked_Id
   is
      Result : Why_Node (W_Postcondition);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Postcondition);
   begin
      Result.Ada_Node :=
        Empty;
      Result.POST_Pred :=
        Why_Empty;
      Set_Link (Result.POST_Pred, New_Id);
      Result.POST_Handlers :=
        New_List;
      Set_Link (Result.POST_Handlers, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Postcondition;

   ---------------------------------
   -- New_Unchecked_Exn_Condition --
   ---------------------------------

   function New_Unchecked_Exn_Condition
     return W_Exn_Condition_Unchecked_Id
   is
      Result : Why_Node (W_Exn_Condition);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Exn_Condition);
   begin
      Result.Ada_Node :=
        Empty;
      Result.EC_Exn_Case :=
        Why_Empty;
      Set_Link (Result.EC_Exn_Case, New_Id);
      Result.EC_Pred :=
        Why_Empty;
      Set_Link (Result.EC_Pred, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Exn_Condition;

   ---------------------------------
   -- New_Unchecked_Prog_Constant --
   ---------------------------------

   function New_Unchecked_Prog_Constant
     return W_Prog_Constant_Unchecked_Id
   is
      Result : Why_Node (W_Prog_Constant);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Prog_Constant);
   begin
      Result.Ada_Node :=
        Empty;
      Result.PC_Def :=
        Why_Empty;
      Set_Link (Result.PC_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Prog_Constant;

   -----------------------------------
   -- New_Unchecked_Prog_Identifier --
   -----------------------------------

   function New_Unchecked_Prog_Identifier
     return W_Prog_Identifier_Unchecked_Id
   is
      Result : Why_Node (W_Prog_Identifier);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Prog_Identifier);
   begin
      Result.Ada_Node :=
        Empty;
      Result.PI_Def :=
        Why_Empty;
      Set_Link (Result.PI_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Prog_Identifier;

   ----------------------------
   -- New_Unchecked_Any_Expr --
   ----------------------------

   function New_Unchecked_Any_Expr
     return W_Any_Expr_Unchecked_Id
   is
      Result : Why_Node (W_Any_Expr);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Any_Expr);
   begin
      Result.Ada_Node :=
        Empty;
      Result.AE_Any_Type :=
        Why_Empty;
      Set_Link (Result.AE_Any_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Any_Expr;

   -------------------------
   -- New_Unchecked_Deref --
   -------------------------

   function New_Unchecked_Deref
     return W_Deref_Unchecked_Id
   is
      Result : Why_Node (W_Deref);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Deref);
   begin
      Result.Ada_Node :=
        Empty;
      Result.D_Ref :=
        Why_Empty;
      Set_Link (Result.D_Ref, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Deref;

   ------------------------------
   -- New_Unchecked_Assignment --
   ------------------------------

   function New_Unchecked_Assignment
     return W_Assignment_Unchecked_Id
   is
      Result : Why_Node (W_Assignment);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Assignment);
   begin
      Result.Ada_Node :=
        Empty;
      Result.A_Name :=
        Why_Empty;
      Set_Link (Result.A_Name, New_Id);
      Result.A_Value :=
        Why_Empty;
      Set_Link (Result.A_Value, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Assignment;

   --------------------------------
   -- New_Unchecked_Array_Access --
   --------------------------------

   function New_Unchecked_Array_Access
     return W_Array_Access_Unchecked_Id
   is
      Result : Why_Node (W_Array_Access);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Array_Access);
   begin
      Result.Ada_Node :=
        Empty;
      Result.AA_Name :=
        Why_Empty;
      Set_Link (Result.AA_Name, New_Id);
      Result.AA_Index :=
        Why_Empty;
      Set_Link (Result.AA_Index, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Array_Access;

   --------------------------------
   -- New_Unchecked_Array_Update --
   --------------------------------

   function New_Unchecked_Array_Update
     return W_Array_Update_Unchecked_Id
   is
      Result : Why_Node (W_Array_Update);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Array_Update);
   begin
      Result.Ada_Node :=
        Empty;
      Result.AU_Name :=
        Why_Empty;
      Set_Link (Result.AU_Name, New_Id);
      Result.AU_Index :=
        Why_Empty;
      Set_Link (Result.AU_Index, New_Id);
      Result.AU_Value :=
        Why_Empty;
      Set_Link (Result.AU_Value, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Array_Update;

   ------------------------------
   -- New_Unchecked_Infix_Call --
   ------------------------------

   function New_Unchecked_Infix_Call
     return W_Infix_Call_Unchecked_Id
   is
      Result : Why_Node (W_Infix_Call);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Infix_Call);
   begin
      Result.Ada_Node :=
        Empty;
      Result.IC_Left :=
        Why_Empty;
      Set_Link (Result.IC_Left, New_Id);
      Result.IC_Infix :=
        Why_Empty;
      Set_Link (Result.IC_Infix, New_Id);
      Result.IC_Right :=
        Why_Empty;
      Set_Link (Result.IC_Right, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Infix_Call;

   -------------------------------
   -- New_Unchecked_Prefix_Call --
   -------------------------------

   function New_Unchecked_Prefix_Call
     return W_Prefix_Call_Unchecked_Id
   is
      Result : Why_Node (W_Prefix_Call);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Prefix_Call);
   begin
      Result.Ada_Node :=
        Empty;
      Result.PC_Prefix :=
        Why_Empty;
      Set_Link (Result.PC_Prefix, New_Id);
      Result.PC_Operand :=
        Why_Empty;
      Set_Link (Result.PC_Operand, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Prefix_Call;

   --------------------------------
   -- New_Unchecked_Binding_Prog --
   --------------------------------

   function New_Unchecked_Binding_Prog
     return W_Binding_Prog_Unchecked_Id
   is
      Result : Why_Node (W_Binding_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Binding_Prog);
   begin
      Result.Ada_Node :=
        Empty;
      Result.BPG_Name :=
        Why_Empty;
      Set_Link (Result.BPG_Name, New_Id);
      Result.BPG_Def :=
        Why_Empty;
      Set_Link (Result.BPG_Def, New_Id);
      Result.BPG_Context :=
        Why_Empty;
      Set_Link (Result.BPG_Context, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Binding_Prog;

   -------------------------------
   -- New_Unchecked_Binding_Ref --
   -------------------------------

   function New_Unchecked_Binding_Ref
     return W_Binding_Ref_Unchecked_Id
   is
      Result : Why_Node (W_Binding_Ref);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Binding_Ref);
   begin
      Result.Ada_Node :=
        Empty;
      Result.BPG_Name :=
        Why_Empty;
      Set_Link (Result.BPG_Name, New_Id);
      Result.BPG_Def :=
        Why_Empty;
      Set_Link (Result.BPG_Def, New_Id);
      Result.BPG_Context :=
        Why_Empty;
      Set_Link (Result.BPG_Context, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Binding_Ref;

   ------------------------------------
   -- New_Unchecked_Conditional_Prog --
   ------------------------------------

   function New_Unchecked_Conditional_Prog
     return W_Conditional_Prog_Unchecked_Id
   is
      Result : Why_Node (W_Conditional_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Conditional_Prog);
   begin
      Result.Ada_Node :=
        Empty;
      Result.CPG_Condition :=
        Why_Empty;
      Set_Link (Result.CPG_Condition, New_Id);
      Result.CPG_Then_Part :=
        Why_Empty;
      Set_Link (Result.CPG_Then_Part, New_Id);
      Result.CPG_Else_Part :=
        Why_Empty;
      Set_Link (Result.CPG_Else_Part, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Conditional_Prog;

   ------------------------------
   -- New_Unchecked_While_Loop --
   ------------------------------

   function New_Unchecked_While_Loop
     return W_While_Loop_Unchecked_Id
   is
      Result : Why_Node (W_While_Loop);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_While_Loop);
   begin
      Result.Ada_Node :=
        Empty;
      Result.WL_Condition :=
        Why_Empty;
      Set_Link (Result.WL_Condition, New_Id);
      Result.WL_Annotation :=
        Why_Empty;
      Set_Link (Result.WL_Annotation, New_Id);
      Result.WL_Loop_Content :=
        Why_Empty;
      Set_Link (Result.WL_Loop_Content, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_While_Loop;

   --------------------------------------
   -- New_Unchecked_Statement_Sequence --
   --------------------------------------

   function New_Unchecked_Statement_Sequence
     return W_Statement_Sequence_Unchecked_Id
   is
      Result : Why_Node (W_Statement_Sequence);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Statement_Sequence);
   begin
      Result.Ada_Node :=
        Empty;
      Result.SS_Statements :=
        New_List;
      Set_Link (Result.SS_Statements, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Statement_Sequence;

   -------------------------
   -- New_Unchecked_Label --
   -------------------------

   function New_Unchecked_Label
     return W_Label_Unchecked_Id
   is
      Result : Why_Node (W_Label);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Label);
   begin
      Result.Ada_Node :=
        Empty;
      Result.L_Name :=
        Why_Empty;
      Set_Link (Result.L_Name, New_Id);
      Result.L_Def :=
        Why_Empty;
      Set_Link (Result.L_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Label;

   --------------------------
   -- New_Unchecked_Assert --
   --------------------------

   function New_Unchecked_Assert
     return W_Assert_Unchecked_Id
   is
      Result : Why_Node (W_Assert);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Assert);
   begin
      Result.Ada_Node :=
        Empty;
      Result.AS_Preds :=
        New_List;
      Set_Link (Result.AS_Preds, New_Id);
      Result.AS_Prog :=
        Why_Empty;
      Set_Link (Result.AS_Prog, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Assert;

   ----------------------------------
   -- New_Unchecked_Post_Assertion --
   ----------------------------------

   function New_Unchecked_Post_Assertion
     return W_Post_Assertion_Unchecked_Id
   is
      Result : Why_Node (W_Post_Assertion);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Post_Assertion);
   begin
      Result.Ada_Node :=
        Empty;
      Result.PA_Prog :=
        Why_Empty;
      Set_Link (Result.PA_Prog, New_Id);
      Result.PA_Post :=
        Why_Empty;
      Set_Link (Result.PA_Post, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Post_Assertion;

   ------------------------------------
   -- New_Unchecked_Opaque_Assertion --
   ------------------------------------

   function New_Unchecked_Opaque_Assertion
     return W_Opaque_Assertion_Unchecked_Id
   is
      Result : Why_Node (W_Opaque_Assertion);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Opaque_Assertion);
   begin
      Result.Ada_Node :=
        Empty;
      Result.PA_Prog :=
        Why_Empty;
      Set_Link (Result.PA_Prog, New_Id);
      Result.PA_Post :=
        Why_Empty;
      Set_Link (Result.PA_Post, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Opaque_Assertion;

   ---------------------------
   -- New_Unchecked_Fun_Def --
   ---------------------------

   function New_Unchecked_Fun_Def
     return W_Fun_Def_Unchecked_Id
   is
      Result : Why_Node (W_Fun_Def);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Fun_Def);
   begin
      Result.Ada_Node :=
        Empty;
      Result.FD_Binders :=
        New_List;
      Set_Link (Result.FD_Binders, New_Id);
      Result.FD_Pre :=
        Why_Empty;
      Set_Link (Result.FD_Pre, New_Id);
      Result.FD_Def :=
        Why_Empty;
      Set_Link (Result.FD_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Fun_Def;

   -------------------------------
   -- New_Unchecked_Binding_Fun --
   -------------------------------

   function New_Unchecked_Binding_Fun
     return W_Binding_Fun_Unchecked_Id
   is
      Result : Why_Node (W_Binding_Fun);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Binding_Fun);
   begin
      Result.Ada_Node :=
        Empty;
      Result.BF_Name :=
        Why_Empty;
      Set_Link (Result.BF_Name, New_Id);
      Result.BF_Binders :=
        New_List;
      Set_Link (Result.BF_Binders, New_Id);
      Result.BF_Pre :=
        Why_Empty;
      Set_Link (Result.BF_Pre, New_Id);
      Result.BF_Def :=
        Why_Empty;
      Set_Link (Result.BF_Def, New_Id);
      Result.BF_Context :=
        Why_Empty;
      Set_Link (Result.BF_Context, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Binding_Fun;

   -------------------------------
   -- New_Unchecked_Binding_Rec --
   -------------------------------

   function New_Unchecked_Binding_Rec
     return W_Binding_Rec_Unchecked_Id
   is
      Result : Why_Node (W_Binding_Rec);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Binding_Rec);
   begin
      Result.Ada_Node :=
        Empty;
      Result.BR_Recfun :=
        Why_Empty;
      Set_Link (Result.BR_Recfun, New_Id);
      Result.BR_Context :=
        Why_Empty;
      Set_Link (Result.BR_Context, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Binding_Rec;

   -----------------------------
   -- New_Unchecked_Prog_Call --
   -----------------------------

   function New_Unchecked_Prog_Call
     return W_Prog_Call_Unchecked_Id
   is
      Result : Why_Node (W_Prog_Call);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Prog_Call);
   begin
      Result.Ada_Node :=
        Empty;
      Result.PS_Name :=
        Why_Empty;
      Set_Link (Result.PS_Name, New_Id);
      Result.PS_Progs :=
        New_List;
      Set_Link (Result.PS_Progs, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Prog_Call;

   -----------------------------------
   -- New_Unchecked_Raise_Statement --
   -----------------------------------

   function New_Unchecked_Raise_Statement
     return W_Raise_Statement_Unchecked_Id
   is
      Result : Why_Node (W_Raise_Statement);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Raise_Statement);
   begin
      Result.Ada_Node :=
        Empty;
      Result.RS_Name :=
        Why_Empty;
      Set_Link (Result.RS_Name, New_Id);
      Result.RS_Exn_Type :=
        Why_Empty;
      Set_Link (Result.RS_Exn_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Raise_Statement;

   ---------------------------------------------------
   -- New_Unchecked_Raise_Statement_With_Parameters --
   ---------------------------------------------------

   function New_Unchecked_Raise_Statement_With_Parameters
     return W_Raise_Statement_With_Parameters_Unchecked_Id
   is
      Result : Why_Node (W_Raise_Statement_With_Parameters);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Raise_Statement_With_Parameters);
   begin
      Result.Ada_Node :=
        Empty;
      Result.RSWP_Name :=
        Why_Empty;
      Set_Link (Result.RSWP_Name, New_Id);
      Result.RSWP_Parameter :=
        Why_Empty;
      Set_Link (Result.RSWP_Parameter, New_Id);
      Result.RSWP_Exn_Type :=
        Why_Empty;
      Set_Link (Result.RSWP_Exn_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Raise_Statement_With_Parameters;

   -----------------------------
   -- New_Unchecked_Try_Block --
   -----------------------------

   function New_Unchecked_Try_Block
     return W_Try_Block_Unchecked_Id
   is
      Result : Why_Node (W_Try_Block);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Try_Block);
   begin
      Result.Ada_Node :=
        Empty;
      Result.TB_Prog :=
        Why_Empty;
      Set_Link (Result.TB_Prog, New_Id);
      Result.TB_Handler :=
        New_List;
      Set_Link (Result.TB_Handler, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Try_Block;

   ------------------------------------
   -- New_Unchecked_Unreachable_Code --
   ------------------------------------

   function New_Unchecked_Unreachable_Code
     return W_Unreachable_Code_Unchecked_Id
   is
      Result : Why_Node (W_Unreachable_Code);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Unreachable_Code);
   begin
      Result.Ada_Node :=
        Empty;
      Result.UC_Exn_Type :=
        Why_Empty;
      Set_Link (Result.UC_Exn_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Unreachable_Code;

   -------------------------------
   -- New_Unchecked_Begin_Block --
   -------------------------------

   function New_Unchecked_Begin_Block
     return W_Begin_Block_Unchecked_Id
   is
      Result : Why_Node (W_Begin_Block);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Begin_Block);
   begin
      Result.Ada_Node :=
        Empty;
      Result.BB_Prog :=
        Why_Empty;
      Set_Link (Result.BB_Prog, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Begin_Block;

   ----------------------------------
   -- New_Unchecked_Protected_Prog --
   ----------------------------------

   function New_Unchecked_Protected_Prog
     return W_Protected_Prog_Unchecked_Id
   is
      Result : Why_Node (W_Protected_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Protected_Prog);
   begin
      Result.Ada_Node :=
        Empty;
      Result.BB_Prog :=
        Why_Empty;
      Set_Link (Result.BB_Prog, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Protected_Prog;

   -------------------------------
   -- New_Unchecked_Op_Add_Prog --
   -------------------------------

   function New_Unchecked_Op_Add_Prog
     return W_Op_Add_Prog_Unchecked_Id
   is
      Result : Why_Node (W_Op_Add_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Add_Prog);
   begin
      Result.Ada_Node :=
        Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Op_Add_Prog;

   -------------------------------------
   -- New_Unchecked_Op_Substract_Prog --
   -------------------------------------

   function New_Unchecked_Op_Substract_Prog
     return W_Op_Substract_Prog_Unchecked_Id
   is
      Result : Why_Node (W_Op_Substract_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Substract_Prog);
   begin
      Result.Ada_Node :=
        Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Op_Substract_Prog;

   ------------------------------------
   -- New_Unchecked_Op_Multiply_Prog --
   ------------------------------------

   function New_Unchecked_Op_Multiply_Prog
     return W_Op_Multiply_Prog_Unchecked_Id
   is
      Result : Why_Node (W_Op_Multiply_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Multiply_Prog);
   begin
      Result.Ada_Node :=
        Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Op_Multiply_Prog;

   ----------------------------------
   -- New_Unchecked_Op_Divide_Prog --
   ----------------------------------

   function New_Unchecked_Op_Divide_Prog
     return W_Op_Divide_Prog_Unchecked_Id
   is
      Result : Why_Node (W_Op_Divide_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Divide_Prog);
   begin
      Result.Ada_Node :=
        Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Op_Divide_Prog;

   -------------------------------
   -- New_Unchecked_Op_Mod_Prog --
   -------------------------------

   function New_Unchecked_Op_Mod_Prog
     return W_Op_Mod_Prog_Unchecked_Id
   is
      Result : Why_Node (W_Op_Mod_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Mod_Prog);
   begin
      Result.Ada_Node :=
        Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Op_Mod_Prog;

   ------------------------------
   -- New_Unchecked_Op_Eq_Prog --
   ------------------------------

   function New_Unchecked_Op_Eq_Prog
     return W_Op_Eq_Prog_Unchecked_Id
   is
      Result : Why_Node (W_Op_Eq_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Eq_Prog);
   begin
      Result.Ada_Node :=
        Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Op_Eq_Prog;

   ------------------------------
   -- New_Unchecked_Op_Ne_Prog --
   ------------------------------

   function New_Unchecked_Op_Ne_Prog
     return W_Op_Ne_Prog_Unchecked_Id
   is
      Result : Why_Node (W_Op_Ne_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Ne_Prog);
   begin
      Result.Ada_Node :=
        Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Op_Ne_Prog;

   ------------------------------
   -- New_Unchecked_Op_Lt_Prog --
   ------------------------------

   function New_Unchecked_Op_Lt_Prog
     return W_Op_Lt_Prog_Unchecked_Id
   is
      Result : Why_Node (W_Op_Lt_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Lt_Prog);
   begin
      Result.Ada_Node :=
        Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Op_Lt_Prog;

   ------------------------------
   -- New_Unchecked_Op_Le_Prog --
   ------------------------------

   function New_Unchecked_Op_Le_Prog
     return W_Op_Le_Prog_Unchecked_Id
   is
      Result : Why_Node (W_Op_Le_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Le_Prog);
   begin
      Result.Ada_Node :=
        Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Op_Le_Prog;

   ------------------------------
   -- New_Unchecked_Op_Gt_Prog --
   ------------------------------

   function New_Unchecked_Op_Gt_Prog
     return W_Op_Gt_Prog_Unchecked_Id
   is
      Result : Why_Node (W_Op_Gt_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Gt_Prog);
   begin
      Result.Ada_Node :=
        Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Op_Gt_Prog;

   ------------------------------
   -- New_Unchecked_Op_Ge_Prog --
   ------------------------------

   function New_Unchecked_Op_Ge_Prog
     return W_Op_Ge_Prog_Unchecked_Id
   is
      Result : Why_Node (W_Op_Ge_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Ge_Prog);
   begin
      Result.Ada_Node :=
        Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Op_Ge_Prog;

   -----------------------------------
   -- New_Unchecked_Op_Or_Else_Prog --
   -----------------------------------

   function New_Unchecked_Op_Or_Else_Prog
     return W_Op_Or_Else_Prog_Unchecked_Id
   is
      Result : Why_Node (W_Op_Or_Else_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Or_Else_Prog);
   begin
      Result.Ada_Node :=
        Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Op_Or_Else_Prog;

   ------------------------------------
   -- New_Unchecked_Op_And_Then_Prog --
   ------------------------------------

   function New_Unchecked_Op_And_Then_Prog
     return W_Op_And_Then_Prog_Unchecked_Id
   is
      Result : Why_Node (W_Op_And_Then_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_And_Then_Prog);
   begin
      Result.Ada_Node :=
        Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Op_And_Then_Prog;

   ---------------------------------
   -- New_Unchecked_Op_Minus_Prog --
   ---------------------------------

   function New_Unchecked_Op_Minus_Prog
     return W_Op_Minus_Prog_Unchecked_Id
   is
      Result : Why_Node (W_Op_Minus_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Minus_Prog);
   begin
      Result.Ada_Node :=
        Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Op_Minus_Prog;

   -------------------------------
   -- New_Unchecked_Op_Not_Prog --
   -------------------------------

   function New_Unchecked_Op_Not_Prog
     return W_Op_Not_Prog_Unchecked_Id
   is
      Result : Why_Node (W_Op_Not_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Not_Prog);
   begin
      Result.Ada_Node :=
        Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Op_Not_Prog;

   --------------------------
   -- New_Unchecked_Binder --
   --------------------------

   function New_Unchecked_Binder
     return W_Binder_Unchecked_Id
   is
      Result : Why_Node (W_Binder);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Binder);
   begin
      Result.Ada_Node :=
        Empty;
      Result.B_Names :=
        New_List;
      Set_Link (Result.B_Names, New_Id);
      Result.B_Arg_Type :=
        Why_Empty;
      Set_Link (Result.B_Arg_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Binder;

   --------------------------
   -- New_Unchecked_Recfun --
   --------------------------

   function New_Unchecked_Recfun
     return W_Recfun_Unchecked_Id
   is
      Result : Why_Node (W_Recfun);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Recfun);
   begin
      Result.Ada_Node :=
        Empty;
      Result.RF_Name :=
        Why_Empty;
      Set_Link (Result.RF_Name, New_Id);
      Result.RF_Binders :=
        New_List;
      Set_Link (Result.RF_Binders, New_Id);
      Result.RF_Return_Type :=
        Why_Empty;
      Set_Link (Result.RF_Return_Type, New_Id);
      Result.RF_Variant :=
        Why_Empty;
      Set_Link (Result.RF_Variant, New_Id);
      Result.RF_Pre :=
        Why_Empty;
      Set_Link (Result.RF_Pre, New_Id);
      Result.RF_Def :=
        Why_Empty;
      Set_Link (Result.RF_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Recfun;

   ------------------------------
   -- New_Unchecked_Loop_Annot --
   ------------------------------

   function New_Unchecked_Loop_Annot
     return W_Loop_Annot_Unchecked_Id
   is
      Result : Why_Node (W_Loop_Annot);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Loop_Annot);
   begin
      Result.Ada_Node :=
        Empty;
      Result.LA_Invariant :=
        Why_Empty;
      Set_Link (Result.LA_Invariant, New_Id);
      Result.LA_Variant :=
        Why_Empty;
      Set_Link (Result.LA_Variant, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Loop_Annot;

   --------------------------
   -- New_Unchecked_Wf_Arg --
   --------------------------

   function New_Unchecked_Wf_Arg
     return W_Wf_Arg_Unchecked_Id
   is
      Result : Why_Node (W_Wf_Arg);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Wf_Arg);
   begin
      Result.Ada_Node :=
        Empty;
      Result.WA_Def :=
        Why_Empty;
      Set_Link (Result.WA_Def, New_Id);
      Result.WA_For_Id :=
        Why_Empty;
      Set_Link (Result.WA_For_Id, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Wf_Arg;

   ---------------------------
   -- New_Unchecked_Handler --
   ---------------------------

   function New_Unchecked_Handler
     return W_Handler_Unchecked_Id
   is
      Result : Why_Node (W_Handler);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Handler);
   begin
      Result.Ada_Node :=
        Empty;
      Result.H_Name :=
        Why_Empty;
      Set_Link (Result.H_Name, New_Id);
      Result.H_Parameter :=
        Why_Empty;
      Set_Link (Result.H_Parameter, New_Id);
      Result.H_Def :=
        Why_Empty;
      Set_Link (Result.H_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Handler;

   ------------------------
   -- New_Unchecked_File --
   ------------------------

   function New_Unchecked_File
     return W_File_Unchecked_Id
   is
      Result : Why_Node (W_File);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_File);
   begin
      Result.Ada_Node :=
        Empty;
      Result.F_Declarations :=
        New_List;
      Set_Link (Result.F_Declarations, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_File;

   ----------------------------------
   -- New_Unchecked_Global_Binding --
   ----------------------------------

   function New_Unchecked_Global_Binding
     return W_Global_Binding_Unchecked_Id
   is
      Result : Why_Node (W_Global_Binding);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Global_Binding);
   begin
      Result.Ada_Node :=
        Empty;
      Result.GB_Name :=
        Why_Empty;
      Set_Link (Result.GB_Name, New_Id);
      Result.GB_Binders :=
        New_List;
      Set_Link (Result.GB_Binders, New_Id);
      Result.GB_Pre :=
        Why_Empty;
      Set_Link (Result.GB_Pre, New_Id);
      Result.GB_Def :=
        Why_Empty;
      Set_Link (Result.GB_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Global_Binding;

   --------------------------------------
   -- New_Unchecked_Global_Rec_Binding --
   --------------------------------------

   function New_Unchecked_Global_Rec_Binding
     return W_Global_Rec_Binding_Unchecked_Id
   is
      Result : Why_Node (W_Global_Rec_Binding);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Global_Rec_Binding);
   begin
      Result.Ada_Node :=
        Empty;
      Result.GRB_Name :=
        Why_Empty;
      Set_Link (Result.GRB_Name, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Global_Rec_Binding;

   -----------------------------------------
   -- New_Unchecked_Parameter_Declaration --
   -----------------------------------------

   function New_Unchecked_Parameter_Declaration
     return W_Parameter_Declaration_Unchecked_Id
   is
      Result : Why_Node (W_Parameter_Declaration);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Parameter_Declaration);
   begin
      Result.Ada_Node :=
        Empty;
      Result.PD_External :=
        Why_Empty;
      Set_Link (Result.PD_External, New_Id);
      Result.PD_Names :=
        New_List;
      Set_Link (Result.PD_Names, New_Id);
      Result.PD_Parameter_Type :=
        Why_Empty;
      Set_Link (Result.PD_Parameter_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Parameter_Declaration;

   ------------------------------------------
   -- New_Unchecked_Global_Ref_Declaration --
   ------------------------------------------

   function New_Unchecked_Global_Ref_Declaration
     return W_Global_Ref_Declaration_Unchecked_Id
   is
      Result : Why_Node (W_Global_Ref_Declaration);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Global_Ref_Declaration);
   begin
      Result.Ada_Node :=
        Empty;
      Result.GR_Name :=
        Why_Empty;
      Set_Link (Result.GR_Name, New_Id);
      Result.GR_Parameter_Type :=
        Why_Empty;
      Set_Link (Result.GR_Parameter_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Global_Ref_Declaration;

   -----------------------------------------
   -- New_Unchecked_Exception_Declaration --
   -----------------------------------------

   function New_Unchecked_Exception_Declaration
     return W_Exception_Declaration_Unchecked_Id
   is
      Result : Why_Node (W_Exception_Declaration);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Exception_Declaration);
   begin
      Result.Ada_Node :=
        Empty;
      Result.ED_Name :=
        Why_Empty;
      Set_Link (Result.ED_Name, New_Id);
      Result.ED_Parameter :=
        Why_Empty;
      Set_Link (Result.ED_Parameter, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Exception_Declaration;

   -------------------------------------
   -- New_Unchecked_Logic_Declaration --
   -------------------------------------

   function New_Unchecked_Logic_Declaration
     return W_Logic_Declaration_Unchecked_Id
   is
      Result : Why_Node (W_Logic_Declaration);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Logic_Declaration);
   begin
      Result.Ada_Node :=
        Empty;
      Result.LD_Decl :=
        Why_Empty;
      Set_Link (Result.LD_Decl, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Logic_Declaration;

   ---------------------------------------
   -- New_Unchecked_Include_Declaration --
   ---------------------------------------

   function New_Unchecked_Include_Declaration
     return W_Include_Declaration_Unchecked_Id
   is
      Result : Why_Node (W_Include_Declaration);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Include_Declaration);
   begin
      Result.Ada_Node :=
        Empty;
      Result.ID_Name :=
        Why_Empty;
      Set_Link (Result.ID_Name, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Include_Declaration;

   --------------------------
   -- Duplicate_Identifier --
   --------------------------

   function Duplicate_Identifier
     (Ada_Node : Node_Id := Empty;
      Id       : W_Identifier_Valid_OId)
     return W_Identifier_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Identifier);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Identifier);
         Symbol : constant Name_Id :=
            Identifier_Get_Symbol (Id);
         Entity : constant Why_Node_Id :=
            Identifier_Get_Entity (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Symbol := Symbol;
         Result.Entity := Entity;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Identifier;

   -------------------------
   -- Duplicate_Type_Prop --
   -------------------------

   function Duplicate_Type_Prop
     (Ada_Node : Node_Id := Empty;
      Id       : W_Type_Prop_Valid_OId)
     return W_Type_Prop_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Type_Prop);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Type_Prop);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Type_Prop;

   ------------------------
   -- Duplicate_Type_Int --
   ------------------------

   function Duplicate_Type_Int
     (Ada_Node : Node_Id := Empty;
      Id       : W_Type_Int_Valid_OId)
     return W_Type_Int_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Type_Int);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Type_Int);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Type_Int;

   -------------------------
   -- Duplicate_Type_Bool --
   -------------------------

   function Duplicate_Type_Bool
     (Ada_Node : Node_Id := Empty;
      Id       : W_Type_Bool_Valid_OId)
     return W_Type_Bool_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Type_Bool);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Type_Bool);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Type_Bool;

   -------------------------
   -- Duplicate_Type_Real --
   -------------------------

   function Duplicate_Type_Real
     (Ada_Node : Node_Id := Empty;
      Id       : W_Type_Real_Valid_OId)
     return W_Type_Real_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Type_Real);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Type_Real);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Type_Real;

   -------------------------
   -- Duplicate_Type_Unit --
   -------------------------

   function Duplicate_Type_Unit
     (Ada_Node : Node_Id := Empty;
      Id       : W_Type_Unit_Valid_OId)
     return W_Type_Unit_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Type_Unit);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Type_Unit);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Type_Unit;

   -----------------------------
   -- Duplicate_Abstract_Type --
   -----------------------------

   function Duplicate_Abstract_Type
     (Ada_Node : Node_Id := Empty;
      Id       : W_Abstract_Type_Valid_OId)
     return W_Abstract_Type_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Abstract_Type);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Abstract_Type);
         Name : constant W_Identifier_Valid_Id :=
            +Abstract_Type_Get_Name (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.AT_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.AT_Name, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Abstract_Type;

   -----------------------------------
   -- Duplicate_Generic_Formal_Type --
   -----------------------------------

   function Duplicate_Generic_Formal_Type
     (Ada_Node : Node_Id := Empty;
      Id       : W_Generic_Formal_Type_Valid_OId)
     return W_Generic_Formal_Type_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Generic_Formal_Type);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Generic_Formal_Type);
         Name : constant W_Identifier_Valid_Id :=
            +Generic_Formal_Type_Get_Name (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.GFT_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.GFT_Name, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Generic_Formal_Type;

   -----------------------------------------
   -- Duplicate_Generic_Actual_Type_Chain --
   -----------------------------------------

   function Duplicate_Generic_Actual_Type_Chain
     (Ada_Node : Node_Id := Empty;
      Id       : W_Generic_Actual_Type_Chain_Valid_OId)
     return W_Generic_Actual_Type_Chain_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Generic_Actual_Type_Chain);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Generic_Actual_Type_Chain);
         Type_Chain : constant W_Primitive_Type_Valid_List :=
            +Generic_Actual_Type_Chain_Get_Type_Chain (Id);
         Name       : constant W_Identifier_Valid_Id :=
            +Generic_Actual_Type_Chain_Get_Name (Id);
      begin
         Result.Ada_Node := Ada_Node;
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Type_Chain);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Primitive_Type_Valid_Id :=
                           Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.GATC_Type_Chain := NL;
         end;
         Set_Link (Result.GATC_Type_Chain, New_Id);
         Result.GATC_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.GATC_Name, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Generic_Actual_Type_Chain;

   --------------------------
   -- Duplicate_Array_Type --
   --------------------------

   function Duplicate_Array_Type
     (Ada_Node : Node_Id := Empty;
      Id       : W_Array_Type_Valid_OId)
     return W_Array_Type_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Array_Type);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Array_Type);
         Component_Type : constant W_Primitive_Type_Valid_Id :=
            +Array_Type_Get_Component_Type (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.AT_Component_Type :=
           Duplicate_Primitive_Type
           (Id => Component_Type);
         Set_Link (Result.AT_Component_Type, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Array_Type;

   ------------------------
   -- Duplicate_Ref_Type --
   ------------------------

   function Duplicate_Ref_Type
     (Ada_Node : Node_Id := Empty;
      Id       : W_Ref_Type_Valid_OId)
     return W_Ref_Type_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Ref_Type);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Ref_Type);
         Aliased_Type : constant W_Primitive_Type_Valid_Id :=
            +Ref_Type_Get_Aliased_Type (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.RT_Aliased_Type :=
           Duplicate_Primitive_Type
           (Id => Aliased_Type);
         Set_Link (Result.RT_Aliased_Type, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Ref_Type;

   --------------------------------
   -- Duplicate_Computation_Type --
   --------------------------------

   function Duplicate_Computation_Type
     (Ada_Node : Node_Id := Empty;
      Id       : W_Computation_Type_Valid_OId)
     return W_Computation_Type_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Computation_Type);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Computation_Type);
         Binders       : constant W_Binder_Valid_OList :=
            +Computation_Type_Get_Binders (Id);
         Precondition  : constant W_Precondition_Valid_OId :=
            +Computation_Type_Get_Precondition (Id);
         Result_Name   : constant W_Identifier_Valid_OId :=
            +Computation_Type_Get_Result_Name (Id);
         Return_Type   : constant W_Primitive_Type_Valid_Id :=
            +Computation_Type_Get_Return_Type (Id);
         Effects       : constant W_Effects_Valid_Id :=
            +Computation_Type_Get_Effects (Id);
         Postcondition : constant W_Postcondition_Valid_OId :=
            +Computation_Type_Get_Postcondition (Id);
      begin
         Result.Ada_Node := Ada_Node;
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Binders);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Binder_Valid_Id :=
                           Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.CS_Binders := NL;
         end;
         Set_Link (Result.CS_Binders, New_Id);
         if Precondition = Why_Empty then
            Result.CS_Precondition := Why_Empty;
         else
            Result.CS_Precondition :=
              Duplicate_Precondition
              (Id => Precondition);
         end if;
         Set_Link (Result.CS_Precondition, New_Id);
         if Result_Name = Why_Empty then
            Result.CS_Result_Name := Why_Empty;
         else
            Result.CS_Result_Name :=
              Duplicate_Identifier
              (Id => Result_Name);
         end if;
         Set_Link (Result.CS_Result_Name, New_Id);
         Result.CS_Return_Type :=
           Duplicate_Primitive_Type
           (Id => Return_Type);
         Set_Link (Result.CS_Return_Type, New_Id);
         Result.CS_Effects :=
           Duplicate_Effects
           (Id => Effects);
         Set_Link (Result.CS_Effects, New_Id);
         if Postcondition = Why_Empty then
            Result.CS_Postcondition := Why_Empty;
         else
            Result.CS_Postcondition :=
              Duplicate_Postcondition
              (Id => Postcondition);
         end if;
         Set_Link (Result.CS_Postcondition, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Computation_Type;

   --------------------------------
   -- Duplicate_Integer_Constant --
   --------------------------------

   function Duplicate_Integer_Constant
     (Ada_Node : Node_Id := Empty;
      Id       : W_Integer_Constant_Valid_OId)
     return W_Integer_Constant_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Integer_Constant);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Integer_Constant);
         Value : constant Uint :=
            Integer_Constant_Get_Value (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.IC_Value := Value;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Integer_Constant;

   -----------------------------
   -- Duplicate_Real_Constant --
   -----------------------------

   function Duplicate_Real_Constant
     (Ada_Node : Node_Id := Empty;
      Id       : W_Real_Constant_Valid_OId)
     return W_Real_Constant_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Real_Constant);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Real_Constant);
         Value : constant Ureal :=
            Real_Constant_Get_Value (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.RC_Value := Value;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Real_Constant;

   ----------------------------
   -- Duplicate_True_Literal --
   ----------------------------

   function Duplicate_True_Literal
     (Ada_Node : Node_Id := Empty;
      Id       : W_True_Literal_Valid_OId)
     return W_True_Literal_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_True_Literal);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_True_Literal);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_True_Literal;

   -----------------------------
   -- Duplicate_False_Literal --
   -----------------------------

   function Duplicate_False_Literal
     (Ada_Node : Node_Id := Empty;
      Id       : W_False_Literal_Valid_OId)
     return W_False_Literal_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_False_Literal);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_False_Literal);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_False_Literal;

   ----------------------------
   -- Duplicate_Void_Literal --
   ----------------------------

   function Duplicate_Void_Literal
     (Ada_Node : Node_Id := Empty;
      Id       : W_Void_Literal_Valid_OId)
     return W_Void_Literal_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Void_Literal);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Void_Literal);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Void_Literal;

   -------------------------------
   -- Duplicate_Arith_Operation --
   -------------------------------

   function Duplicate_Arith_Operation
     (Ada_Node : Node_Id := Empty;
      Id       : W_Arith_Operation_Valid_OId)
     return W_Arith_Operation_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Arith_Operation);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Arith_Operation);
         Left  : constant W_Term_Valid_Id :=
            +Arith_Operation_Get_Left (Id);
         Op    : constant W_Arith_Op_Valid_Id :=
            +Arith_Operation_Get_Op (Id);
         Right : constant W_Term_Valid_Id :=
            +Arith_Operation_Get_Right (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.AO_Left :=
           Duplicate_Term
           (Id => Left);
         Set_Link (Result.AO_Left, New_Id);
         Result.AO_Op :=
           Duplicate_Arith_Op
           (Id => Op);
         Set_Link (Result.AO_Op, New_Id);
         Result.AO_Right :=
           Duplicate_Term
           (Id => Right);
         Set_Link (Result.AO_Right, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Arith_Operation;

   -----------------------------
   -- Duplicate_Negative_Term --
   -----------------------------

   function Duplicate_Negative_Term
     (Ada_Node : Node_Id := Empty;
      Id       : W_Negative_Term_Valid_OId)
     return W_Negative_Term_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Negative_Term);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Negative_Term);
         Operand : constant W_Term_Valid_Id :=
            +Negative_Term_Get_Operand (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.NT_Operand :=
           Duplicate_Term
           (Id => Operand);
         Set_Link (Result.NT_Operand, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Negative_Term;

   -------------------------------
   -- Duplicate_Term_Identifier --
   -------------------------------

   function Duplicate_Term_Identifier
     (Ada_Node : Node_Id := Empty;
      Id       : W_Term_Identifier_Valid_OId)
     return W_Term_Identifier_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Term_Identifier);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Term_Identifier);
         Name  : constant W_Identifier_Valid_Id :=
            +Term_Identifier_Get_Name (Id);
         Label : constant W_Identifier_Valid_OId :=
            +Term_Identifier_Get_Label (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.TIL_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.TIL_Name, New_Id);
         if Label = Why_Empty then
            Result.TIL_Label := Why_Empty;
         else
            Result.TIL_Label :=
              Duplicate_Identifier
              (Id => Label);
         end if;
         Set_Link (Result.TIL_Label, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Term_Identifier;

   -------------------------
   -- Duplicate_Operation --
   -------------------------

   function Duplicate_Operation
     (Ada_Node : Node_Id := Empty;
      Id       : W_Operation_Valid_OId)
     return W_Operation_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Operation);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Operation);
         Name       : constant W_Identifier_Valid_Id :=
            +Operation_Get_Name (Id);
         Parameters : constant W_Term_Valid_List :=
            +Operation_Get_Parameters (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.O_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.O_Name, New_Id);
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Parameters);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Term_Valid_Id :=
                           Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.O_Parameters := NL;
         end;
         Set_Link (Result.O_Parameters, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Operation;

   --------------------------
   -- Duplicate_Named_Term --
   --------------------------

   function Duplicate_Named_Term
     (Ada_Node : Node_Id := Empty;
      Id       : W_Named_Term_Valid_OId)
     return W_Named_Term_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Named_Term);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Named_Term);
         Name : constant W_Identifier_Valid_Id :=
            +Named_Term_Get_Name (Id);
         Term : constant W_Term_Valid_Id :=
            +Named_Term_Get_Term (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.NT_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.NT_Name, New_Id);
         Result.NT_Term :=
           Duplicate_Term
           (Id => Term);
         Set_Link (Result.NT_Term, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Named_Term;

   --------------------------------
   -- Duplicate_Conditional_Term --
   --------------------------------

   function Duplicate_Conditional_Term
     (Ada_Node : Node_Id := Empty;
      Id       : W_Conditional_Term_Valid_OId)
     return W_Conditional_Term_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Conditional_Term);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Conditional_Term);
         Condition : constant W_Term_Valid_Id :=
            +Conditional_Term_Get_Condition (Id);
         Then_Part : constant W_Term_Valid_Id :=
            +Conditional_Term_Get_Then_Part (Id);
         Else_Part : constant W_Term_Valid_Id :=
            +Conditional_Term_Get_Else_Part (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.CT_Condition :=
           Duplicate_Term
           (Id => Condition);
         Set_Link (Result.CT_Condition, New_Id);
         Result.CT_Then_Part :=
           Duplicate_Term
           (Id => Then_Part);
         Set_Link (Result.CT_Then_Part, New_Id);
         Result.CT_Else_Part :=
           Duplicate_Term
           (Id => Else_Part);
         Set_Link (Result.CT_Else_Part, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Conditional_Term;

   -----------------------------
   -- Duplicate_Matching_Term --
   -----------------------------

   function Duplicate_Matching_Term
     (Ada_Node : Node_Id := Empty;
      Id       : W_Matching_Term_Valid_OId)
     return W_Matching_Term_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Matching_Term);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Matching_Term);
         Term     : constant W_Term_Valid_Id :=
            +Matching_Term_Get_Term (Id);
         Branches : constant W_Match_Case_Valid_List :=
            +Matching_Term_Get_Branches (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.MT_Term :=
           Duplicate_Term
           (Id => Term);
         Set_Link (Result.MT_Term, New_Id);
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Branches);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Match_Case_Valid_Id :=
                           Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.MT_Branches := NL;
         end;
         Set_Link (Result.MT_Branches, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Matching_Term;

   ----------------------------
   -- Duplicate_Binding_Term --
   ----------------------------

   function Duplicate_Binding_Term
     (Ada_Node : Node_Id := Empty;
      Id       : W_Binding_Term_Valid_OId)
     return W_Binding_Term_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Binding_Term);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Binding_Term);
         Name    : constant W_Identifier_Valid_Id :=
            +Binding_Term_Get_Name (Id);
         Def     : constant W_Term_Valid_Id :=
            +Binding_Term_Get_Def (Id);
         Context : constant W_Term_Valid_Id :=
            +Binding_Term_Get_Context (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.BT_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.BT_Name, New_Id);
         Result.BT_Def :=
           Duplicate_Term
           (Id => Def);
         Set_Link (Result.BT_Def, New_Id);
         Result.BT_Context :=
           Duplicate_Term
           (Id => Context);
         Set_Link (Result.BT_Context, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Binding_Term;

   ------------------------------
   -- Duplicate_Protected_Term --
   ------------------------------

   function Duplicate_Protected_Term
     (Ada_Node : Node_Id := Empty;
      Id       : W_Protected_Term_Valid_OId)
     return W_Protected_Term_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Protected_Term);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Protected_Term);
         Term : constant W_Term_Valid_Id :=
            +Protected_Term_Get_Term (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.BT_Term :=
           Duplicate_Term
           (Id => Term);
         Set_Link (Result.BT_Term, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Protected_Term;

   ----------------------
   -- Duplicate_Op_Add --
   ----------------------

   function Duplicate_Op_Add
     (Ada_Node : Node_Id := Empty;
      Id       : W_Op_Add_Valid_OId)
     return W_Op_Add_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Op_Add);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Op_Add);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Op_Add;

   ----------------------------
   -- Duplicate_Op_Substract --
   ----------------------------

   function Duplicate_Op_Substract
     (Ada_Node : Node_Id := Empty;
      Id       : W_Op_Substract_Valid_OId)
     return W_Op_Substract_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Op_Substract);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Op_Substract);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Op_Substract;

   ---------------------------
   -- Duplicate_Op_Multiply --
   ---------------------------

   function Duplicate_Op_Multiply
     (Ada_Node : Node_Id := Empty;
      Id       : W_Op_Multiply_Valid_OId)
     return W_Op_Multiply_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Op_Multiply);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Op_Multiply);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Op_Multiply;

   -------------------------
   -- Duplicate_Op_Divide --
   -------------------------

   function Duplicate_Op_Divide
     (Ada_Node : Node_Id := Empty;
      Id       : W_Op_Divide_Valid_OId)
     return W_Op_Divide_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Op_Divide);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Op_Divide);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Op_Divide;

   -------------------------
   -- Duplicate_Op_Modulo --
   -------------------------

   function Duplicate_Op_Modulo
     (Ada_Node : Node_Id := Empty;
      Id       : W_Op_Modulo_Valid_OId)
     return W_Op_Modulo_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Op_Modulo);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Op_Modulo);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Op_Modulo;

   ---------------------------------
   -- Duplicate_True_Literal_Pred --
   ---------------------------------

   function Duplicate_True_Literal_Pred
     (Ada_Node : Node_Id := Empty;
      Id       : W_True_Literal_Pred_Valid_OId)
     return W_True_Literal_Pred_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_True_Literal_Pred);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_True_Literal_Pred);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_True_Literal_Pred;

   ----------------------------------
   -- Duplicate_False_Literal_Pred --
   ----------------------------------

   function Duplicate_False_Literal_Pred
     (Ada_Node : Node_Id := Empty;
      Id       : W_False_Literal_Pred_Valid_OId)
     return W_False_Literal_Pred_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_False_Literal_Pred);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_False_Literal_Pred);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_False_Literal_Pred;

   ------------------------------------
   -- Duplicate_Predicate_Identifier --
   ------------------------------------

   function Duplicate_Predicate_Identifier
     (Ada_Node : Node_Id := Empty;
      Id       : W_Predicate_Identifier_Valid_OId)
     return W_Predicate_Identifier_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Predicate_Identifier);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Predicate_Identifier);
         Name : constant W_Identifier_Valid_Id :=
            +Predicate_Identifier_Get_Name (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.PID_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.PID_Name, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Predicate_Identifier;

   ----------------------------------
   -- Duplicate_Predicate_Instance --
   ----------------------------------

   function Duplicate_Predicate_Instance
     (Ada_Node : Node_Id := Empty;
      Id       : W_Predicate_Instance_Valid_OId)
     return W_Predicate_Instance_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Predicate_Instance);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Predicate_Instance);
         Name       : constant W_Identifier_Valid_Id :=
            +Predicate_Instance_Get_Name (Id);
         Parameters : constant W_Term_Valid_List :=
            +Predicate_Instance_Get_Parameters (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.PIN_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.PIN_Name, New_Id);
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Parameters);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Term_Valid_Id :=
                           Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.PIN_Parameters := NL;
         end;
         Set_Link (Result.PIN_Parameters, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Predicate_Instance;

   -----------------------------
   -- Duplicate_Related_Terms --
   -----------------------------

   function Duplicate_Related_Terms
     (Ada_Node : Node_Id := Empty;
      Id       : W_Related_Terms_Valid_OId)
     return W_Related_Terms_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Related_Terms);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Related_Terms);
         Left   : constant W_Term_Valid_Id :=
            +Related_Terms_Get_Left (Id);
         Op     : constant W_Relation_Valid_Id :=
            +Related_Terms_Get_Op (Id);
         Right  : constant W_Term_Valid_Id :=
            +Related_Terms_Get_Right (Id);
         Op2    : constant W_Relation_Valid_OId :=
            +Related_Terms_Get_Op2 (Id);
         Right2 : constant W_Term_Valid_OId :=
            +Related_Terms_Get_Right2 (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.RT_Left :=
           Duplicate_Term
           (Id => Left);
         Set_Link (Result.RT_Left, New_Id);
         Result.RT_Op :=
           Duplicate_Relation
           (Id => Op);
         Set_Link (Result.RT_Op, New_Id);
         Result.RT_Right :=
           Duplicate_Term
           (Id => Right);
         Set_Link (Result.RT_Right, New_Id);
         if Op2 = Why_Empty then
            Result.RT_Op2 := Why_Empty;
         else
            Result.RT_Op2 :=
              Duplicate_Relation
              (Id => Op2);
         end if;
         Set_Link (Result.RT_Op2, New_Id);
         if Right2 = Why_Empty then
            Result.RT_Right2 := Why_Empty;
         else
            Result.RT_Right2 :=
              Duplicate_Term
              (Id => Right2);
         end if;
         Set_Link (Result.RT_Right2, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Related_Terms;

   ---------------------------
   -- Duplicate_Implication --
   ---------------------------

   function Duplicate_Implication
     (Ada_Node : Node_Id := Empty;
      Id       : W_Implication_Valid_OId)
     return W_Implication_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Implication);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Implication);
         Left  : constant W_Predicate_Valid_Id :=
            +Implication_Get_Left (Id);
         Right : constant W_Predicate_Valid_Id :=
            +Implication_Get_Right (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.ITOC_Left :=
           Duplicate_Predicate
           (Id => Left);
         Set_Link (Result.ITOC_Left, New_Id);
         Result.ITOC_Right :=
           Duplicate_Predicate
           (Id => Right);
         Set_Link (Result.ITOC_Right, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Implication;

   ---------------------------
   -- Duplicate_Equivalence --
   ---------------------------

   function Duplicate_Equivalence
     (Ada_Node : Node_Id := Empty;
      Id       : W_Equivalence_Valid_OId)
     return W_Equivalence_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Equivalence);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Equivalence);
         Left  : constant W_Predicate_Valid_Id :=
            +Equivalence_Get_Left (Id);
         Right : constant W_Predicate_Valid_Id :=
            +Equivalence_Get_Right (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.ITOC_Left :=
           Duplicate_Predicate
           (Id => Left);
         Set_Link (Result.ITOC_Left, New_Id);
         Result.ITOC_Right :=
           Duplicate_Predicate
           (Id => Right);
         Set_Link (Result.ITOC_Right, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Equivalence;

   ---------------------------
   -- Duplicate_Disjunction --
   ---------------------------

   function Duplicate_Disjunction
     (Ada_Node : Node_Id := Empty;
      Id       : W_Disjunction_Valid_OId)
     return W_Disjunction_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Disjunction);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Disjunction);
         Left  : constant W_Predicate_Valid_Id :=
            +Disjunction_Get_Left (Id);
         Right : constant W_Predicate_Valid_Id :=
            +Disjunction_Get_Right (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.ITOC_Left :=
           Duplicate_Predicate
           (Id => Left);
         Set_Link (Result.ITOC_Left, New_Id);
         Result.ITOC_Right :=
           Duplicate_Predicate
           (Id => Right);
         Set_Link (Result.ITOC_Right, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Disjunction;

   ---------------------------
   -- Duplicate_Conjunction --
   ---------------------------

   function Duplicate_Conjunction
     (Ada_Node : Node_Id := Empty;
      Id       : W_Conjunction_Valid_OId)
     return W_Conjunction_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Conjunction);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Conjunction);
         Left  : constant W_Predicate_Valid_Id :=
            +Conjunction_Get_Left (Id);
         Right : constant W_Predicate_Valid_Id :=
            +Conjunction_Get_Right (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.ITOC_Left :=
           Duplicate_Predicate
           (Id => Left);
         Set_Link (Result.ITOC_Left, New_Id);
         Result.ITOC_Right :=
           Duplicate_Predicate
           (Id => Right);
         Set_Link (Result.ITOC_Right, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Conjunction;

   ------------------------
   -- Duplicate_Negation --
   ------------------------

   function Duplicate_Negation
     (Ada_Node : Node_Id := Empty;
      Id       : W_Negation_Valid_OId)
     return W_Negation_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Negation);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Negation);
         Operand : constant W_Predicate_Valid_Id :=
            +Negation_Get_Operand (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.N_Operand :=
           Duplicate_Predicate
           (Id => Operand);
         Set_Link (Result.N_Operand, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Negation;

   --------------------------------
   -- Duplicate_Conditional_Pred --
   --------------------------------

   function Duplicate_Conditional_Pred
     (Ada_Node : Node_Id := Empty;
      Id       : W_Conditional_Pred_Valid_OId)
     return W_Conditional_Pred_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Conditional_Pred);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Conditional_Pred);
         Condition : constant W_Term_Valid_Id :=
            +Conditional_Pred_Get_Condition (Id);
         Then_Part : constant W_Predicate_Valid_Id :=
            +Conditional_Pred_Get_Then_Part (Id);
         Else_Part : constant W_Predicate_Valid_Id :=
            +Conditional_Pred_Get_Else_Part (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.CPD_Condition :=
           Duplicate_Term
           (Id => Condition);
         Set_Link (Result.CPD_Condition, New_Id);
         Result.CPD_Then_Part :=
           Duplicate_Predicate
           (Id => Then_Part);
         Set_Link (Result.CPD_Then_Part, New_Id);
         Result.CPD_Else_Part :=
           Duplicate_Predicate
           (Id => Else_Part);
         Set_Link (Result.CPD_Else_Part, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Conditional_Pred;

   ----------------------------
   -- Duplicate_Binding_Pred --
   ----------------------------

   function Duplicate_Binding_Pred
     (Ada_Node : Node_Id := Empty;
      Id       : W_Binding_Pred_Valid_OId)
     return W_Binding_Pred_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Binding_Pred);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Binding_Pred);
         Name    : constant W_Identifier_Valid_Id :=
            +Binding_Pred_Get_Name (Id);
         Def     : constant W_Term_Valid_Id :=
            +Binding_Pred_Get_Def (Id);
         Context : constant W_Predicate_Valid_Id :=
            +Binding_Pred_Get_Context (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.BPD_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.BPD_Name, New_Id);
         Result.BPD_Def :=
           Duplicate_Term
           (Id => Def);
         Set_Link (Result.BPD_Def, New_Id);
         Result.BPD_Context :=
           Duplicate_Predicate
           (Id => Context);
         Set_Link (Result.BPD_Context, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Binding_Pred;

   ---------------------------------
   -- Duplicate_Universal_Quantif --
   ---------------------------------

   function Duplicate_Universal_Quantif
     (Ada_Node : Node_Id := Empty;
      Id       : W_Universal_Quantif_Valid_OId)
     return W_Universal_Quantif_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Universal_Quantif);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Universal_Quantif);
         Variables : constant W_Identifier_Valid_List :=
            +Universal_Quantif_Get_Variables (Id);
         Var_Type  : constant W_Primitive_Type_Valid_Id :=
            +Universal_Quantif_Get_Var_Type (Id);
         Triggers  : constant W_Triggers_Valid_OId :=
            +Universal_Quantif_Get_Triggers (Id);
         Pred      : constant W_Predicate_Valid_Id :=
            +Universal_Quantif_Get_Pred (Id);
      begin
         Result.Ada_Node := Ada_Node;
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Variables);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Identifier_Valid_Id :=
                           Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.UQ_Variables := NL;
         end;
         Set_Link (Result.UQ_Variables, New_Id);
         Result.UQ_Var_Type :=
           Duplicate_Primitive_Type
           (Id => Var_Type);
         Set_Link (Result.UQ_Var_Type, New_Id);
         if Triggers = Why_Empty then
            Result.UQ_Triggers := Why_Empty;
         else
            Result.UQ_Triggers :=
              Duplicate_Triggers
              (Id => Triggers);
         end if;
         Set_Link (Result.UQ_Triggers, New_Id);
         Result.UQ_Pred :=
           Duplicate_Predicate
           (Id => Pred);
         Set_Link (Result.UQ_Pred, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Universal_Quantif;

   -----------------------------------
   -- Duplicate_Existential_Quantif --
   -----------------------------------

   function Duplicate_Existential_Quantif
     (Ada_Node : Node_Id := Empty;
      Id       : W_Existential_Quantif_Valid_OId)
     return W_Existential_Quantif_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Existential_Quantif);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Existential_Quantif);
         Variables : constant W_Identifier_Valid_List :=
            +Existential_Quantif_Get_Variables (Id);
         Var_Type  : constant W_Primitive_Type_Valid_Id :=
            +Existential_Quantif_Get_Var_Type (Id);
         Pred      : constant W_Predicate_Valid_Id :=
            +Existential_Quantif_Get_Pred (Id);
      begin
         Result.Ada_Node := Ada_Node;
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Variables);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Identifier_Valid_Id :=
                           Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.EQ_Variables := NL;
         end;
         Set_Link (Result.EQ_Variables, New_Id);
         Result.EQ_Var_Type :=
           Duplicate_Primitive_Type
           (Id => Var_Type);
         Set_Link (Result.EQ_Var_Type, New_Id);
         Result.EQ_Pred :=
           Duplicate_Predicate
           (Id => Pred);
         Set_Link (Result.EQ_Pred, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Existential_Quantif;

   -------------------------------
   -- Duplicate_Named_Predicate --
   -------------------------------

   function Duplicate_Named_Predicate
     (Ada_Node : Node_Id := Empty;
      Id       : W_Named_Predicate_Valid_OId)
     return W_Named_Predicate_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Named_Predicate);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Named_Predicate);
         Name : constant W_Identifier_Valid_Id :=
            +Named_Predicate_Get_Name (Id);
         Pred : constant W_Predicate_Valid_Id :=
            +Named_Predicate_Get_Pred (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.NP_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.NP_Name, New_Id);
         Result.NP_Pred :=
           Duplicate_Predicate
           (Id => Pred);
         Set_Link (Result.NP_Pred, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Named_Predicate;

   -----------------------------------
   -- Duplicate_Protected_Predicate --
   -----------------------------------

   function Duplicate_Protected_Predicate
     (Ada_Node : Node_Id := Empty;
      Id       : W_Protected_Predicate_Valid_OId)
     return W_Protected_Predicate_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Protected_Predicate);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Protected_Predicate);
         Pred : constant W_Predicate_Valid_Id :=
            +Protected_Predicate_Get_Pred (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.PP_Pred :=
           Duplicate_Predicate
           (Id => Pred);
         Set_Link (Result.PP_Pred, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Protected_Predicate;

   -----------------------
   -- Duplicate_Pattern --
   -----------------------

   function Duplicate_Pattern
     (Ada_Node : Node_Id := Empty;
      Id       : W_Pattern_Valid_OId)
     return W_Pattern_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Pattern);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Pattern);
         Constr : constant W_Identifier_Valid_Id :=
            +Pattern_Get_Constr (Id);
         Args   : constant W_Identifier_Valid_OList :=
            +Pattern_Get_Args (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.PAT_Constr :=
           Duplicate_Identifier
           (Id => Constr);
         Set_Link (Result.PAT_Constr, New_Id);
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Args);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Identifier_Valid_Id :=
                           Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.PAT_Args := NL;
         end;
         Set_Link (Result.PAT_Args, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Pattern;

   --------------------------
   -- Duplicate_Match_Case --
   --------------------------

   function Duplicate_Match_Case
     (Ada_Node : Node_Id := Empty;
      Id       : W_Match_Case_Valid_OId)
     return W_Match_Case_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Match_Case);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Match_Case);
         Pattern : constant W_Pattern_Valid_Id :=
            +Match_Case_Get_Pattern (Id);
         Term    : constant W_Term_Valid_Id :=
            +Match_Case_Get_Term (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.MC_Pattern :=
           Duplicate_Pattern
           (Id => Pattern);
         Set_Link (Result.MC_Pattern, New_Id);
         Result.MC_Term :=
           Duplicate_Term
           (Id => Term);
         Set_Link (Result.MC_Term, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Match_Case;

   ------------------------
   -- Duplicate_Triggers --
   ------------------------

   function Duplicate_Triggers
     (Ada_Node : Node_Id := Empty;
      Id       : W_Triggers_Valid_OId)
     return W_Triggers_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Triggers);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Triggers);
         Triggers : constant W_Trigger_Valid_List :=
            +Triggers_Get_Triggers (Id);
      begin
         Result.Ada_Node := Ada_Node;
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Triggers);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Trigger_Valid_Id :=
                           Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.TRS_Triggers := NL;
         end;
         Set_Link (Result.TRS_Triggers, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Triggers;

   -----------------------
   -- Duplicate_Trigger --
   -----------------------

   function Duplicate_Trigger
     (Ada_Node : Node_Id := Empty;
      Id       : W_Trigger_Valid_OId)
     return W_Trigger_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Trigger);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Trigger);
         Terms : constant W_Term_Valid_List :=
            +Trigger_Get_Terms (Id);
      begin
         Result.Ada_Node := Ada_Node;
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Terms);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Term_Valid_Id :=
                           Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.TRI_Terms := NL;
         end;
         Set_Link (Result.TRI_Terms, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Trigger;

   ----------------------
   -- Duplicate_Rel_Eq --
   ----------------------

   function Duplicate_Rel_Eq
     (Ada_Node : Node_Id := Empty;
      Id       : W_Rel_Eq_Valid_OId)
     return W_Rel_Eq_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Rel_Eq);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Rel_Eq);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Rel_Eq;

   ----------------------
   -- Duplicate_Rel_Ne --
   ----------------------

   function Duplicate_Rel_Ne
     (Ada_Node : Node_Id := Empty;
      Id       : W_Rel_Ne_Valid_OId)
     return W_Rel_Ne_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Rel_Ne);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Rel_Ne);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Rel_Ne;

   ----------------------
   -- Duplicate_Rel_Lt --
   ----------------------

   function Duplicate_Rel_Lt
     (Ada_Node : Node_Id := Empty;
      Id       : W_Rel_Lt_Valid_OId)
     return W_Rel_Lt_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Rel_Lt);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Rel_Lt);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Rel_Lt;

   ----------------------
   -- Duplicate_Rel_Le --
   ----------------------

   function Duplicate_Rel_Le
     (Ada_Node : Node_Id := Empty;
      Id       : W_Rel_Le_Valid_OId)
     return W_Rel_Le_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Rel_Le);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Rel_Le);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Rel_Le;

   ----------------------
   -- Duplicate_Rel_Gt --
   ----------------------

   function Duplicate_Rel_Gt
     (Ada_Node : Node_Id := Empty;
      Id       : W_Rel_Gt_Valid_OId)
     return W_Rel_Gt_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Rel_Gt);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Rel_Gt);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Rel_Gt;

   ----------------------
   -- Duplicate_Rel_Ge --
   ----------------------

   function Duplicate_Rel_Ge
     (Ada_Node : Node_Id := Empty;
      Id       : W_Rel_Ge_Valid_OId)
     return W_Rel_Ge_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Rel_Ge);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Rel_Ge);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Rel_Ge;

   --------------------
   -- Duplicate_Type --
   --------------------

   function Duplicate_Type
     (Ada_Node : Node_Id := Empty;
      Id       : W_Type_Valid_OId)
     return W_Type_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Type);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Type);
         External        : constant W_External_Valid_OId :=
            +Type_Get_External (Id);
         Type_Parameters : constant W_Identifier_Valid_OList :=
            +Type_Get_Type_Parameters (Id);
         Name            : constant W_Identifier_Valid_Id :=
            +Type_Get_Name (Id);
         Definition      : constant W_Type_Definition_Valid_OId :=
            +Type_Get_Definition (Id);
      begin
         Result.Ada_Node := Ada_Node;
         if External = Why_Empty then
            Result.T_External := Why_Empty;
         else
            Result.T_External :=
              Duplicate_External
              (Id => External);
         end if;
         Set_Link (Result.T_External, New_Id);
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Type_Parameters);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Identifier_Valid_Id :=
                           Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.T_Type_Parameters := NL;
         end;
         Set_Link (Result.T_Type_Parameters, New_Id);
         Result.T_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.T_Name, New_Id);
         if Definition = Why_Empty then
            Result.T_Definition := Why_Empty;
         else
            Result.T_Definition :=
              Duplicate_Type_Definition
              (Id => Definition);
         end if;
         Set_Link (Result.T_Definition, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Type;

   ---------------------
   -- Duplicate_Logic --
   ---------------------

   function Duplicate_Logic
     (Ada_Node : Node_Id := Empty;
      Id       : W_Logic_Valid_OId)
     return W_Logic_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Logic);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Logic);
         External   : constant W_External_Valid_OId :=
            +Logic_Get_External (Id);
         Names      : constant W_Identifier_Valid_List :=
            +Logic_Get_Names (Id);
         Logic_Type : constant W_Logic_Type_Valid_Id :=
            +Logic_Get_Logic_Type (Id);
      begin
         Result.Ada_Node := Ada_Node;
         if External = Why_Empty then
            Result.L_External := Why_Empty;
         else
            Result.L_External :=
              Duplicate_External
              (Id => External);
         end if;
         Set_Link (Result.L_External, New_Id);
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Names);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Identifier_Valid_Id :=
                           Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.L_Names := NL;
         end;
         Set_Link (Result.L_Names, New_Id);
         Result.L_Logic_Type :=
           Duplicate_Logic_Type
           (Id => Logic_Type);
         Set_Link (Result.L_Logic_Type, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Logic;

   ------------------------
   -- Duplicate_Function --
   ------------------------

   function Duplicate_Function
     (Ada_Node : Node_Id := Empty;
      Id       : W_Function_Valid_OId)
     return W_Function_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Function);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Function);
         Name        : constant W_Identifier_Valid_Id :=
            +Function_Get_Name (Id);
         Binders     : constant W_Logic_Binder_Valid_List :=
            +Function_Get_Binders (Id);
         Return_Type : constant W_Primitive_Type_Valid_Id :=
            +Function_Get_Return_Type (Id);
         Def         : constant W_Term_Valid_Id :=
            +Function_Get_Def (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.F_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.F_Name, New_Id);
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Binders);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Logic_Binder_Valid_Id :=
                           Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.F_Binders := NL;
         end;
         Set_Link (Result.F_Binders, New_Id);
         Result.F_Return_Type :=
           Duplicate_Primitive_Type
           (Id => Return_Type);
         Set_Link (Result.F_Return_Type, New_Id);
         Result.F_Def :=
           Duplicate_Term
           (Id => Def);
         Set_Link (Result.F_Def, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Function;

   ------------------------------------
   -- Duplicate_Predicate_Definition --
   ------------------------------------

   function Duplicate_Predicate_Definition
     (Ada_Node : Node_Id := Empty;
      Id       : W_Predicate_Definition_Valid_OId)
     return W_Predicate_Definition_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Predicate_Definition);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Predicate_Definition);
         Name    : constant W_Identifier_Valid_Id :=
            +Predicate_Definition_Get_Name (Id);
         Binders : constant W_Logic_Binder_Valid_List :=
            +Predicate_Definition_Get_Binders (Id);
         Def     : constant W_Predicate_Valid_Id :=
            +Predicate_Definition_Get_Def (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.P_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.P_Name, New_Id);
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Binders);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Logic_Binder_Valid_Id :=
                           Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.P_Binders := NL;
         end;
         Set_Link (Result.P_Binders, New_Id);
         Result.P_Def :=
           Duplicate_Predicate
           (Id => Def);
         Set_Link (Result.P_Def, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Predicate_Definition;

   -------------------------
   -- Duplicate_Inductive --
   -------------------------

   function Duplicate_Inductive
     (Ada_Node : Node_Id := Empty;
      Id       : W_Inductive_Valid_OId)
     return W_Inductive_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Inductive);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Inductive);
         Name       : constant W_Identifier_Valid_Id :=
            +Inductive_Get_Name (Id);
         Logic_Type : constant W_Logic_Type_Valid_Id :=
            +Inductive_Get_Logic_Type (Id);
         Def        : constant W_Inductive_Case_Valid_List :=
            +Inductive_Get_Def (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.I_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.I_Name, New_Id);
         Result.I_Logic_Type :=
           Duplicate_Logic_Type
           (Id => Logic_Type);
         Set_Link (Result.I_Logic_Type, New_Id);
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Def);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Inductive_Case_Valid_Id :=
                           Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.I_Def := NL;
         end;
         Set_Link (Result.I_Def, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Inductive;

   ---------------------
   -- Duplicate_Axiom --
   ---------------------

   function Duplicate_Axiom
     (Ada_Node : Node_Id := Empty;
      Id       : W_Axiom_Valid_OId)
     return W_Axiom_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Axiom);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Axiom);
         Name : constant W_Identifier_Valid_Id :=
            +Axiom_Get_Name (Id);
         Def  : constant W_Predicate_Valid_Id :=
            +Axiom_Get_Def (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.AX_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.AX_Name, New_Id);
         Result.AX_Def :=
           Duplicate_Predicate
           (Id => Def);
         Set_Link (Result.AX_Def, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Axiom;

   --------------------
   -- Duplicate_Goal --
   --------------------

   function Duplicate_Goal
     (Ada_Node : Node_Id := Empty;
      Id       : W_Goal_Valid_OId)
     return W_Goal_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Goal);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Goal);
         Name : constant W_Identifier_Valid_Id :=
            +Goal_Get_Name (Id);
         Def  : constant W_Predicate_Valid_Id :=
            +Goal_Get_Def (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.G_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.G_Name, New_Id);
         Result.G_Def :=
           Duplicate_Predicate
           (Id => Def);
         Set_Link (Result.G_Def, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Goal;

   ------------------------
   -- Duplicate_External --
   ------------------------

   function Duplicate_External
     (Ada_Node : Node_Id := Empty;
      Id       : W_External_Valid_OId)
     return W_External_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_External);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_External);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_External;

   --------------------------
   -- Duplicate_Logic_Type --
   --------------------------

   function Duplicate_Logic_Type
     (Ada_Node : Node_Id := Empty;
      Id       : W_Logic_Type_Valid_OId)
     return W_Logic_Type_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Logic_Type);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Logic_Type);
         Arg_Types   : constant W_Logic_Arg_Type_Valid_OList :=
            +Logic_Type_Get_Arg_Types (Id);
         Return_Type : constant W_Logic_Return_Type_Valid_Id :=
            +Logic_Type_Get_Return_Type (Id);
      begin
         Result.Ada_Node := Ada_Node;
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Arg_Types);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Logic_Arg_Type_Valid_Id :=
                           Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.LT_Arg_Types := NL;
         end;
         Set_Link (Result.LT_Arg_Types, New_Id);
         Result.LT_Return_Type :=
           Duplicate_Logic_Return_Type
           (Id => Return_Type);
         Set_Link (Result.LT_Return_Type, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Logic_Type;

   ----------------------------
   -- Duplicate_Logic_Binder --
   ----------------------------

   function Duplicate_Logic_Binder
     (Ada_Node : Node_Id := Empty;
      Id       : W_Logic_Binder_Valid_OId)
     return W_Logic_Binder_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Logic_Binder);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Logic_Binder);
         Name       : constant W_Identifier_Valid_Id :=
            +Logic_Binder_Get_Name (Id);
         Param_Type : constant W_Primitive_Type_Valid_Id :=
            +Logic_Binder_Get_Param_Type (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.LB_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.LB_Name, New_Id);
         Result.LB_Param_Type :=
           Duplicate_Primitive_Type
           (Id => Param_Type);
         Set_Link (Result.LB_Param_Type, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Logic_Binder;

   ------------------------------
   -- Duplicate_Inductive_Case --
   ------------------------------

   function Duplicate_Inductive_Case
     (Ada_Node : Node_Id := Empty;
      Id       : W_Inductive_Case_Valid_OId)
     return W_Inductive_Case_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Inductive_Case);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Inductive_Case);
         Name : constant W_Identifier_Valid_Id :=
            +Inductive_Case_Get_Name (Id);
         Pred : constant W_Predicate_Valid_Id :=
            +Inductive_Case_Get_Pred (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.IC_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.IC_Name, New_Id);
         Result.IC_Pred :=
           Duplicate_Predicate
           (Id => Pred);
         Set_Link (Result.IC_Pred, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Inductive_Case;

   -------------------------------------------
   -- Duplicate_Transparent_Type_Definition --
   -------------------------------------------

   function Duplicate_Transparent_Type_Definition
     (Ada_Node : Node_Id := Empty;
      Id       : W_Transparent_Type_Definition_Valid_OId)
     return W_Transparent_Type_Definition_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Transparent_Type_Definition);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Transparent_Type_Definition);
         Type_Definition : constant W_Primitive_Type_Valid_Id :=
            +Transparent_Type_Definition_Get_Type_Definition (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Tr_Type_Definition :=
           Duplicate_Primitive_Type
           (Id => Type_Definition);
         Set_Link (Result.Tr_Type_Definition, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Transparent_Type_Definition;

   ------------------------------
   -- Duplicate_Adt_Definition --
   ------------------------------

   function Duplicate_Adt_Definition
     (Ada_Node : Node_Id := Empty;
      Id       : W_Adt_Definition_Valid_OId)
     return W_Adt_Definition_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Adt_Definition);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Adt_Definition);
         Constructors : constant W_Constr_Decl_Valid_List :=
            +Adt_Definition_Get_Constructors (Id);
      begin
         Result.Ada_Node := Ada_Node;
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Constructors);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Constr_Decl_Valid_Id :=
                           Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.Adt_Constructors := NL;
         end;
         Set_Link (Result.Adt_Constructors, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Adt_Definition;

   ---------------------------
   -- Duplicate_Constr_Decl --
   ---------------------------

   function Duplicate_Constr_Decl
     (Ada_Node : Node_Id := Empty;
      Id       : W_Constr_Decl_Valid_OId)
     return W_Constr_Decl_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Constr_Decl);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Constr_Decl);
         Name     : constant W_Identifier_Valid_Id :=
            +Constr_Decl_Get_Name (Id);
         Arg_List : constant W_Primitive_Type_Valid_OList :=
            +Constr_Decl_Get_Arg_List (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.C_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.C_Name, New_Id);
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Arg_List);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Primitive_Type_Valid_Id :=
                           Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.C_Arg_List := NL;
         end;
         Set_Link (Result.C_Arg_List, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Constr_Decl;

   -----------------------
   -- Duplicate_Effects --
   -----------------------

   function Duplicate_Effects
     (Ada_Node : Node_Id := Empty;
      Id       : W_Effects_Valid_OId)
     return W_Effects_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Effects);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Effects);
         Reads  : constant W_Identifier_Valid_OList :=
            +Effects_Get_Reads (Id);
         Writes : constant W_Identifier_Valid_OList :=
            +Effects_Get_Writes (Id);
         Raises : constant W_Identifier_Valid_OList :=
            +Effects_Get_Raises (Id);
      begin
         Result.Ada_Node := Ada_Node;
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Reads);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Identifier_Valid_Id :=
                           Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.E_Reads := NL;
         end;
         Set_Link (Result.E_Reads, New_Id);
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Writes);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Identifier_Valid_Id :=
                           Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.E_Writes := NL;
         end;
         Set_Link (Result.E_Writes, New_Id);
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Raises);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Identifier_Valid_Id :=
                           Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.E_Raises := NL;
         end;
         Set_Link (Result.E_Raises, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Effects;

   ----------------------------
   -- Duplicate_Precondition --
   ----------------------------

   function Duplicate_Precondition
     (Ada_Node : Node_Id := Empty;
      Id       : W_Precondition_Valid_OId)
     return W_Precondition_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Precondition);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Precondition);
         Pred : constant W_Predicate_Valid_Id :=
            +Precondition_Get_Pred (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.PRE_Pred :=
           Duplicate_Predicate
           (Id => Pred);
         Set_Link (Result.PRE_Pred, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Precondition;

   -----------------------------
   -- Duplicate_Postcondition --
   -----------------------------

   function Duplicate_Postcondition
     (Ada_Node : Node_Id := Empty;
      Id       : W_Postcondition_Valid_OId)
     return W_Postcondition_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Postcondition);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Postcondition);
         Pred     : constant W_Predicate_Valid_Id :=
            +Postcondition_Get_Pred (Id);
         Handlers : constant W_Exn_Condition_Valid_OList :=
            +Postcondition_Get_Handlers (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.POST_Pred :=
           Duplicate_Predicate
           (Id => Pred);
         Set_Link (Result.POST_Pred, New_Id);
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Handlers);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Exn_Condition_Valid_Id :=
                           Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.POST_Handlers := NL;
         end;
         Set_Link (Result.POST_Handlers, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Postcondition;

   -----------------------------
   -- Duplicate_Exn_Condition --
   -----------------------------

   function Duplicate_Exn_Condition
     (Ada_Node : Node_Id := Empty;
      Id       : W_Exn_Condition_Valid_OId)
     return W_Exn_Condition_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Exn_Condition);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Exn_Condition);
         Exn_Case : constant W_Identifier_Valid_Id :=
            +Exn_Condition_Get_Exn_Case (Id);
         Pred     : constant W_Predicate_Valid_Id :=
            +Exn_Condition_Get_Pred (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.EC_Exn_Case :=
           Duplicate_Identifier
           (Id => Exn_Case);
         Set_Link (Result.EC_Exn_Case, New_Id);
         Result.EC_Pred :=
           Duplicate_Predicate
           (Id => Pred);
         Set_Link (Result.EC_Pred, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Exn_Condition;

   -----------------------------
   -- Duplicate_Prog_Constant --
   -----------------------------

   function Duplicate_Prog_Constant
     (Ada_Node : Node_Id := Empty;
      Id       : W_Prog_Constant_Valid_OId)
     return W_Prog_Constant_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Prog_Constant);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Prog_Constant);
         Def : constant W_Constant_Valid_Id :=
            +Prog_Constant_Get_Def (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.PC_Def :=
           Duplicate_Constant
           (Id => Def);
         Set_Link (Result.PC_Def, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Prog_Constant;

   -------------------------------
   -- Duplicate_Prog_Identifier --
   -------------------------------

   function Duplicate_Prog_Identifier
     (Ada_Node : Node_Id := Empty;
      Id       : W_Prog_Identifier_Valid_OId)
     return W_Prog_Identifier_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Prog_Identifier);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Prog_Identifier);
         Def : constant W_Identifier_Valid_Id :=
            +Prog_Identifier_Get_Def (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.PI_Def :=
           Duplicate_Identifier
           (Id => Def);
         Set_Link (Result.PI_Def, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Prog_Identifier;

   ------------------------
   -- Duplicate_Any_Expr --
   ------------------------

   function Duplicate_Any_Expr
     (Ada_Node : Node_Id := Empty;
      Id       : W_Any_Expr_Valid_OId)
     return W_Any_Expr_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Any_Expr);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Any_Expr);
         Any_Type : constant W_Computation_Type_Valid_Id :=
            +Any_Expr_Get_Any_Type (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.AE_Any_Type :=
           Duplicate_Computation_Type
           (Id => Any_Type);
         Set_Link (Result.AE_Any_Type, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Any_Expr;

   ---------------------
   -- Duplicate_Deref --
   ---------------------

   function Duplicate_Deref
     (Ada_Node : Node_Id := Empty;
      Id       : W_Deref_Valid_OId)
     return W_Deref_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Deref);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Deref);
         Ref : constant W_Identifier_Valid_Id :=
            +Deref_Get_Ref (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.D_Ref :=
           Duplicate_Identifier
           (Id => Ref);
         Set_Link (Result.D_Ref, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Deref;

   --------------------------
   -- Duplicate_Assignment --
   --------------------------

   function Duplicate_Assignment
     (Ada_Node : Node_Id := Empty;
      Id       : W_Assignment_Valid_OId)
     return W_Assignment_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Assignment);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Assignment);
         Name  : constant W_Identifier_Valid_Id :=
            +Assignment_Get_Name (Id);
         Value : constant W_Prog_Valid_Id :=
            +Assignment_Get_Value (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.A_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.A_Name, New_Id);
         Result.A_Value :=
           Duplicate_Prog
           (Id => Value);
         Set_Link (Result.A_Value, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Assignment;

   ----------------------------
   -- Duplicate_Array_Access --
   ----------------------------

   function Duplicate_Array_Access
     (Ada_Node : Node_Id := Empty;
      Id       : W_Array_Access_Valid_OId)
     return W_Array_Access_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Array_Access);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Array_Access);
         Name  : constant W_Identifier_Valid_Id :=
            +Array_Access_Get_Name (Id);
         Index : constant W_Prog_Valid_Id :=
            +Array_Access_Get_Index (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.AA_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.AA_Name, New_Id);
         Result.AA_Index :=
           Duplicate_Prog
           (Id => Index);
         Set_Link (Result.AA_Index, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Array_Access;

   ----------------------------
   -- Duplicate_Array_Update --
   ----------------------------

   function Duplicate_Array_Update
     (Ada_Node : Node_Id := Empty;
      Id       : W_Array_Update_Valid_OId)
     return W_Array_Update_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Array_Update);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Array_Update);
         Name  : constant W_Identifier_Valid_Id :=
            +Array_Update_Get_Name (Id);
         Index : constant W_Prog_Valid_Id :=
            +Array_Update_Get_Index (Id);
         Value : constant W_Prog_Valid_Id :=
            +Array_Update_Get_Value (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.AU_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.AU_Name, New_Id);
         Result.AU_Index :=
           Duplicate_Prog
           (Id => Index);
         Set_Link (Result.AU_Index, New_Id);
         Result.AU_Value :=
           Duplicate_Prog
           (Id => Value);
         Set_Link (Result.AU_Value, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Array_Update;

   --------------------------
   -- Duplicate_Infix_Call --
   --------------------------

   function Duplicate_Infix_Call
     (Ada_Node : Node_Id := Empty;
      Id       : W_Infix_Call_Valid_OId)
     return W_Infix_Call_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Infix_Call);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Infix_Call);
         Left  : constant W_Prog_Valid_Id :=
            +Infix_Call_Get_Left (Id);
         Infix : constant W_Infix_Valid_Id :=
            +Infix_Call_Get_Infix (Id);
         Right : constant W_Prog_Valid_Id :=
            +Infix_Call_Get_Right (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.IC_Left :=
           Duplicate_Prog
           (Id => Left);
         Set_Link (Result.IC_Left, New_Id);
         Result.IC_Infix :=
           Duplicate_Infix
           (Id => Infix);
         Set_Link (Result.IC_Infix, New_Id);
         Result.IC_Right :=
           Duplicate_Prog
           (Id => Right);
         Set_Link (Result.IC_Right, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Infix_Call;

   ---------------------------
   -- Duplicate_Prefix_Call --
   ---------------------------

   function Duplicate_Prefix_Call
     (Ada_Node : Node_Id := Empty;
      Id       : W_Prefix_Call_Valid_OId)
     return W_Prefix_Call_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Prefix_Call);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Prefix_Call);
         Prefix  : constant W_Prefix_Valid_Id :=
            +Prefix_Call_Get_Prefix (Id);
         Operand : constant W_Prog_Valid_Id :=
            +Prefix_Call_Get_Operand (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.PC_Prefix :=
           Duplicate_Prefix
           (Id => Prefix);
         Set_Link (Result.PC_Prefix, New_Id);
         Result.PC_Operand :=
           Duplicate_Prog
           (Id => Operand);
         Set_Link (Result.PC_Operand, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Prefix_Call;

   ----------------------------
   -- Duplicate_Binding_Prog --
   ----------------------------

   function Duplicate_Binding_Prog
     (Ada_Node : Node_Id := Empty;
      Id       : W_Binding_Prog_Valid_OId)
     return W_Binding_Prog_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Binding_Prog);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Binding_Prog);
         Name    : constant W_Identifier_Valid_Id :=
            +Binding_Prog_Get_Name (Id);
         Def     : constant W_Prog_Valid_Id :=
            +Binding_Prog_Get_Def (Id);
         Context : constant W_Prog_Valid_Id :=
            +Binding_Prog_Get_Context (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.BPG_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.BPG_Name, New_Id);
         Result.BPG_Def :=
           Duplicate_Prog
           (Id => Def);
         Set_Link (Result.BPG_Def, New_Id);
         Result.BPG_Context :=
           Duplicate_Prog
           (Id => Context);
         Set_Link (Result.BPG_Context, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Binding_Prog;

   ---------------------------
   -- Duplicate_Binding_Ref --
   ---------------------------

   function Duplicate_Binding_Ref
     (Ada_Node : Node_Id := Empty;
      Id       : W_Binding_Ref_Valid_OId)
     return W_Binding_Ref_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Binding_Ref);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Binding_Ref);
         Name    : constant W_Identifier_Valid_Id :=
            +Binding_Ref_Get_Name (Id);
         Def     : constant W_Prog_Valid_Id :=
            +Binding_Ref_Get_Def (Id);
         Context : constant W_Prog_Valid_Id :=
            +Binding_Ref_Get_Context (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.BPG_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.BPG_Name, New_Id);
         Result.BPG_Def :=
           Duplicate_Prog
           (Id => Def);
         Set_Link (Result.BPG_Def, New_Id);
         Result.BPG_Context :=
           Duplicate_Prog
           (Id => Context);
         Set_Link (Result.BPG_Context, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Binding_Ref;

   --------------------------------
   -- Duplicate_Conditional_Prog --
   --------------------------------

   function Duplicate_Conditional_Prog
     (Ada_Node : Node_Id := Empty;
      Id       : W_Conditional_Prog_Valid_OId)
     return W_Conditional_Prog_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Conditional_Prog);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Conditional_Prog);
         Condition : constant W_Prog_Valid_Id :=
            +Conditional_Prog_Get_Condition (Id);
         Then_Part : constant W_Prog_Valid_Id :=
            +Conditional_Prog_Get_Then_Part (Id);
         Else_Part : constant W_Prog_Valid_OId :=
            +Conditional_Prog_Get_Else_Part (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.CPG_Condition :=
           Duplicate_Prog
           (Id => Condition);
         Set_Link (Result.CPG_Condition, New_Id);
         Result.CPG_Then_Part :=
           Duplicate_Prog
           (Id => Then_Part);
         Set_Link (Result.CPG_Then_Part, New_Id);
         if Else_Part = Why_Empty then
            Result.CPG_Else_Part := Why_Empty;
         else
            Result.CPG_Else_Part :=
              Duplicate_Prog
              (Id => Else_Part);
         end if;
         Set_Link (Result.CPG_Else_Part, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Conditional_Prog;

   --------------------------
   -- Duplicate_While_Loop --
   --------------------------

   function Duplicate_While_Loop
     (Ada_Node : Node_Id := Empty;
      Id       : W_While_Loop_Valid_OId)
     return W_While_Loop_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_While_Loop);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_While_Loop);
         Condition    : constant W_Prog_Valid_Id :=
            +While_Loop_Get_Condition (Id);
         Annotation   : constant W_Loop_Annot_Valid_Id :=
            +While_Loop_Get_Annotation (Id);
         Loop_Content : constant W_Prog_Valid_Id :=
            +While_Loop_Get_Loop_Content (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.WL_Condition :=
           Duplicate_Prog
           (Id => Condition);
         Set_Link (Result.WL_Condition, New_Id);
         Result.WL_Annotation :=
           Duplicate_Loop_Annot
           (Id => Annotation);
         Set_Link (Result.WL_Annotation, New_Id);
         Result.WL_Loop_Content :=
           Duplicate_Prog
           (Id => Loop_Content);
         Set_Link (Result.WL_Loop_Content, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_While_Loop;

   ----------------------------------
   -- Duplicate_Statement_Sequence --
   ----------------------------------

   function Duplicate_Statement_Sequence
     (Ada_Node : Node_Id := Empty;
      Id       : W_Statement_Sequence_Valid_OId)
     return W_Statement_Sequence_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Statement_Sequence);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Statement_Sequence);
         Statements : constant W_Prog_Valid_List :=
            +Statement_Sequence_Get_Statements (Id);
      begin
         Result.Ada_Node := Ada_Node;
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Statements);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Prog_Valid_Id :=
                           Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.SS_Statements := NL;
         end;
         Set_Link (Result.SS_Statements, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Statement_Sequence;

   ---------------------
   -- Duplicate_Label --
   ---------------------

   function Duplicate_Label
     (Ada_Node : Node_Id := Empty;
      Id       : W_Label_Valid_OId)
     return W_Label_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Label);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Label);
         Name : constant W_Identifier_Valid_Id :=
            +Label_Get_Name (Id);
         Def  : constant W_Prog_Valid_Id :=
            +Label_Get_Def (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.L_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.L_Name, New_Id);
         Result.L_Def :=
           Duplicate_Prog
           (Id => Def);
         Set_Link (Result.L_Def, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Label;

   ----------------------
   -- Duplicate_Assert --
   ----------------------

   function Duplicate_Assert
     (Ada_Node : Node_Id := Empty;
      Id       : W_Assert_Valid_OId)
     return W_Assert_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Assert);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Assert);
         Preds : constant W_Predicate_Valid_List :=
            +Assert_Get_Preds (Id);
         Prog  : constant W_Prog_Valid_Id :=
            +Assert_Get_Prog (Id);
      begin
         Result.Ada_Node := Ada_Node;
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Preds);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Predicate_Valid_Id :=
                           Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.AS_Preds := NL;
         end;
         Set_Link (Result.AS_Preds, New_Id);
         Result.AS_Prog :=
           Duplicate_Prog
           (Id => Prog);
         Set_Link (Result.AS_Prog, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Assert;

   ------------------------------
   -- Duplicate_Post_Assertion --
   ------------------------------

   function Duplicate_Post_Assertion
     (Ada_Node : Node_Id := Empty;
      Id       : W_Post_Assertion_Valid_OId)
     return W_Post_Assertion_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Post_Assertion);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Post_Assertion);
         Prog : constant W_Prog_Valid_Id :=
            +Post_Assertion_Get_Prog (Id);
         Post : constant W_Postcondition_Valid_Id :=
            +Post_Assertion_Get_Post (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.PA_Prog :=
           Duplicate_Prog
           (Id => Prog);
         Set_Link (Result.PA_Prog, New_Id);
         Result.PA_Post :=
           Duplicate_Postcondition
           (Id => Post);
         Set_Link (Result.PA_Post, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Post_Assertion;

   --------------------------------
   -- Duplicate_Opaque_Assertion --
   --------------------------------

   function Duplicate_Opaque_Assertion
     (Ada_Node : Node_Id := Empty;
      Id       : W_Opaque_Assertion_Valid_OId)
     return W_Opaque_Assertion_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Opaque_Assertion);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Opaque_Assertion);
         Prog : constant W_Prog_Valid_Id :=
            +Opaque_Assertion_Get_Prog (Id);
         Post : constant W_Postcondition_Valid_Id :=
            +Opaque_Assertion_Get_Post (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.PA_Prog :=
           Duplicate_Prog
           (Id => Prog);
         Set_Link (Result.PA_Prog, New_Id);
         Result.PA_Post :=
           Duplicate_Postcondition
           (Id => Post);
         Set_Link (Result.PA_Post, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Opaque_Assertion;

   -----------------------
   -- Duplicate_Fun_Def --
   -----------------------

   function Duplicate_Fun_Def
     (Ada_Node : Node_Id := Empty;
      Id       : W_Fun_Def_Valid_OId)
     return W_Fun_Def_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Fun_Def);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Fun_Def);
         Binders : constant W_Binder_Valid_List :=
            +Fun_Def_Get_Binders (Id);
         Pre     : constant W_Precondition_Valid_Id :=
            +Fun_Def_Get_Pre (Id);
         Def     : constant W_Prog_Valid_Id :=
            +Fun_Def_Get_Def (Id);
      begin
         Result.Ada_Node := Ada_Node;
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Binders);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Binder_Valid_Id :=
                           Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.FD_Binders := NL;
         end;
         Set_Link (Result.FD_Binders, New_Id);
         Result.FD_Pre :=
           Duplicate_Precondition
           (Id => Pre);
         Set_Link (Result.FD_Pre, New_Id);
         Result.FD_Def :=
           Duplicate_Prog
           (Id => Def);
         Set_Link (Result.FD_Def, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Fun_Def;

   ---------------------------
   -- Duplicate_Binding_Fun --
   ---------------------------

   function Duplicate_Binding_Fun
     (Ada_Node : Node_Id := Empty;
      Id       : W_Binding_Fun_Valid_OId)
     return W_Binding_Fun_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Binding_Fun);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Binding_Fun);
         Name    : constant W_Identifier_Valid_Id :=
            +Binding_Fun_Get_Name (Id);
         Binders : constant W_Binder_Valid_List :=
            +Binding_Fun_Get_Binders (Id);
         Pre     : constant W_Precondition_Valid_Id :=
            +Binding_Fun_Get_Pre (Id);
         Def     : constant W_Prog_Valid_Id :=
            +Binding_Fun_Get_Def (Id);
         Context : constant W_Prog_Valid_Id :=
            +Binding_Fun_Get_Context (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.BF_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.BF_Name, New_Id);
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Binders);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Binder_Valid_Id :=
                           Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.BF_Binders := NL;
         end;
         Set_Link (Result.BF_Binders, New_Id);
         Result.BF_Pre :=
           Duplicate_Precondition
           (Id => Pre);
         Set_Link (Result.BF_Pre, New_Id);
         Result.BF_Def :=
           Duplicate_Prog
           (Id => Def);
         Set_Link (Result.BF_Def, New_Id);
         Result.BF_Context :=
           Duplicate_Prog
           (Id => Context);
         Set_Link (Result.BF_Context, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Binding_Fun;

   ---------------------------
   -- Duplicate_Binding_Rec --
   ---------------------------

   function Duplicate_Binding_Rec
     (Ada_Node : Node_Id := Empty;
      Id       : W_Binding_Rec_Valid_OId)
     return W_Binding_Rec_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Binding_Rec);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Binding_Rec);
         Recfun  : constant W_Recfun_Valid_Id :=
            +Binding_Rec_Get_Recfun (Id);
         Context : constant W_Prog_Valid_Id :=
            +Binding_Rec_Get_Context (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.BR_Recfun :=
           Duplicate_Recfun
           (Id => Recfun);
         Set_Link (Result.BR_Recfun, New_Id);
         Result.BR_Context :=
           Duplicate_Prog
           (Id => Context);
         Set_Link (Result.BR_Context, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Binding_Rec;

   -------------------------
   -- Duplicate_Prog_Call --
   -------------------------

   function Duplicate_Prog_Call
     (Ada_Node : Node_Id := Empty;
      Id       : W_Prog_Call_Valid_OId)
     return W_Prog_Call_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Prog_Call);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Prog_Call);
         Name  : constant W_Identifier_Valid_Id :=
            +Prog_Call_Get_Name (Id);
         Progs : constant W_Prog_Valid_List :=
            +Prog_Call_Get_Progs (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.PS_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.PS_Name, New_Id);
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Progs);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Prog_Valid_Id :=
                           Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.PS_Progs := NL;
         end;
         Set_Link (Result.PS_Progs, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Prog_Call;

   -------------------------------
   -- Duplicate_Raise_Statement --
   -------------------------------

   function Duplicate_Raise_Statement
     (Ada_Node : Node_Id := Empty;
      Id       : W_Raise_Statement_Valid_OId)
     return W_Raise_Statement_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Raise_Statement);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Raise_Statement);
         Name     : constant W_Identifier_Valid_Id :=
            +Raise_Statement_Get_Name (Id);
         Exn_Type : constant W_Simple_Value_Type_Valid_OId :=
            +Raise_Statement_Get_Exn_Type (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.RS_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.RS_Name, New_Id);
         if Exn_Type = Why_Empty then
            Result.RS_Exn_Type := Why_Empty;
         else
            Result.RS_Exn_Type :=
              Duplicate_Simple_Value_Type
              (Id => Exn_Type);
         end if;
         Set_Link (Result.RS_Exn_Type, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Raise_Statement;

   -----------------------------------------------
   -- Duplicate_Raise_Statement_With_Parameters --
   -----------------------------------------------

   function Duplicate_Raise_Statement_With_Parameters
     (Ada_Node : Node_Id := Empty;
      Id       : W_Raise_Statement_With_Parameters_Valid_OId)
     return W_Raise_Statement_With_Parameters_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Raise_Statement_With_Parameters);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Raise_Statement_With_Parameters);
         Name      : constant W_Identifier_Valid_Id :=
            +Raise_Statement_With_Parameters_Get_Name (Id);
         Parameter : constant W_Term_Valid_Id :=
            +Raise_Statement_With_Parameters_Get_Parameter (Id);
         Exn_Type  : constant W_Simple_Value_Type_Valid_OId :=
            +Raise_Statement_With_Parameters_Get_Exn_Type (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.RSWP_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.RSWP_Name, New_Id);
         Result.RSWP_Parameter :=
           Duplicate_Term
           (Id => Parameter);
         Set_Link (Result.RSWP_Parameter, New_Id);
         if Exn_Type = Why_Empty then
            Result.RSWP_Exn_Type := Why_Empty;
         else
            Result.RSWP_Exn_Type :=
              Duplicate_Simple_Value_Type
              (Id => Exn_Type);
         end if;
         Set_Link (Result.RSWP_Exn_Type, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Raise_Statement_With_Parameters;

   -------------------------
   -- Duplicate_Try_Block --
   -------------------------

   function Duplicate_Try_Block
     (Ada_Node : Node_Id := Empty;
      Id       : W_Try_Block_Valid_OId)
     return W_Try_Block_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Try_Block);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Try_Block);
         Prog    : constant W_Prog_Valid_Id :=
            +Try_Block_Get_Prog (Id);
         Handler : constant W_Handler_Valid_List :=
            +Try_Block_Get_Handler (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.TB_Prog :=
           Duplicate_Prog
           (Id => Prog);
         Set_Link (Result.TB_Prog, New_Id);
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Handler);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Handler_Valid_Id :=
                           Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.TB_Handler := NL;
         end;
         Set_Link (Result.TB_Handler, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Try_Block;

   --------------------------------
   -- Duplicate_Unreachable_Code --
   --------------------------------

   function Duplicate_Unreachable_Code
     (Ada_Node : Node_Id := Empty;
      Id       : W_Unreachable_Code_Valid_OId)
     return W_Unreachable_Code_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Unreachable_Code);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Unreachable_Code);
         Exn_Type : constant W_Simple_Value_Type_Valid_OId :=
            +Unreachable_Code_Get_Exn_Type (Id);
      begin
         Result.Ada_Node := Ada_Node;
         if Exn_Type = Why_Empty then
            Result.UC_Exn_Type := Why_Empty;
         else
            Result.UC_Exn_Type :=
              Duplicate_Simple_Value_Type
              (Id => Exn_Type);
         end if;
         Set_Link (Result.UC_Exn_Type, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Unreachable_Code;

   ---------------------------
   -- Duplicate_Begin_Block --
   ---------------------------

   function Duplicate_Begin_Block
     (Ada_Node : Node_Id := Empty;
      Id       : W_Begin_Block_Valid_OId)
     return W_Begin_Block_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Begin_Block);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Begin_Block);
         Prog : constant W_Prog_Valid_Id :=
            +Begin_Block_Get_Prog (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.BB_Prog :=
           Duplicate_Prog
           (Id => Prog);
         Set_Link (Result.BB_Prog, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Begin_Block;

   ------------------------------
   -- Duplicate_Protected_Prog --
   ------------------------------

   function Duplicate_Protected_Prog
     (Ada_Node : Node_Id := Empty;
      Id       : W_Protected_Prog_Valid_OId)
     return W_Protected_Prog_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Protected_Prog);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Protected_Prog);
         Prog : constant W_Prog_Valid_Id :=
            +Protected_Prog_Get_Prog (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.BB_Prog :=
           Duplicate_Prog
           (Id => Prog);
         Set_Link (Result.BB_Prog, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Protected_Prog;

   ---------------------------
   -- Duplicate_Op_Add_Prog --
   ---------------------------

   function Duplicate_Op_Add_Prog
     (Ada_Node : Node_Id := Empty;
      Id       : W_Op_Add_Prog_Valid_OId)
     return W_Op_Add_Prog_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Op_Add_Prog);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Op_Add_Prog);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Op_Add_Prog;

   ---------------------------------
   -- Duplicate_Op_Substract_Prog --
   ---------------------------------

   function Duplicate_Op_Substract_Prog
     (Ada_Node : Node_Id := Empty;
      Id       : W_Op_Substract_Prog_Valid_OId)
     return W_Op_Substract_Prog_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Op_Substract_Prog);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Op_Substract_Prog);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Op_Substract_Prog;

   --------------------------------
   -- Duplicate_Op_Multiply_Prog --
   --------------------------------

   function Duplicate_Op_Multiply_Prog
     (Ada_Node : Node_Id := Empty;
      Id       : W_Op_Multiply_Prog_Valid_OId)
     return W_Op_Multiply_Prog_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Op_Multiply_Prog);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Op_Multiply_Prog);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Op_Multiply_Prog;

   ------------------------------
   -- Duplicate_Op_Divide_Prog --
   ------------------------------

   function Duplicate_Op_Divide_Prog
     (Ada_Node : Node_Id := Empty;
      Id       : W_Op_Divide_Prog_Valid_OId)
     return W_Op_Divide_Prog_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Op_Divide_Prog);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Op_Divide_Prog);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Op_Divide_Prog;

   ---------------------------
   -- Duplicate_Op_Mod_Prog --
   ---------------------------

   function Duplicate_Op_Mod_Prog
     (Ada_Node : Node_Id := Empty;
      Id       : W_Op_Mod_Prog_Valid_OId)
     return W_Op_Mod_Prog_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Op_Mod_Prog);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Op_Mod_Prog);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Op_Mod_Prog;

   --------------------------
   -- Duplicate_Op_Eq_Prog --
   --------------------------

   function Duplicate_Op_Eq_Prog
     (Ada_Node : Node_Id := Empty;
      Id       : W_Op_Eq_Prog_Valid_OId)
     return W_Op_Eq_Prog_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Op_Eq_Prog);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Op_Eq_Prog);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Op_Eq_Prog;

   --------------------------
   -- Duplicate_Op_Ne_Prog --
   --------------------------

   function Duplicate_Op_Ne_Prog
     (Ada_Node : Node_Id := Empty;
      Id       : W_Op_Ne_Prog_Valid_OId)
     return W_Op_Ne_Prog_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Op_Ne_Prog);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Op_Ne_Prog);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Op_Ne_Prog;

   --------------------------
   -- Duplicate_Op_Lt_Prog --
   --------------------------

   function Duplicate_Op_Lt_Prog
     (Ada_Node : Node_Id := Empty;
      Id       : W_Op_Lt_Prog_Valid_OId)
     return W_Op_Lt_Prog_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Op_Lt_Prog);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Op_Lt_Prog);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Op_Lt_Prog;

   --------------------------
   -- Duplicate_Op_Le_Prog --
   --------------------------

   function Duplicate_Op_Le_Prog
     (Ada_Node : Node_Id := Empty;
      Id       : W_Op_Le_Prog_Valid_OId)
     return W_Op_Le_Prog_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Op_Le_Prog);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Op_Le_Prog);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Op_Le_Prog;

   --------------------------
   -- Duplicate_Op_Gt_Prog --
   --------------------------

   function Duplicate_Op_Gt_Prog
     (Ada_Node : Node_Id := Empty;
      Id       : W_Op_Gt_Prog_Valid_OId)
     return W_Op_Gt_Prog_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Op_Gt_Prog);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Op_Gt_Prog);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Op_Gt_Prog;

   --------------------------
   -- Duplicate_Op_Ge_Prog --
   --------------------------

   function Duplicate_Op_Ge_Prog
     (Ada_Node : Node_Id := Empty;
      Id       : W_Op_Ge_Prog_Valid_OId)
     return W_Op_Ge_Prog_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Op_Ge_Prog);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Op_Ge_Prog);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Op_Ge_Prog;

   -------------------------------
   -- Duplicate_Op_Or_Else_Prog --
   -------------------------------

   function Duplicate_Op_Or_Else_Prog
     (Ada_Node : Node_Id := Empty;
      Id       : W_Op_Or_Else_Prog_Valid_OId)
     return W_Op_Or_Else_Prog_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Op_Or_Else_Prog);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Op_Or_Else_Prog);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Op_Or_Else_Prog;

   --------------------------------
   -- Duplicate_Op_And_Then_Prog --
   --------------------------------

   function Duplicate_Op_And_Then_Prog
     (Ada_Node : Node_Id := Empty;
      Id       : W_Op_And_Then_Prog_Valid_OId)
     return W_Op_And_Then_Prog_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Op_And_Then_Prog);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Op_And_Then_Prog);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Op_And_Then_Prog;

   -----------------------------
   -- Duplicate_Op_Minus_Prog --
   -----------------------------

   function Duplicate_Op_Minus_Prog
     (Ada_Node : Node_Id := Empty;
      Id       : W_Op_Minus_Prog_Valid_OId)
     return W_Op_Minus_Prog_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Op_Minus_Prog);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Op_Minus_Prog);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Op_Minus_Prog;

   ---------------------------
   -- Duplicate_Op_Not_Prog --
   ---------------------------

   function Duplicate_Op_Not_Prog
     (Ada_Node : Node_Id := Empty;
      Id       : W_Op_Not_Prog_Valid_OId)
     return W_Op_Not_Prog_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Op_Not_Prog);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Op_Not_Prog);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Op_Not_Prog;

   ----------------------
   -- Duplicate_Binder --
   ----------------------

   function Duplicate_Binder
     (Ada_Node : Node_Id := Empty;
      Id       : W_Binder_Valid_OId)
     return W_Binder_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Binder);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Binder);
         Names    : constant W_Identifier_Valid_List :=
            +Binder_Get_Names (Id);
         Arg_Type : constant W_Simple_Value_Type_Valid_Id :=
            +Binder_Get_Arg_Type (Id);
      begin
         Result.Ada_Node := Ada_Node;
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Names);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Identifier_Valid_Id :=
                           Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.B_Names := NL;
         end;
         Set_Link (Result.B_Names, New_Id);
         Result.B_Arg_Type :=
           Duplicate_Simple_Value_Type
           (Id => Arg_Type);
         Set_Link (Result.B_Arg_Type, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Binder;

   ----------------------
   -- Duplicate_Recfun --
   ----------------------

   function Duplicate_Recfun
     (Ada_Node : Node_Id := Empty;
      Id       : W_Recfun_Valid_OId)
     return W_Recfun_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Recfun);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Recfun);
         Name        : constant W_Identifier_Valid_Id :=
            +Recfun_Get_Name (Id);
         Binders     : constant W_Binder_Valid_List :=
            +Recfun_Get_Binders (Id);
         Return_Type : constant W_Prog_Valid_Id :=
            +Recfun_Get_Return_Type (Id);
         Variant     : constant W_Wf_Arg_Valid_Id :=
            +Recfun_Get_Variant (Id);
         Pre         : constant W_Precondition_Valid_Id :=
            +Recfun_Get_Pre (Id);
         Def         : constant W_Prog_Valid_Id :=
            +Recfun_Get_Def (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.RF_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.RF_Name, New_Id);
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Binders);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Binder_Valid_Id :=
                           Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.RF_Binders := NL;
         end;
         Set_Link (Result.RF_Binders, New_Id);
         Result.RF_Return_Type :=
           Duplicate_Prog
           (Id => Return_Type);
         Set_Link (Result.RF_Return_Type, New_Id);
         Result.RF_Variant :=
           Duplicate_Wf_Arg
           (Id => Variant);
         Set_Link (Result.RF_Variant, New_Id);
         Result.RF_Pre :=
           Duplicate_Precondition
           (Id => Pre);
         Set_Link (Result.RF_Pre, New_Id);
         Result.RF_Def :=
           Duplicate_Prog
           (Id => Def);
         Set_Link (Result.RF_Def, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Recfun;

   --------------------------
   -- Duplicate_Loop_Annot --
   --------------------------

   function Duplicate_Loop_Annot
     (Ada_Node : Node_Id := Empty;
      Id       : W_Loop_Annot_Valid_OId)
     return W_Loop_Annot_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Loop_Annot);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Loop_Annot);
         Invariant : constant W_Predicate_Valid_OId :=
            +Loop_Annot_Get_Invariant (Id);
         Variant   : constant W_Wf_Arg_Valid_OId :=
            +Loop_Annot_Get_Variant (Id);
      begin
         Result.Ada_Node := Ada_Node;
         if Invariant = Why_Empty then
            Result.LA_Invariant := Why_Empty;
         else
            Result.LA_Invariant :=
              Duplicate_Predicate
              (Id => Invariant);
         end if;
         Set_Link (Result.LA_Invariant, New_Id);
         if Variant = Why_Empty then
            Result.LA_Variant := Why_Empty;
         else
            Result.LA_Variant :=
              Duplicate_Wf_Arg
              (Id => Variant);
         end if;
         Set_Link (Result.LA_Variant, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Loop_Annot;

   ----------------------
   -- Duplicate_Wf_Arg --
   ----------------------

   function Duplicate_Wf_Arg
     (Ada_Node : Node_Id := Empty;
      Id       : W_Wf_Arg_Valid_OId)
     return W_Wf_Arg_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Wf_Arg);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Wf_Arg);
         Def    : constant W_Term_Valid_Id :=
            +Wf_Arg_Get_Def (Id);
         For_Id : constant W_Identifier_Valid_OId :=
            +Wf_Arg_Get_For_Id (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.WA_Def :=
           Duplicate_Term
           (Id => Def);
         Set_Link (Result.WA_Def, New_Id);
         if For_Id = Why_Empty then
            Result.WA_For_Id := Why_Empty;
         else
            Result.WA_For_Id :=
              Duplicate_Identifier
              (Id => For_Id);
         end if;
         Set_Link (Result.WA_For_Id, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Wf_Arg;

   -----------------------
   -- Duplicate_Handler --
   -----------------------

   function Duplicate_Handler
     (Ada_Node : Node_Id := Empty;
      Id       : W_Handler_Valid_OId)
     return W_Handler_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Handler);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Handler);
         Name      : constant W_Identifier_Valid_Id :=
            +Handler_Get_Name (Id);
         Parameter : constant W_Prog_Valid_OId :=
            +Handler_Get_Parameter (Id);
         Def       : constant W_Prog_Valid_Id :=
            +Handler_Get_Def (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.H_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.H_Name, New_Id);
         if Parameter = Why_Empty then
            Result.H_Parameter := Why_Empty;
         else
            Result.H_Parameter :=
              Duplicate_Prog
              (Id => Parameter);
         end if;
         Set_Link (Result.H_Parameter, New_Id);
         Result.H_Def :=
           Duplicate_Prog
           (Id => Def);
         Set_Link (Result.H_Def, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Handler;

   --------------------
   -- Duplicate_File --
   --------------------

   function Duplicate_File
     (Ada_Node : Node_Id := Empty;
      Id       : W_File_Valid_OId)
     return W_File_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_File);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_File);
         Declarations : constant W_Declaration_Valid_OList :=
            +File_Get_Declarations (Id);
      begin
         Result.Ada_Node := Ada_Node;
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Declarations);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Declaration_Valid_Id :=
                           Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.F_Declarations := NL;
         end;
         Set_Link (Result.F_Declarations, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_File;

   ------------------------------
   -- Duplicate_Global_Binding --
   ------------------------------

   function Duplicate_Global_Binding
     (Ada_Node : Node_Id := Empty;
      Id       : W_Global_Binding_Valid_OId)
     return W_Global_Binding_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Global_Binding);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Global_Binding);
         Name    : constant W_Identifier_Valid_Id :=
            +Global_Binding_Get_Name (Id);
         Binders : constant W_Binder_Valid_OList :=
            +Global_Binding_Get_Binders (Id);
         Pre     : constant W_Precondition_Valid_Id :=
            +Global_Binding_Get_Pre (Id);
         Def     : constant W_Prog_Valid_Id :=
            +Global_Binding_Get_Def (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.GB_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.GB_Name, New_Id);
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Binders);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Binder_Valid_Id :=
                           Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.GB_Binders := NL;
         end;
         Set_Link (Result.GB_Binders, New_Id);
         Result.GB_Pre :=
           Duplicate_Precondition
           (Id => Pre);
         Set_Link (Result.GB_Pre, New_Id);
         Result.GB_Def :=
           Duplicate_Prog
           (Id => Def);
         Set_Link (Result.GB_Def, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Global_Binding;

   ----------------------------------
   -- Duplicate_Global_Rec_Binding --
   ----------------------------------

   function Duplicate_Global_Rec_Binding
     (Ada_Node : Node_Id := Empty;
      Id       : W_Global_Rec_Binding_Valid_OId)
     return W_Global_Rec_Binding_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Global_Rec_Binding);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Global_Rec_Binding);
         Name : constant W_Recfun_Valid_Id :=
            +Global_Rec_Binding_Get_Name (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.GRB_Name :=
           Duplicate_Recfun
           (Id => Name);
         Set_Link (Result.GRB_Name, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Global_Rec_Binding;

   -------------------------------------
   -- Duplicate_Parameter_Declaration --
   -------------------------------------

   function Duplicate_Parameter_Declaration
     (Ada_Node : Node_Id := Empty;
      Id       : W_Parameter_Declaration_Valid_OId)
     return W_Parameter_Declaration_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Parameter_Declaration);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Parameter_Declaration);
         External       : constant W_External_Valid_OId :=
            +Parameter_Declaration_Get_External (Id);
         Names          : constant W_Identifier_Valid_List :=
            +Parameter_Declaration_Get_Names (Id);
         Parameter_Type : constant W_Computation_Type_Valid_Id :=
            +Parameter_Declaration_Get_Parameter_Type (Id);
      begin
         Result.Ada_Node := Ada_Node;
         if External = Why_Empty then
            Result.PD_External := Why_Empty;
         else
            Result.PD_External :=
              Duplicate_External
              (Id => External);
         end if;
         Set_Link (Result.PD_External, New_Id);
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Names);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Identifier_Valid_Id :=
                           Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.PD_Names := NL;
         end;
         Set_Link (Result.PD_Names, New_Id);
         Result.PD_Parameter_Type :=
           Duplicate_Computation_Type
           (Id => Parameter_Type);
         Set_Link (Result.PD_Parameter_Type, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Parameter_Declaration;

   --------------------------------------
   -- Duplicate_Global_Ref_Declaration --
   --------------------------------------

   function Duplicate_Global_Ref_Declaration
     (Ada_Node : Node_Id := Empty;
      Id       : W_Global_Ref_Declaration_Valid_OId)
     return W_Global_Ref_Declaration_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Global_Ref_Declaration);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Global_Ref_Declaration);
         Name           : constant W_Identifier_Valid_Id :=
            +Global_Ref_Declaration_Get_Name (Id);
         Parameter_Type : constant W_Primitive_Type_Valid_Id :=
            +Global_Ref_Declaration_Get_Parameter_Type (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.GR_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.GR_Name, New_Id);
         Result.GR_Parameter_Type :=
           Duplicate_Primitive_Type
           (Id => Parameter_Type);
         Set_Link (Result.GR_Parameter_Type, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Global_Ref_Declaration;

   -------------------------------------
   -- Duplicate_Exception_Declaration --
   -------------------------------------

   function Duplicate_Exception_Declaration
     (Ada_Node : Node_Id := Empty;
      Id       : W_Exception_Declaration_Valid_OId)
     return W_Exception_Declaration_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Exception_Declaration);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Exception_Declaration);
         Name      : constant W_Identifier_Valid_Id :=
            +Exception_Declaration_Get_Name (Id);
         Parameter : constant W_Primitive_Type_Valid_OId :=
            +Exception_Declaration_Get_Parameter (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.ED_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.ED_Name, New_Id);
         if Parameter = Why_Empty then
            Result.ED_Parameter := Why_Empty;
         else
            Result.ED_Parameter :=
              Duplicate_Primitive_Type
              (Id => Parameter);
         end if;
         Set_Link (Result.ED_Parameter, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Exception_Declaration;

   ---------------------------------
   -- Duplicate_Logic_Declaration --
   ---------------------------------

   function Duplicate_Logic_Declaration
     (Ada_Node : Node_Id := Empty;
      Id       : W_Logic_Declaration_Valid_OId)
     return W_Logic_Declaration_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Logic_Declaration);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Logic_Declaration);
         Decl : constant W_Logic_Declaration_Class_Valid_Id :=
            +Logic_Declaration_Get_Decl (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.LD_Decl :=
           Duplicate_Logic_Declaration_Class
           (Id => Decl);
         Set_Link (Result.LD_Decl, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Logic_Declaration;

   -----------------------------------
   -- Duplicate_Include_Declaration --
   -----------------------------------

   function Duplicate_Include_Declaration
     (Ada_Node : Node_Id := Empty;
      Id       : W_Include_Declaration_Valid_OId)
     return W_Include_Declaration_Valid_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Include_Declaration);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Include_Declaration);
         Name : constant W_Identifier_Valid_Id :=
            +Include_Declaration_Get_Name (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.ID_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.ID_Name, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Include_Declaration;

   --------------------
   -- New_Identifier --
   --------------------

   function New_Identifier
     (Ada_Node : Node_Id := Empty;
      Symbol   : Name_Id;
      Entity   : Why_Node_Id := Why_Empty)
     return W_Identifier_Id
   is
      Result : Why_Node (W_Identifier);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Identifier);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Symbol :=
        Symbol;
      Result.Entity :=
        Entity;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Identifier_Id (New_Id);
   end New_Identifier;
   -------------------
   -- New_Type_Prop --
   -------------------

   function New_Type_Prop
     (Ada_Node : Node_Id := Empty)
     return W_Type_Prop_Id
   is
      Result : Why_Node (W_Type_Prop);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Type_Prop);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Type_Prop_Id (New_Id);
   end New_Type_Prop;

   -------------------
   -- New_Type_Prop --
   -------------------

   function New_Type_Prop
     (Ada_Node : Node_Id := Empty)
     return W_Logic_Return_Type_Id
   is
      Result : Why_Node (W_Type_Prop);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Type_Prop);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Logic_Return_Type_Id (New_Id);
   end New_Type_Prop;
   ------------------
   -- New_Type_Int --
   ------------------

   function New_Type_Int
     (Ada_Node : Node_Id := Empty)
     return W_Type_Int_Id
   is
      Result : Why_Node (W_Type_Int);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Type_Int);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Type_Int_Id (New_Id);
   end New_Type_Int;

   ------------------
   -- New_Type_Int --
   ------------------

   function New_Type_Int
     (Ada_Node : Node_Id := Empty)
     return W_Primitive_Type_Id
   is
      Result : Why_Node (W_Type_Int);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Type_Int);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Primitive_Type_Id (New_Id);
   end New_Type_Int;

   ------------------
   -- New_Type_Int --
   ------------------

   function New_Type_Int
     (Ada_Node : Node_Id := Empty)
     return W_Logic_Return_Type_Id
   is
      Result : Why_Node (W_Type_Int);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Type_Int);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Logic_Return_Type_Id (New_Id);
   end New_Type_Int;

   ------------------
   -- New_Type_Int --
   ------------------

   function New_Type_Int
     (Ada_Node : Node_Id := Empty)
     return W_Logic_Arg_Type_Id
   is
      Result : Why_Node (W_Type_Int);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Type_Int);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Logic_Arg_Type_Id (New_Id);
   end New_Type_Int;

   ------------------
   -- New_Type_Int --
   ------------------

   function New_Type_Int
     (Ada_Node : Node_Id := Empty)
     return W_Simple_Value_Type_Id
   is
      Result : Why_Node (W_Type_Int);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Type_Int);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Simple_Value_Type_Id (New_Id);
   end New_Type_Int;
   -------------------
   -- New_Type_Bool --
   -------------------

   function New_Type_Bool
     (Ada_Node : Node_Id := Empty)
     return W_Type_Bool_Id
   is
      Result : Why_Node (W_Type_Bool);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Type_Bool);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Type_Bool_Id (New_Id);
   end New_Type_Bool;

   -------------------
   -- New_Type_Bool --
   -------------------

   function New_Type_Bool
     (Ada_Node : Node_Id := Empty)
     return W_Primitive_Type_Id
   is
      Result : Why_Node (W_Type_Bool);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Type_Bool);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Primitive_Type_Id (New_Id);
   end New_Type_Bool;

   -------------------
   -- New_Type_Bool --
   -------------------

   function New_Type_Bool
     (Ada_Node : Node_Id := Empty)
     return W_Logic_Return_Type_Id
   is
      Result : Why_Node (W_Type_Bool);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Type_Bool);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Logic_Return_Type_Id (New_Id);
   end New_Type_Bool;

   -------------------
   -- New_Type_Bool --
   -------------------

   function New_Type_Bool
     (Ada_Node : Node_Id := Empty)
     return W_Logic_Arg_Type_Id
   is
      Result : Why_Node (W_Type_Bool);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Type_Bool);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Logic_Arg_Type_Id (New_Id);
   end New_Type_Bool;

   -------------------
   -- New_Type_Bool --
   -------------------

   function New_Type_Bool
     (Ada_Node : Node_Id := Empty)
     return W_Simple_Value_Type_Id
   is
      Result : Why_Node (W_Type_Bool);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Type_Bool);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Simple_Value_Type_Id (New_Id);
   end New_Type_Bool;
   -------------------
   -- New_Type_Real --
   -------------------

   function New_Type_Real
     (Ada_Node : Node_Id := Empty)
     return W_Type_Real_Id
   is
      Result : Why_Node (W_Type_Real);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Type_Real);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Type_Real_Id (New_Id);
   end New_Type_Real;

   -------------------
   -- New_Type_Real --
   -------------------

   function New_Type_Real
     (Ada_Node : Node_Id := Empty)
     return W_Primitive_Type_Id
   is
      Result : Why_Node (W_Type_Real);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Type_Real);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Primitive_Type_Id (New_Id);
   end New_Type_Real;

   -------------------
   -- New_Type_Real --
   -------------------

   function New_Type_Real
     (Ada_Node : Node_Id := Empty)
     return W_Logic_Return_Type_Id
   is
      Result : Why_Node (W_Type_Real);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Type_Real);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Logic_Return_Type_Id (New_Id);
   end New_Type_Real;

   -------------------
   -- New_Type_Real --
   -------------------

   function New_Type_Real
     (Ada_Node : Node_Id := Empty)
     return W_Logic_Arg_Type_Id
   is
      Result : Why_Node (W_Type_Real);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Type_Real);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Logic_Arg_Type_Id (New_Id);
   end New_Type_Real;

   -------------------
   -- New_Type_Real --
   -------------------

   function New_Type_Real
     (Ada_Node : Node_Id := Empty)
     return W_Simple_Value_Type_Id
   is
      Result : Why_Node (W_Type_Real);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Type_Real);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Simple_Value_Type_Id (New_Id);
   end New_Type_Real;
   -------------------
   -- New_Type_Unit --
   -------------------

   function New_Type_Unit
     (Ada_Node : Node_Id := Empty)
     return W_Type_Unit_Id
   is
      Result : Why_Node (W_Type_Unit);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Type_Unit);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Type_Unit_Id (New_Id);
   end New_Type_Unit;

   -------------------
   -- New_Type_Unit --
   -------------------

   function New_Type_Unit
     (Ada_Node : Node_Id := Empty)
     return W_Primitive_Type_Id
   is
      Result : Why_Node (W_Type_Unit);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Type_Unit);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Primitive_Type_Id (New_Id);
   end New_Type_Unit;

   -------------------
   -- New_Type_Unit --
   -------------------

   function New_Type_Unit
     (Ada_Node : Node_Id := Empty)
     return W_Logic_Return_Type_Id
   is
      Result : Why_Node (W_Type_Unit);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Type_Unit);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Logic_Return_Type_Id (New_Id);
   end New_Type_Unit;

   -------------------
   -- New_Type_Unit --
   -------------------

   function New_Type_Unit
     (Ada_Node : Node_Id := Empty)
     return W_Logic_Arg_Type_Id
   is
      Result : Why_Node (W_Type_Unit);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Type_Unit);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Logic_Arg_Type_Id (New_Id);
   end New_Type_Unit;

   -------------------
   -- New_Type_Unit --
   -------------------

   function New_Type_Unit
     (Ada_Node : Node_Id := Empty)
     return W_Simple_Value_Type_Id
   is
      Result : Why_Node (W_Type_Unit);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Type_Unit);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Simple_Value_Type_Id (New_Id);
   end New_Type_Unit;
   -----------------------
   -- New_Abstract_Type --
   -----------------------

   function New_Abstract_Type
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id)
     return W_Abstract_Type_Id
   is
      Result : Why_Node (W_Abstract_Type);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Abstract_Type);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.AT_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.AT_Name, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Abstract_Type_Id (New_Id);
   end New_Abstract_Type;

   -----------------------
   -- New_Abstract_Type --
   -----------------------

   function New_Abstract_Type
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id)
     return W_Primitive_Type_Id
   is
      Result : Why_Node (W_Abstract_Type);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Abstract_Type);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.AT_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.AT_Name, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Primitive_Type_Id (New_Id);
   end New_Abstract_Type;

   -----------------------
   -- New_Abstract_Type --
   -----------------------

   function New_Abstract_Type
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id)
     return W_Logic_Return_Type_Id
   is
      Result : Why_Node (W_Abstract_Type);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Abstract_Type);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.AT_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.AT_Name, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Logic_Return_Type_Id (New_Id);
   end New_Abstract_Type;

   -----------------------
   -- New_Abstract_Type --
   -----------------------

   function New_Abstract_Type
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id)
     return W_Logic_Arg_Type_Id
   is
      Result : Why_Node (W_Abstract_Type);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Abstract_Type);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.AT_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.AT_Name, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Logic_Arg_Type_Id (New_Id);
   end New_Abstract_Type;

   -----------------------
   -- New_Abstract_Type --
   -----------------------

   function New_Abstract_Type
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id)
     return W_Simple_Value_Type_Id
   is
      Result : Why_Node (W_Abstract_Type);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Abstract_Type);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.AT_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.AT_Name, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Simple_Value_Type_Id (New_Id);
   end New_Abstract_Type;
   -----------------------------
   -- New_Generic_Formal_Type --
   -----------------------------

   function New_Generic_Formal_Type
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id)
     return W_Generic_Formal_Type_Id
   is
      Result : Why_Node (W_Generic_Formal_Type);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Generic_Formal_Type);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.GFT_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.GFT_Name, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Generic_Formal_Type_Id (New_Id);
   end New_Generic_Formal_Type;

   -----------------------------
   -- New_Generic_Formal_Type --
   -----------------------------

   function New_Generic_Formal_Type
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id)
     return W_Primitive_Type_Id
   is
      Result : Why_Node (W_Generic_Formal_Type);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Generic_Formal_Type);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.GFT_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.GFT_Name, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Primitive_Type_Id (New_Id);
   end New_Generic_Formal_Type;

   -----------------------------
   -- New_Generic_Formal_Type --
   -----------------------------

   function New_Generic_Formal_Type
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id)
     return W_Logic_Return_Type_Id
   is
      Result : Why_Node (W_Generic_Formal_Type);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Generic_Formal_Type);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.GFT_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.GFT_Name, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Logic_Return_Type_Id (New_Id);
   end New_Generic_Formal_Type;

   -----------------------------
   -- New_Generic_Formal_Type --
   -----------------------------

   function New_Generic_Formal_Type
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id)
     return W_Logic_Arg_Type_Id
   is
      Result : Why_Node (W_Generic_Formal_Type);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Generic_Formal_Type);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.GFT_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.GFT_Name, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Logic_Arg_Type_Id (New_Id);
   end New_Generic_Formal_Type;

   -----------------------------
   -- New_Generic_Formal_Type --
   -----------------------------

   function New_Generic_Formal_Type
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id)
     return W_Simple_Value_Type_Id
   is
      Result : Why_Node (W_Generic_Formal_Type);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Generic_Formal_Type);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.GFT_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.GFT_Name, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Simple_Value_Type_Id (New_Id);
   end New_Generic_Formal_Type;
   -----------------------------------
   -- New_Generic_Actual_Type_Chain --
   -----------------------------------

   function New_Generic_Actual_Type_Chain
     (Ada_Node   : Node_Id := Empty;
      Type_Chain : W_Primitive_Type_Array;
      Name       : W_Identifier_Id)
     return W_Generic_Actual_Type_Chain_Id
   is
      Result : Why_Node (W_Generic_Actual_Type_Chain);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Generic_Actual_Type_Chain);
   begin
      Result.Ada_Node :=
        Ada_Node;
      pragma Assert (Type_Chain'Length > 0);
      Result.GATC_Type_Chain := New_List;
      for J in Type_Chain'Range loop
         pragma Assert
           (Primitive_Type_Id_Kind_Valid
            (+(W_Primitive_Type_Valid_Id (Type_Chain (J)))));
         pragma Assert
           (Primitive_Type_Id_Valid
            (+(W_Primitive_Type_Valid_Id (Type_Chain (J)))));
         Append
           (Result.GATC_Type_Chain,
            +(W_Primitive_Type_Valid_Id (Type_Chain (J))));
      end loop;
      Set_Link (Result.GATC_Type_Chain, New_Id);
      Result.GATC_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.GATC_Name, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Generic_Actual_Type_Chain_Id (New_Id);
   end New_Generic_Actual_Type_Chain;

   -----------------------------------
   -- New_Generic_Actual_Type_Chain --
   -----------------------------------

   function New_Generic_Actual_Type_Chain
     (Ada_Node   : Node_Id := Empty;
      Type_Chain : W_Primitive_Type_Array;
      Name       : W_Identifier_Id)
     return W_Primitive_Type_Id
   is
      Result : Why_Node (W_Generic_Actual_Type_Chain);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Generic_Actual_Type_Chain);
   begin
      Result.Ada_Node :=
        Ada_Node;
      pragma Assert (Type_Chain'Length > 0);
      Result.GATC_Type_Chain := New_List;
      for J in Type_Chain'Range loop
         pragma Assert
           (Primitive_Type_Id_Kind_Valid
            (+(W_Primitive_Type_Valid_Id (Type_Chain (J)))));
         pragma Assert
           (Primitive_Type_Id_Valid
            (+(W_Primitive_Type_Valid_Id (Type_Chain (J)))));
         Append
           (Result.GATC_Type_Chain,
            +(W_Primitive_Type_Valid_Id (Type_Chain (J))));
      end loop;
      Set_Link (Result.GATC_Type_Chain, New_Id);
      Result.GATC_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.GATC_Name, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Primitive_Type_Id (New_Id);
   end New_Generic_Actual_Type_Chain;

   -----------------------------------
   -- New_Generic_Actual_Type_Chain --
   -----------------------------------

   function New_Generic_Actual_Type_Chain
     (Ada_Node   : Node_Id := Empty;
      Type_Chain : W_Primitive_Type_Array;
      Name       : W_Identifier_Id)
     return W_Logic_Return_Type_Id
   is
      Result : Why_Node (W_Generic_Actual_Type_Chain);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Generic_Actual_Type_Chain);
   begin
      Result.Ada_Node :=
        Ada_Node;
      pragma Assert (Type_Chain'Length > 0);
      Result.GATC_Type_Chain := New_List;
      for J in Type_Chain'Range loop
         pragma Assert
           (Primitive_Type_Id_Kind_Valid
            (+(W_Primitive_Type_Valid_Id (Type_Chain (J)))));
         pragma Assert
           (Primitive_Type_Id_Valid
            (+(W_Primitive_Type_Valid_Id (Type_Chain (J)))));
         Append
           (Result.GATC_Type_Chain,
            +(W_Primitive_Type_Valid_Id (Type_Chain (J))));
      end loop;
      Set_Link (Result.GATC_Type_Chain, New_Id);
      Result.GATC_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.GATC_Name, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Logic_Return_Type_Id (New_Id);
   end New_Generic_Actual_Type_Chain;

   -----------------------------------
   -- New_Generic_Actual_Type_Chain --
   -----------------------------------

   function New_Generic_Actual_Type_Chain
     (Ada_Node   : Node_Id := Empty;
      Type_Chain : W_Primitive_Type_Array;
      Name       : W_Identifier_Id)
     return W_Logic_Arg_Type_Id
   is
      Result : Why_Node (W_Generic_Actual_Type_Chain);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Generic_Actual_Type_Chain);
   begin
      Result.Ada_Node :=
        Ada_Node;
      pragma Assert (Type_Chain'Length > 0);
      Result.GATC_Type_Chain := New_List;
      for J in Type_Chain'Range loop
         pragma Assert
           (Primitive_Type_Id_Kind_Valid
            (+(W_Primitive_Type_Valid_Id (Type_Chain (J)))));
         pragma Assert
           (Primitive_Type_Id_Valid
            (+(W_Primitive_Type_Valid_Id (Type_Chain (J)))));
         Append
           (Result.GATC_Type_Chain,
            +(W_Primitive_Type_Valid_Id (Type_Chain (J))));
      end loop;
      Set_Link (Result.GATC_Type_Chain, New_Id);
      Result.GATC_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.GATC_Name, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Logic_Arg_Type_Id (New_Id);
   end New_Generic_Actual_Type_Chain;

   -----------------------------------
   -- New_Generic_Actual_Type_Chain --
   -----------------------------------

   function New_Generic_Actual_Type_Chain
     (Ada_Node   : Node_Id := Empty;
      Type_Chain : W_Primitive_Type_Array;
      Name       : W_Identifier_Id)
     return W_Simple_Value_Type_Id
   is
      Result : Why_Node (W_Generic_Actual_Type_Chain);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Generic_Actual_Type_Chain);
   begin
      Result.Ada_Node :=
        Ada_Node;
      pragma Assert (Type_Chain'Length > 0);
      Result.GATC_Type_Chain := New_List;
      for J in Type_Chain'Range loop
         pragma Assert
           (Primitive_Type_Id_Kind_Valid
            (+(W_Primitive_Type_Valid_Id (Type_Chain (J)))));
         pragma Assert
           (Primitive_Type_Id_Valid
            (+(W_Primitive_Type_Valid_Id (Type_Chain (J)))));
         Append
           (Result.GATC_Type_Chain,
            +(W_Primitive_Type_Valid_Id (Type_Chain (J))));
      end loop;
      Set_Link (Result.GATC_Type_Chain, New_Id);
      Result.GATC_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.GATC_Name, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Simple_Value_Type_Id (New_Id);
   end New_Generic_Actual_Type_Chain;
   --------------------
   -- New_Array_Type --
   --------------------

   function New_Array_Type
     (Ada_Node       : Node_Id := Empty;
      Component_Type : W_Primitive_Type_Id)
     return W_Array_Type_Id
   is
      Result : Why_Node (W_Array_Type);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Array_Type);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.AT_Component_Type :=
        +(W_Primitive_Type_Valid_Id (Component_Type));
      Set_Link (Result.AT_Component_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Array_Type_Id (New_Id);
   end New_Array_Type;

   --------------------
   -- New_Array_Type --
   --------------------

   function New_Array_Type
     (Ada_Node       : Node_Id := Empty;
      Component_Type : W_Primitive_Type_Id)
     return W_Logic_Arg_Type_Id
   is
      Result : Why_Node (W_Array_Type);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Array_Type);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.AT_Component_Type :=
        +(W_Primitive_Type_Valid_Id (Component_Type));
      Set_Link (Result.AT_Component_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Logic_Arg_Type_Id (New_Id);
   end New_Array_Type;

   --------------------
   -- New_Array_Type --
   --------------------

   function New_Array_Type
     (Ada_Node       : Node_Id := Empty;
      Component_Type : W_Primitive_Type_Id)
     return W_Simple_Value_Type_Id
   is
      Result : Why_Node (W_Array_Type);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Array_Type);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.AT_Component_Type :=
        +(W_Primitive_Type_Valid_Id (Component_Type));
      Set_Link (Result.AT_Component_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Simple_Value_Type_Id (New_Id);
   end New_Array_Type;
   ------------------
   -- New_Ref_Type --
   ------------------

   function New_Ref_Type
     (Ada_Node     : Node_Id := Empty;
      Aliased_Type : W_Primitive_Type_Id)
     return W_Ref_Type_Id
   is
      Result : Why_Node (W_Ref_Type);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Ref_Type);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.RT_Aliased_Type :=
        +(W_Primitive_Type_Valid_Id (Aliased_Type));
      Set_Link (Result.RT_Aliased_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Ref_Type_Id (New_Id);
   end New_Ref_Type;

   ------------------
   -- New_Ref_Type --
   ------------------

   function New_Ref_Type
     (Ada_Node     : Node_Id := Empty;
      Aliased_Type : W_Primitive_Type_Id)
     return W_Simple_Value_Type_Id
   is
      Result : Why_Node (W_Ref_Type);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Ref_Type);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.RT_Aliased_Type :=
        +(W_Primitive_Type_Valid_Id (Aliased_Type));
      Set_Link (Result.RT_Aliased_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Simple_Value_Type_Id (New_Id);
   end New_Ref_Type;
   --------------------------
   -- New_Computation_Type --
   --------------------------

   function New_Computation_Type
     (Ada_Node      : Node_Id := Empty;
      Binders       : W_Binder_Array := (2 .. 1 => <>);
      Precondition  : W_Precondition_OId := Why_Empty;
      Result_Name   : W_Identifier_OId := Why_Empty;
      Return_Type   : W_Primitive_Type_Id;
      Effects       : W_Effects_Id;
      Postcondition : W_Postcondition_OId := Why_Empty)
     return W_Computation_Type_Id
   is
      Result : Why_Node (W_Computation_Type);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Computation_Type);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.CS_Binders := New_List;
      for J in Binders'Range loop
         pragma Assert
           (Binder_Id_Kind_Valid
            (+(W_Binder_Valid_OId (Binders (J)))));
         pragma Assert
           (Binder_Id_Valid
            (+(W_Binder_Valid_OId (Binders (J)))));
         Append
           (Result.CS_Binders,
            +(W_Binder_Valid_OId (Binders (J))));
      end loop;
      Set_Link (Result.CS_Binders, New_Id);
      Result.CS_Precondition :=
        +(W_Precondition_Valid_OId (Precondition));
      Set_Link (Result.CS_Precondition, New_Id);
      Result.CS_Result_Name :=
        +(W_Identifier_Valid_OId (Result_Name));
      Set_Link (Result.CS_Result_Name, New_Id);
      Result.CS_Return_Type :=
        +(W_Primitive_Type_Valid_Id (Return_Type));
      Set_Link (Result.CS_Return_Type, New_Id);
      Result.CS_Effects :=
        +(W_Effects_Valid_Id (Effects));
      Set_Link (Result.CS_Effects, New_Id);
      Result.CS_Postcondition :=
        +(W_Postcondition_Valid_OId (Postcondition));
      Set_Link (Result.CS_Postcondition, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Computation_Type_Id (New_Id);
   end New_Computation_Type;
   --------------------------
   -- New_Integer_Constant --
   --------------------------

   function New_Integer_Constant
     (Ada_Node : Node_Id := Empty;
      Value    : Uint)
     return W_Integer_Constant_Id
   is
      Result : Why_Node (W_Integer_Constant);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Integer_Constant);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.IC_Value :=
        Value;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Integer_Constant_Id (New_Id);
   end New_Integer_Constant;

   --------------------------
   -- New_Integer_Constant --
   --------------------------

   function New_Integer_Constant
     (Ada_Node : Node_Id := Empty;
      Value    : Uint)
     return W_Term_Id
   is
      Result : Why_Node (W_Integer_Constant);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Integer_Constant);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.IC_Value :=
        Value;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Term_Id (New_Id);
   end New_Integer_Constant;

   --------------------------
   -- New_Integer_Constant --
   --------------------------

   function New_Integer_Constant
     (Ada_Node : Node_Id := Empty;
      Value    : Uint)
     return W_Constant_Id
   is
      Result : Why_Node (W_Integer_Constant);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Integer_Constant);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.IC_Value :=
        Value;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Constant_Id (New_Id);
   end New_Integer_Constant;
   -----------------------
   -- New_Real_Constant --
   -----------------------

   function New_Real_Constant
     (Ada_Node : Node_Id := Empty;
      Value    : Ureal)
     return W_Real_Constant_Id
   is
      Result : Why_Node (W_Real_Constant);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Real_Constant);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.RC_Value :=
        Value;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Real_Constant_Id (New_Id);
   end New_Real_Constant;

   -----------------------
   -- New_Real_Constant --
   -----------------------

   function New_Real_Constant
     (Ada_Node : Node_Id := Empty;
      Value    : Ureal)
     return W_Term_Id
   is
      Result : Why_Node (W_Real_Constant);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Real_Constant);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.RC_Value :=
        Value;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Term_Id (New_Id);
   end New_Real_Constant;

   -----------------------
   -- New_Real_Constant --
   -----------------------

   function New_Real_Constant
     (Ada_Node : Node_Id := Empty;
      Value    : Ureal)
     return W_Constant_Id
   is
      Result : Why_Node (W_Real_Constant);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Real_Constant);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.RC_Value :=
        Value;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Constant_Id (New_Id);
   end New_Real_Constant;
   ----------------------
   -- New_True_Literal --
   ----------------------

   function New_True_Literal
     (Ada_Node : Node_Id := Empty)
     return W_True_Literal_Id
   is
      Result : Why_Node (W_True_Literal);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_True_Literal);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_True_Literal_Id (New_Id);
   end New_True_Literal;

   ----------------------
   -- New_True_Literal --
   ----------------------

   function New_True_Literal
     (Ada_Node : Node_Id := Empty)
     return W_Term_Id
   is
      Result : Why_Node (W_True_Literal);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_True_Literal);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Term_Id (New_Id);
   end New_True_Literal;

   ----------------------
   -- New_True_Literal --
   ----------------------

   function New_True_Literal
     (Ada_Node : Node_Id := Empty)
     return W_Constant_Id
   is
      Result : Why_Node (W_True_Literal);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_True_Literal);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Constant_Id (New_Id);
   end New_True_Literal;
   -----------------------
   -- New_False_Literal --
   -----------------------

   function New_False_Literal
     (Ada_Node : Node_Id := Empty)
     return W_False_Literal_Id
   is
      Result : Why_Node (W_False_Literal);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_False_Literal);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_False_Literal_Id (New_Id);
   end New_False_Literal;

   -----------------------
   -- New_False_Literal --
   -----------------------

   function New_False_Literal
     (Ada_Node : Node_Id := Empty)
     return W_Term_Id
   is
      Result : Why_Node (W_False_Literal);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_False_Literal);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Term_Id (New_Id);
   end New_False_Literal;

   -----------------------
   -- New_False_Literal --
   -----------------------

   function New_False_Literal
     (Ada_Node : Node_Id := Empty)
     return W_Constant_Id
   is
      Result : Why_Node (W_False_Literal);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_False_Literal);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Constant_Id (New_Id);
   end New_False_Literal;
   ----------------------
   -- New_Void_Literal --
   ----------------------

   function New_Void_Literal
     (Ada_Node : Node_Id := Empty)
     return W_Void_Literal_Id
   is
      Result : Why_Node (W_Void_Literal);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Void_Literal);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Void_Literal_Id (New_Id);
   end New_Void_Literal;

   ----------------------
   -- New_Void_Literal --
   ----------------------

   function New_Void_Literal
     (Ada_Node : Node_Id := Empty)
     return W_Term_Id
   is
      Result : Why_Node (W_Void_Literal);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Void_Literal);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Term_Id (New_Id);
   end New_Void_Literal;

   ----------------------
   -- New_Void_Literal --
   ----------------------

   function New_Void_Literal
     (Ada_Node : Node_Id := Empty)
     return W_Constant_Id
   is
      Result : Why_Node (W_Void_Literal);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Void_Literal);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Constant_Id (New_Id);
   end New_Void_Literal;
   -------------------------
   -- New_Arith_Operation --
   -------------------------

   function New_Arith_Operation
     (Ada_Node : Node_Id := Empty;
      Left     : W_Term_Id;
      Op       : W_Arith_Op_Id;
      Right    : W_Term_Id)
     return W_Arith_Operation_Id
   is
      Result : Why_Node (W_Arith_Operation);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Arith_Operation);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.AO_Left :=
        +(W_Term_Valid_Id (Left));
      Set_Link (Result.AO_Left, New_Id);
      Result.AO_Op :=
        +(W_Arith_Op_Valid_Id (Op));
      Set_Link (Result.AO_Op, New_Id);
      Result.AO_Right :=
        +(W_Term_Valid_Id (Right));
      Set_Link (Result.AO_Right, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Arith_Operation_Id (New_Id);
   end New_Arith_Operation;

   -------------------------
   -- New_Arith_Operation --
   -------------------------

   function New_Arith_Operation
     (Ada_Node : Node_Id := Empty;
      Left     : W_Term_Id;
      Op       : W_Arith_Op_Id;
      Right    : W_Term_Id)
     return W_Term_Id
   is
      Result : Why_Node (W_Arith_Operation);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Arith_Operation);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.AO_Left :=
        +(W_Term_Valid_Id (Left));
      Set_Link (Result.AO_Left, New_Id);
      Result.AO_Op :=
        +(W_Arith_Op_Valid_Id (Op));
      Set_Link (Result.AO_Op, New_Id);
      Result.AO_Right :=
        +(W_Term_Valid_Id (Right));
      Set_Link (Result.AO_Right, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Term_Id (New_Id);
   end New_Arith_Operation;
   -----------------------
   -- New_Negative_Term --
   -----------------------

   function New_Negative_Term
     (Ada_Node : Node_Id := Empty;
      Operand  : W_Term_Id)
     return W_Negative_Term_Id
   is
      Result : Why_Node (W_Negative_Term);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Negative_Term);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.NT_Operand :=
        +(W_Term_Valid_Id (Operand));
      Set_Link (Result.NT_Operand, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Negative_Term_Id (New_Id);
   end New_Negative_Term;

   -----------------------
   -- New_Negative_Term --
   -----------------------

   function New_Negative_Term
     (Ada_Node : Node_Id := Empty;
      Operand  : W_Term_Id)
     return W_Term_Id
   is
      Result : Why_Node (W_Negative_Term);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Negative_Term);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.NT_Operand :=
        +(W_Term_Valid_Id (Operand));
      Set_Link (Result.NT_Operand, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Term_Id (New_Id);
   end New_Negative_Term;
   -------------------------
   -- New_Term_Identifier --
   -------------------------

   function New_Term_Identifier
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id;
      Label    : W_Identifier_OId := Why_Empty)
     return W_Term_Identifier_Id
   is
      Result : Why_Node (W_Term_Identifier);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Term_Identifier);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.TIL_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.TIL_Name, New_Id);
      Result.TIL_Label :=
        +(W_Identifier_Valid_OId (Label));
      Set_Link (Result.TIL_Label, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Term_Identifier_Id (New_Id);
   end New_Term_Identifier;

   -------------------------
   -- New_Term_Identifier --
   -------------------------

   function New_Term_Identifier
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id;
      Label    : W_Identifier_OId := Why_Empty)
     return W_Term_Id
   is
      Result : Why_Node (W_Term_Identifier);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Term_Identifier);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.TIL_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.TIL_Name, New_Id);
      Result.TIL_Label :=
        +(W_Identifier_Valid_OId (Label));
      Set_Link (Result.TIL_Label, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Term_Id (New_Id);
   end New_Term_Identifier;
   -------------------
   -- New_Operation --
   -------------------

   function New_Operation
     (Ada_Node   : Node_Id := Empty;
      Name       : W_Identifier_Id;
      Parameters : W_Term_Array)
     return W_Operation_Id
   is
      Result : Why_Node (W_Operation);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Operation);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.O_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.O_Name, New_Id);
      pragma Assert (Parameters'Length > 0);
      Result.O_Parameters := New_List;
      for J in Parameters'Range loop
         pragma Assert
           (Term_Id_Kind_Valid
            (+(W_Term_Valid_Id (Parameters (J)))));
         pragma Assert
           (Term_Id_Valid
            (+(W_Term_Valid_Id (Parameters (J)))));
         Append
           (Result.O_Parameters,
            +(W_Term_Valid_Id (Parameters (J))));
      end loop;
      Set_Link (Result.O_Parameters, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Operation_Id (New_Id);
   end New_Operation;

   -------------------
   -- New_Operation --
   -------------------

   function New_Operation
     (Ada_Node   : Node_Id := Empty;
      Name       : W_Identifier_Id;
      Parameters : W_Term_Array)
     return W_Term_Id
   is
      Result : Why_Node (W_Operation);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Operation);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.O_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.O_Name, New_Id);
      pragma Assert (Parameters'Length > 0);
      Result.O_Parameters := New_List;
      for J in Parameters'Range loop
         pragma Assert
           (Term_Id_Kind_Valid
            (+(W_Term_Valid_Id (Parameters (J)))));
         pragma Assert
           (Term_Id_Valid
            (+(W_Term_Valid_Id (Parameters (J)))));
         Append
           (Result.O_Parameters,
            +(W_Term_Valid_Id (Parameters (J))));
      end loop;
      Set_Link (Result.O_Parameters, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Term_Id (New_Id);
   end New_Operation;
   --------------------
   -- New_Named_Term --
   --------------------

   function New_Named_Term
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id;
      Term     : W_Term_Id)
     return W_Named_Term_Id
   is
      Result : Why_Node (W_Named_Term);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Named_Term);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.NT_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.NT_Name, New_Id);
      Result.NT_Term :=
        +(W_Term_Valid_Id (Term));
      Set_Link (Result.NT_Term, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Named_Term_Id (New_Id);
   end New_Named_Term;

   --------------------
   -- New_Named_Term --
   --------------------

   function New_Named_Term
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id;
      Term     : W_Term_Id)
     return W_Term_Id
   is
      Result : Why_Node (W_Named_Term);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Named_Term);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.NT_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.NT_Name, New_Id);
      Result.NT_Term :=
        +(W_Term_Valid_Id (Term));
      Set_Link (Result.NT_Term, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Term_Id (New_Id);
   end New_Named_Term;
   --------------------------
   -- New_Conditional_Term --
   --------------------------

   function New_Conditional_Term
     (Ada_Node  : Node_Id := Empty;
      Condition : W_Term_Id;
      Then_Part : W_Term_Id;
      Else_Part : W_Term_Id)
     return W_Conditional_Term_Id
   is
      Result : Why_Node (W_Conditional_Term);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Conditional_Term);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.CT_Condition :=
        +(W_Term_Valid_Id (Condition));
      Set_Link (Result.CT_Condition, New_Id);
      Result.CT_Then_Part :=
        +(W_Term_Valid_Id (Then_Part));
      Set_Link (Result.CT_Then_Part, New_Id);
      Result.CT_Else_Part :=
        +(W_Term_Valid_Id (Else_Part));
      Set_Link (Result.CT_Else_Part, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Conditional_Term_Id (New_Id);
   end New_Conditional_Term;

   --------------------------
   -- New_Conditional_Term --
   --------------------------

   function New_Conditional_Term
     (Ada_Node  : Node_Id := Empty;
      Condition : W_Term_Id;
      Then_Part : W_Term_Id;
      Else_Part : W_Term_Id)
     return W_Term_Id
   is
      Result : Why_Node (W_Conditional_Term);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Conditional_Term);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.CT_Condition :=
        +(W_Term_Valid_Id (Condition));
      Set_Link (Result.CT_Condition, New_Id);
      Result.CT_Then_Part :=
        +(W_Term_Valid_Id (Then_Part));
      Set_Link (Result.CT_Then_Part, New_Id);
      Result.CT_Else_Part :=
        +(W_Term_Valid_Id (Else_Part));
      Set_Link (Result.CT_Else_Part, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Term_Id (New_Id);
   end New_Conditional_Term;
   -----------------------
   -- New_Matching_Term --
   -----------------------

   function New_Matching_Term
     (Ada_Node : Node_Id := Empty;
      Term     : W_Term_Id;
      Branches : W_Match_Case_Array)
     return W_Matching_Term_Id
   is
      Result : Why_Node (W_Matching_Term);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Matching_Term);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.MT_Term :=
        +(W_Term_Valid_Id (Term));
      Set_Link (Result.MT_Term, New_Id);
      pragma Assert (Branches'Length > 0);
      Result.MT_Branches := New_List;
      for J in Branches'Range loop
         pragma Assert
           (Match_Case_Id_Kind_Valid
            (+(W_Match_Case_Valid_Id (Branches (J)))));
         pragma Assert
           (Match_Case_Id_Valid
            (+(W_Match_Case_Valid_Id (Branches (J)))));
         Append
           (Result.MT_Branches,
            +(W_Match_Case_Valid_Id (Branches (J))));
      end loop;
      Set_Link (Result.MT_Branches, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Matching_Term_Id (New_Id);
   end New_Matching_Term;

   -----------------------
   -- New_Matching_Term --
   -----------------------

   function New_Matching_Term
     (Ada_Node : Node_Id := Empty;
      Term     : W_Term_Id;
      Branches : W_Match_Case_Array)
     return W_Term_Id
   is
      Result : Why_Node (W_Matching_Term);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Matching_Term);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.MT_Term :=
        +(W_Term_Valid_Id (Term));
      Set_Link (Result.MT_Term, New_Id);
      pragma Assert (Branches'Length > 0);
      Result.MT_Branches := New_List;
      for J in Branches'Range loop
         pragma Assert
           (Match_Case_Id_Kind_Valid
            (+(W_Match_Case_Valid_Id (Branches (J)))));
         pragma Assert
           (Match_Case_Id_Valid
            (+(W_Match_Case_Valid_Id (Branches (J)))));
         Append
           (Result.MT_Branches,
            +(W_Match_Case_Valid_Id (Branches (J))));
      end loop;
      Set_Link (Result.MT_Branches, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Term_Id (New_Id);
   end New_Matching_Term;
   ----------------------
   -- New_Binding_Term --
   ----------------------

   function New_Binding_Term
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id;
      Def      : W_Term_Id;
      Context  : W_Term_Id)
     return W_Binding_Term_Id
   is
      Result : Why_Node (W_Binding_Term);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Binding_Term);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.BT_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.BT_Name, New_Id);
      Result.BT_Def :=
        +(W_Term_Valid_Id (Def));
      Set_Link (Result.BT_Def, New_Id);
      Result.BT_Context :=
        +(W_Term_Valid_Id (Context));
      Set_Link (Result.BT_Context, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Binding_Term_Id (New_Id);
   end New_Binding_Term;

   ----------------------
   -- New_Binding_Term --
   ----------------------

   function New_Binding_Term
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id;
      Def      : W_Term_Id;
      Context  : W_Term_Id)
     return W_Term_Id
   is
      Result : Why_Node (W_Binding_Term);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Binding_Term);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.BT_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.BT_Name, New_Id);
      Result.BT_Def :=
        +(W_Term_Valid_Id (Def));
      Set_Link (Result.BT_Def, New_Id);
      Result.BT_Context :=
        +(W_Term_Valid_Id (Context));
      Set_Link (Result.BT_Context, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Term_Id (New_Id);
   end New_Binding_Term;
   ------------------------
   -- New_Protected_Term --
   ------------------------

   function New_Protected_Term
     (Ada_Node : Node_Id := Empty;
      Term     : W_Term_Id)
     return W_Protected_Term_Id
   is
      Result : Why_Node (W_Protected_Term);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Protected_Term);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.BT_Term :=
        +(W_Term_Valid_Id (Term));
      Set_Link (Result.BT_Term, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Protected_Term_Id (New_Id);
   end New_Protected_Term;

   ------------------------
   -- New_Protected_Term --
   ------------------------

   function New_Protected_Term
     (Ada_Node : Node_Id := Empty;
      Term     : W_Term_Id)
     return W_Term_Id
   is
      Result : Why_Node (W_Protected_Term);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Protected_Term);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.BT_Term :=
        +(W_Term_Valid_Id (Term));
      Set_Link (Result.BT_Term, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Term_Id (New_Id);
   end New_Protected_Term;
   ----------------
   -- New_Op_Add --
   ----------------

   function New_Op_Add
     (Ada_Node : Node_Id := Empty)
     return W_Op_Add_Id
   is
      Result : Why_Node (W_Op_Add);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Add);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Op_Add_Id (New_Id);
   end New_Op_Add;

   ----------------
   -- New_Op_Add --
   ----------------

   function New_Op_Add
     (Ada_Node : Node_Id := Empty)
     return W_Arith_Op_Id
   is
      Result : Why_Node (W_Op_Add);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Add);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Arith_Op_Id (New_Id);
   end New_Op_Add;
   ----------------------
   -- New_Op_Substract --
   ----------------------

   function New_Op_Substract
     (Ada_Node : Node_Id := Empty)
     return W_Op_Substract_Id
   is
      Result : Why_Node (W_Op_Substract);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Substract);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Op_Substract_Id (New_Id);
   end New_Op_Substract;

   ----------------------
   -- New_Op_Substract --
   ----------------------

   function New_Op_Substract
     (Ada_Node : Node_Id := Empty)
     return W_Arith_Op_Id
   is
      Result : Why_Node (W_Op_Substract);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Substract);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Arith_Op_Id (New_Id);
   end New_Op_Substract;
   ---------------------
   -- New_Op_Multiply --
   ---------------------

   function New_Op_Multiply
     (Ada_Node : Node_Id := Empty)
     return W_Op_Multiply_Id
   is
      Result : Why_Node (W_Op_Multiply);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Multiply);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Op_Multiply_Id (New_Id);
   end New_Op_Multiply;

   ---------------------
   -- New_Op_Multiply --
   ---------------------

   function New_Op_Multiply
     (Ada_Node : Node_Id := Empty)
     return W_Arith_Op_Id
   is
      Result : Why_Node (W_Op_Multiply);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Multiply);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Arith_Op_Id (New_Id);
   end New_Op_Multiply;
   -------------------
   -- New_Op_Divide --
   -------------------

   function New_Op_Divide
     (Ada_Node : Node_Id := Empty)
     return W_Op_Divide_Id
   is
      Result : Why_Node (W_Op_Divide);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Divide);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Op_Divide_Id (New_Id);
   end New_Op_Divide;

   -------------------
   -- New_Op_Divide --
   -------------------

   function New_Op_Divide
     (Ada_Node : Node_Id := Empty)
     return W_Arith_Op_Id
   is
      Result : Why_Node (W_Op_Divide);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Divide);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Arith_Op_Id (New_Id);
   end New_Op_Divide;
   -------------------
   -- New_Op_Modulo --
   -------------------

   function New_Op_Modulo
     (Ada_Node : Node_Id := Empty)
     return W_Op_Modulo_Id
   is
      Result : Why_Node (W_Op_Modulo);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Modulo);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Op_Modulo_Id (New_Id);
   end New_Op_Modulo;

   -------------------
   -- New_Op_Modulo --
   -------------------

   function New_Op_Modulo
     (Ada_Node : Node_Id := Empty)
     return W_Arith_Op_Id
   is
      Result : Why_Node (W_Op_Modulo);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Modulo);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Arith_Op_Id (New_Id);
   end New_Op_Modulo;
   ---------------------------
   -- New_True_Literal_Pred --
   ---------------------------

   function New_True_Literal_Pred
     (Ada_Node : Node_Id := Empty)
     return W_True_Literal_Pred_Id
   is
      Result : Why_Node (W_True_Literal_Pred);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_True_Literal_Pred);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_True_Literal_Pred_Id (New_Id);
   end New_True_Literal_Pred;

   ---------------------------
   -- New_True_Literal_Pred --
   ---------------------------

   function New_True_Literal_Pred
     (Ada_Node : Node_Id := Empty)
     return W_Predicate_Id
   is
      Result : Why_Node (W_True_Literal_Pred);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_True_Literal_Pred);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Predicate_Id (New_Id);
   end New_True_Literal_Pred;
   ----------------------------
   -- New_False_Literal_Pred --
   ----------------------------

   function New_False_Literal_Pred
     (Ada_Node : Node_Id := Empty)
     return W_False_Literal_Pred_Id
   is
      Result : Why_Node (W_False_Literal_Pred);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_False_Literal_Pred);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_False_Literal_Pred_Id (New_Id);
   end New_False_Literal_Pred;

   ----------------------------
   -- New_False_Literal_Pred --
   ----------------------------

   function New_False_Literal_Pred
     (Ada_Node : Node_Id := Empty)
     return W_Predicate_Id
   is
      Result : Why_Node (W_False_Literal_Pred);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_False_Literal_Pred);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Predicate_Id (New_Id);
   end New_False_Literal_Pred;
   ------------------------------
   -- New_Predicate_Identifier --
   ------------------------------

   function New_Predicate_Identifier
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id)
     return W_Predicate_Identifier_Id
   is
      Result : Why_Node (W_Predicate_Identifier);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Predicate_Identifier);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.PID_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.PID_Name, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Predicate_Identifier_Id (New_Id);
   end New_Predicate_Identifier;

   ------------------------------
   -- New_Predicate_Identifier --
   ------------------------------

   function New_Predicate_Identifier
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id)
     return W_Predicate_Id
   is
      Result : Why_Node (W_Predicate_Identifier);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Predicate_Identifier);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.PID_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.PID_Name, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Predicate_Id (New_Id);
   end New_Predicate_Identifier;
   ----------------------------
   -- New_Predicate_Instance --
   ----------------------------

   function New_Predicate_Instance
     (Ada_Node   : Node_Id := Empty;
      Name       : W_Identifier_Id;
      Parameters : W_Term_Array)
     return W_Predicate_Instance_Id
   is
      Result : Why_Node (W_Predicate_Instance);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Predicate_Instance);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.PIN_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.PIN_Name, New_Id);
      pragma Assert (Parameters'Length > 0);
      Result.PIN_Parameters := New_List;
      for J in Parameters'Range loop
         pragma Assert
           (Term_Id_Kind_Valid
            (+(W_Term_Valid_Id (Parameters (J)))));
         pragma Assert
           (Term_Id_Valid
            (+(W_Term_Valid_Id (Parameters (J)))));
         Append
           (Result.PIN_Parameters,
            +(W_Term_Valid_Id (Parameters (J))));
      end loop;
      Set_Link (Result.PIN_Parameters, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Predicate_Instance_Id (New_Id);
   end New_Predicate_Instance;

   ----------------------------
   -- New_Predicate_Instance --
   ----------------------------

   function New_Predicate_Instance
     (Ada_Node   : Node_Id := Empty;
      Name       : W_Identifier_Id;
      Parameters : W_Term_Array)
     return W_Predicate_Id
   is
      Result : Why_Node (W_Predicate_Instance);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Predicate_Instance);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.PIN_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.PIN_Name, New_Id);
      pragma Assert (Parameters'Length > 0);
      Result.PIN_Parameters := New_List;
      for J in Parameters'Range loop
         pragma Assert
           (Term_Id_Kind_Valid
            (+(W_Term_Valid_Id (Parameters (J)))));
         pragma Assert
           (Term_Id_Valid
            (+(W_Term_Valid_Id (Parameters (J)))));
         Append
           (Result.PIN_Parameters,
            +(W_Term_Valid_Id (Parameters (J))));
      end loop;
      Set_Link (Result.PIN_Parameters, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Predicate_Id (New_Id);
   end New_Predicate_Instance;
   -----------------------
   -- New_Related_Terms --
   -----------------------

   function New_Related_Terms
     (Ada_Node : Node_Id := Empty;
      Left     : W_Term_Id;
      Op       : W_Relation_Id;
      Right    : W_Term_Id;
      Op2      : W_Relation_OId := Why_Empty;
      Right2   : W_Term_OId := Why_Empty)
     return W_Related_Terms_Id
   is
      Result : Why_Node (W_Related_Terms);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Related_Terms);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.RT_Left :=
        +(W_Term_Valid_Id (Left));
      Set_Link (Result.RT_Left, New_Id);
      Result.RT_Op :=
        +(W_Relation_Valid_Id (Op));
      Set_Link (Result.RT_Op, New_Id);
      Result.RT_Right :=
        +(W_Term_Valid_Id (Right));
      Set_Link (Result.RT_Right, New_Id);
      Result.RT_Op2 :=
        +(W_Relation_Valid_OId (Op2));
      Set_Link (Result.RT_Op2, New_Id);
      Result.RT_Right2 :=
        +(W_Term_Valid_OId (Right2));
      Set_Link (Result.RT_Right2, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Related_Terms_Id (New_Id);
   end New_Related_Terms;

   -----------------------
   -- New_Related_Terms --
   -----------------------

   function New_Related_Terms
     (Ada_Node : Node_Id := Empty;
      Left     : W_Term_Id;
      Op       : W_Relation_Id;
      Right    : W_Term_Id;
      Op2      : W_Relation_OId := Why_Empty;
      Right2   : W_Term_OId := Why_Empty)
     return W_Predicate_Id
   is
      Result : Why_Node (W_Related_Terms);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Related_Terms);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.RT_Left :=
        +(W_Term_Valid_Id (Left));
      Set_Link (Result.RT_Left, New_Id);
      Result.RT_Op :=
        +(W_Relation_Valid_Id (Op));
      Set_Link (Result.RT_Op, New_Id);
      Result.RT_Right :=
        +(W_Term_Valid_Id (Right));
      Set_Link (Result.RT_Right, New_Id);
      Result.RT_Op2 :=
        +(W_Relation_Valid_OId (Op2));
      Set_Link (Result.RT_Op2, New_Id);
      Result.RT_Right2 :=
        +(W_Term_Valid_OId (Right2));
      Set_Link (Result.RT_Right2, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Predicate_Id (New_Id);
   end New_Related_Terms;
   ---------------------
   -- New_Implication --
   ---------------------

   function New_Implication
     (Ada_Node : Node_Id := Empty;
      Left     : W_Predicate_Id;
      Right    : W_Predicate_Id)
     return W_Implication_Id
   is
      Result : Why_Node (W_Implication);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Implication);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.ITOC_Left :=
        +(W_Predicate_Valid_Id (Left));
      Set_Link (Result.ITOC_Left, New_Id);
      Result.ITOC_Right :=
        +(W_Predicate_Valid_Id (Right));
      Set_Link (Result.ITOC_Right, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Implication_Id (New_Id);
   end New_Implication;

   ---------------------
   -- New_Implication --
   ---------------------

   function New_Implication
     (Ada_Node : Node_Id := Empty;
      Left     : W_Predicate_Id;
      Right    : W_Predicate_Id)
     return W_Predicate_Id
   is
      Result : Why_Node (W_Implication);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Implication);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.ITOC_Left :=
        +(W_Predicate_Valid_Id (Left));
      Set_Link (Result.ITOC_Left, New_Id);
      Result.ITOC_Right :=
        +(W_Predicate_Valid_Id (Right));
      Set_Link (Result.ITOC_Right, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Predicate_Id (New_Id);
   end New_Implication;
   ---------------------
   -- New_Equivalence --
   ---------------------

   function New_Equivalence
     (Ada_Node : Node_Id := Empty;
      Left     : W_Predicate_Id;
      Right    : W_Predicate_Id)
     return W_Equivalence_Id
   is
      Result : Why_Node (W_Equivalence);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Equivalence);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.ITOC_Left :=
        +(W_Predicate_Valid_Id (Left));
      Set_Link (Result.ITOC_Left, New_Id);
      Result.ITOC_Right :=
        +(W_Predicate_Valid_Id (Right));
      Set_Link (Result.ITOC_Right, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Equivalence_Id (New_Id);
   end New_Equivalence;

   ---------------------
   -- New_Equivalence --
   ---------------------

   function New_Equivalence
     (Ada_Node : Node_Id := Empty;
      Left     : W_Predicate_Id;
      Right    : W_Predicate_Id)
     return W_Predicate_Id
   is
      Result : Why_Node (W_Equivalence);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Equivalence);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.ITOC_Left :=
        +(W_Predicate_Valid_Id (Left));
      Set_Link (Result.ITOC_Left, New_Id);
      Result.ITOC_Right :=
        +(W_Predicate_Valid_Id (Right));
      Set_Link (Result.ITOC_Right, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Predicate_Id (New_Id);
   end New_Equivalence;
   ---------------------
   -- New_Disjunction --
   ---------------------

   function New_Disjunction
     (Ada_Node : Node_Id := Empty;
      Left     : W_Predicate_Id;
      Right    : W_Predicate_Id)
     return W_Disjunction_Id
   is
      Result : Why_Node (W_Disjunction);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Disjunction);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.ITOC_Left :=
        +(W_Predicate_Valid_Id (Left));
      Set_Link (Result.ITOC_Left, New_Id);
      Result.ITOC_Right :=
        +(W_Predicate_Valid_Id (Right));
      Set_Link (Result.ITOC_Right, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Disjunction_Id (New_Id);
   end New_Disjunction;

   ---------------------
   -- New_Disjunction --
   ---------------------

   function New_Disjunction
     (Ada_Node : Node_Id := Empty;
      Left     : W_Predicate_Id;
      Right    : W_Predicate_Id)
     return W_Predicate_Id
   is
      Result : Why_Node (W_Disjunction);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Disjunction);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.ITOC_Left :=
        +(W_Predicate_Valid_Id (Left));
      Set_Link (Result.ITOC_Left, New_Id);
      Result.ITOC_Right :=
        +(W_Predicate_Valid_Id (Right));
      Set_Link (Result.ITOC_Right, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Predicate_Id (New_Id);
   end New_Disjunction;
   ---------------------
   -- New_Conjunction --
   ---------------------

   function New_Conjunction
     (Ada_Node : Node_Id := Empty;
      Left     : W_Predicate_Id;
      Right    : W_Predicate_Id)
     return W_Conjunction_Id
   is
      Result : Why_Node (W_Conjunction);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Conjunction);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.ITOC_Left :=
        +(W_Predicate_Valid_Id (Left));
      Set_Link (Result.ITOC_Left, New_Id);
      Result.ITOC_Right :=
        +(W_Predicate_Valid_Id (Right));
      Set_Link (Result.ITOC_Right, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Conjunction_Id (New_Id);
   end New_Conjunction;

   ---------------------
   -- New_Conjunction --
   ---------------------

   function New_Conjunction
     (Ada_Node : Node_Id := Empty;
      Left     : W_Predicate_Id;
      Right    : W_Predicate_Id)
     return W_Predicate_Id
   is
      Result : Why_Node (W_Conjunction);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Conjunction);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.ITOC_Left :=
        +(W_Predicate_Valid_Id (Left));
      Set_Link (Result.ITOC_Left, New_Id);
      Result.ITOC_Right :=
        +(W_Predicate_Valid_Id (Right));
      Set_Link (Result.ITOC_Right, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Predicate_Id (New_Id);
   end New_Conjunction;
   ------------------
   -- New_Negation --
   ------------------

   function New_Negation
     (Ada_Node : Node_Id := Empty;
      Operand  : W_Predicate_Id)
     return W_Negation_Id
   is
      Result : Why_Node (W_Negation);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Negation);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.N_Operand :=
        +(W_Predicate_Valid_Id (Operand));
      Set_Link (Result.N_Operand, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Negation_Id (New_Id);
   end New_Negation;

   ------------------
   -- New_Negation --
   ------------------

   function New_Negation
     (Ada_Node : Node_Id := Empty;
      Operand  : W_Predicate_Id)
     return W_Predicate_Id
   is
      Result : Why_Node (W_Negation);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Negation);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.N_Operand :=
        +(W_Predicate_Valid_Id (Operand));
      Set_Link (Result.N_Operand, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Predicate_Id (New_Id);
   end New_Negation;
   --------------------------
   -- New_Conditional_Pred --
   --------------------------

   function New_Conditional_Pred
     (Ada_Node  : Node_Id := Empty;
      Condition : W_Term_Id;
      Then_Part : W_Predicate_Id;
      Else_Part : W_Predicate_Id)
     return W_Conditional_Pred_Id
   is
      Result : Why_Node (W_Conditional_Pred);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Conditional_Pred);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.CPD_Condition :=
        +(W_Term_Valid_Id (Condition));
      Set_Link (Result.CPD_Condition, New_Id);
      Result.CPD_Then_Part :=
        +(W_Predicate_Valid_Id (Then_Part));
      Set_Link (Result.CPD_Then_Part, New_Id);
      Result.CPD_Else_Part :=
        +(W_Predicate_Valid_Id (Else_Part));
      Set_Link (Result.CPD_Else_Part, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Conditional_Pred_Id (New_Id);
   end New_Conditional_Pred;

   --------------------------
   -- New_Conditional_Pred --
   --------------------------

   function New_Conditional_Pred
     (Ada_Node  : Node_Id := Empty;
      Condition : W_Term_Id;
      Then_Part : W_Predicate_Id;
      Else_Part : W_Predicate_Id)
     return W_Predicate_Id
   is
      Result : Why_Node (W_Conditional_Pred);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Conditional_Pred);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.CPD_Condition :=
        +(W_Term_Valid_Id (Condition));
      Set_Link (Result.CPD_Condition, New_Id);
      Result.CPD_Then_Part :=
        +(W_Predicate_Valid_Id (Then_Part));
      Set_Link (Result.CPD_Then_Part, New_Id);
      Result.CPD_Else_Part :=
        +(W_Predicate_Valid_Id (Else_Part));
      Set_Link (Result.CPD_Else_Part, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Predicate_Id (New_Id);
   end New_Conditional_Pred;
   ----------------------
   -- New_Binding_Pred --
   ----------------------

   function New_Binding_Pred
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id;
      Def      : W_Term_Id;
      Context  : W_Predicate_Id)
     return W_Binding_Pred_Id
   is
      Result : Why_Node (W_Binding_Pred);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Binding_Pred);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.BPD_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.BPD_Name, New_Id);
      Result.BPD_Def :=
        +(W_Term_Valid_Id (Def));
      Set_Link (Result.BPD_Def, New_Id);
      Result.BPD_Context :=
        +(W_Predicate_Valid_Id (Context));
      Set_Link (Result.BPD_Context, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Binding_Pred_Id (New_Id);
   end New_Binding_Pred;

   ----------------------
   -- New_Binding_Pred --
   ----------------------

   function New_Binding_Pred
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id;
      Def      : W_Term_Id;
      Context  : W_Predicate_Id)
     return W_Predicate_Id
   is
      Result : Why_Node (W_Binding_Pred);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Binding_Pred);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.BPD_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.BPD_Name, New_Id);
      Result.BPD_Def :=
        +(W_Term_Valid_Id (Def));
      Set_Link (Result.BPD_Def, New_Id);
      Result.BPD_Context :=
        +(W_Predicate_Valid_Id (Context));
      Set_Link (Result.BPD_Context, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Predicate_Id (New_Id);
   end New_Binding_Pred;
   ---------------------------
   -- New_Universal_Quantif --
   ---------------------------

   function New_Universal_Quantif
     (Ada_Node  : Node_Id := Empty;
      Variables : W_Identifier_Array;
      Var_Type  : W_Primitive_Type_Id;
      Triggers  : W_Triggers_OId := Why_Empty;
      Pred      : W_Predicate_Id)
     return W_Universal_Quantif_Id
   is
      Result : Why_Node (W_Universal_Quantif);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Universal_Quantif);
   begin
      Result.Ada_Node :=
        Ada_Node;
      pragma Assert (Variables'Length > 0);
      Result.UQ_Variables := New_List;
      for J in Variables'Range loop
         pragma Assert
           (Identifier_Id_Kind_Valid
            (+(W_Identifier_Valid_Id (Variables (J)))));
         pragma Assert
           (Identifier_Id_Valid
            (+(W_Identifier_Valid_Id (Variables (J)))));
         Append
           (Result.UQ_Variables,
            +(W_Identifier_Valid_Id (Variables (J))));
      end loop;
      Set_Link (Result.UQ_Variables, New_Id);
      Result.UQ_Var_Type :=
        +(W_Primitive_Type_Valid_Id (Var_Type));
      Set_Link (Result.UQ_Var_Type, New_Id);
      Result.UQ_Triggers :=
        +(W_Triggers_Valid_OId (Triggers));
      Set_Link (Result.UQ_Triggers, New_Id);
      Result.UQ_Pred :=
        +(W_Predicate_Valid_Id (Pred));
      Set_Link (Result.UQ_Pred, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Universal_Quantif_Id (New_Id);
   end New_Universal_Quantif;

   ---------------------------
   -- New_Universal_Quantif --
   ---------------------------

   function New_Universal_Quantif
     (Ada_Node  : Node_Id := Empty;
      Variables : W_Identifier_Array;
      Var_Type  : W_Primitive_Type_Id;
      Triggers  : W_Triggers_OId := Why_Empty;
      Pred      : W_Predicate_Id)
     return W_Predicate_Id
   is
      Result : Why_Node (W_Universal_Quantif);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Universal_Quantif);
   begin
      Result.Ada_Node :=
        Ada_Node;
      pragma Assert (Variables'Length > 0);
      Result.UQ_Variables := New_List;
      for J in Variables'Range loop
         pragma Assert
           (Identifier_Id_Kind_Valid
            (+(W_Identifier_Valid_Id (Variables (J)))));
         pragma Assert
           (Identifier_Id_Valid
            (+(W_Identifier_Valid_Id (Variables (J)))));
         Append
           (Result.UQ_Variables,
            +(W_Identifier_Valid_Id (Variables (J))));
      end loop;
      Set_Link (Result.UQ_Variables, New_Id);
      Result.UQ_Var_Type :=
        +(W_Primitive_Type_Valid_Id (Var_Type));
      Set_Link (Result.UQ_Var_Type, New_Id);
      Result.UQ_Triggers :=
        +(W_Triggers_Valid_OId (Triggers));
      Set_Link (Result.UQ_Triggers, New_Id);
      Result.UQ_Pred :=
        +(W_Predicate_Valid_Id (Pred));
      Set_Link (Result.UQ_Pred, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Predicate_Id (New_Id);
   end New_Universal_Quantif;
   -----------------------------
   -- New_Existential_Quantif --
   -----------------------------

   function New_Existential_Quantif
     (Ada_Node  : Node_Id := Empty;
      Variables : W_Identifier_Array;
      Var_Type  : W_Primitive_Type_Id;
      Pred      : W_Predicate_Id)
     return W_Existential_Quantif_Id
   is
      Result : Why_Node (W_Existential_Quantif);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Existential_Quantif);
   begin
      Result.Ada_Node :=
        Ada_Node;
      pragma Assert (Variables'Length > 0);
      Result.EQ_Variables := New_List;
      for J in Variables'Range loop
         pragma Assert
           (Identifier_Id_Kind_Valid
            (+(W_Identifier_Valid_Id (Variables (J)))));
         pragma Assert
           (Identifier_Id_Valid
            (+(W_Identifier_Valid_Id (Variables (J)))));
         Append
           (Result.EQ_Variables,
            +(W_Identifier_Valid_Id (Variables (J))));
      end loop;
      Set_Link (Result.EQ_Variables, New_Id);
      Result.EQ_Var_Type :=
        +(W_Primitive_Type_Valid_Id (Var_Type));
      Set_Link (Result.EQ_Var_Type, New_Id);
      Result.EQ_Pred :=
        +(W_Predicate_Valid_Id (Pred));
      Set_Link (Result.EQ_Pred, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Existential_Quantif_Id (New_Id);
   end New_Existential_Quantif;

   -----------------------------
   -- New_Existential_Quantif --
   -----------------------------

   function New_Existential_Quantif
     (Ada_Node  : Node_Id := Empty;
      Variables : W_Identifier_Array;
      Var_Type  : W_Primitive_Type_Id;
      Pred      : W_Predicate_Id)
     return W_Predicate_Id
   is
      Result : Why_Node (W_Existential_Quantif);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Existential_Quantif);
   begin
      Result.Ada_Node :=
        Ada_Node;
      pragma Assert (Variables'Length > 0);
      Result.EQ_Variables := New_List;
      for J in Variables'Range loop
         pragma Assert
           (Identifier_Id_Kind_Valid
            (+(W_Identifier_Valid_Id (Variables (J)))));
         pragma Assert
           (Identifier_Id_Valid
            (+(W_Identifier_Valid_Id (Variables (J)))));
         Append
           (Result.EQ_Variables,
            +(W_Identifier_Valid_Id (Variables (J))));
      end loop;
      Set_Link (Result.EQ_Variables, New_Id);
      Result.EQ_Var_Type :=
        +(W_Primitive_Type_Valid_Id (Var_Type));
      Set_Link (Result.EQ_Var_Type, New_Id);
      Result.EQ_Pred :=
        +(W_Predicate_Valid_Id (Pred));
      Set_Link (Result.EQ_Pred, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Predicate_Id (New_Id);
   end New_Existential_Quantif;
   -------------------------
   -- New_Named_Predicate --
   -------------------------

   function New_Named_Predicate
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id;
      Pred     : W_Predicate_Id)
     return W_Named_Predicate_Id
   is
      Result : Why_Node (W_Named_Predicate);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Named_Predicate);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.NP_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.NP_Name, New_Id);
      Result.NP_Pred :=
        +(W_Predicate_Valid_Id (Pred));
      Set_Link (Result.NP_Pred, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Named_Predicate_Id (New_Id);
   end New_Named_Predicate;

   -------------------------
   -- New_Named_Predicate --
   -------------------------

   function New_Named_Predicate
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id;
      Pred     : W_Predicate_Id)
     return W_Predicate_Id
   is
      Result : Why_Node (W_Named_Predicate);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Named_Predicate);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.NP_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.NP_Name, New_Id);
      Result.NP_Pred :=
        +(W_Predicate_Valid_Id (Pred));
      Set_Link (Result.NP_Pred, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Predicate_Id (New_Id);
   end New_Named_Predicate;
   -----------------------------
   -- New_Protected_Predicate --
   -----------------------------

   function New_Protected_Predicate
     (Ada_Node : Node_Id := Empty;
      Pred     : W_Predicate_Id)
     return W_Protected_Predicate_Id
   is
      Result : Why_Node (W_Protected_Predicate);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Protected_Predicate);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.PP_Pred :=
        +(W_Predicate_Valid_Id (Pred));
      Set_Link (Result.PP_Pred, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Protected_Predicate_Id (New_Id);
   end New_Protected_Predicate;

   -----------------------------
   -- New_Protected_Predicate --
   -----------------------------

   function New_Protected_Predicate
     (Ada_Node : Node_Id := Empty;
      Pred     : W_Predicate_Id)
     return W_Predicate_Id
   is
      Result : Why_Node (W_Protected_Predicate);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Protected_Predicate);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.PP_Pred :=
        +(W_Predicate_Valid_Id (Pred));
      Set_Link (Result.PP_Pred, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Predicate_Id (New_Id);
   end New_Protected_Predicate;
   -----------------
   -- New_Pattern --
   -----------------

   function New_Pattern
     (Ada_Node : Node_Id := Empty;
      Constr   : W_Identifier_Id;
      Args     : W_Identifier_Array := (2 .. 1 => <>))
     return W_Pattern_Id
   is
      Result : Why_Node (W_Pattern);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Pattern);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.PAT_Constr :=
        +(W_Identifier_Valid_Id (Constr));
      Set_Link (Result.PAT_Constr, New_Id);
      Result.PAT_Args := New_List;
      for J in Args'Range loop
         pragma Assert
           (Identifier_Id_Kind_Valid
            (+(W_Identifier_Valid_OId (Args (J)))));
         pragma Assert
           (Identifier_Id_Valid
            (+(W_Identifier_Valid_OId (Args (J)))));
         Append
           (Result.PAT_Args,
            +(W_Identifier_Valid_OId (Args (J))));
      end loop;
      Set_Link (Result.PAT_Args, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Pattern_Id (New_Id);
   end New_Pattern;
   --------------------
   -- New_Match_Case --
   --------------------

   function New_Match_Case
     (Ada_Node : Node_Id := Empty;
      Pattern  : W_Pattern_Id;
      Term     : W_Term_Id)
     return W_Match_Case_Id
   is
      Result : Why_Node (W_Match_Case);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Match_Case);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.MC_Pattern :=
        +(W_Pattern_Valid_Id (Pattern));
      Set_Link (Result.MC_Pattern, New_Id);
      Result.MC_Term :=
        +(W_Term_Valid_Id (Term));
      Set_Link (Result.MC_Term, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Match_Case_Id (New_Id);
   end New_Match_Case;
   ------------------
   -- New_Triggers --
   ------------------

   function New_Triggers
     (Ada_Node : Node_Id := Empty;
      Triggers : W_Trigger_Array)
     return W_Triggers_Id
   is
      Result : Why_Node (W_Triggers);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Triggers);
   begin
      Result.Ada_Node :=
        Ada_Node;
      pragma Assert (Triggers'Length > 0);
      Result.TRS_Triggers := New_List;
      for J in Triggers'Range loop
         pragma Assert
           (Trigger_Id_Kind_Valid
            (+(W_Trigger_Valid_Id (Triggers (J)))));
         pragma Assert
           (Trigger_Id_Valid
            (+(W_Trigger_Valid_Id (Triggers (J)))));
         Append
           (Result.TRS_Triggers,
            +(W_Trigger_Valid_Id (Triggers (J))));
      end loop;
      Set_Link (Result.TRS_Triggers, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Triggers_Id (New_Id);
   end New_Triggers;
   -----------------
   -- New_Trigger --
   -----------------

   function New_Trigger
     (Ada_Node : Node_Id := Empty;
      Terms    : W_Term_Array)
     return W_Trigger_Id
   is
      Result : Why_Node (W_Trigger);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Trigger);
   begin
      Result.Ada_Node :=
        Ada_Node;
      pragma Assert (Terms'Length > 0);
      Result.TRI_Terms := New_List;
      for J in Terms'Range loop
         pragma Assert
           (Term_Id_Kind_Valid
            (+(W_Term_Valid_Id (Terms (J)))));
         pragma Assert
           (Term_Id_Valid
            (+(W_Term_Valid_Id (Terms (J)))));
         Append
           (Result.TRI_Terms,
            +(W_Term_Valid_Id (Terms (J))));
      end loop;
      Set_Link (Result.TRI_Terms, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Trigger_Id (New_Id);
   end New_Trigger;
   ----------------
   -- New_Rel_Eq --
   ----------------

   function New_Rel_Eq
     (Ada_Node : Node_Id := Empty)
     return W_Rel_Eq_Id
   is
      Result : Why_Node (W_Rel_Eq);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Rel_Eq);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Rel_Eq_Id (New_Id);
   end New_Rel_Eq;

   ----------------
   -- New_Rel_Eq --
   ----------------

   function New_Rel_Eq
     (Ada_Node : Node_Id := Empty)
     return W_Relation_Id
   is
      Result : Why_Node (W_Rel_Eq);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Rel_Eq);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Relation_Id (New_Id);
   end New_Rel_Eq;
   ----------------
   -- New_Rel_Ne --
   ----------------

   function New_Rel_Ne
     (Ada_Node : Node_Id := Empty)
     return W_Rel_Ne_Id
   is
      Result : Why_Node (W_Rel_Ne);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Rel_Ne);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Rel_Ne_Id (New_Id);
   end New_Rel_Ne;

   ----------------
   -- New_Rel_Ne --
   ----------------

   function New_Rel_Ne
     (Ada_Node : Node_Id := Empty)
     return W_Relation_Id
   is
      Result : Why_Node (W_Rel_Ne);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Rel_Ne);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Relation_Id (New_Id);
   end New_Rel_Ne;
   ----------------
   -- New_Rel_Lt --
   ----------------

   function New_Rel_Lt
     (Ada_Node : Node_Id := Empty)
     return W_Rel_Lt_Id
   is
      Result : Why_Node (W_Rel_Lt);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Rel_Lt);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Rel_Lt_Id (New_Id);
   end New_Rel_Lt;

   ----------------
   -- New_Rel_Lt --
   ----------------

   function New_Rel_Lt
     (Ada_Node : Node_Id := Empty)
     return W_Relation_Id
   is
      Result : Why_Node (W_Rel_Lt);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Rel_Lt);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Relation_Id (New_Id);
   end New_Rel_Lt;
   ----------------
   -- New_Rel_Le --
   ----------------

   function New_Rel_Le
     (Ada_Node : Node_Id := Empty)
     return W_Rel_Le_Id
   is
      Result : Why_Node (W_Rel_Le);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Rel_Le);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Rel_Le_Id (New_Id);
   end New_Rel_Le;

   ----------------
   -- New_Rel_Le --
   ----------------

   function New_Rel_Le
     (Ada_Node : Node_Id := Empty)
     return W_Relation_Id
   is
      Result : Why_Node (W_Rel_Le);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Rel_Le);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Relation_Id (New_Id);
   end New_Rel_Le;
   ----------------
   -- New_Rel_Gt --
   ----------------

   function New_Rel_Gt
     (Ada_Node : Node_Id := Empty)
     return W_Rel_Gt_Id
   is
      Result : Why_Node (W_Rel_Gt);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Rel_Gt);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Rel_Gt_Id (New_Id);
   end New_Rel_Gt;

   ----------------
   -- New_Rel_Gt --
   ----------------

   function New_Rel_Gt
     (Ada_Node : Node_Id := Empty)
     return W_Relation_Id
   is
      Result : Why_Node (W_Rel_Gt);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Rel_Gt);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Relation_Id (New_Id);
   end New_Rel_Gt;
   ----------------
   -- New_Rel_Ge --
   ----------------

   function New_Rel_Ge
     (Ada_Node : Node_Id := Empty)
     return W_Rel_Ge_Id
   is
      Result : Why_Node (W_Rel_Ge);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Rel_Ge);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Rel_Ge_Id (New_Id);
   end New_Rel_Ge;

   ----------------
   -- New_Rel_Ge --
   ----------------

   function New_Rel_Ge
     (Ada_Node : Node_Id := Empty)
     return W_Relation_Id
   is
      Result : Why_Node (W_Rel_Ge);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Rel_Ge);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Relation_Id (New_Id);
   end New_Rel_Ge;
   --------------
   -- New_Type --
   --------------

   function New_Type
     (Ada_Node        : Node_Id := Empty;
      External        : W_External_OId := Why_Empty;
      Type_Parameters : W_Identifier_Array := (2 .. 1 => <>);
      Name            : W_Identifier_Id;
      Definition      : W_Type_Definition_OId := Why_Empty)
     return W_Type_Id
   is
      Result : Why_Node (W_Type);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Type);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.T_External :=
        +(W_External_Valid_OId (External));
      Set_Link (Result.T_External, New_Id);
      Result.T_Type_Parameters := New_List;
      for J in Type_Parameters'Range loop
         pragma Assert
           (Identifier_Id_Kind_Valid
            (+(W_Identifier_Valid_OId (Type_Parameters (J)))));
         pragma Assert
           (Identifier_Id_Valid
            (+(W_Identifier_Valid_OId (Type_Parameters (J)))));
         Append
           (Result.T_Type_Parameters,
            +(W_Identifier_Valid_OId (Type_Parameters (J))));
      end loop;
      Set_Link (Result.T_Type_Parameters, New_Id);
      Result.T_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.T_Name, New_Id);
      Result.T_Definition :=
        +(W_Type_Definition_Valid_OId (Definition));
      Set_Link (Result.T_Definition, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Type_Id (New_Id);
   end New_Type;

   --------------
   -- New_Type --
   --------------

   function New_Type
     (Ada_Node        : Node_Id := Empty;
      External        : W_External_OId := Why_Empty;
      Type_Parameters : W_Identifier_Array := (2 .. 1 => <>);
      Name            : W_Identifier_Id;
      Definition      : W_Type_Definition_OId := Why_Empty)
     return W_Logic_Declaration_Class_Id
   is
      Result : Why_Node (W_Type);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Type);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.T_External :=
        +(W_External_Valid_OId (External));
      Set_Link (Result.T_External, New_Id);
      Result.T_Type_Parameters := New_List;
      for J in Type_Parameters'Range loop
         pragma Assert
           (Identifier_Id_Kind_Valid
            (+(W_Identifier_Valid_OId (Type_Parameters (J)))));
         pragma Assert
           (Identifier_Id_Valid
            (+(W_Identifier_Valid_OId (Type_Parameters (J)))));
         Append
           (Result.T_Type_Parameters,
            +(W_Identifier_Valid_OId (Type_Parameters (J))));
      end loop;
      Set_Link (Result.T_Type_Parameters, New_Id);
      Result.T_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.T_Name, New_Id);
      Result.T_Definition :=
        +(W_Type_Definition_Valid_OId (Definition));
      Set_Link (Result.T_Definition, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Logic_Declaration_Class_Id (New_Id);
   end New_Type;
   ---------------
   -- New_Logic --
   ---------------

   function New_Logic
     (Ada_Node   : Node_Id := Empty;
      External   : W_External_OId := Why_Empty;
      Names      : W_Identifier_Array;
      Logic_Type : W_Logic_Type_Id)
     return W_Logic_Id
   is
      Result : Why_Node (W_Logic);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Logic);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.L_External :=
        +(W_External_Valid_OId (External));
      Set_Link (Result.L_External, New_Id);
      pragma Assert (Names'Length > 0);
      Result.L_Names := New_List;
      for J in Names'Range loop
         pragma Assert
           (Identifier_Id_Kind_Valid
            (+(W_Identifier_Valid_Id (Names (J)))));
         pragma Assert
           (Identifier_Id_Valid
            (+(W_Identifier_Valid_Id (Names (J)))));
         Append
           (Result.L_Names,
            +(W_Identifier_Valid_Id (Names (J))));
      end loop;
      Set_Link (Result.L_Names, New_Id);
      Result.L_Logic_Type :=
        +(W_Logic_Type_Valid_Id (Logic_Type));
      Set_Link (Result.L_Logic_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Logic_Id (New_Id);
   end New_Logic;

   ---------------
   -- New_Logic --
   ---------------

   function New_Logic
     (Ada_Node   : Node_Id := Empty;
      External   : W_External_OId := Why_Empty;
      Names      : W_Identifier_Array;
      Logic_Type : W_Logic_Type_Id)
     return W_Logic_Declaration_Class_Id
   is
      Result : Why_Node (W_Logic);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Logic);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.L_External :=
        +(W_External_Valid_OId (External));
      Set_Link (Result.L_External, New_Id);
      pragma Assert (Names'Length > 0);
      Result.L_Names := New_List;
      for J in Names'Range loop
         pragma Assert
           (Identifier_Id_Kind_Valid
            (+(W_Identifier_Valid_Id (Names (J)))));
         pragma Assert
           (Identifier_Id_Valid
            (+(W_Identifier_Valid_Id (Names (J)))));
         Append
           (Result.L_Names,
            +(W_Identifier_Valid_Id (Names (J))));
      end loop;
      Set_Link (Result.L_Names, New_Id);
      Result.L_Logic_Type :=
        +(W_Logic_Type_Valid_Id (Logic_Type));
      Set_Link (Result.L_Logic_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Logic_Declaration_Class_Id (New_Id);
   end New_Logic;
   ------------------
   -- New_Function --
   ------------------

   function New_Function
     (Ada_Node    : Node_Id := Empty;
      Name        : W_Identifier_Id;
      Binders     : W_Logic_Binder_Array;
      Return_Type : W_Primitive_Type_Id;
      Def         : W_Term_Id)
     return W_Function_Id
   is
      Result : Why_Node (W_Function);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Function);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.F_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.F_Name, New_Id);
      pragma Assert (Binders'Length > 0);
      Result.F_Binders := New_List;
      for J in Binders'Range loop
         pragma Assert
           (Logic_Binder_Id_Kind_Valid
            (+(W_Logic_Binder_Valid_Id (Binders (J)))));
         pragma Assert
           (Logic_Binder_Id_Valid
            (+(W_Logic_Binder_Valid_Id (Binders (J)))));
         Append
           (Result.F_Binders,
            +(W_Logic_Binder_Valid_Id (Binders (J))));
      end loop;
      Set_Link (Result.F_Binders, New_Id);
      Result.F_Return_Type :=
        +(W_Primitive_Type_Valid_Id (Return_Type));
      Set_Link (Result.F_Return_Type, New_Id);
      Result.F_Def :=
        +(W_Term_Valid_Id (Def));
      Set_Link (Result.F_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Function_Id (New_Id);
   end New_Function;

   ------------------
   -- New_Function --
   ------------------

   function New_Function
     (Ada_Node    : Node_Id := Empty;
      Name        : W_Identifier_Id;
      Binders     : W_Logic_Binder_Array;
      Return_Type : W_Primitive_Type_Id;
      Def         : W_Term_Id)
     return W_Logic_Declaration_Class_Id
   is
      Result : Why_Node (W_Function);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Function);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.F_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.F_Name, New_Id);
      pragma Assert (Binders'Length > 0);
      Result.F_Binders := New_List;
      for J in Binders'Range loop
         pragma Assert
           (Logic_Binder_Id_Kind_Valid
            (+(W_Logic_Binder_Valid_Id (Binders (J)))));
         pragma Assert
           (Logic_Binder_Id_Valid
            (+(W_Logic_Binder_Valid_Id (Binders (J)))));
         Append
           (Result.F_Binders,
            +(W_Logic_Binder_Valid_Id (Binders (J))));
      end loop;
      Set_Link (Result.F_Binders, New_Id);
      Result.F_Return_Type :=
        +(W_Primitive_Type_Valid_Id (Return_Type));
      Set_Link (Result.F_Return_Type, New_Id);
      Result.F_Def :=
        +(W_Term_Valid_Id (Def));
      Set_Link (Result.F_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Logic_Declaration_Class_Id (New_Id);
   end New_Function;
   ------------------------------
   -- New_Predicate_Definition --
   ------------------------------

   function New_Predicate_Definition
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id;
      Binders  : W_Logic_Binder_Array;
      Def      : W_Predicate_Id)
     return W_Predicate_Definition_Id
   is
      Result : Why_Node (W_Predicate_Definition);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Predicate_Definition);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.P_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.P_Name, New_Id);
      pragma Assert (Binders'Length > 0);
      Result.P_Binders := New_List;
      for J in Binders'Range loop
         pragma Assert
           (Logic_Binder_Id_Kind_Valid
            (+(W_Logic_Binder_Valid_Id (Binders (J)))));
         pragma Assert
           (Logic_Binder_Id_Valid
            (+(W_Logic_Binder_Valid_Id (Binders (J)))));
         Append
           (Result.P_Binders,
            +(W_Logic_Binder_Valid_Id (Binders (J))));
      end loop;
      Set_Link (Result.P_Binders, New_Id);
      Result.P_Def :=
        +(W_Predicate_Valid_Id (Def));
      Set_Link (Result.P_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Predicate_Definition_Id (New_Id);
   end New_Predicate_Definition;

   ------------------------------
   -- New_Predicate_Definition --
   ------------------------------

   function New_Predicate_Definition
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id;
      Binders  : W_Logic_Binder_Array;
      Def      : W_Predicate_Id)
     return W_Logic_Declaration_Class_Id
   is
      Result : Why_Node (W_Predicate_Definition);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Predicate_Definition);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.P_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.P_Name, New_Id);
      pragma Assert (Binders'Length > 0);
      Result.P_Binders := New_List;
      for J in Binders'Range loop
         pragma Assert
           (Logic_Binder_Id_Kind_Valid
            (+(W_Logic_Binder_Valid_Id (Binders (J)))));
         pragma Assert
           (Logic_Binder_Id_Valid
            (+(W_Logic_Binder_Valid_Id (Binders (J)))));
         Append
           (Result.P_Binders,
            +(W_Logic_Binder_Valid_Id (Binders (J))));
      end loop;
      Set_Link (Result.P_Binders, New_Id);
      Result.P_Def :=
        +(W_Predicate_Valid_Id (Def));
      Set_Link (Result.P_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Logic_Declaration_Class_Id (New_Id);
   end New_Predicate_Definition;
   -------------------
   -- New_Inductive --
   -------------------

   function New_Inductive
     (Ada_Node   : Node_Id := Empty;
      Name       : W_Identifier_Id;
      Logic_Type : W_Logic_Type_Id;
      Def        : W_Inductive_Case_Array)
     return W_Inductive_Id
   is
      Result : Why_Node (W_Inductive);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Inductive);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.I_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.I_Name, New_Id);
      Result.I_Logic_Type :=
        +(W_Logic_Type_Valid_Id (Logic_Type));
      Set_Link (Result.I_Logic_Type, New_Id);
      pragma Assert (Def'Length > 0);
      Result.I_Def := New_List;
      for J in Def'Range loop
         pragma Assert
           (Inductive_Case_Id_Kind_Valid
            (+(W_Inductive_Case_Valid_Id (Def (J)))));
         pragma Assert
           (Inductive_Case_Id_Valid
            (+(W_Inductive_Case_Valid_Id (Def (J)))));
         Append
           (Result.I_Def,
            +(W_Inductive_Case_Valid_Id (Def (J))));
      end loop;
      Set_Link (Result.I_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Inductive_Id (New_Id);
   end New_Inductive;

   -------------------
   -- New_Inductive --
   -------------------

   function New_Inductive
     (Ada_Node   : Node_Id := Empty;
      Name       : W_Identifier_Id;
      Logic_Type : W_Logic_Type_Id;
      Def        : W_Inductive_Case_Array)
     return W_Logic_Declaration_Class_Id
   is
      Result : Why_Node (W_Inductive);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Inductive);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.I_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.I_Name, New_Id);
      Result.I_Logic_Type :=
        +(W_Logic_Type_Valid_Id (Logic_Type));
      Set_Link (Result.I_Logic_Type, New_Id);
      pragma Assert (Def'Length > 0);
      Result.I_Def := New_List;
      for J in Def'Range loop
         pragma Assert
           (Inductive_Case_Id_Kind_Valid
            (+(W_Inductive_Case_Valid_Id (Def (J)))));
         pragma Assert
           (Inductive_Case_Id_Valid
            (+(W_Inductive_Case_Valid_Id (Def (J)))));
         Append
           (Result.I_Def,
            +(W_Inductive_Case_Valid_Id (Def (J))));
      end loop;
      Set_Link (Result.I_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Logic_Declaration_Class_Id (New_Id);
   end New_Inductive;
   ---------------
   -- New_Axiom --
   ---------------

   function New_Axiom
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id;
      Def      : W_Predicate_Id)
     return W_Axiom_Id
   is
      Result : Why_Node (W_Axiom);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Axiom);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.AX_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.AX_Name, New_Id);
      Result.AX_Def :=
        +(W_Predicate_Valid_Id (Def));
      Set_Link (Result.AX_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Axiom_Id (New_Id);
   end New_Axiom;

   ---------------
   -- New_Axiom --
   ---------------

   function New_Axiom
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id;
      Def      : W_Predicate_Id)
     return W_Logic_Declaration_Class_Id
   is
      Result : Why_Node (W_Axiom);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Axiom);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.AX_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.AX_Name, New_Id);
      Result.AX_Def :=
        +(W_Predicate_Valid_Id (Def));
      Set_Link (Result.AX_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Logic_Declaration_Class_Id (New_Id);
   end New_Axiom;
   --------------
   -- New_Goal --
   --------------

   function New_Goal
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id;
      Def      : W_Predicate_Id)
     return W_Goal_Id
   is
      Result : Why_Node (W_Goal);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Goal);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.G_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.G_Name, New_Id);
      Result.G_Def :=
        +(W_Predicate_Valid_Id (Def));
      Set_Link (Result.G_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Goal_Id (New_Id);
   end New_Goal;

   --------------
   -- New_Goal --
   --------------

   function New_Goal
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id;
      Def      : W_Predicate_Id)
     return W_Logic_Declaration_Class_Id
   is
      Result : Why_Node (W_Goal);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Goal);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.G_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.G_Name, New_Id);
      Result.G_Def :=
        +(W_Predicate_Valid_Id (Def));
      Set_Link (Result.G_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Logic_Declaration_Class_Id (New_Id);
   end New_Goal;
   ------------------
   -- New_External --
   ------------------

   function New_External
     (Ada_Node : Node_Id := Empty)
     return W_External_Id
   is
      Result : Why_Node (W_External);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_External);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_External_Id (New_Id);
   end New_External;
   --------------------
   -- New_Logic_Type --
   --------------------

   function New_Logic_Type
     (Ada_Node    : Node_Id := Empty;
      Arg_Types   : W_Logic_Arg_Type_Array := (2 .. 1 => <>);
      Return_Type : W_Logic_Return_Type_Id)
     return W_Logic_Type_Id
   is
      Result : Why_Node (W_Logic_Type);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Logic_Type);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.LT_Arg_Types := New_List;
      for J in Arg_Types'Range loop
         pragma Assert
           (Logic_Arg_Type_Id_Kind_Valid
            (+(W_Logic_Arg_Type_Valid_OId (Arg_Types (J)))));
         pragma Assert
           (Logic_Arg_Type_Id_Valid
            (+(W_Logic_Arg_Type_Valid_OId (Arg_Types (J)))));
         Append
           (Result.LT_Arg_Types,
            +(W_Logic_Arg_Type_Valid_OId (Arg_Types (J))));
      end loop;
      Set_Link (Result.LT_Arg_Types, New_Id);
      Result.LT_Return_Type :=
        +(W_Logic_Return_Type_Valid_Id (Return_Type));
      Set_Link (Result.LT_Return_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Logic_Type_Id (New_Id);
   end New_Logic_Type;
   ----------------------
   -- New_Logic_Binder --
   ----------------------

   function New_Logic_Binder
     (Ada_Node   : Node_Id := Empty;
      Name       : W_Identifier_Id;
      Param_Type : W_Primitive_Type_Id)
     return W_Logic_Binder_Id
   is
      Result : Why_Node (W_Logic_Binder);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Logic_Binder);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.LB_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.LB_Name, New_Id);
      Result.LB_Param_Type :=
        +(W_Primitive_Type_Valid_Id (Param_Type));
      Set_Link (Result.LB_Param_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Logic_Binder_Id (New_Id);
   end New_Logic_Binder;
   ------------------------
   -- New_Inductive_Case --
   ------------------------

   function New_Inductive_Case
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id;
      Pred     : W_Predicate_Id)
     return W_Inductive_Case_Id
   is
      Result : Why_Node (W_Inductive_Case);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Inductive_Case);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.IC_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.IC_Name, New_Id);
      Result.IC_Pred :=
        +(W_Predicate_Valid_Id (Pred));
      Set_Link (Result.IC_Pred, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Inductive_Case_Id (New_Id);
   end New_Inductive_Case;
   -------------------------------------
   -- New_Transparent_Type_Definition --
   -------------------------------------

   function New_Transparent_Type_Definition
     (Ada_Node        : Node_Id := Empty;
      Type_Definition : W_Primitive_Type_Id)
     return W_Transparent_Type_Definition_Id
   is
      Result : Why_Node (W_Transparent_Type_Definition);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Transparent_Type_Definition);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Tr_Type_Definition :=
        +(W_Primitive_Type_Valid_Id (Type_Definition));
      Set_Link (Result.Tr_Type_Definition, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Transparent_Type_Definition_Id (New_Id);
   end New_Transparent_Type_Definition;

   -------------------------------------
   -- New_Transparent_Type_Definition --
   -------------------------------------

   function New_Transparent_Type_Definition
     (Ada_Node        : Node_Id := Empty;
      Type_Definition : W_Primitive_Type_Id)
     return W_Type_Definition_Id
   is
      Result : Why_Node (W_Transparent_Type_Definition);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Transparent_Type_Definition);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Tr_Type_Definition :=
        +(W_Primitive_Type_Valid_Id (Type_Definition));
      Set_Link (Result.Tr_Type_Definition, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Type_Definition_Id (New_Id);
   end New_Transparent_Type_Definition;
   ------------------------
   -- New_Adt_Definition --
   ------------------------

   function New_Adt_Definition
     (Ada_Node     : Node_Id := Empty;
      Constructors : W_Constr_Decl_Array)
     return W_Adt_Definition_Id
   is
      Result : Why_Node (W_Adt_Definition);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Adt_Definition);
   begin
      Result.Ada_Node :=
        Ada_Node;
      pragma Assert (Constructors'Length > 0);
      Result.Adt_Constructors := New_List;
      for J in Constructors'Range loop
         pragma Assert
           (Constr_Decl_Id_Kind_Valid
            (+(W_Constr_Decl_Valid_Id (Constructors (J)))));
         pragma Assert
           (Constr_Decl_Id_Valid
            (+(W_Constr_Decl_Valid_Id (Constructors (J)))));
         Append
           (Result.Adt_Constructors,
            +(W_Constr_Decl_Valid_Id (Constructors (J))));
      end loop;
      Set_Link (Result.Adt_Constructors, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Adt_Definition_Id (New_Id);
   end New_Adt_Definition;

   ------------------------
   -- New_Adt_Definition --
   ------------------------

   function New_Adt_Definition
     (Ada_Node     : Node_Id := Empty;
      Constructors : W_Constr_Decl_Array)
     return W_Type_Definition_Id
   is
      Result : Why_Node (W_Adt_Definition);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Adt_Definition);
   begin
      Result.Ada_Node :=
        Ada_Node;
      pragma Assert (Constructors'Length > 0);
      Result.Adt_Constructors := New_List;
      for J in Constructors'Range loop
         pragma Assert
           (Constr_Decl_Id_Kind_Valid
            (+(W_Constr_Decl_Valid_Id (Constructors (J)))));
         pragma Assert
           (Constr_Decl_Id_Valid
            (+(W_Constr_Decl_Valid_Id (Constructors (J)))));
         Append
           (Result.Adt_Constructors,
            +(W_Constr_Decl_Valid_Id (Constructors (J))));
      end loop;
      Set_Link (Result.Adt_Constructors, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Type_Definition_Id (New_Id);
   end New_Adt_Definition;
   ---------------------
   -- New_Constr_Decl --
   ---------------------

   function New_Constr_Decl
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id;
      Arg_List : W_Primitive_Type_Array := (2 .. 1 => <>))
     return W_Constr_Decl_Id
   is
      Result : Why_Node (W_Constr_Decl);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Constr_Decl);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.C_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.C_Name, New_Id);
      Result.C_Arg_List := New_List;
      for J in Arg_List'Range loop
         pragma Assert
           (Primitive_Type_Id_Kind_Valid
            (+(W_Primitive_Type_Valid_OId (Arg_List (J)))));
         pragma Assert
           (Primitive_Type_Id_Valid
            (+(W_Primitive_Type_Valid_OId (Arg_List (J)))));
         Append
           (Result.C_Arg_List,
            +(W_Primitive_Type_Valid_OId (Arg_List (J))));
      end loop;
      Set_Link (Result.C_Arg_List, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Constr_Decl_Id (New_Id);
   end New_Constr_Decl;
   -----------------
   -- New_Effects --
   -----------------

   function New_Effects
     (Ada_Node : Node_Id := Empty;
      Reads    : W_Identifier_Array := (2 .. 1 => <>);
      Writes   : W_Identifier_Array := (2 .. 1 => <>);
      Raises   : W_Identifier_Array := (2 .. 1 => <>))
     return W_Effects_Id
   is
      Result : Why_Node (W_Effects);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Effects);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.E_Reads := New_List;
      for J in Reads'Range loop
         pragma Assert
           (Identifier_Id_Kind_Valid
            (+(W_Identifier_Valid_OId (Reads (J)))));
         pragma Assert
           (Identifier_Id_Valid
            (+(W_Identifier_Valid_OId (Reads (J)))));
         Append
           (Result.E_Reads,
            +(W_Identifier_Valid_OId (Reads (J))));
      end loop;
      Set_Link (Result.E_Reads, New_Id);
      Result.E_Writes := New_List;
      for J in Writes'Range loop
         pragma Assert
           (Identifier_Id_Kind_Valid
            (+(W_Identifier_Valid_OId (Writes (J)))));
         pragma Assert
           (Identifier_Id_Valid
            (+(W_Identifier_Valid_OId (Writes (J)))));
         Append
           (Result.E_Writes,
            +(W_Identifier_Valid_OId (Writes (J))));
      end loop;
      Set_Link (Result.E_Writes, New_Id);
      Result.E_Raises := New_List;
      for J in Raises'Range loop
         pragma Assert
           (Identifier_Id_Kind_Valid
            (+(W_Identifier_Valid_OId (Raises (J)))));
         pragma Assert
           (Identifier_Id_Valid
            (+(W_Identifier_Valid_OId (Raises (J)))));
         Append
           (Result.E_Raises,
            +(W_Identifier_Valid_OId (Raises (J))));
      end loop;
      Set_Link (Result.E_Raises, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Effects_Id (New_Id);
   end New_Effects;
   ----------------------
   -- New_Precondition --
   ----------------------

   function New_Precondition
     (Ada_Node : Node_Id := Empty;
      Pred     : W_Predicate_Id)
     return W_Precondition_Id
   is
      Result : Why_Node (W_Precondition);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Precondition);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.PRE_Pred :=
        +(W_Predicate_Valid_Id (Pred));
      Set_Link (Result.PRE_Pred, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Precondition_Id (New_Id);
   end New_Precondition;
   -----------------------
   -- New_Postcondition --
   -----------------------

   function New_Postcondition
     (Ada_Node : Node_Id := Empty;
      Pred     : W_Predicate_Id;
      Handlers : W_Exn_Condition_Array := (2 .. 1 => <>))
     return W_Postcondition_Id
   is
      Result : Why_Node (W_Postcondition);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Postcondition);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.POST_Pred :=
        +(W_Predicate_Valid_Id (Pred));
      Set_Link (Result.POST_Pred, New_Id);
      Result.POST_Handlers := New_List;
      for J in Handlers'Range loop
         pragma Assert
           (Exn_Condition_Id_Kind_Valid
            (+(W_Exn_Condition_Valid_OId (Handlers (J)))));
         pragma Assert
           (Exn_Condition_Id_Valid
            (+(W_Exn_Condition_Valid_OId (Handlers (J)))));
         Append
           (Result.POST_Handlers,
            +(W_Exn_Condition_Valid_OId (Handlers (J))));
      end loop;
      Set_Link (Result.POST_Handlers, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Postcondition_Id (New_Id);
   end New_Postcondition;
   -----------------------
   -- New_Exn_Condition --
   -----------------------

   function New_Exn_Condition
     (Ada_Node : Node_Id := Empty;
      Exn_Case : W_Identifier_Id;
      Pred     : W_Predicate_Id)
     return W_Exn_Condition_Id
   is
      Result : Why_Node (W_Exn_Condition);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Exn_Condition);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.EC_Exn_Case :=
        +(W_Identifier_Valid_Id (Exn_Case));
      Set_Link (Result.EC_Exn_Case, New_Id);
      Result.EC_Pred :=
        +(W_Predicate_Valid_Id (Pred));
      Set_Link (Result.EC_Pred, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Exn_Condition_Id (New_Id);
   end New_Exn_Condition;
   -----------------------
   -- New_Prog_Constant --
   -----------------------

   function New_Prog_Constant
     (Ada_Node : Node_Id := Empty;
      Def      : W_Constant_Id)
     return W_Prog_Constant_Id
   is
      Result : Why_Node (W_Prog_Constant);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Prog_Constant);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.PC_Def :=
        +(W_Constant_Valid_Id (Def));
      Set_Link (Result.PC_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Prog_Constant_Id (New_Id);
   end New_Prog_Constant;

   -----------------------
   -- New_Prog_Constant --
   -----------------------

   function New_Prog_Constant
     (Ada_Node : Node_Id := Empty;
      Def      : W_Constant_Id)
     return W_Prog_Id
   is
      Result : Why_Node (W_Prog_Constant);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Prog_Constant);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.PC_Def :=
        +(W_Constant_Valid_Id (Def));
      Set_Link (Result.PC_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Prog_Id (New_Id);
   end New_Prog_Constant;
   -------------------------
   -- New_Prog_Identifier --
   -------------------------

   function New_Prog_Identifier
     (Ada_Node : Node_Id := Empty;
      Def      : W_Identifier_Id)
     return W_Prog_Identifier_Id
   is
      Result : Why_Node (W_Prog_Identifier);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Prog_Identifier);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.PI_Def :=
        +(W_Identifier_Valid_Id (Def));
      Set_Link (Result.PI_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Prog_Identifier_Id (New_Id);
   end New_Prog_Identifier;

   -------------------------
   -- New_Prog_Identifier --
   -------------------------

   function New_Prog_Identifier
     (Ada_Node : Node_Id := Empty;
      Def      : W_Identifier_Id)
     return W_Prog_Id
   is
      Result : Why_Node (W_Prog_Identifier);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Prog_Identifier);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.PI_Def :=
        +(W_Identifier_Valid_Id (Def));
      Set_Link (Result.PI_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Prog_Id (New_Id);
   end New_Prog_Identifier;
   ------------------
   -- New_Any_Expr --
   ------------------

   function New_Any_Expr
     (Ada_Node : Node_Id := Empty;
      Any_Type : W_Computation_Type_Id)
     return W_Any_Expr_Id
   is
      Result : Why_Node (W_Any_Expr);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Any_Expr);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.AE_Any_Type :=
        +(W_Computation_Type_Valid_Id (Any_Type));
      Set_Link (Result.AE_Any_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Any_Expr_Id (New_Id);
   end New_Any_Expr;

   ------------------
   -- New_Any_Expr --
   ------------------

   function New_Any_Expr
     (Ada_Node : Node_Id := Empty;
      Any_Type : W_Computation_Type_Id)
     return W_Prog_Id
   is
      Result : Why_Node (W_Any_Expr);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Any_Expr);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.AE_Any_Type :=
        +(W_Computation_Type_Valid_Id (Any_Type));
      Set_Link (Result.AE_Any_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Prog_Id (New_Id);
   end New_Any_Expr;
   ---------------
   -- New_Deref --
   ---------------

   function New_Deref
     (Ada_Node : Node_Id := Empty;
      Ref      : W_Identifier_Id)
     return W_Deref_Id
   is
      Result : Why_Node (W_Deref);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Deref);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.D_Ref :=
        +(W_Identifier_Valid_Id (Ref));
      Set_Link (Result.D_Ref, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Deref_Id (New_Id);
   end New_Deref;

   ---------------
   -- New_Deref --
   ---------------

   function New_Deref
     (Ada_Node : Node_Id := Empty;
      Ref      : W_Identifier_Id)
     return W_Prog_Id
   is
      Result : Why_Node (W_Deref);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Deref);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.D_Ref :=
        +(W_Identifier_Valid_Id (Ref));
      Set_Link (Result.D_Ref, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Prog_Id (New_Id);
   end New_Deref;
   --------------------
   -- New_Assignment --
   --------------------

   function New_Assignment
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id;
      Value    : W_Prog_Id)
     return W_Assignment_Id
   is
      Result : Why_Node (W_Assignment);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Assignment);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.A_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.A_Name, New_Id);
      Result.A_Value :=
        +(W_Prog_Valid_Id (Value));
      Set_Link (Result.A_Value, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Assignment_Id (New_Id);
   end New_Assignment;

   --------------------
   -- New_Assignment --
   --------------------

   function New_Assignment
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id;
      Value    : W_Prog_Id)
     return W_Prog_Id
   is
      Result : Why_Node (W_Assignment);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Assignment);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.A_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.A_Name, New_Id);
      Result.A_Value :=
        +(W_Prog_Valid_Id (Value));
      Set_Link (Result.A_Value, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Prog_Id (New_Id);
   end New_Assignment;
   ----------------------
   -- New_Array_Access --
   ----------------------

   function New_Array_Access
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id;
      Index    : W_Prog_Id)
     return W_Array_Access_Id
   is
      Result : Why_Node (W_Array_Access);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Array_Access);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.AA_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.AA_Name, New_Id);
      Result.AA_Index :=
        +(W_Prog_Valid_Id (Index));
      Set_Link (Result.AA_Index, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Array_Access_Id (New_Id);
   end New_Array_Access;

   ----------------------
   -- New_Array_Access --
   ----------------------

   function New_Array_Access
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id;
      Index    : W_Prog_Id)
     return W_Prog_Id
   is
      Result : Why_Node (W_Array_Access);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Array_Access);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.AA_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.AA_Name, New_Id);
      Result.AA_Index :=
        +(W_Prog_Valid_Id (Index));
      Set_Link (Result.AA_Index, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Prog_Id (New_Id);
   end New_Array_Access;
   ----------------------
   -- New_Array_Update --
   ----------------------

   function New_Array_Update
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id;
      Index    : W_Prog_Id;
      Value    : W_Prog_Id)
     return W_Array_Update_Id
   is
      Result : Why_Node (W_Array_Update);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Array_Update);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.AU_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.AU_Name, New_Id);
      Result.AU_Index :=
        +(W_Prog_Valid_Id (Index));
      Set_Link (Result.AU_Index, New_Id);
      Result.AU_Value :=
        +(W_Prog_Valid_Id (Value));
      Set_Link (Result.AU_Value, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Array_Update_Id (New_Id);
   end New_Array_Update;

   ----------------------
   -- New_Array_Update --
   ----------------------

   function New_Array_Update
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id;
      Index    : W_Prog_Id;
      Value    : W_Prog_Id)
     return W_Prog_Id
   is
      Result : Why_Node (W_Array_Update);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Array_Update);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.AU_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.AU_Name, New_Id);
      Result.AU_Index :=
        +(W_Prog_Valid_Id (Index));
      Set_Link (Result.AU_Index, New_Id);
      Result.AU_Value :=
        +(W_Prog_Valid_Id (Value));
      Set_Link (Result.AU_Value, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Prog_Id (New_Id);
   end New_Array_Update;
   --------------------
   -- New_Infix_Call --
   --------------------

   function New_Infix_Call
     (Ada_Node : Node_Id := Empty;
      Left     : W_Prog_Id;
      Infix    : W_Infix_Id;
      Right    : W_Prog_Id)
     return W_Infix_Call_Id
   is
      Result : Why_Node (W_Infix_Call);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Infix_Call);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.IC_Left :=
        +(W_Prog_Valid_Id (Left));
      Set_Link (Result.IC_Left, New_Id);
      Result.IC_Infix :=
        +(W_Infix_Valid_Id (Infix));
      Set_Link (Result.IC_Infix, New_Id);
      Result.IC_Right :=
        +(W_Prog_Valid_Id (Right));
      Set_Link (Result.IC_Right, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Infix_Call_Id (New_Id);
   end New_Infix_Call;

   --------------------
   -- New_Infix_Call --
   --------------------

   function New_Infix_Call
     (Ada_Node : Node_Id := Empty;
      Left     : W_Prog_Id;
      Infix    : W_Infix_Id;
      Right    : W_Prog_Id)
     return W_Prog_Id
   is
      Result : Why_Node (W_Infix_Call);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Infix_Call);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.IC_Left :=
        +(W_Prog_Valid_Id (Left));
      Set_Link (Result.IC_Left, New_Id);
      Result.IC_Infix :=
        +(W_Infix_Valid_Id (Infix));
      Set_Link (Result.IC_Infix, New_Id);
      Result.IC_Right :=
        +(W_Prog_Valid_Id (Right));
      Set_Link (Result.IC_Right, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Prog_Id (New_Id);
   end New_Infix_Call;
   ---------------------
   -- New_Prefix_Call --
   ---------------------

   function New_Prefix_Call
     (Ada_Node : Node_Id := Empty;
      Prefix   : W_Prefix_Id;
      Operand  : W_Prog_Id)
     return W_Prefix_Call_Id
   is
      Result : Why_Node (W_Prefix_Call);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Prefix_Call);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.PC_Prefix :=
        +(W_Prefix_Valid_Id (Prefix));
      Set_Link (Result.PC_Prefix, New_Id);
      Result.PC_Operand :=
        +(W_Prog_Valid_Id (Operand));
      Set_Link (Result.PC_Operand, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Prefix_Call_Id (New_Id);
   end New_Prefix_Call;

   ---------------------
   -- New_Prefix_Call --
   ---------------------

   function New_Prefix_Call
     (Ada_Node : Node_Id := Empty;
      Prefix   : W_Prefix_Id;
      Operand  : W_Prog_Id)
     return W_Prog_Id
   is
      Result : Why_Node (W_Prefix_Call);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Prefix_Call);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.PC_Prefix :=
        +(W_Prefix_Valid_Id (Prefix));
      Set_Link (Result.PC_Prefix, New_Id);
      Result.PC_Operand :=
        +(W_Prog_Valid_Id (Operand));
      Set_Link (Result.PC_Operand, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Prog_Id (New_Id);
   end New_Prefix_Call;
   ----------------------
   -- New_Binding_Prog --
   ----------------------

   function New_Binding_Prog
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id;
      Def      : W_Prog_Id;
      Context  : W_Prog_Id)
     return W_Binding_Prog_Id
   is
      Result : Why_Node (W_Binding_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Binding_Prog);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.BPG_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.BPG_Name, New_Id);
      Result.BPG_Def :=
        +(W_Prog_Valid_Id (Def));
      Set_Link (Result.BPG_Def, New_Id);
      Result.BPG_Context :=
        +(W_Prog_Valid_Id (Context));
      Set_Link (Result.BPG_Context, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Binding_Prog_Id (New_Id);
   end New_Binding_Prog;

   ----------------------
   -- New_Binding_Prog --
   ----------------------

   function New_Binding_Prog
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id;
      Def      : W_Prog_Id;
      Context  : W_Prog_Id)
     return W_Prog_Id
   is
      Result : Why_Node (W_Binding_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Binding_Prog);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.BPG_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.BPG_Name, New_Id);
      Result.BPG_Def :=
        +(W_Prog_Valid_Id (Def));
      Set_Link (Result.BPG_Def, New_Id);
      Result.BPG_Context :=
        +(W_Prog_Valid_Id (Context));
      Set_Link (Result.BPG_Context, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Prog_Id (New_Id);
   end New_Binding_Prog;
   ---------------------
   -- New_Binding_Ref --
   ---------------------

   function New_Binding_Ref
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id;
      Def      : W_Prog_Id;
      Context  : W_Prog_Id)
     return W_Binding_Ref_Id
   is
      Result : Why_Node (W_Binding_Ref);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Binding_Ref);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.BPG_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.BPG_Name, New_Id);
      Result.BPG_Def :=
        +(W_Prog_Valid_Id (Def));
      Set_Link (Result.BPG_Def, New_Id);
      Result.BPG_Context :=
        +(W_Prog_Valid_Id (Context));
      Set_Link (Result.BPG_Context, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Binding_Ref_Id (New_Id);
   end New_Binding_Ref;

   ---------------------
   -- New_Binding_Ref --
   ---------------------

   function New_Binding_Ref
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id;
      Def      : W_Prog_Id;
      Context  : W_Prog_Id)
     return W_Prog_Id
   is
      Result : Why_Node (W_Binding_Ref);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Binding_Ref);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.BPG_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.BPG_Name, New_Id);
      Result.BPG_Def :=
        +(W_Prog_Valid_Id (Def));
      Set_Link (Result.BPG_Def, New_Id);
      Result.BPG_Context :=
        +(W_Prog_Valid_Id (Context));
      Set_Link (Result.BPG_Context, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Prog_Id (New_Id);
   end New_Binding_Ref;
   --------------------------
   -- New_Conditional_Prog --
   --------------------------

   function New_Conditional_Prog
     (Ada_Node  : Node_Id := Empty;
      Condition : W_Prog_Id;
      Then_Part : W_Prog_Id;
      Else_Part : W_Prog_OId := Why_Empty)
     return W_Conditional_Prog_Id
   is
      Result : Why_Node (W_Conditional_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Conditional_Prog);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.CPG_Condition :=
        +(W_Prog_Valid_Id (Condition));
      Set_Link (Result.CPG_Condition, New_Id);
      Result.CPG_Then_Part :=
        +(W_Prog_Valid_Id (Then_Part));
      Set_Link (Result.CPG_Then_Part, New_Id);
      Result.CPG_Else_Part :=
        +(W_Prog_Valid_OId (Else_Part));
      Set_Link (Result.CPG_Else_Part, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Conditional_Prog_Id (New_Id);
   end New_Conditional_Prog;

   --------------------------
   -- New_Conditional_Prog --
   --------------------------

   function New_Conditional_Prog
     (Ada_Node  : Node_Id := Empty;
      Condition : W_Prog_Id;
      Then_Part : W_Prog_Id;
      Else_Part : W_Prog_OId := Why_Empty)
     return W_Prog_Id
   is
      Result : Why_Node (W_Conditional_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Conditional_Prog);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.CPG_Condition :=
        +(W_Prog_Valid_Id (Condition));
      Set_Link (Result.CPG_Condition, New_Id);
      Result.CPG_Then_Part :=
        +(W_Prog_Valid_Id (Then_Part));
      Set_Link (Result.CPG_Then_Part, New_Id);
      Result.CPG_Else_Part :=
        +(W_Prog_Valid_OId (Else_Part));
      Set_Link (Result.CPG_Else_Part, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Prog_Id (New_Id);
   end New_Conditional_Prog;
   --------------------
   -- New_While_Loop --
   --------------------

   function New_While_Loop
     (Ada_Node     : Node_Id := Empty;
      Condition    : W_Prog_Id;
      Annotation   : W_Loop_Annot_Id;
      Loop_Content : W_Prog_Id)
     return W_While_Loop_Id
   is
      Result : Why_Node (W_While_Loop);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_While_Loop);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.WL_Condition :=
        +(W_Prog_Valid_Id (Condition));
      Set_Link (Result.WL_Condition, New_Id);
      Result.WL_Annotation :=
        +(W_Loop_Annot_Valid_Id (Annotation));
      Set_Link (Result.WL_Annotation, New_Id);
      Result.WL_Loop_Content :=
        +(W_Prog_Valid_Id (Loop_Content));
      Set_Link (Result.WL_Loop_Content, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_While_Loop_Id (New_Id);
   end New_While_Loop;

   --------------------
   -- New_While_Loop --
   --------------------

   function New_While_Loop
     (Ada_Node     : Node_Id := Empty;
      Condition    : W_Prog_Id;
      Annotation   : W_Loop_Annot_Id;
      Loop_Content : W_Prog_Id)
     return W_Prog_Id
   is
      Result : Why_Node (W_While_Loop);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_While_Loop);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.WL_Condition :=
        +(W_Prog_Valid_Id (Condition));
      Set_Link (Result.WL_Condition, New_Id);
      Result.WL_Annotation :=
        +(W_Loop_Annot_Valid_Id (Annotation));
      Set_Link (Result.WL_Annotation, New_Id);
      Result.WL_Loop_Content :=
        +(W_Prog_Valid_Id (Loop_Content));
      Set_Link (Result.WL_Loop_Content, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Prog_Id (New_Id);
   end New_While_Loop;
   ----------------------------
   -- New_Statement_Sequence --
   ----------------------------

   function New_Statement_Sequence
     (Ada_Node   : Node_Id := Empty;
      Statements : W_Prog_Array)
     return W_Statement_Sequence_Id
   is
      Result : Why_Node (W_Statement_Sequence);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Statement_Sequence);
   begin
      Result.Ada_Node :=
        Ada_Node;
      pragma Assert (Statements'Length > 0);
      Result.SS_Statements := New_List;
      for J in Statements'Range loop
         pragma Assert
           (Prog_Id_Kind_Valid
            (+(W_Prog_Valid_Id (Statements (J)))));
         pragma Assert
           (Prog_Id_Valid
            (+(W_Prog_Valid_Id (Statements (J)))));
         Append
           (Result.SS_Statements,
            +(W_Prog_Valid_Id (Statements (J))));
      end loop;
      Set_Link (Result.SS_Statements, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Statement_Sequence_Id (New_Id);
   end New_Statement_Sequence;

   ----------------------------
   -- New_Statement_Sequence --
   ----------------------------

   function New_Statement_Sequence
     (Ada_Node   : Node_Id := Empty;
      Statements : W_Prog_Array)
     return W_Prog_Id
   is
      Result : Why_Node (W_Statement_Sequence);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Statement_Sequence);
   begin
      Result.Ada_Node :=
        Ada_Node;
      pragma Assert (Statements'Length > 0);
      Result.SS_Statements := New_List;
      for J in Statements'Range loop
         pragma Assert
           (Prog_Id_Kind_Valid
            (+(W_Prog_Valid_Id (Statements (J)))));
         pragma Assert
           (Prog_Id_Valid
            (+(W_Prog_Valid_Id (Statements (J)))));
         Append
           (Result.SS_Statements,
            +(W_Prog_Valid_Id (Statements (J))));
      end loop;
      Set_Link (Result.SS_Statements, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Prog_Id (New_Id);
   end New_Statement_Sequence;
   ---------------
   -- New_Label --
   ---------------

   function New_Label
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id;
      Def      : W_Prog_Id)
     return W_Label_Id
   is
      Result : Why_Node (W_Label);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Label);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.L_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.L_Name, New_Id);
      Result.L_Def :=
        +(W_Prog_Valid_Id (Def));
      Set_Link (Result.L_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Label_Id (New_Id);
   end New_Label;

   ---------------
   -- New_Label --
   ---------------

   function New_Label
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id;
      Def      : W_Prog_Id)
     return W_Prog_Id
   is
      Result : Why_Node (W_Label);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Label);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.L_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.L_Name, New_Id);
      Result.L_Def :=
        +(W_Prog_Valid_Id (Def));
      Set_Link (Result.L_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Prog_Id (New_Id);
   end New_Label;
   ----------------
   -- New_Assert --
   ----------------

   function New_Assert
     (Ada_Node : Node_Id := Empty;
      Preds    : W_Predicate_Array;
      Prog     : W_Prog_Id)
     return W_Assert_Id
   is
      Result : Why_Node (W_Assert);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Assert);
   begin
      Result.Ada_Node :=
        Ada_Node;
      pragma Assert (Preds'Length > 0);
      Result.AS_Preds := New_List;
      for J in Preds'Range loop
         pragma Assert
           (Predicate_Id_Kind_Valid
            (+(W_Predicate_Valid_Id (Preds (J)))));
         pragma Assert
           (Predicate_Id_Valid
            (+(W_Predicate_Valid_Id (Preds (J)))));
         Append
           (Result.AS_Preds,
            +(W_Predicate_Valid_Id (Preds (J))));
      end loop;
      Set_Link (Result.AS_Preds, New_Id);
      Result.AS_Prog :=
        +(W_Prog_Valid_Id (Prog));
      Set_Link (Result.AS_Prog, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Assert_Id (New_Id);
   end New_Assert;

   ----------------
   -- New_Assert --
   ----------------

   function New_Assert
     (Ada_Node : Node_Id := Empty;
      Preds    : W_Predicate_Array;
      Prog     : W_Prog_Id)
     return W_Prog_Id
   is
      Result : Why_Node (W_Assert);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Assert);
   begin
      Result.Ada_Node :=
        Ada_Node;
      pragma Assert (Preds'Length > 0);
      Result.AS_Preds := New_List;
      for J in Preds'Range loop
         pragma Assert
           (Predicate_Id_Kind_Valid
            (+(W_Predicate_Valid_Id (Preds (J)))));
         pragma Assert
           (Predicate_Id_Valid
            (+(W_Predicate_Valid_Id (Preds (J)))));
         Append
           (Result.AS_Preds,
            +(W_Predicate_Valid_Id (Preds (J))));
      end loop;
      Set_Link (Result.AS_Preds, New_Id);
      Result.AS_Prog :=
        +(W_Prog_Valid_Id (Prog));
      Set_Link (Result.AS_Prog, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Prog_Id (New_Id);
   end New_Assert;
   ------------------------
   -- New_Post_Assertion --
   ------------------------

   function New_Post_Assertion
     (Ada_Node : Node_Id := Empty;
      Prog     : W_Prog_Id;
      Post     : W_Postcondition_Id)
     return W_Post_Assertion_Id
   is
      Result : Why_Node (W_Post_Assertion);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Post_Assertion);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.PA_Prog :=
        +(W_Prog_Valid_Id (Prog));
      Set_Link (Result.PA_Prog, New_Id);
      Result.PA_Post :=
        +(W_Postcondition_Valid_Id (Post));
      Set_Link (Result.PA_Post, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Post_Assertion_Id (New_Id);
   end New_Post_Assertion;

   ------------------------
   -- New_Post_Assertion --
   ------------------------

   function New_Post_Assertion
     (Ada_Node : Node_Id := Empty;
      Prog     : W_Prog_Id;
      Post     : W_Postcondition_Id)
     return W_Prog_Id
   is
      Result : Why_Node (W_Post_Assertion);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Post_Assertion);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.PA_Prog :=
        +(W_Prog_Valid_Id (Prog));
      Set_Link (Result.PA_Prog, New_Id);
      Result.PA_Post :=
        +(W_Postcondition_Valid_Id (Post));
      Set_Link (Result.PA_Post, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Prog_Id (New_Id);
   end New_Post_Assertion;
   --------------------------
   -- New_Opaque_Assertion --
   --------------------------

   function New_Opaque_Assertion
     (Ada_Node : Node_Id := Empty;
      Prog     : W_Prog_Id;
      Post     : W_Postcondition_Id)
     return W_Opaque_Assertion_Id
   is
      Result : Why_Node (W_Opaque_Assertion);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Opaque_Assertion);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.PA_Prog :=
        +(W_Prog_Valid_Id (Prog));
      Set_Link (Result.PA_Prog, New_Id);
      Result.PA_Post :=
        +(W_Postcondition_Valid_Id (Post));
      Set_Link (Result.PA_Post, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Opaque_Assertion_Id (New_Id);
   end New_Opaque_Assertion;

   --------------------------
   -- New_Opaque_Assertion --
   --------------------------

   function New_Opaque_Assertion
     (Ada_Node : Node_Id := Empty;
      Prog     : W_Prog_Id;
      Post     : W_Postcondition_Id)
     return W_Prog_Id
   is
      Result : Why_Node (W_Opaque_Assertion);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Opaque_Assertion);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.PA_Prog :=
        +(W_Prog_Valid_Id (Prog));
      Set_Link (Result.PA_Prog, New_Id);
      Result.PA_Post :=
        +(W_Postcondition_Valid_Id (Post));
      Set_Link (Result.PA_Post, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Prog_Id (New_Id);
   end New_Opaque_Assertion;
   -----------------
   -- New_Fun_Def --
   -----------------

   function New_Fun_Def
     (Ada_Node : Node_Id := Empty;
      Binders  : W_Binder_Array;
      Pre      : W_Precondition_Id;
      Def      : W_Prog_Id)
     return W_Fun_Def_Id
   is
      Result : Why_Node (W_Fun_Def);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Fun_Def);
   begin
      Result.Ada_Node :=
        Ada_Node;
      pragma Assert (Binders'Length > 0);
      Result.FD_Binders := New_List;
      for J in Binders'Range loop
         pragma Assert
           (Binder_Id_Kind_Valid
            (+(W_Binder_Valid_Id (Binders (J)))));
         pragma Assert
           (Binder_Id_Valid
            (+(W_Binder_Valid_Id (Binders (J)))));
         Append
           (Result.FD_Binders,
            +(W_Binder_Valid_Id (Binders (J))));
      end loop;
      Set_Link (Result.FD_Binders, New_Id);
      Result.FD_Pre :=
        +(W_Precondition_Valid_Id (Pre));
      Set_Link (Result.FD_Pre, New_Id);
      Result.FD_Def :=
        +(W_Prog_Valid_Id (Def));
      Set_Link (Result.FD_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Fun_Def_Id (New_Id);
   end New_Fun_Def;

   -----------------
   -- New_Fun_Def --
   -----------------

   function New_Fun_Def
     (Ada_Node : Node_Id := Empty;
      Binders  : W_Binder_Array;
      Pre      : W_Precondition_Id;
      Def      : W_Prog_Id)
     return W_Prog_Id
   is
      Result : Why_Node (W_Fun_Def);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Fun_Def);
   begin
      Result.Ada_Node :=
        Ada_Node;
      pragma Assert (Binders'Length > 0);
      Result.FD_Binders := New_List;
      for J in Binders'Range loop
         pragma Assert
           (Binder_Id_Kind_Valid
            (+(W_Binder_Valid_Id (Binders (J)))));
         pragma Assert
           (Binder_Id_Valid
            (+(W_Binder_Valid_Id (Binders (J)))));
         Append
           (Result.FD_Binders,
            +(W_Binder_Valid_Id (Binders (J))));
      end loop;
      Set_Link (Result.FD_Binders, New_Id);
      Result.FD_Pre :=
        +(W_Precondition_Valid_Id (Pre));
      Set_Link (Result.FD_Pre, New_Id);
      Result.FD_Def :=
        +(W_Prog_Valid_Id (Def));
      Set_Link (Result.FD_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Prog_Id (New_Id);
   end New_Fun_Def;
   ---------------------
   -- New_Binding_Fun --
   ---------------------

   function New_Binding_Fun
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id;
      Binders  : W_Binder_Array;
      Pre      : W_Precondition_Id;
      Def      : W_Prog_Id;
      Context  : W_Prog_Id)
     return W_Binding_Fun_Id
   is
      Result : Why_Node (W_Binding_Fun);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Binding_Fun);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.BF_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.BF_Name, New_Id);
      pragma Assert (Binders'Length > 0);
      Result.BF_Binders := New_List;
      for J in Binders'Range loop
         pragma Assert
           (Binder_Id_Kind_Valid
            (+(W_Binder_Valid_Id (Binders (J)))));
         pragma Assert
           (Binder_Id_Valid
            (+(W_Binder_Valid_Id (Binders (J)))));
         Append
           (Result.BF_Binders,
            +(W_Binder_Valid_Id (Binders (J))));
      end loop;
      Set_Link (Result.BF_Binders, New_Id);
      Result.BF_Pre :=
        +(W_Precondition_Valid_Id (Pre));
      Set_Link (Result.BF_Pre, New_Id);
      Result.BF_Def :=
        +(W_Prog_Valid_Id (Def));
      Set_Link (Result.BF_Def, New_Id);
      Result.BF_Context :=
        +(W_Prog_Valid_Id (Context));
      Set_Link (Result.BF_Context, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Binding_Fun_Id (New_Id);
   end New_Binding_Fun;

   ---------------------
   -- New_Binding_Fun --
   ---------------------

   function New_Binding_Fun
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id;
      Binders  : W_Binder_Array;
      Pre      : W_Precondition_Id;
      Def      : W_Prog_Id;
      Context  : W_Prog_Id)
     return W_Prog_Id
   is
      Result : Why_Node (W_Binding_Fun);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Binding_Fun);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.BF_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.BF_Name, New_Id);
      pragma Assert (Binders'Length > 0);
      Result.BF_Binders := New_List;
      for J in Binders'Range loop
         pragma Assert
           (Binder_Id_Kind_Valid
            (+(W_Binder_Valid_Id (Binders (J)))));
         pragma Assert
           (Binder_Id_Valid
            (+(W_Binder_Valid_Id (Binders (J)))));
         Append
           (Result.BF_Binders,
            +(W_Binder_Valid_Id (Binders (J))));
      end loop;
      Set_Link (Result.BF_Binders, New_Id);
      Result.BF_Pre :=
        +(W_Precondition_Valid_Id (Pre));
      Set_Link (Result.BF_Pre, New_Id);
      Result.BF_Def :=
        +(W_Prog_Valid_Id (Def));
      Set_Link (Result.BF_Def, New_Id);
      Result.BF_Context :=
        +(W_Prog_Valid_Id (Context));
      Set_Link (Result.BF_Context, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Prog_Id (New_Id);
   end New_Binding_Fun;
   ---------------------
   -- New_Binding_Rec --
   ---------------------

   function New_Binding_Rec
     (Ada_Node : Node_Id := Empty;
      Recfun   : W_Recfun_Id;
      Context  : W_Prog_Id)
     return W_Binding_Rec_Id
   is
      Result : Why_Node (W_Binding_Rec);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Binding_Rec);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.BR_Recfun :=
        +(W_Recfun_Valid_Id (Recfun));
      Set_Link (Result.BR_Recfun, New_Id);
      Result.BR_Context :=
        +(W_Prog_Valid_Id (Context));
      Set_Link (Result.BR_Context, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Binding_Rec_Id (New_Id);
   end New_Binding_Rec;

   ---------------------
   -- New_Binding_Rec --
   ---------------------

   function New_Binding_Rec
     (Ada_Node : Node_Id := Empty;
      Recfun   : W_Recfun_Id;
      Context  : W_Prog_Id)
     return W_Prog_Id
   is
      Result : Why_Node (W_Binding_Rec);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Binding_Rec);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.BR_Recfun :=
        +(W_Recfun_Valid_Id (Recfun));
      Set_Link (Result.BR_Recfun, New_Id);
      Result.BR_Context :=
        +(W_Prog_Valid_Id (Context));
      Set_Link (Result.BR_Context, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Prog_Id (New_Id);
   end New_Binding_Rec;
   -------------------
   -- New_Prog_Call --
   -------------------

   function New_Prog_Call
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id;
      Progs    : W_Prog_Array)
     return W_Prog_Call_Id
   is
      Result : Why_Node (W_Prog_Call);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Prog_Call);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.PS_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.PS_Name, New_Id);
      pragma Assert (Progs'Length > 0);
      Result.PS_Progs := New_List;
      for J in Progs'Range loop
         pragma Assert
           (Prog_Id_Kind_Valid
            (+(W_Prog_Valid_Id (Progs (J)))));
         pragma Assert
           (Prog_Id_Valid
            (+(W_Prog_Valid_Id (Progs (J)))));
         Append
           (Result.PS_Progs,
            +(W_Prog_Valid_Id (Progs (J))));
      end loop;
      Set_Link (Result.PS_Progs, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Prog_Call_Id (New_Id);
   end New_Prog_Call;

   -------------------
   -- New_Prog_Call --
   -------------------

   function New_Prog_Call
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id;
      Progs    : W_Prog_Array)
     return W_Prog_Id
   is
      Result : Why_Node (W_Prog_Call);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Prog_Call);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.PS_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.PS_Name, New_Id);
      pragma Assert (Progs'Length > 0);
      Result.PS_Progs := New_List;
      for J in Progs'Range loop
         pragma Assert
           (Prog_Id_Kind_Valid
            (+(W_Prog_Valid_Id (Progs (J)))));
         pragma Assert
           (Prog_Id_Valid
            (+(W_Prog_Valid_Id (Progs (J)))));
         Append
           (Result.PS_Progs,
            +(W_Prog_Valid_Id (Progs (J))));
      end loop;
      Set_Link (Result.PS_Progs, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Prog_Id (New_Id);
   end New_Prog_Call;
   -------------------------
   -- New_Raise_Statement --
   -------------------------

   function New_Raise_Statement
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id;
      Exn_Type : W_Simple_Value_Type_OId := Why_Empty)
     return W_Raise_Statement_Id
   is
      Result : Why_Node (W_Raise_Statement);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Raise_Statement);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.RS_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.RS_Name, New_Id);
      Result.RS_Exn_Type :=
        +(W_Simple_Value_Type_Valid_OId (Exn_Type));
      Set_Link (Result.RS_Exn_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Raise_Statement_Id (New_Id);
   end New_Raise_Statement;

   -------------------------
   -- New_Raise_Statement --
   -------------------------

   function New_Raise_Statement
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id;
      Exn_Type : W_Simple_Value_Type_OId := Why_Empty)
     return W_Prog_Id
   is
      Result : Why_Node (W_Raise_Statement);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Raise_Statement);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.RS_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.RS_Name, New_Id);
      Result.RS_Exn_Type :=
        +(W_Simple_Value_Type_Valid_OId (Exn_Type));
      Set_Link (Result.RS_Exn_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Prog_Id (New_Id);
   end New_Raise_Statement;
   -----------------------------------------
   -- New_Raise_Statement_With_Parameters --
   -----------------------------------------

   function New_Raise_Statement_With_Parameters
     (Ada_Node  : Node_Id := Empty;
      Name      : W_Identifier_Id;
      Parameter : W_Term_Id;
      Exn_Type  : W_Simple_Value_Type_OId := Why_Empty)
     return W_Raise_Statement_With_Parameters_Id
   is
      Result : Why_Node (W_Raise_Statement_With_Parameters);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Raise_Statement_With_Parameters);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.RSWP_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.RSWP_Name, New_Id);
      Result.RSWP_Parameter :=
        +(W_Term_Valid_Id (Parameter));
      Set_Link (Result.RSWP_Parameter, New_Id);
      Result.RSWP_Exn_Type :=
        +(W_Simple_Value_Type_Valid_OId (Exn_Type));
      Set_Link (Result.RSWP_Exn_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Raise_Statement_With_Parameters_Id (New_Id);
   end New_Raise_Statement_With_Parameters;

   -----------------------------------------
   -- New_Raise_Statement_With_Parameters --
   -----------------------------------------

   function New_Raise_Statement_With_Parameters
     (Ada_Node  : Node_Id := Empty;
      Name      : W_Identifier_Id;
      Parameter : W_Term_Id;
      Exn_Type  : W_Simple_Value_Type_OId := Why_Empty)
     return W_Prog_Id
   is
      Result : Why_Node (W_Raise_Statement_With_Parameters);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Raise_Statement_With_Parameters);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.RSWP_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.RSWP_Name, New_Id);
      Result.RSWP_Parameter :=
        +(W_Term_Valid_Id (Parameter));
      Set_Link (Result.RSWP_Parameter, New_Id);
      Result.RSWP_Exn_Type :=
        +(W_Simple_Value_Type_Valid_OId (Exn_Type));
      Set_Link (Result.RSWP_Exn_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Prog_Id (New_Id);
   end New_Raise_Statement_With_Parameters;
   -------------------
   -- New_Try_Block --
   -------------------

   function New_Try_Block
     (Ada_Node : Node_Id := Empty;
      Prog     : W_Prog_Id;
      Handler  : W_Handler_Array)
     return W_Try_Block_Id
   is
      Result : Why_Node (W_Try_Block);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Try_Block);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.TB_Prog :=
        +(W_Prog_Valid_Id (Prog));
      Set_Link (Result.TB_Prog, New_Id);
      pragma Assert (Handler'Length > 0);
      Result.TB_Handler := New_List;
      for J in Handler'Range loop
         pragma Assert
           (Handler_Id_Kind_Valid
            (+(W_Handler_Valid_Id (Handler (J)))));
         pragma Assert
           (Handler_Id_Valid
            (+(W_Handler_Valid_Id (Handler (J)))));
         Append
           (Result.TB_Handler,
            +(W_Handler_Valid_Id (Handler (J))));
      end loop;
      Set_Link (Result.TB_Handler, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Try_Block_Id (New_Id);
   end New_Try_Block;

   -------------------
   -- New_Try_Block --
   -------------------

   function New_Try_Block
     (Ada_Node : Node_Id := Empty;
      Prog     : W_Prog_Id;
      Handler  : W_Handler_Array)
     return W_Prog_Id
   is
      Result : Why_Node (W_Try_Block);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Try_Block);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.TB_Prog :=
        +(W_Prog_Valid_Id (Prog));
      Set_Link (Result.TB_Prog, New_Id);
      pragma Assert (Handler'Length > 0);
      Result.TB_Handler := New_List;
      for J in Handler'Range loop
         pragma Assert
           (Handler_Id_Kind_Valid
            (+(W_Handler_Valid_Id (Handler (J)))));
         pragma Assert
           (Handler_Id_Valid
            (+(W_Handler_Valid_Id (Handler (J)))));
         Append
           (Result.TB_Handler,
            +(W_Handler_Valid_Id (Handler (J))));
      end loop;
      Set_Link (Result.TB_Handler, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Prog_Id (New_Id);
   end New_Try_Block;
   --------------------------
   -- New_Unreachable_Code --
   --------------------------

   function New_Unreachable_Code
     (Ada_Node : Node_Id := Empty;
      Exn_Type : W_Simple_Value_Type_OId := Why_Empty)
     return W_Unreachable_Code_Id
   is
      Result : Why_Node (W_Unreachable_Code);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Unreachable_Code);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.UC_Exn_Type :=
        +(W_Simple_Value_Type_Valid_OId (Exn_Type));
      Set_Link (Result.UC_Exn_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Unreachable_Code_Id (New_Id);
   end New_Unreachable_Code;

   --------------------------
   -- New_Unreachable_Code --
   --------------------------

   function New_Unreachable_Code
     (Ada_Node : Node_Id := Empty;
      Exn_Type : W_Simple_Value_Type_OId := Why_Empty)
     return W_Prog_Id
   is
      Result : Why_Node (W_Unreachable_Code);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Unreachable_Code);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.UC_Exn_Type :=
        +(W_Simple_Value_Type_Valid_OId (Exn_Type));
      Set_Link (Result.UC_Exn_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Prog_Id (New_Id);
   end New_Unreachable_Code;
   ---------------------
   -- New_Begin_Block --
   ---------------------

   function New_Begin_Block
     (Ada_Node : Node_Id := Empty;
      Prog     : W_Prog_Id)
     return W_Begin_Block_Id
   is
      Result : Why_Node (W_Begin_Block);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Begin_Block);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.BB_Prog :=
        +(W_Prog_Valid_Id (Prog));
      Set_Link (Result.BB_Prog, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Begin_Block_Id (New_Id);
   end New_Begin_Block;

   ---------------------
   -- New_Begin_Block --
   ---------------------

   function New_Begin_Block
     (Ada_Node : Node_Id := Empty;
      Prog     : W_Prog_Id)
     return W_Prog_Id
   is
      Result : Why_Node (W_Begin_Block);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Begin_Block);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.BB_Prog :=
        +(W_Prog_Valid_Id (Prog));
      Set_Link (Result.BB_Prog, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Prog_Id (New_Id);
   end New_Begin_Block;
   ------------------------
   -- New_Protected_Prog --
   ------------------------

   function New_Protected_Prog
     (Ada_Node : Node_Id := Empty;
      Prog     : W_Prog_Id)
     return W_Protected_Prog_Id
   is
      Result : Why_Node (W_Protected_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Protected_Prog);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.BB_Prog :=
        +(W_Prog_Valid_Id (Prog));
      Set_Link (Result.BB_Prog, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Protected_Prog_Id (New_Id);
   end New_Protected_Prog;

   ------------------------
   -- New_Protected_Prog --
   ------------------------

   function New_Protected_Prog
     (Ada_Node : Node_Id := Empty;
      Prog     : W_Prog_Id)
     return W_Prog_Id
   is
      Result : Why_Node (W_Protected_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Protected_Prog);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.BB_Prog :=
        +(W_Prog_Valid_Id (Prog));
      Set_Link (Result.BB_Prog, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Prog_Id (New_Id);
   end New_Protected_Prog;
   ---------------------
   -- New_Op_Add_Prog --
   ---------------------

   function New_Op_Add_Prog
     (Ada_Node : Node_Id := Empty)
     return W_Op_Add_Prog_Id
   is
      Result : Why_Node (W_Op_Add_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Add_Prog);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Op_Add_Prog_Id (New_Id);
   end New_Op_Add_Prog;

   ---------------------
   -- New_Op_Add_Prog --
   ---------------------

   function New_Op_Add_Prog
     (Ada_Node : Node_Id := Empty)
     return W_Infix_Id
   is
      Result : Why_Node (W_Op_Add_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Add_Prog);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Infix_Id (New_Id);
   end New_Op_Add_Prog;
   ---------------------------
   -- New_Op_Substract_Prog --
   ---------------------------

   function New_Op_Substract_Prog
     (Ada_Node : Node_Id := Empty)
     return W_Op_Substract_Prog_Id
   is
      Result : Why_Node (W_Op_Substract_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Substract_Prog);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Op_Substract_Prog_Id (New_Id);
   end New_Op_Substract_Prog;

   ---------------------------
   -- New_Op_Substract_Prog --
   ---------------------------

   function New_Op_Substract_Prog
     (Ada_Node : Node_Id := Empty)
     return W_Infix_Id
   is
      Result : Why_Node (W_Op_Substract_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Substract_Prog);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Infix_Id (New_Id);
   end New_Op_Substract_Prog;
   --------------------------
   -- New_Op_Multiply_Prog --
   --------------------------

   function New_Op_Multiply_Prog
     (Ada_Node : Node_Id := Empty)
     return W_Op_Multiply_Prog_Id
   is
      Result : Why_Node (W_Op_Multiply_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Multiply_Prog);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Op_Multiply_Prog_Id (New_Id);
   end New_Op_Multiply_Prog;

   --------------------------
   -- New_Op_Multiply_Prog --
   --------------------------

   function New_Op_Multiply_Prog
     (Ada_Node : Node_Id := Empty)
     return W_Infix_Id
   is
      Result : Why_Node (W_Op_Multiply_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Multiply_Prog);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Infix_Id (New_Id);
   end New_Op_Multiply_Prog;
   ------------------------
   -- New_Op_Divide_Prog --
   ------------------------

   function New_Op_Divide_Prog
     (Ada_Node : Node_Id := Empty)
     return W_Op_Divide_Prog_Id
   is
      Result : Why_Node (W_Op_Divide_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Divide_Prog);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Op_Divide_Prog_Id (New_Id);
   end New_Op_Divide_Prog;

   ------------------------
   -- New_Op_Divide_Prog --
   ------------------------

   function New_Op_Divide_Prog
     (Ada_Node : Node_Id := Empty)
     return W_Infix_Id
   is
      Result : Why_Node (W_Op_Divide_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Divide_Prog);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Infix_Id (New_Id);
   end New_Op_Divide_Prog;
   ---------------------
   -- New_Op_Mod_Prog --
   ---------------------

   function New_Op_Mod_Prog
     (Ada_Node : Node_Id := Empty)
     return W_Op_Mod_Prog_Id
   is
      Result : Why_Node (W_Op_Mod_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Mod_Prog);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Op_Mod_Prog_Id (New_Id);
   end New_Op_Mod_Prog;

   ---------------------
   -- New_Op_Mod_Prog --
   ---------------------

   function New_Op_Mod_Prog
     (Ada_Node : Node_Id := Empty)
     return W_Infix_Id
   is
      Result : Why_Node (W_Op_Mod_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Mod_Prog);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Infix_Id (New_Id);
   end New_Op_Mod_Prog;
   --------------------
   -- New_Op_Eq_Prog --
   --------------------

   function New_Op_Eq_Prog
     (Ada_Node : Node_Id := Empty)
     return W_Op_Eq_Prog_Id
   is
      Result : Why_Node (W_Op_Eq_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Eq_Prog);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Op_Eq_Prog_Id (New_Id);
   end New_Op_Eq_Prog;

   --------------------
   -- New_Op_Eq_Prog --
   --------------------

   function New_Op_Eq_Prog
     (Ada_Node : Node_Id := Empty)
     return W_Infix_Id
   is
      Result : Why_Node (W_Op_Eq_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Eq_Prog);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Infix_Id (New_Id);
   end New_Op_Eq_Prog;
   --------------------
   -- New_Op_Ne_Prog --
   --------------------

   function New_Op_Ne_Prog
     (Ada_Node : Node_Id := Empty)
     return W_Op_Ne_Prog_Id
   is
      Result : Why_Node (W_Op_Ne_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Ne_Prog);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Op_Ne_Prog_Id (New_Id);
   end New_Op_Ne_Prog;

   --------------------
   -- New_Op_Ne_Prog --
   --------------------

   function New_Op_Ne_Prog
     (Ada_Node : Node_Id := Empty)
     return W_Infix_Id
   is
      Result : Why_Node (W_Op_Ne_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Ne_Prog);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Infix_Id (New_Id);
   end New_Op_Ne_Prog;
   --------------------
   -- New_Op_Lt_Prog --
   --------------------

   function New_Op_Lt_Prog
     (Ada_Node : Node_Id := Empty)
     return W_Op_Lt_Prog_Id
   is
      Result : Why_Node (W_Op_Lt_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Lt_Prog);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Op_Lt_Prog_Id (New_Id);
   end New_Op_Lt_Prog;

   --------------------
   -- New_Op_Lt_Prog --
   --------------------

   function New_Op_Lt_Prog
     (Ada_Node : Node_Id := Empty)
     return W_Infix_Id
   is
      Result : Why_Node (W_Op_Lt_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Lt_Prog);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Infix_Id (New_Id);
   end New_Op_Lt_Prog;
   --------------------
   -- New_Op_Le_Prog --
   --------------------

   function New_Op_Le_Prog
     (Ada_Node : Node_Id := Empty)
     return W_Op_Le_Prog_Id
   is
      Result : Why_Node (W_Op_Le_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Le_Prog);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Op_Le_Prog_Id (New_Id);
   end New_Op_Le_Prog;

   --------------------
   -- New_Op_Le_Prog --
   --------------------

   function New_Op_Le_Prog
     (Ada_Node : Node_Id := Empty)
     return W_Infix_Id
   is
      Result : Why_Node (W_Op_Le_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Le_Prog);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Infix_Id (New_Id);
   end New_Op_Le_Prog;
   --------------------
   -- New_Op_Gt_Prog --
   --------------------

   function New_Op_Gt_Prog
     (Ada_Node : Node_Id := Empty)
     return W_Op_Gt_Prog_Id
   is
      Result : Why_Node (W_Op_Gt_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Gt_Prog);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Op_Gt_Prog_Id (New_Id);
   end New_Op_Gt_Prog;

   --------------------
   -- New_Op_Gt_Prog --
   --------------------

   function New_Op_Gt_Prog
     (Ada_Node : Node_Id := Empty)
     return W_Infix_Id
   is
      Result : Why_Node (W_Op_Gt_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Gt_Prog);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Infix_Id (New_Id);
   end New_Op_Gt_Prog;
   --------------------
   -- New_Op_Ge_Prog --
   --------------------

   function New_Op_Ge_Prog
     (Ada_Node : Node_Id := Empty)
     return W_Op_Ge_Prog_Id
   is
      Result : Why_Node (W_Op_Ge_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Ge_Prog);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Op_Ge_Prog_Id (New_Id);
   end New_Op_Ge_Prog;

   --------------------
   -- New_Op_Ge_Prog --
   --------------------

   function New_Op_Ge_Prog
     (Ada_Node : Node_Id := Empty)
     return W_Infix_Id
   is
      Result : Why_Node (W_Op_Ge_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Ge_Prog);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Infix_Id (New_Id);
   end New_Op_Ge_Prog;
   -------------------------
   -- New_Op_Or_Else_Prog --
   -------------------------

   function New_Op_Or_Else_Prog
     (Ada_Node : Node_Id := Empty)
     return W_Op_Or_Else_Prog_Id
   is
      Result : Why_Node (W_Op_Or_Else_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Or_Else_Prog);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Op_Or_Else_Prog_Id (New_Id);
   end New_Op_Or_Else_Prog;

   -------------------------
   -- New_Op_Or_Else_Prog --
   -------------------------

   function New_Op_Or_Else_Prog
     (Ada_Node : Node_Id := Empty)
     return W_Infix_Id
   is
      Result : Why_Node (W_Op_Or_Else_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Or_Else_Prog);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Infix_Id (New_Id);
   end New_Op_Or_Else_Prog;
   --------------------------
   -- New_Op_And_Then_Prog --
   --------------------------

   function New_Op_And_Then_Prog
     (Ada_Node : Node_Id := Empty)
     return W_Op_And_Then_Prog_Id
   is
      Result : Why_Node (W_Op_And_Then_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_And_Then_Prog);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Op_And_Then_Prog_Id (New_Id);
   end New_Op_And_Then_Prog;

   --------------------------
   -- New_Op_And_Then_Prog --
   --------------------------

   function New_Op_And_Then_Prog
     (Ada_Node : Node_Id := Empty)
     return W_Infix_Id
   is
      Result : Why_Node (W_Op_And_Then_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_And_Then_Prog);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Infix_Id (New_Id);
   end New_Op_And_Then_Prog;
   -----------------------
   -- New_Op_Minus_Prog --
   -----------------------

   function New_Op_Minus_Prog
     (Ada_Node : Node_Id := Empty)
     return W_Op_Minus_Prog_Id
   is
      Result : Why_Node (W_Op_Minus_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Minus_Prog);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Op_Minus_Prog_Id (New_Id);
   end New_Op_Minus_Prog;

   -----------------------
   -- New_Op_Minus_Prog --
   -----------------------

   function New_Op_Minus_Prog
     (Ada_Node : Node_Id := Empty)
     return W_Prefix_Id
   is
      Result : Why_Node (W_Op_Minus_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Minus_Prog);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Prefix_Id (New_Id);
   end New_Op_Minus_Prog;
   ---------------------
   -- New_Op_Not_Prog --
   ---------------------

   function New_Op_Not_Prog
     (Ada_Node : Node_Id := Empty)
     return W_Op_Not_Prog_Id
   is
      Result : Why_Node (W_Op_Not_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Not_Prog);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Op_Not_Prog_Id (New_Id);
   end New_Op_Not_Prog;

   ---------------------
   -- New_Op_Not_Prog --
   ---------------------

   function New_Op_Not_Prog
     (Ada_Node : Node_Id := Empty)
     return W_Prefix_Id
   is
      Result : Why_Node (W_Op_Not_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Not_Prog);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Prefix_Id (New_Id);
   end New_Op_Not_Prog;
   ----------------
   -- New_Binder --
   ----------------

   function New_Binder
     (Ada_Node : Node_Id := Empty;
      Names    : W_Identifier_Array;
      Arg_Type : W_Simple_Value_Type_Id)
     return W_Binder_Id
   is
      Result : Why_Node (W_Binder);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Binder);
   begin
      Result.Ada_Node :=
        Ada_Node;
      pragma Assert (Names'Length > 0);
      Result.B_Names := New_List;
      for J in Names'Range loop
         pragma Assert
           (Identifier_Id_Kind_Valid
            (+(W_Identifier_Valid_Id (Names (J)))));
         pragma Assert
           (Identifier_Id_Valid
            (+(W_Identifier_Valid_Id (Names (J)))));
         Append
           (Result.B_Names,
            +(W_Identifier_Valid_Id (Names (J))));
      end loop;
      Set_Link (Result.B_Names, New_Id);
      Result.B_Arg_Type :=
        +(W_Simple_Value_Type_Valid_Id (Arg_Type));
      Set_Link (Result.B_Arg_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Binder_Id (New_Id);
   end New_Binder;
   ----------------
   -- New_Recfun --
   ----------------

   function New_Recfun
     (Ada_Node    : Node_Id := Empty;
      Name        : W_Identifier_Id;
      Binders     : W_Binder_Array;
      Return_Type : W_Prog_Id;
      Variant     : W_Wf_Arg_Id;
      Pre         : W_Precondition_Id;
      Def         : W_Prog_Id)
     return W_Recfun_Id
   is
      Result : Why_Node (W_Recfun);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Recfun);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.RF_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.RF_Name, New_Id);
      pragma Assert (Binders'Length > 0);
      Result.RF_Binders := New_List;
      for J in Binders'Range loop
         pragma Assert
           (Binder_Id_Kind_Valid
            (+(W_Binder_Valid_Id (Binders (J)))));
         pragma Assert
           (Binder_Id_Valid
            (+(W_Binder_Valid_Id (Binders (J)))));
         Append
           (Result.RF_Binders,
            +(W_Binder_Valid_Id (Binders (J))));
      end loop;
      Set_Link (Result.RF_Binders, New_Id);
      Result.RF_Return_Type :=
        +(W_Prog_Valid_Id (Return_Type));
      Set_Link (Result.RF_Return_Type, New_Id);
      Result.RF_Variant :=
        +(W_Wf_Arg_Valid_Id (Variant));
      Set_Link (Result.RF_Variant, New_Id);
      Result.RF_Pre :=
        +(W_Precondition_Valid_Id (Pre));
      Set_Link (Result.RF_Pre, New_Id);
      Result.RF_Def :=
        +(W_Prog_Valid_Id (Def));
      Set_Link (Result.RF_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Recfun_Id (New_Id);
   end New_Recfun;
   --------------------
   -- New_Loop_Annot --
   --------------------

   function New_Loop_Annot
     (Ada_Node  : Node_Id := Empty;
      Invariant : W_Predicate_OId := Why_Empty;
      Variant   : W_Wf_Arg_OId := Why_Empty)
     return W_Loop_Annot_Id
   is
      Result : Why_Node (W_Loop_Annot);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Loop_Annot);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.LA_Invariant :=
        +(W_Predicate_Valid_OId (Invariant));
      Set_Link (Result.LA_Invariant, New_Id);
      Result.LA_Variant :=
        +(W_Wf_Arg_Valid_OId (Variant));
      Set_Link (Result.LA_Variant, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Loop_Annot_Id (New_Id);
   end New_Loop_Annot;
   ----------------
   -- New_Wf_Arg --
   ----------------

   function New_Wf_Arg
     (Ada_Node : Node_Id := Empty;
      Def      : W_Term_Id;
      For_Id   : W_Identifier_OId := Why_Empty)
     return W_Wf_Arg_Id
   is
      Result : Why_Node (W_Wf_Arg);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Wf_Arg);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.WA_Def :=
        +(W_Term_Valid_Id (Def));
      Set_Link (Result.WA_Def, New_Id);
      Result.WA_For_Id :=
        +(W_Identifier_Valid_OId (For_Id));
      Set_Link (Result.WA_For_Id, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Wf_Arg_Id (New_Id);
   end New_Wf_Arg;
   -----------------
   -- New_Handler --
   -----------------

   function New_Handler
     (Ada_Node  : Node_Id := Empty;
      Name      : W_Identifier_Id;
      Parameter : W_Prog_OId := Why_Empty;
      Def       : W_Prog_Id)
     return W_Handler_Id
   is
      Result : Why_Node (W_Handler);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Handler);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.H_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.H_Name, New_Id);
      Result.H_Parameter :=
        +(W_Prog_Valid_OId (Parameter));
      Set_Link (Result.H_Parameter, New_Id);
      Result.H_Def :=
        +(W_Prog_Valid_Id (Def));
      Set_Link (Result.H_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Handler_Id (New_Id);
   end New_Handler;
   --------------
   -- New_File --
   --------------

   function New_File
     (Ada_Node     : Node_Id := Empty;
      Declarations : W_Declaration_Array := (2 .. 1 => <>))
     return W_File_Id
   is
      Result : Why_Node (W_File);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_File);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.F_Declarations := New_List;
      for J in Declarations'Range loop
         pragma Assert
           (Declaration_Id_Kind_Valid
            (+(W_Declaration_Valid_OId (Declarations (J)))));
         pragma Assert
           (Declaration_Id_Valid
            (+(W_Declaration_Valid_OId (Declarations (J)))));
         Append
           (Result.F_Declarations,
            +(W_Declaration_Valid_OId (Declarations (J))));
      end loop;
      Set_Link (Result.F_Declarations, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_File_Id (New_Id);
   end New_File;
   ------------------------
   -- New_Global_Binding --
   ------------------------

   function New_Global_Binding
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id;
      Binders  : W_Binder_Array := (2 .. 1 => <>);
      Pre      : W_Precondition_Id;
      Def      : W_Prog_Id)
     return W_Global_Binding_Id
   is
      Result : Why_Node (W_Global_Binding);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Global_Binding);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.GB_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.GB_Name, New_Id);
      Result.GB_Binders := New_List;
      for J in Binders'Range loop
         pragma Assert
           (Binder_Id_Kind_Valid
            (+(W_Binder_Valid_OId (Binders (J)))));
         pragma Assert
           (Binder_Id_Valid
            (+(W_Binder_Valid_OId (Binders (J)))));
         Append
           (Result.GB_Binders,
            +(W_Binder_Valid_OId (Binders (J))));
      end loop;
      Set_Link (Result.GB_Binders, New_Id);
      Result.GB_Pre :=
        +(W_Precondition_Valid_Id (Pre));
      Set_Link (Result.GB_Pre, New_Id);
      Result.GB_Def :=
        +(W_Prog_Valid_Id (Def));
      Set_Link (Result.GB_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Global_Binding_Id (New_Id);
   end New_Global_Binding;

   ------------------------
   -- New_Global_Binding --
   ------------------------

   function New_Global_Binding
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id;
      Binders  : W_Binder_Array := (2 .. 1 => <>);
      Pre      : W_Precondition_Id;
      Def      : W_Prog_Id)
     return W_Declaration_Id
   is
      Result : Why_Node (W_Global_Binding);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Global_Binding);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.GB_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.GB_Name, New_Id);
      Result.GB_Binders := New_List;
      for J in Binders'Range loop
         pragma Assert
           (Binder_Id_Kind_Valid
            (+(W_Binder_Valid_OId (Binders (J)))));
         pragma Assert
           (Binder_Id_Valid
            (+(W_Binder_Valid_OId (Binders (J)))));
         Append
           (Result.GB_Binders,
            +(W_Binder_Valid_OId (Binders (J))));
      end loop;
      Set_Link (Result.GB_Binders, New_Id);
      Result.GB_Pre :=
        +(W_Precondition_Valid_Id (Pre));
      Set_Link (Result.GB_Pre, New_Id);
      Result.GB_Def :=
        +(W_Prog_Valid_Id (Def));
      Set_Link (Result.GB_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Declaration_Id (New_Id);
   end New_Global_Binding;
   ----------------------------
   -- New_Global_Rec_Binding --
   ----------------------------

   function New_Global_Rec_Binding
     (Ada_Node : Node_Id := Empty;
      Name     : W_Recfun_Id)
     return W_Global_Rec_Binding_Id
   is
      Result : Why_Node (W_Global_Rec_Binding);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Global_Rec_Binding);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.GRB_Name :=
        +(W_Recfun_Valid_Id (Name));
      Set_Link (Result.GRB_Name, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Global_Rec_Binding_Id (New_Id);
   end New_Global_Rec_Binding;

   ----------------------------
   -- New_Global_Rec_Binding --
   ----------------------------

   function New_Global_Rec_Binding
     (Ada_Node : Node_Id := Empty;
      Name     : W_Recfun_Id)
     return W_Declaration_Id
   is
      Result : Why_Node (W_Global_Rec_Binding);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Global_Rec_Binding);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.GRB_Name :=
        +(W_Recfun_Valid_Id (Name));
      Set_Link (Result.GRB_Name, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Declaration_Id (New_Id);
   end New_Global_Rec_Binding;
   -------------------------------
   -- New_Parameter_Declaration --
   -------------------------------

   function New_Parameter_Declaration
     (Ada_Node       : Node_Id := Empty;
      External       : W_External_OId := Why_Empty;
      Names          : W_Identifier_Array;
      Parameter_Type : W_Computation_Type_Id)
     return W_Parameter_Declaration_Id
   is
      Result : Why_Node (W_Parameter_Declaration);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Parameter_Declaration);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.PD_External :=
        +(W_External_Valid_OId (External));
      Set_Link (Result.PD_External, New_Id);
      pragma Assert (Names'Length > 0);
      Result.PD_Names := New_List;
      for J in Names'Range loop
         pragma Assert
           (Identifier_Id_Kind_Valid
            (+(W_Identifier_Valid_Id (Names (J)))));
         pragma Assert
           (Identifier_Id_Valid
            (+(W_Identifier_Valid_Id (Names (J)))));
         Append
           (Result.PD_Names,
            +(W_Identifier_Valid_Id (Names (J))));
      end loop;
      Set_Link (Result.PD_Names, New_Id);
      Result.PD_Parameter_Type :=
        +(W_Computation_Type_Valid_Id (Parameter_Type));
      Set_Link (Result.PD_Parameter_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Parameter_Declaration_Id (New_Id);
   end New_Parameter_Declaration;

   -------------------------------
   -- New_Parameter_Declaration --
   -------------------------------

   function New_Parameter_Declaration
     (Ada_Node       : Node_Id := Empty;
      External       : W_External_OId := Why_Empty;
      Names          : W_Identifier_Array;
      Parameter_Type : W_Computation_Type_Id)
     return W_Declaration_Id
   is
      Result : Why_Node (W_Parameter_Declaration);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Parameter_Declaration);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.PD_External :=
        +(W_External_Valid_OId (External));
      Set_Link (Result.PD_External, New_Id);
      pragma Assert (Names'Length > 0);
      Result.PD_Names := New_List;
      for J in Names'Range loop
         pragma Assert
           (Identifier_Id_Kind_Valid
            (+(W_Identifier_Valid_Id (Names (J)))));
         pragma Assert
           (Identifier_Id_Valid
            (+(W_Identifier_Valid_Id (Names (J)))));
         Append
           (Result.PD_Names,
            +(W_Identifier_Valid_Id (Names (J))));
      end loop;
      Set_Link (Result.PD_Names, New_Id);
      Result.PD_Parameter_Type :=
        +(W_Computation_Type_Valid_Id (Parameter_Type));
      Set_Link (Result.PD_Parameter_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Declaration_Id (New_Id);
   end New_Parameter_Declaration;
   --------------------------------
   -- New_Global_Ref_Declaration --
   --------------------------------

   function New_Global_Ref_Declaration
     (Ada_Node       : Node_Id := Empty;
      Name           : W_Identifier_Id;
      Parameter_Type : W_Primitive_Type_Id)
     return W_Global_Ref_Declaration_Id
   is
      Result : Why_Node (W_Global_Ref_Declaration);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Global_Ref_Declaration);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.GR_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.GR_Name, New_Id);
      Result.GR_Parameter_Type :=
        +(W_Primitive_Type_Valid_Id (Parameter_Type));
      Set_Link (Result.GR_Parameter_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Global_Ref_Declaration_Id (New_Id);
   end New_Global_Ref_Declaration;

   --------------------------------
   -- New_Global_Ref_Declaration --
   --------------------------------

   function New_Global_Ref_Declaration
     (Ada_Node       : Node_Id := Empty;
      Name           : W_Identifier_Id;
      Parameter_Type : W_Primitive_Type_Id)
     return W_Declaration_Id
   is
      Result : Why_Node (W_Global_Ref_Declaration);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Global_Ref_Declaration);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.GR_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.GR_Name, New_Id);
      Result.GR_Parameter_Type :=
        +(W_Primitive_Type_Valid_Id (Parameter_Type));
      Set_Link (Result.GR_Parameter_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Declaration_Id (New_Id);
   end New_Global_Ref_Declaration;
   -------------------------------
   -- New_Exception_Declaration --
   -------------------------------

   function New_Exception_Declaration
     (Ada_Node  : Node_Id := Empty;
      Name      : W_Identifier_Id;
      Parameter : W_Primitive_Type_OId := Why_Empty)
     return W_Exception_Declaration_Id
   is
      Result : Why_Node (W_Exception_Declaration);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Exception_Declaration);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.ED_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.ED_Name, New_Id);
      Result.ED_Parameter :=
        +(W_Primitive_Type_Valid_OId (Parameter));
      Set_Link (Result.ED_Parameter, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Exception_Declaration_Id (New_Id);
   end New_Exception_Declaration;

   -------------------------------
   -- New_Exception_Declaration --
   -------------------------------

   function New_Exception_Declaration
     (Ada_Node  : Node_Id := Empty;
      Name      : W_Identifier_Id;
      Parameter : W_Primitive_Type_OId := Why_Empty)
     return W_Declaration_Id
   is
      Result : Why_Node (W_Exception_Declaration);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Exception_Declaration);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.ED_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.ED_Name, New_Id);
      Result.ED_Parameter :=
        +(W_Primitive_Type_Valid_OId (Parameter));
      Set_Link (Result.ED_Parameter, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Declaration_Id (New_Id);
   end New_Exception_Declaration;
   ---------------------------
   -- New_Logic_Declaration --
   ---------------------------

   function New_Logic_Declaration
     (Ada_Node : Node_Id := Empty;
      Decl     : W_Logic_Declaration_Class_Id)
     return W_Logic_Declaration_Id
   is
      Result : Why_Node (W_Logic_Declaration);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Logic_Declaration);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.LD_Decl :=
        +(W_Logic_Declaration_Class_Valid_Id (Decl));
      Set_Link (Result.LD_Decl, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Logic_Declaration_Id (New_Id);
   end New_Logic_Declaration;

   ---------------------------
   -- New_Logic_Declaration --
   ---------------------------

   function New_Logic_Declaration
     (Ada_Node : Node_Id := Empty;
      Decl     : W_Logic_Declaration_Class_Id)
     return W_Declaration_Id
   is
      Result : Why_Node (W_Logic_Declaration);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Logic_Declaration);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.LD_Decl :=
        +(W_Logic_Declaration_Class_Valid_Id (Decl));
      Set_Link (Result.LD_Decl, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Declaration_Id (New_Id);
   end New_Logic_Declaration;
   -----------------------------
   -- New_Include_Declaration --
   -----------------------------

   function New_Include_Declaration
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id)
     return W_Include_Declaration_Id
   is
      Result : Why_Node (W_Include_Declaration);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Include_Declaration);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.ID_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.ID_Name, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Include_Declaration_Id (New_Id);
   end New_Include_Declaration;

   -----------------------------
   -- New_Include_Declaration --
   -----------------------------

   function New_Include_Declaration
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id)
     return W_Declaration_Id
   is
      Result : Why_Node (W_Include_Declaration);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Include_Declaration);
   begin
      Result.Ada_Node :=
        Ada_Node;
      Result.ID_Name :=
        +(W_Identifier_Valid_Id (Name));
      Set_Link (Result.ID_Name, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return W_Declaration_Id (New_Id);
   end New_Include_Declaration;

   --------------------
   -- Duplicate_Term --
   --------------------

   function Duplicate_Term
     (Ada_Node : Node_Id := Empty;
      Id       : W_Term_Valid_Id)
     return W_Term_Valid_Id is
   begin
      case Get_Kind (Id) is
         when W_Integer_Constant =>
            return Duplicate_Integer_Constant
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Real_Constant =>
            return Duplicate_Real_Constant
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_True_Literal =>
            return Duplicate_True_Literal
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_False_Literal =>
            return Duplicate_False_Literal
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Void_Literal =>
            return Duplicate_Void_Literal
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Arith_Operation =>
            return Duplicate_Arith_Operation
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Negative_Term =>
            return Duplicate_Negative_Term
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Term_Identifier =>
            return Duplicate_Term_Identifier
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Operation =>
            return Duplicate_Operation
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Named_Term =>
            return Duplicate_Named_Term
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Conditional_Term =>
            return Duplicate_Conditional_Term
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Matching_Term =>
            return Duplicate_Matching_Term
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Binding_Term =>
            return Duplicate_Binding_Term
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Protected_Term =>
            return Duplicate_Protected_Term
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when others =>
            return Why_Empty;
      end case;
   end Duplicate_Term;

   ------------------------
   -- Duplicate_Constant --
   ------------------------

   function Duplicate_Constant
     (Ada_Node : Node_Id := Empty;
      Id       : W_Constant_Valid_Id)
     return W_Constant_Valid_Id is
   begin
      case Get_Kind (Id) is
         when W_Integer_Constant =>
            return Duplicate_Integer_Constant
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Real_Constant =>
            return Duplicate_Real_Constant
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_True_Literal =>
            return Duplicate_True_Literal
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_False_Literal =>
            return Duplicate_False_Literal
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Void_Literal =>
            return Duplicate_Void_Literal
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when others =>
            return Why_Empty;
      end case;
   end Duplicate_Constant;

   ------------------------
   -- Duplicate_Arith_Op --
   ------------------------

   function Duplicate_Arith_Op
     (Ada_Node : Node_Id := Empty;
      Id       : W_Arith_Op_Valid_Id)
     return W_Arith_Op_Valid_Id is
   begin
      case Get_Kind (Id) is
         when W_Op_Add =>
            return Duplicate_Op_Add
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Op_Substract =>
            return Duplicate_Op_Substract
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Op_Multiply =>
            return Duplicate_Op_Multiply
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Op_Divide =>
            return Duplicate_Op_Divide
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Op_Modulo =>
            return Duplicate_Op_Modulo
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when others =>
            return Why_Empty;
      end case;
   end Duplicate_Arith_Op;

   -------------------------
   -- Duplicate_Predicate --
   -------------------------

   function Duplicate_Predicate
     (Ada_Node : Node_Id := Empty;
      Id       : W_Predicate_Valid_Id)
     return W_Predicate_Valid_Id is
   begin
      case Get_Kind (Id) is
         when W_True_Literal_Pred =>
            return Duplicate_True_Literal_Pred
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_False_Literal_Pred =>
            return Duplicate_False_Literal_Pred
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Predicate_Identifier =>
            return Duplicate_Predicate_Identifier
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Predicate_Instance =>
            return Duplicate_Predicate_Instance
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Related_Terms =>
            return Duplicate_Related_Terms
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Implication =>
            return Duplicate_Implication
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Equivalence =>
            return Duplicate_Equivalence
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Disjunction =>
            return Duplicate_Disjunction
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Conjunction =>
            return Duplicate_Conjunction
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Negation =>
            return Duplicate_Negation
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Conditional_Pred =>
            return Duplicate_Conditional_Pred
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Binding_Pred =>
            return Duplicate_Binding_Pred
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Universal_Quantif =>
            return Duplicate_Universal_Quantif
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Existential_Quantif =>
            return Duplicate_Existential_Quantif
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Named_Predicate =>
            return Duplicate_Named_Predicate
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Protected_Predicate =>
            return Duplicate_Protected_Predicate
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when others =>
            return Why_Empty;
      end case;
   end Duplicate_Predicate;

   ------------------------------
   -- Duplicate_Primitive_Type --
   ------------------------------

   function Duplicate_Primitive_Type
     (Ada_Node : Node_Id := Empty;
      Id       : W_Primitive_Type_Valid_Id)
     return W_Primitive_Type_Valid_Id is
   begin
      case Get_Kind (Id) is
         when W_Type_Int =>
            return Duplicate_Type_Int
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Type_Bool =>
            return Duplicate_Type_Bool
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Type_Real =>
            return Duplicate_Type_Real
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Type_Unit =>
            return Duplicate_Type_Unit
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Abstract_Type =>
            return Duplicate_Abstract_Type
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Generic_Formal_Type =>
            return Duplicate_Generic_Formal_Type
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Generic_Actual_Type_Chain =>
            return Duplicate_Generic_Actual_Type_Chain
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when others =>
            return Why_Empty;
      end case;
   end Duplicate_Primitive_Type;

   ------------------------
   -- Duplicate_Relation --
   ------------------------

   function Duplicate_Relation
     (Ada_Node : Node_Id := Empty;
      Id       : W_Relation_Valid_Id)
     return W_Relation_Valid_Id is
   begin
      case Get_Kind (Id) is
         when W_Rel_Eq =>
            return Duplicate_Rel_Eq
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Rel_Ne =>
            return Duplicate_Rel_Ne
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Rel_Lt =>
            return Duplicate_Rel_Lt
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Rel_Le =>
            return Duplicate_Rel_Le
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Rel_Gt =>
            return Duplicate_Rel_Gt
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Rel_Ge =>
            return Duplicate_Rel_Ge
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when others =>
            return Why_Empty;
      end case;
   end Duplicate_Relation;

   ---------------------------------------
   -- Duplicate_Logic_Declaration_Class --
   ---------------------------------------

   function Duplicate_Logic_Declaration_Class
     (Ada_Node : Node_Id := Empty;
      Id       : W_Logic_Declaration_Class_Valid_Id)
     return W_Logic_Declaration_Class_Valid_Id is
   begin
      case Get_Kind (Id) is
         when W_Type =>
            return Duplicate_Type
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Logic =>
            return Duplicate_Logic
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Function =>
            return Duplicate_Function
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Predicate_Definition =>
            return Duplicate_Predicate_Definition
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Inductive =>
            return Duplicate_Inductive
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Axiom =>
            return Duplicate_Axiom
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Goal =>
            return Duplicate_Goal
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when others =>
            return Why_Empty;
      end case;
   end Duplicate_Logic_Declaration_Class;

   ---------------------------------
   -- Duplicate_Logic_Return_Type --
   ---------------------------------

   function Duplicate_Logic_Return_Type
     (Ada_Node : Node_Id := Empty;
      Id       : W_Logic_Return_Type_Valid_Id)
     return W_Logic_Return_Type_Valid_Id is
   begin
      case Get_Kind (Id) is
         when W_Type_Prop =>
            return Duplicate_Type_Prop
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Type_Int =>
            return Duplicate_Type_Int
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Type_Bool =>
            return Duplicate_Type_Bool
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Type_Real =>
            return Duplicate_Type_Real
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Type_Unit =>
            return Duplicate_Type_Unit
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Abstract_Type =>
            return Duplicate_Abstract_Type
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Generic_Formal_Type =>
            return Duplicate_Generic_Formal_Type
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Generic_Actual_Type_Chain =>
            return Duplicate_Generic_Actual_Type_Chain
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when others =>
            return Why_Empty;
      end case;
   end Duplicate_Logic_Return_Type;

   ------------------------------
   -- Duplicate_Logic_Arg_Type --
   ------------------------------

   function Duplicate_Logic_Arg_Type
     (Ada_Node : Node_Id := Empty;
      Id       : W_Logic_Arg_Type_Valid_Id)
     return W_Logic_Arg_Type_Valid_Id is
   begin
      case Get_Kind (Id) is
         when W_Type_Int =>
            return Duplicate_Type_Int
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Type_Bool =>
            return Duplicate_Type_Bool
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Type_Real =>
            return Duplicate_Type_Real
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Type_Unit =>
            return Duplicate_Type_Unit
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Abstract_Type =>
            return Duplicate_Abstract_Type
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Generic_Formal_Type =>
            return Duplicate_Generic_Formal_Type
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Generic_Actual_Type_Chain =>
            return Duplicate_Generic_Actual_Type_Chain
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Array_Type =>
            return Duplicate_Array_Type
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when others =>
            return Why_Empty;
      end case;
   end Duplicate_Logic_Arg_Type;

   ---------------------------------
   -- Duplicate_Simple_Value_Type --
   ---------------------------------

   function Duplicate_Simple_Value_Type
     (Ada_Node : Node_Id := Empty;
      Id       : W_Simple_Value_Type_Valid_Id)
     return W_Simple_Value_Type_Valid_Id is
   begin
      case Get_Kind (Id) is
         when W_Type_Int =>
            return Duplicate_Type_Int
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Type_Bool =>
            return Duplicate_Type_Bool
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Type_Real =>
            return Duplicate_Type_Real
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Type_Unit =>
            return Duplicate_Type_Unit
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Abstract_Type =>
            return Duplicate_Abstract_Type
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Generic_Formal_Type =>
            return Duplicate_Generic_Formal_Type
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Generic_Actual_Type_Chain =>
            return Duplicate_Generic_Actual_Type_Chain
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Array_Type =>
            return Duplicate_Array_Type
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Ref_Type =>
            return Duplicate_Ref_Type
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when others =>
            return Why_Empty;
      end case;
   end Duplicate_Simple_Value_Type;

   --------------------
   -- Duplicate_Prog --
   --------------------

   function Duplicate_Prog
     (Ada_Node : Node_Id := Empty;
      Id       : W_Prog_Valid_Id)
     return W_Prog_Valid_Id is
   begin
      case Get_Kind (Id) is
         when W_Prog_Constant =>
            return Duplicate_Prog_Constant
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Prog_Identifier =>
            return Duplicate_Prog_Identifier
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Any_Expr =>
            return Duplicate_Any_Expr
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Deref =>
            return Duplicate_Deref
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Assignment =>
            return Duplicate_Assignment
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Array_Access =>
            return Duplicate_Array_Access
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Array_Update =>
            return Duplicate_Array_Update
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Infix_Call =>
            return Duplicate_Infix_Call
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Prefix_Call =>
            return Duplicate_Prefix_Call
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Binding_Prog =>
            return Duplicate_Binding_Prog
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Binding_Ref =>
            return Duplicate_Binding_Ref
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Conditional_Prog =>
            return Duplicate_Conditional_Prog
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_While_Loop =>
            return Duplicate_While_Loop
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Statement_Sequence =>
            return Duplicate_Statement_Sequence
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Label =>
            return Duplicate_Label
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Assert =>
            return Duplicate_Assert
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Post_Assertion =>
            return Duplicate_Post_Assertion
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Opaque_Assertion =>
            return Duplicate_Opaque_Assertion
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Fun_Def =>
            return Duplicate_Fun_Def
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Binding_Fun =>
            return Duplicate_Binding_Fun
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Binding_Rec =>
            return Duplicate_Binding_Rec
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Prog_Call =>
            return Duplicate_Prog_Call
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Raise_Statement =>
            return Duplicate_Raise_Statement
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Raise_Statement_With_Parameters =>
            return Duplicate_Raise_Statement_With_Parameters
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Try_Block =>
            return Duplicate_Try_Block
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Unreachable_Code =>
            return Duplicate_Unreachable_Code
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Begin_Block =>
            return Duplicate_Begin_Block
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Protected_Prog =>
            return Duplicate_Protected_Prog
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when others =>
            return Why_Empty;
      end case;
   end Duplicate_Prog;

   ---------------------
   -- Duplicate_Infix --
   ---------------------

   function Duplicate_Infix
     (Ada_Node : Node_Id := Empty;
      Id       : W_Infix_Valid_Id)
     return W_Infix_Valid_Id is
   begin
      case Get_Kind (Id) is
         when W_Op_Add_Prog =>
            return Duplicate_Op_Add_Prog
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Op_Substract_Prog =>
            return Duplicate_Op_Substract_Prog
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Op_Multiply_Prog =>
            return Duplicate_Op_Multiply_Prog
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Op_Divide_Prog =>
            return Duplicate_Op_Divide_Prog
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Op_Mod_Prog =>
            return Duplicate_Op_Mod_Prog
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Op_Eq_Prog =>
            return Duplicate_Op_Eq_Prog
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Op_Ne_Prog =>
            return Duplicate_Op_Ne_Prog
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Op_Lt_Prog =>
            return Duplicate_Op_Lt_Prog
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Op_Le_Prog =>
            return Duplicate_Op_Le_Prog
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Op_Gt_Prog =>
            return Duplicate_Op_Gt_Prog
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Op_Ge_Prog =>
            return Duplicate_Op_Ge_Prog
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Op_Or_Else_Prog =>
            return Duplicate_Op_Or_Else_Prog
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Op_And_Then_Prog =>
            return Duplicate_Op_And_Then_Prog
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when others =>
            return Why_Empty;
      end case;
   end Duplicate_Infix;

   ----------------------
   -- Duplicate_Prefix --
   ----------------------

   function Duplicate_Prefix
     (Ada_Node : Node_Id := Empty;
      Id       : W_Prefix_Valid_Id)
     return W_Prefix_Valid_Id is
   begin
      case Get_Kind (Id) is
         when W_Op_Minus_Prog =>
            return Duplicate_Op_Minus_Prog
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Op_Not_Prog =>
            return Duplicate_Op_Not_Prog
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when others =>
            return Why_Empty;
      end case;
   end Duplicate_Prefix;

   ---------------------------
   -- Duplicate_Declaration --
   ---------------------------

   function Duplicate_Declaration
     (Ada_Node : Node_Id := Empty;
      Id       : W_Declaration_Valid_Id)
     return W_Declaration_Valid_Id is
   begin
      case Get_Kind (Id) is
         when W_Global_Binding =>
            return Duplicate_Global_Binding
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Global_Rec_Binding =>
            return Duplicate_Global_Rec_Binding
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Parameter_Declaration =>
            return Duplicate_Parameter_Declaration
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Global_Ref_Declaration =>
            return Duplicate_Global_Ref_Declaration
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Exception_Declaration =>
            return Duplicate_Exception_Declaration
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Logic_Declaration =>
            return Duplicate_Logic_Declaration
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Include_Declaration =>
            return Duplicate_Include_Declaration
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when others =>
            return Why_Empty;
      end case;
   end Duplicate_Declaration;

   ------------------------
   -- Duplicate_Any_Node --
   ------------------------

   function Duplicate_Any_Node
     (Ada_Node : Node_Id := Empty;
      Id       : W_Any_Node_Valid_Id)
     return W_Any_Node_Valid_Id is
   begin
      case Get_Kind (Id) is
         when W_Identifier =>
            return Duplicate_Identifier
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Type_Prop =>
            return Duplicate_Type_Prop
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Type_Int =>
            return Duplicate_Type_Int
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Type_Bool =>
            return Duplicate_Type_Bool
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Type_Real =>
            return Duplicate_Type_Real
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Type_Unit =>
            return Duplicate_Type_Unit
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Abstract_Type =>
            return Duplicate_Abstract_Type
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Generic_Formal_Type =>
            return Duplicate_Generic_Formal_Type
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Generic_Actual_Type_Chain =>
            return Duplicate_Generic_Actual_Type_Chain
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Array_Type =>
            return Duplicate_Array_Type
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Ref_Type =>
            return Duplicate_Ref_Type
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Computation_Type =>
            return Duplicate_Computation_Type
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Integer_Constant =>
            return Duplicate_Integer_Constant
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Real_Constant =>
            return Duplicate_Real_Constant
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_True_Literal =>
            return Duplicate_True_Literal
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_False_Literal =>
            return Duplicate_False_Literal
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Void_Literal =>
            return Duplicate_Void_Literal
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Arith_Operation =>
            return Duplicate_Arith_Operation
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Negative_Term =>
            return Duplicate_Negative_Term
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Term_Identifier =>
            return Duplicate_Term_Identifier
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Operation =>
            return Duplicate_Operation
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Named_Term =>
            return Duplicate_Named_Term
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Conditional_Term =>
            return Duplicate_Conditional_Term
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Matching_Term =>
            return Duplicate_Matching_Term
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Binding_Term =>
            return Duplicate_Binding_Term
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Protected_Term =>
            return Duplicate_Protected_Term
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Op_Add =>
            return Duplicate_Op_Add
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Op_Substract =>
            return Duplicate_Op_Substract
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Op_Multiply =>
            return Duplicate_Op_Multiply
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Op_Divide =>
            return Duplicate_Op_Divide
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Op_Modulo =>
            return Duplicate_Op_Modulo
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_True_Literal_Pred =>
            return Duplicate_True_Literal_Pred
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_False_Literal_Pred =>
            return Duplicate_False_Literal_Pred
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Predicate_Identifier =>
            return Duplicate_Predicate_Identifier
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Predicate_Instance =>
            return Duplicate_Predicate_Instance
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Related_Terms =>
            return Duplicate_Related_Terms
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Implication =>
            return Duplicate_Implication
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Equivalence =>
            return Duplicate_Equivalence
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Disjunction =>
            return Duplicate_Disjunction
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Conjunction =>
            return Duplicate_Conjunction
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Negation =>
            return Duplicate_Negation
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Conditional_Pred =>
            return Duplicate_Conditional_Pred
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Binding_Pred =>
            return Duplicate_Binding_Pred
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Universal_Quantif =>
            return Duplicate_Universal_Quantif
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Existential_Quantif =>
            return Duplicate_Existential_Quantif
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Named_Predicate =>
            return Duplicate_Named_Predicate
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Protected_Predicate =>
            return Duplicate_Protected_Predicate
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Pattern =>
            return Duplicate_Pattern
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Match_Case =>
            return Duplicate_Match_Case
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Triggers =>
            return Duplicate_Triggers
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Trigger =>
            return Duplicate_Trigger
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Rel_Eq =>
            return Duplicate_Rel_Eq
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Rel_Ne =>
            return Duplicate_Rel_Ne
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Rel_Lt =>
            return Duplicate_Rel_Lt
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Rel_Le =>
            return Duplicate_Rel_Le
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Rel_Gt =>
            return Duplicate_Rel_Gt
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Rel_Ge =>
            return Duplicate_Rel_Ge
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Type =>
            return Duplicate_Type
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Logic =>
            return Duplicate_Logic
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Function =>
            return Duplicate_Function
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Predicate_Definition =>
            return Duplicate_Predicate_Definition
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Inductive =>
            return Duplicate_Inductive
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Axiom =>
            return Duplicate_Axiom
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Goal =>
            return Duplicate_Goal
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_External =>
            return Duplicate_External
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Logic_Type =>
            return Duplicate_Logic_Type
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Logic_Binder =>
            return Duplicate_Logic_Binder
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Inductive_Case =>
            return Duplicate_Inductive_Case
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Transparent_Type_Definition =>
            return Duplicate_Transparent_Type_Definition
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Adt_Definition =>
            return Duplicate_Adt_Definition
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Constr_Decl =>
            return Duplicate_Constr_Decl
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Effects =>
            return Duplicate_Effects
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Precondition =>
            return Duplicate_Precondition
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Postcondition =>
            return Duplicate_Postcondition
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Exn_Condition =>
            return Duplicate_Exn_Condition
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Prog_Constant =>
            return Duplicate_Prog_Constant
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Prog_Identifier =>
            return Duplicate_Prog_Identifier
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Any_Expr =>
            return Duplicate_Any_Expr
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Deref =>
            return Duplicate_Deref
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Assignment =>
            return Duplicate_Assignment
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Array_Access =>
            return Duplicate_Array_Access
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Array_Update =>
            return Duplicate_Array_Update
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Infix_Call =>
            return Duplicate_Infix_Call
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Prefix_Call =>
            return Duplicate_Prefix_Call
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Binding_Prog =>
            return Duplicate_Binding_Prog
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Binding_Ref =>
            return Duplicate_Binding_Ref
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Conditional_Prog =>
            return Duplicate_Conditional_Prog
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_While_Loop =>
            return Duplicate_While_Loop
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Statement_Sequence =>
            return Duplicate_Statement_Sequence
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Label =>
            return Duplicate_Label
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Assert =>
            return Duplicate_Assert
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Post_Assertion =>
            return Duplicate_Post_Assertion
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Opaque_Assertion =>
            return Duplicate_Opaque_Assertion
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Fun_Def =>
            return Duplicate_Fun_Def
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Binding_Fun =>
            return Duplicate_Binding_Fun
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Binding_Rec =>
            return Duplicate_Binding_Rec
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Prog_Call =>
            return Duplicate_Prog_Call
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Raise_Statement =>
            return Duplicate_Raise_Statement
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Raise_Statement_With_Parameters =>
            return Duplicate_Raise_Statement_With_Parameters
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Try_Block =>
            return Duplicate_Try_Block
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Unreachable_Code =>
            return Duplicate_Unreachable_Code
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Begin_Block =>
            return Duplicate_Begin_Block
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Protected_Prog =>
            return Duplicate_Protected_Prog
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Op_Add_Prog =>
            return Duplicate_Op_Add_Prog
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Op_Substract_Prog =>
            return Duplicate_Op_Substract_Prog
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Op_Multiply_Prog =>
            return Duplicate_Op_Multiply_Prog
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Op_Divide_Prog =>
            return Duplicate_Op_Divide_Prog
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Op_Mod_Prog =>
            return Duplicate_Op_Mod_Prog
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Op_Eq_Prog =>
            return Duplicate_Op_Eq_Prog
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Op_Ne_Prog =>
            return Duplicate_Op_Ne_Prog
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Op_Lt_Prog =>
            return Duplicate_Op_Lt_Prog
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Op_Le_Prog =>
            return Duplicate_Op_Le_Prog
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Op_Gt_Prog =>
            return Duplicate_Op_Gt_Prog
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Op_Ge_Prog =>
            return Duplicate_Op_Ge_Prog
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Op_Or_Else_Prog =>
            return Duplicate_Op_Or_Else_Prog
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Op_And_Then_Prog =>
            return Duplicate_Op_And_Then_Prog
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Op_Minus_Prog =>
            return Duplicate_Op_Minus_Prog
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Op_Not_Prog =>
            return Duplicate_Op_Not_Prog
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Binder =>
            return Duplicate_Binder
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Recfun =>
            return Duplicate_Recfun
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Loop_Annot =>
            return Duplicate_Loop_Annot
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Wf_Arg =>
            return Duplicate_Wf_Arg
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Handler =>
            return Duplicate_Handler
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_File =>
            return Duplicate_File
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Global_Binding =>
            return Duplicate_Global_Binding
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Global_Rec_Binding =>
            return Duplicate_Global_Rec_Binding
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Parameter_Declaration =>
            return Duplicate_Parameter_Declaration
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Global_Ref_Declaration =>
            return Duplicate_Global_Ref_Declaration
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Exception_Declaration =>
            return Duplicate_Exception_Declaration
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Logic_Declaration =>
            return Duplicate_Logic_Declaration
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Include_Declaration =>
            return Duplicate_Include_Declaration
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when others =>
            return Why_Empty;
      end case;
   end Duplicate_Any_Node;

   -------------------------------
   -- Duplicate_Type_Definition --
   -------------------------------

   function Duplicate_Type_Definition
     (Ada_Node : Node_Id := Empty;
      Id       : W_Type_Definition_Valid_Id)
     return W_Type_Definition_Valid_Id is
   begin
      case Get_Kind (Id) is
         when W_Transparent_Type_Definition =>
            return Duplicate_Transparent_Type_Definition
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when W_Adt_Definition =>
            return Duplicate_Adt_Definition
             (Ada_Node  => Ada_Node,
              Id        => Id);
         when others =>
            return Why_Empty;
      end case;
   end Duplicate_Type_Definition;

end Why.Atree.Builders;

------------------------------------------------------------------------------
--                                                                          --
--                            GNAT2WHY COMPONENTS                           --
--                                                                          --
--                   W H Y - A T R E E - B U I L D E R S                    --
--                                                                          --
--                                 B o d y                                  --
--                                                                          --
--                       Copyright (C) 2010-2011, AdaCore                   --
--                                                                          --
-- gnat2why is  free  software;  you can redistribute it and/or modify it   --
-- under terms of the  GNU General Public License as published  by the Free --
-- Software Foundation;  either version  2,  or  (at your option) any later --
-- version. gnat2why is distributed in the hope that it will  be  useful,   --
-- but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHAN-  --
-- TABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public --
-- License  for more details. You  should  have  received a copy of the GNU --
-- General Public License  distributed with GNAT; see file COPYING. If not, --
-- write to the Free Software Foundation,  51 Franklin Street, Fifth Floor, --
-- Boston,                                                                  --
--                                                                          --
-- gnat2why is maintained by AdaCore (http://www.adacore.com)               --
--                                                                          --
------------------------------------------------------------------------------
--  This package is automatically generated by xtree. Do not edit manually.

package body Why.Atree.Builders is

   --------------------
   -- New_Identifier --
   --------------------

   function New_Identifier
     (Ada_Node : Node_Id := Empty;
      Symbol   : Name_Id;
      Entity   : Why_Node_Id := Why_Empty)
     return W_Identifier_Id
   is
      Result : Why_Node (W_Identifier);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Identifier);
   begin
      Result.Ada_Node := Ada_Node;
      Result.Symbol := Symbol;
      Result.Entity := Entity;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Identifier;

   -------------------
   -- New_Type_Prop --
   -------------------

   function New_Type_Prop
     (Ada_Node : Node_Id := Empty)
     return W_Type_Prop_Id
   is
      Result : Why_Node (W_Type_Prop);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Type_Prop);
   begin
      Result.Ada_Node := Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Type_Prop;

   ------------------
   -- New_Type_Int --
   ------------------

   function New_Type_Int
     (Ada_Node : Node_Id := Empty)
     return W_Type_Int_Id
   is
      Result : Why_Node (W_Type_Int);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Type_Int);
   begin
      Result.Ada_Node := Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Type_Int;

   -------------------
   -- New_Type_Bool --
   -------------------

   function New_Type_Bool
     (Ada_Node : Node_Id := Empty)
     return W_Type_Bool_Id
   is
      Result : Why_Node (W_Type_Bool);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Type_Bool);
   begin
      Result.Ada_Node := Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Type_Bool;

   -------------------
   -- New_Type_Real --
   -------------------

   function New_Type_Real
     (Ada_Node : Node_Id := Empty)
     return W_Type_Real_Id
   is
      Result : Why_Node (W_Type_Real);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Type_Real);
   begin
      Result.Ada_Node := Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Type_Real;

   -------------------
   -- New_Type_Unit --
   -------------------

   function New_Type_Unit
     (Ada_Node : Node_Id := Empty)
     return W_Type_Unit_Id
   is
      Result : Why_Node (W_Type_Unit);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Type_Unit);
   begin
      Result.Ada_Node := Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Type_Unit;

   -----------------------
   -- New_Abstract_Type --
   -----------------------

   function New_Abstract_Type
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id)
     return W_Abstract_Type_Id
   is
      Result : Why_Node (W_Abstract_Type);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Abstract_Type);
   begin
      Result.Ada_Node := Ada_Node;
      Result.AT_Name := Name;
      Set_Link (Result.AT_Name, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Abstract_Type;

   -----------------------------
   -- New_Generic_Formal_Type --
   -----------------------------

   function New_Generic_Formal_Type
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id)
     return W_Generic_Formal_Type_Id
   is
      Result : Why_Node (W_Generic_Formal_Type);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Generic_Formal_Type);
   begin
      Result.Ada_Node := Ada_Node;
      Result.GFT_Name := Name;
      Set_Link (Result.GFT_Name, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Generic_Formal_Type;

   -----------------------------------
   -- New_Generic_Actual_Type_Chain --
   -----------------------------------

   function New_Generic_Actual_Type_Chain
     (Ada_Node   : Node_Id := Empty;
      Type_Chain : W_Primitive_Type_Array;
      Name       : W_Identifier_Id)
     return W_Generic_Actual_Type_Chain_Id
   is
      Result : Why_Node (W_Generic_Actual_Type_Chain);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Generic_Actual_Type_Chain);
   begin
      Result.Ada_Node := Ada_Node;
      pragma Assert (Type_Chain'Length > 0);
      Result.GATC_Type_Chain := New_List;
      for J in Type_Chain'Range loop
         pragma Assert
           (Primitive_Type_Id_Kind_Valid
            (Type_Chain (J)));
         pragma Assert
           (Primitive_Type_Id_Valid
            (Type_Chain (J)));
         Append
           (Result.GATC_Type_Chain,
            Type_Chain (J));
      end loop;
      Set_Link (Result.GATC_Type_Chain, New_Id);
      Result.GATC_Name := Name;
      Set_Link (Result.GATC_Name, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Generic_Actual_Type_Chain;

   --------------------
   -- New_Array_Type --
   --------------------

   function New_Array_Type
     (Ada_Node       : Node_Id := Empty;
      Component_Type : W_Primitive_Type_Id)
     return W_Array_Type_Id
   is
      Result : Why_Node (W_Array_Type);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Array_Type);
   begin
      Result.Ada_Node := Ada_Node;
      Result.AT_Component_Type := Component_Type;
      Set_Link (Result.AT_Component_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Array_Type;

   ------------------
   -- New_Ref_Type --
   ------------------

   function New_Ref_Type
     (Ada_Node     : Node_Id := Empty;
      Aliased_Type : W_Primitive_Type_Id)
     return W_Ref_Type_Id
   is
      Result : Why_Node (W_Ref_Type);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Ref_Type);
   begin
      Result.Ada_Node := Ada_Node;
      Result.RT_Aliased_Type := Aliased_Type;
      Set_Link (Result.RT_Aliased_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Ref_Type;

   ------------------------------
   -- New_Protected_Value_Type --
   ------------------------------

   function New_Protected_Value_Type
     (Ada_Node   : Node_Id := Empty;
      Value_Type : W_Value_Type_Id)
     return W_Protected_Value_Type_Id
   is
      Result : Why_Node (W_Protected_Value_Type);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Protected_Value_Type);
   begin
      Result.Ada_Node := Ada_Node;
      Result.PVT_Value_Type := Value_Type;
      Set_Link (Result.PVT_Value_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Protected_Value_Type;

   --------------------
   -- New_Arrow_Type --
   --------------------

   function New_Arrow_Type
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_OId := Why_Empty;
      Left     : W_Simple_Value_Type_Id;
      Right    : W_Computation_Type_Id)
     return W_Arrow_Type_Id
   is
      Result : Why_Node (W_Arrow_Type);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Arrow_Type);
   begin
      Result.Ada_Node := Ada_Node;
      Result.NA_Name := Name;
      Set_Link (Result.NA_Name, New_Id);
      Result.NA_Left := Left;
      Set_Link (Result.NA_Left, New_Id);
      Result.NA_Right := Right;
      Set_Link (Result.NA_Right, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Arrow_Type;

   --------------------------
   -- New_Computation_Spec --
   --------------------------

   function New_Computation_Spec
     (Ada_Node      : Node_Id := Empty;
      Precondition  : W_Precondition_OId := Why_Empty;
      Result_Name   : W_Identifier_OId := Why_Empty;
      Return_Type   : W_Value_Type_Id;
      Effects       : W_Effects_Id;
      Postcondition : W_Postcondition_OId := Why_Empty)
     return W_Computation_Spec_Id
   is
      Result : Why_Node (W_Computation_Spec);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Computation_Spec);
   begin
      Result.Ada_Node := Ada_Node;
      Result.CS_Precondition := Precondition;
      Set_Link (Result.CS_Precondition, New_Id);
      Result.CS_Result_Name := Result_Name;
      Set_Link (Result.CS_Result_Name, New_Id);
      Result.CS_Return_Type := Return_Type;
      Set_Link (Result.CS_Return_Type, New_Id);
      Result.CS_Effects := Effects;
      Set_Link (Result.CS_Effects, New_Id);
      Result.CS_Postcondition := Postcondition;
      Set_Link (Result.CS_Postcondition, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Computation_Spec;

   --------------------------
   -- New_Integer_Constant --
   --------------------------

   function New_Integer_Constant
     (Ada_Node : Node_Id := Empty;
      Value    : Uint)
     return W_Integer_Constant_Id
   is
      Result : Why_Node (W_Integer_Constant);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Integer_Constant);
   begin
      Result.Ada_Node := Ada_Node;
      Result.IC_Value := Value;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Integer_Constant;

   -----------------------
   -- New_Real_Constant --
   -----------------------

   function New_Real_Constant
     (Ada_Node : Node_Id := Empty;
      Value    : Ureal)
     return W_Real_Constant_Id
   is
      Result : Why_Node (W_Real_Constant);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Real_Constant);
   begin
      Result.Ada_Node := Ada_Node;
      Result.RC_Value := Value;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Real_Constant;

   ----------------------
   -- New_True_Literal --
   ----------------------

   function New_True_Literal
     (Ada_Node : Node_Id := Empty)
     return W_True_Literal_Id
   is
      Result : Why_Node (W_True_Literal);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_True_Literal);
   begin
      Result.Ada_Node := Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_True_Literal;

   -----------------------
   -- New_False_Literal --
   -----------------------

   function New_False_Literal
     (Ada_Node : Node_Id := Empty)
     return W_False_Literal_Id
   is
      Result : Why_Node (W_False_Literal);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_False_Literal);
   begin
      Result.Ada_Node := Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_False_Literal;

   ----------------------
   -- New_Void_Literal --
   ----------------------

   function New_Void_Literal
     (Ada_Node : Node_Id := Empty)
     return W_Void_Literal_Id
   is
      Result : Why_Node (W_Void_Literal);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Void_Literal);
   begin
      Result.Ada_Node := Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Void_Literal;

   -------------------------
   -- New_Arith_Operation --
   -------------------------

   function New_Arith_Operation
     (Ada_Node : Node_Id := Empty;
      Left     : W_Term_Id;
      Op       : W_Arith_Op_Id;
      Right    : W_Term_Id)
     return W_Arith_Operation_Id
   is
      Result : Why_Node (W_Arith_Operation);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Arith_Operation);
   begin
      Result.Ada_Node := Ada_Node;
      Result.AO_Left := Left;
      Set_Link (Result.AO_Left, New_Id);
      Result.AO_Op := Op;
      Set_Link (Result.AO_Op, New_Id);
      Result.AO_Right := Right;
      Set_Link (Result.AO_Right, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Arith_Operation;

   -----------------------
   -- New_Negative_Term --
   -----------------------

   function New_Negative_Term
     (Ada_Node : Node_Id := Empty;
      Operand  : W_Term_Id)
     return W_Negative_Term_Id
   is
      Result : Why_Node (W_Negative_Term);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Negative_Term);
   begin
      Result.Ada_Node := Ada_Node;
      Result.NT_Operand := Operand;
      Set_Link (Result.NT_Operand, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Negative_Term;

   --------------------------
   -- New_Label_Identifier --
   --------------------------

   function New_Label_Identifier
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id;
      Label    : W_Identifier_OId := Why_Empty)
     return W_Label_Identifier_Id
   is
      Result : Why_Node (W_Label_Identifier);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Label_Identifier);
   begin
      Result.Ada_Node := Ada_Node;
      Result.TI_Name := Name;
      Set_Link (Result.TI_Name, New_Id);
      Result.TI_Label := Label;
      Set_Link (Result.TI_Label, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Label_Identifier;

   -------------------
   -- New_Operation --
   -------------------

   function New_Operation
     (Ada_Node   : Node_Id := Empty;
      Name       : W_Identifier_Id;
      Parameters : W_Term_Array)
     return W_Operation_Id
   is
      Result : Why_Node (W_Operation);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Operation);
   begin
      Result.Ada_Node := Ada_Node;
      Result.O_Name := Name;
      Set_Link (Result.O_Name, New_Id);
      pragma Assert (Parameters'Length > 0);
      Result.O_Parameters := New_List;
      for J in Parameters'Range loop
         pragma Assert
           (Term_Id_Kind_Valid
            (Parameters (J)));
         pragma Assert
           (Term_Id_Valid
            (Parameters (J)));
         Append
           (Result.O_Parameters,
            Parameters (J));
      end loop;
      Set_Link (Result.O_Parameters, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Operation;

   --------------------
   -- New_Named_Term --
   --------------------

   function New_Named_Term
     (Ada_Node : Node_Id := Empty;
      Name     : W_Label_Identifier_Id;
      Term     : W_Term_Id)
     return W_Named_Term_Id
   is
      Result : Why_Node (W_Named_Term);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Named_Term);
   begin
      Result.Ada_Node := Ada_Node;
      Result.NT_Name := Name;
      Set_Link (Result.NT_Name, New_Id);
      Result.NT_Term := Term;
      Set_Link (Result.NT_Term, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Named_Term;

   --------------------------
   -- New_Conditional_Term --
   --------------------------

   function New_Conditional_Term
     (Ada_Node  : Node_Id := Empty;
      Condition : W_Term_Id;
      Then_Part : W_Term_Id;
      Else_Part : W_Term_Id)
     return W_Conditional_Term_Id
   is
      Result : Why_Node (W_Conditional_Term);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Conditional_Term);
   begin
      Result.Ada_Node := Ada_Node;
      Result.CT_Condition := Condition;
      Set_Link (Result.CT_Condition, New_Id);
      Result.CT_Then_Part := Then_Part;
      Set_Link (Result.CT_Then_Part, New_Id);
      Result.CT_Else_Part := Else_Part;
      Set_Link (Result.CT_Else_Part, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Conditional_Term;

   -----------------------
   -- New_Matching_Term --
   -----------------------

   function New_Matching_Term
     (Ada_Node : Node_Id := Empty;
      Term     : W_Term_Id;
      Branches : W_Match_Case_Array)
     return W_Matching_Term_Id
   is
      Result : Why_Node (W_Matching_Term);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Matching_Term);
   begin
      Result.Ada_Node := Ada_Node;
      Result.MT_Term := Term;
      Set_Link (Result.MT_Term, New_Id);
      pragma Assert (Branches'Length > 0);
      Result.MT_Branches := New_List;
      for J in Branches'Range loop
         pragma Assert
           (Match_Case_Id_Kind_Valid
            (Branches (J)));
         pragma Assert
           (Match_Case_Id_Valid
            (Branches (J)));
         Append
           (Result.MT_Branches,
            Branches (J));
      end loop;
      Set_Link (Result.MT_Branches, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Matching_Term;

   ----------------------
   -- New_Binding_Term --
   ----------------------

   function New_Binding_Term
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id;
      Def      : W_Term_Id;
      Context  : W_Term_Id)
     return W_Binding_Term_Id
   is
      Result : Why_Node (W_Binding_Term);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Binding_Term);
   begin
      Result.Ada_Node := Ada_Node;
      Result.BT_Name := Name;
      Set_Link (Result.BT_Name, New_Id);
      Result.BT_Def := Def;
      Set_Link (Result.BT_Def, New_Id);
      Result.BT_Context := Context;
      Set_Link (Result.BT_Context, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Binding_Term;

   ------------------------
   -- New_Protected_Term --
   ------------------------

   function New_Protected_Term
     (Ada_Node : Node_Id := Empty;
      Term     : W_Term_Id)
     return W_Protected_Term_Id
   is
      Result : Why_Node (W_Protected_Term);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Protected_Term);
   begin
      Result.Ada_Node := Ada_Node;
      Result.BT_Term := Term;
      Set_Link (Result.BT_Term, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Protected_Term;

   ----------------
   -- New_Op_Add --
   ----------------

   function New_Op_Add
     (Ada_Node : Node_Id := Empty)
     return W_Op_Add_Id
   is
      Result : Why_Node (W_Op_Add);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Add);
   begin
      Result.Ada_Node := Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Op_Add;

   ----------------------
   -- New_Op_Substract --
   ----------------------

   function New_Op_Substract
     (Ada_Node : Node_Id := Empty)
     return W_Op_Substract_Id
   is
      Result : Why_Node (W_Op_Substract);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Substract);
   begin
      Result.Ada_Node := Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Op_Substract;

   ---------------------
   -- New_Op_Multiply --
   ---------------------

   function New_Op_Multiply
     (Ada_Node : Node_Id := Empty)
     return W_Op_Multiply_Id
   is
      Result : Why_Node (W_Op_Multiply);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Multiply);
   begin
      Result.Ada_Node := Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Op_Multiply;

   -------------------
   -- New_Op_Divide --
   -------------------

   function New_Op_Divide
     (Ada_Node : Node_Id := Empty)
     return W_Op_Divide_Id
   is
      Result : Why_Node (W_Op_Divide);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Divide);
   begin
      Result.Ada_Node := Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Op_Divide;

   -------------------
   -- New_Op_Modulo --
   -------------------

   function New_Op_Modulo
     (Ada_Node : Node_Id := Empty)
     return W_Op_Modulo_Id
   is
      Result : Why_Node (W_Op_Modulo);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Modulo);
   begin
      Result.Ada_Node := Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Op_Modulo;

   ---------------------------
   -- New_True_Literal_Pred --
   ---------------------------

   function New_True_Literal_Pred
     (Ada_Node : Node_Id := Empty)
     return W_True_Literal_Pred_Id
   is
      Result : Why_Node (W_True_Literal_Pred);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_True_Literal_Pred);
   begin
      Result.Ada_Node := Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_True_Literal_Pred;

   ----------------------------
   -- New_False_Literal_Pred --
   ----------------------------

   function New_False_Literal_Pred
     (Ada_Node : Node_Id := Empty)
     return W_False_Literal_Pred_Id
   is
      Result : Why_Node (W_False_Literal_Pred);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_False_Literal_Pred);
   begin
      Result.Ada_Node := Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_False_Literal_Pred;

   ------------------------------
   -- New_Predicate_Identifier --
   ------------------------------

   function New_Predicate_Identifier
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id)
     return W_Predicate_Identifier_Id
   is
      Result : Why_Node (W_Predicate_Identifier);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Predicate_Identifier);
   begin
      Result.Ada_Node := Ada_Node;
      Result.PID_Name := Name;
      Set_Link (Result.PID_Name, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Predicate_Identifier;

   ----------------------------
   -- New_Predicate_Instance --
   ----------------------------

   function New_Predicate_Instance
     (Ada_Node   : Node_Id := Empty;
      Name       : W_Identifier_Id;
      Parameters : W_Term_Array)
     return W_Predicate_Instance_Id
   is
      Result : Why_Node (W_Predicate_Instance);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Predicate_Instance);
   begin
      Result.Ada_Node := Ada_Node;
      Result.PIN_Name := Name;
      Set_Link (Result.PIN_Name, New_Id);
      pragma Assert (Parameters'Length > 0);
      Result.PIN_Parameters := New_List;
      for J in Parameters'Range loop
         pragma Assert
           (Term_Id_Kind_Valid
            (Parameters (J)));
         pragma Assert
           (Term_Id_Valid
            (Parameters (J)));
         Append
           (Result.PIN_Parameters,
            Parameters (J));
      end loop;
      Set_Link (Result.PIN_Parameters, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Predicate_Instance;

   -----------------------
   -- New_Related_Terms --
   -----------------------

   function New_Related_Terms
     (Ada_Node : Node_Id := Empty;
      Left     : W_Term_Id;
      Op       : W_Relation_Id;
      Right    : W_Term_Id;
      Op2      : W_Relation_OId := Why_Empty;
      Right2   : W_Term_OId := Why_Empty)
     return W_Related_Terms_Id
   is
      Result : Why_Node (W_Related_Terms);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Related_Terms);
   begin
      Result.Ada_Node := Ada_Node;
      Result.RT_Left := Left;
      Set_Link (Result.RT_Left, New_Id);
      Result.RT_Op := Op;
      Set_Link (Result.RT_Op, New_Id);
      Result.RT_Right := Right;
      Set_Link (Result.RT_Right, New_Id);
      Result.RT_Op2 := Op2;
      Set_Link (Result.RT_Op2, New_Id);
      Result.RT_Right2 := Right2;
      Set_Link (Result.RT_Right2, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Related_Terms;

   ---------------------
   -- New_Implication --
   ---------------------

   function New_Implication
     (Ada_Node : Node_Id := Empty;
      Left     : W_Predicate_Id;
      Right    : W_Predicate_Id)
     return W_Implication_Id
   is
      Result : Why_Node (W_Implication);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Implication);
   begin
      Result.Ada_Node := Ada_Node;
      Result.ITOC_Left := Left;
      Set_Link (Result.ITOC_Left, New_Id);
      Result.ITOC_Right := Right;
      Set_Link (Result.ITOC_Right, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Implication;

   ---------------------
   -- New_Equivalence --
   ---------------------

   function New_Equivalence
     (Ada_Node : Node_Id := Empty;
      Left     : W_Predicate_Id;
      Right    : W_Predicate_Id)
     return W_Equivalence_Id
   is
      Result : Why_Node (W_Equivalence);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Equivalence);
   begin
      Result.Ada_Node := Ada_Node;
      Result.ITOC_Left := Left;
      Set_Link (Result.ITOC_Left, New_Id);
      Result.ITOC_Right := Right;
      Set_Link (Result.ITOC_Right, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Equivalence;

   ---------------------
   -- New_Disjonction --
   ---------------------

   function New_Disjonction
     (Ada_Node : Node_Id := Empty;
      Left     : W_Predicate_Id;
      Right    : W_Predicate_Id)
     return W_Disjonction_Id
   is
      Result : Why_Node (W_Disjonction);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Disjonction);
   begin
      Result.Ada_Node := Ada_Node;
      Result.ITOC_Left := Left;
      Set_Link (Result.ITOC_Left, New_Id);
      Result.ITOC_Right := Right;
      Set_Link (Result.ITOC_Right, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Disjonction;

   ---------------------
   -- New_Conjonction --
   ---------------------

   function New_Conjonction
     (Ada_Node : Node_Id := Empty;
      Left     : W_Predicate_Id;
      Right    : W_Predicate_Id)
     return W_Conjonction_Id
   is
      Result : Why_Node (W_Conjonction);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Conjonction);
   begin
      Result.Ada_Node := Ada_Node;
      Result.ITOC_Left := Left;
      Set_Link (Result.ITOC_Left, New_Id);
      Result.ITOC_Right := Right;
      Set_Link (Result.ITOC_Right, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Conjonction;

   ------------------
   -- New_Negation --
   ------------------

   function New_Negation
     (Ada_Node : Node_Id := Empty;
      Operand  : W_Predicate_Id)
     return W_Negation_Id
   is
      Result : Why_Node (W_Negation);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Negation);
   begin
      Result.Ada_Node := Ada_Node;
      Result.N_Operand := Operand;
      Set_Link (Result.N_Operand, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Negation;

   --------------------------
   -- New_Conditional_Pred --
   --------------------------

   function New_Conditional_Pred
     (Ada_Node  : Node_Id := Empty;
      Condition : W_Term_Id;
      Then_Part : W_Predicate_Id;
      Else_Part : W_Predicate_Id)
     return W_Conditional_Pred_Id
   is
      Result : Why_Node (W_Conditional_Pred);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Conditional_Pred);
   begin
      Result.Ada_Node := Ada_Node;
      Result.CPD_Condition := Condition;
      Set_Link (Result.CPD_Condition, New_Id);
      Result.CPD_Then_Part := Then_Part;
      Set_Link (Result.CPD_Then_Part, New_Id);
      Result.CPD_Else_Part := Else_Part;
      Set_Link (Result.CPD_Else_Part, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Conditional_Pred;

   ----------------------
   -- New_Binding_Pred --
   ----------------------

   function New_Binding_Pred
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id;
      Def      : W_Term_Id;
      Context  : W_Predicate_Id)
     return W_Binding_Pred_Id
   is
      Result : Why_Node (W_Binding_Pred);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Binding_Pred);
   begin
      Result.Ada_Node := Ada_Node;
      Result.BPD_Name := Name;
      Set_Link (Result.BPD_Name, New_Id);
      Result.BPD_Def := Def;
      Set_Link (Result.BPD_Def, New_Id);
      Result.BPD_Context := Context;
      Set_Link (Result.BPD_Context, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Binding_Pred;

   ---------------------------
   -- New_Universal_Quantif --
   ---------------------------

   function New_Universal_Quantif
     (Ada_Node  : Node_Id := Empty;
      Variables : W_Identifier_Array;
      Var_Type  : W_Primitive_Type_Id;
      Triggers  : W_Triggers_OId := Why_Empty;
      Pred      : W_Predicate_Id)
     return W_Universal_Quantif_Id
   is
      Result : Why_Node (W_Universal_Quantif);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Universal_Quantif);
   begin
      Result.Ada_Node := Ada_Node;
      pragma Assert (Variables'Length > 0);
      Result.UQ_Variables := New_List;
      for J in Variables'Range loop
         pragma Assert
           (Identifier_Id_Kind_Valid
            (Variables (J)));
         pragma Assert
           (Identifier_Id_Valid
            (Variables (J)));
         Append
           (Result.UQ_Variables,
            Variables (J));
      end loop;
      Set_Link (Result.UQ_Variables, New_Id);
      Result.UQ_Var_Type := Var_Type;
      Set_Link (Result.UQ_Var_Type, New_Id);
      Result.UQ_Triggers := Triggers;
      Set_Link (Result.UQ_Triggers, New_Id);
      Result.UQ_Pred := Pred;
      Set_Link (Result.UQ_Pred, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Universal_Quantif;

   -----------------------------
   -- New_Existential_Quantif --
   -----------------------------

   function New_Existential_Quantif
     (Ada_Node  : Node_Id := Empty;
      Variables : W_Identifier_Array;
      Var_Type  : W_Primitive_Type_Id;
      Pred      : W_Predicate_Id)
     return W_Existential_Quantif_Id
   is
      Result : Why_Node (W_Existential_Quantif);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Existential_Quantif);
   begin
      Result.Ada_Node := Ada_Node;
      pragma Assert (Variables'Length > 0);
      Result.EQ_Variables := New_List;
      for J in Variables'Range loop
         pragma Assert
           (Identifier_Id_Kind_Valid
            (Variables (J)));
         pragma Assert
           (Identifier_Id_Valid
            (Variables (J)));
         Append
           (Result.EQ_Variables,
            Variables (J));
      end loop;
      Set_Link (Result.EQ_Variables, New_Id);
      Result.EQ_Var_Type := Var_Type;
      Set_Link (Result.EQ_Var_Type, New_Id);
      Result.EQ_Pred := Pred;
      Set_Link (Result.EQ_Pred, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Existential_Quantif;

   -------------------------
   -- New_Named_Predicate --
   -------------------------

   function New_Named_Predicate
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id;
      Pred     : W_Predicate_Id)
     return W_Named_Predicate_Id
   is
      Result : Why_Node (W_Named_Predicate);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Named_Predicate);
   begin
      Result.Ada_Node := Ada_Node;
      Result.NP_Name := Name;
      Set_Link (Result.NP_Name, New_Id);
      Result.NP_Pred := Pred;
      Set_Link (Result.NP_Pred, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Named_Predicate;

   -----------------------------
   -- New_Protected_Predicate --
   -----------------------------

   function New_Protected_Predicate
     (Ada_Node : Node_Id := Empty;
      Pred     : W_Predicate_Id)
     return W_Protected_Predicate_Id
   is
      Result : Why_Node (W_Protected_Predicate);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Protected_Predicate);
   begin
      Result.Ada_Node := Ada_Node;
      Result.PP_Pred := Pred;
      Set_Link (Result.PP_Pred, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Protected_Predicate;

   -----------------
   -- New_Pattern --
   -----------------

   function New_Pattern
     (Ada_Node : Node_Id := Empty;
      Constr   : W_Identifier_Id;
      Args     : W_Identifier_Array := (2 .. 1 => <>))
     return W_Pattern_Id
   is
      Result : Why_Node (W_Pattern);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Pattern);
   begin
      Result.Ada_Node := Ada_Node;
      Result.PAT_Constr := Constr;
      Set_Link (Result.PAT_Constr, New_Id);
      Result.PAT_Args := New_List;
      for J in Args'Range loop
         pragma Assert
           (Identifier_Id_Kind_Valid
            (Args (J)));
         pragma Assert
           (Identifier_Id_Valid
            (Args (J)));
         Append
           (Result.PAT_Args,
            Args (J));
      end loop;
      Set_Link (Result.PAT_Args, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Pattern;

   --------------------
   -- New_Match_Case --
   --------------------

   function New_Match_Case
     (Ada_Node : Node_Id := Empty;
      Pattern  : W_Pattern_Id;
      Term     : W_Term_Id)
     return W_Match_Case_Id
   is
      Result : Why_Node (W_Match_Case);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Match_Case);
   begin
      Result.Ada_Node := Ada_Node;
      Result.MC_Pattern := Pattern;
      Set_Link (Result.MC_Pattern, New_Id);
      Result.MC_Term := Term;
      Set_Link (Result.MC_Term, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Match_Case;

   ------------------
   -- New_Triggers --
   ------------------

   function New_Triggers
     (Ada_Node : Node_Id := Empty;
      Triggers : W_Trigger_Array)
     return W_Triggers_Id
   is
      Result : Why_Node (W_Triggers);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Triggers);
   begin
      Result.Ada_Node := Ada_Node;
      pragma Assert (Triggers'Length > 0);
      Result.TRS_Triggers := New_List;
      for J in Triggers'Range loop
         pragma Assert
           (Trigger_Id_Kind_Valid
            (Triggers (J)));
         pragma Assert
           (Trigger_Id_Valid
            (Triggers (J)));
         Append
           (Result.TRS_Triggers,
            Triggers (J));
      end loop;
      Set_Link (Result.TRS_Triggers, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Triggers;

   -----------------
   -- New_Trigger --
   -----------------

   function New_Trigger
     (Ada_Node : Node_Id := Empty;
      Terms    : W_Term_Array)
     return W_Trigger_Id
   is
      Result : Why_Node (W_Trigger);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Trigger);
   begin
      Result.Ada_Node := Ada_Node;
      pragma Assert (Terms'Length > 0);
      Result.TRI_Terms := New_List;
      for J in Terms'Range loop
         pragma Assert
           (Term_Id_Kind_Valid
            (Terms (J)));
         pragma Assert
           (Term_Id_Valid
            (Terms (J)));
         Append
           (Result.TRI_Terms,
            Terms (J));
      end loop;
      Set_Link (Result.TRI_Terms, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Trigger;

   ----------------
   -- New_Rel_Eq --
   ----------------

   function New_Rel_Eq
     (Ada_Node : Node_Id := Empty)
     return W_Rel_Eq_Id
   is
      Result : Why_Node (W_Rel_Eq);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Rel_Eq);
   begin
      Result.Ada_Node := Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Rel_Eq;

   ----------------
   -- New_Rel_Ne --
   ----------------

   function New_Rel_Ne
     (Ada_Node : Node_Id := Empty)
     return W_Rel_Ne_Id
   is
      Result : Why_Node (W_Rel_Ne);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Rel_Ne);
   begin
      Result.Ada_Node := Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Rel_Ne;

   ----------------
   -- New_Rel_Lt --
   ----------------

   function New_Rel_Lt
     (Ada_Node : Node_Id := Empty)
     return W_Rel_Lt_Id
   is
      Result : Why_Node (W_Rel_Lt);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Rel_Lt);
   begin
      Result.Ada_Node := Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Rel_Lt;

   ----------------
   -- New_Rel_Le --
   ----------------

   function New_Rel_Le
     (Ada_Node : Node_Id := Empty)
     return W_Rel_Le_Id
   is
      Result : Why_Node (W_Rel_Le);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Rel_Le);
   begin
      Result.Ada_Node := Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Rel_Le;

   ----------------
   -- New_Rel_Gt --
   ----------------

   function New_Rel_Gt
     (Ada_Node : Node_Id := Empty)
     return W_Rel_Gt_Id
   is
      Result : Why_Node (W_Rel_Gt);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Rel_Gt);
   begin
      Result.Ada_Node := Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Rel_Gt;

   ----------------
   -- New_Rel_Ge --
   ----------------

   function New_Rel_Ge
     (Ada_Node : Node_Id := Empty)
     return W_Rel_Ge_Id
   is
      Result : Why_Node (W_Rel_Ge);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Rel_Ge);
   begin
      Result.Ada_Node := Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Rel_Ge;

   --------------
   -- New_Type --
   --------------

   function New_Type
     (Ada_Node        : Node_Id := Empty;
      External        : W_External_OId := Why_Empty;
      Type_Parameters : W_Identifier_Array := (2 .. 1 => <>);
      Name            : W_Identifier_Id;
      Definition      : W_Type_Definition_OId := Why_Empty)
     return W_Type_Id
   is
      Result : Why_Node (W_Type);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Type);
   begin
      Result.Ada_Node := Ada_Node;
      Result.T_External := External;
      Set_Link (Result.T_External, New_Id);
      Result.T_Type_Parameters := New_List;
      for J in Type_Parameters'Range loop
         pragma Assert
           (Identifier_Id_Kind_Valid
            (Type_Parameters (J)));
         pragma Assert
           (Identifier_Id_Valid
            (Type_Parameters (J)));
         Append
           (Result.T_Type_Parameters,
            Type_Parameters (J));
      end loop;
      Set_Link (Result.T_Type_Parameters, New_Id);
      Result.T_Name := Name;
      Set_Link (Result.T_Name, New_Id);
      Result.T_Definition := Definition;
      Set_Link (Result.T_Definition, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Type;

   ---------------
   -- New_Logic --
   ---------------

   function New_Logic
     (Ada_Node   : Node_Id := Empty;
      External   : W_External_OId := Why_Empty;
      Names      : W_Identifier_Array;
      Logic_Type : W_Logic_Type_Id)
     return W_Logic_Id
   is
      Result : Why_Node (W_Logic);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Logic);
   begin
      Result.Ada_Node := Ada_Node;
      Result.L_External := External;
      Set_Link (Result.L_External, New_Id);
      pragma Assert (Names'Length > 0);
      Result.L_Names := New_List;
      for J in Names'Range loop
         pragma Assert
           (Identifier_Id_Kind_Valid
            (Names (J)));
         pragma Assert
           (Identifier_Id_Valid
            (Names (J)));
         Append
           (Result.L_Names,
            Names (J));
      end loop;
      Set_Link (Result.L_Names, New_Id);
      Result.L_Logic_Type := Logic_Type;
      Set_Link (Result.L_Logic_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Logic;

   ------------------
   -- New_Function --
   ------------------

   function New_Function
     (Ada_Node    : Node_Id := Empty;
      Name        : W_Identifier_Id;
      Binders     : W_Logic_Binder_Array;
      Return_Type : W_Primitive_Type_Id;
      Def         : W_Term_Id)
     return W_Function_Id
   is
      Result : Why_Node (W_Function);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Function);
   begin
      Result.Ada_Node := Ada_Node;
      Result.F_Name := Name;
      Set_Link (Result.F_Name, New_Id);
      pragma Assert (Binders'Length > 0);
      Result.F_Binders := New_List;
      for J in Binders'Range loop
         pragma Assert
           (Logic_Binder_Id_Kind_Valid
            (Binders (J)));
         pragma Assert
           (Logic_Binder_Id_Valid
            (Binders (J)));
         Append
           (Result.F_Binders,
            Binders (J));
      end loop;
      Set_Link (Result.F_Binders, New_Id);
      Result.F_Return_Type := Return_Type;
      Set_Link (Result.F_Return_Type, New_Id);
      Result.F_Def := Def;
      Set_Link (Result.F_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Function;

   ------------------------------
   -- New_Predicate_Definition --
   ------------------------------

   function New_Predicate_Definition
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id;
      Binders  : W_Logic_Binder_Array;
      Def      : W_Predicate_Id)
     return W_Predicate_Definition_Id
   is
      Result : Why_Node (W_Predicate_Definition);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Predicate_Definition);
   begin
      Result.Ada_Node := Ada_Node;
      Result.P_Name := Name;
      Set_Link (Result.P_Name, New_Id);
      pragma Assert (Binders'Length > 0);
      Result.P_Binders := New_List;
      for J in Binders'Range loop
         pragma Assert
           (Logic_Binder_Id_Kind_Valid
            (Binders (J)));
         pragma Assert
           (Logic_Binder_Id_Valid
            (Binders (J)));
         Append
           (Result.P_Binders,
            Binders (J));
      end loop;
      Set_Link (Result.P_Binders, New_Id);
      Result.P_Def := Def;
      Set_Link (Result.P_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Predicate_Definition;

   -------------------
   -- New_Inductive --
   -------------------

   function New_Inductive
     (Ada_Node   : Node_Id := Empty;
      Name       : W_Identifier_Id;
      Logic_Type : W_Logic_Type_Id;
      Def        : W_Inductive_Case_Array)
     return W_Inductive_Id
   is
      Result : Why_Node (W_Inductive);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Inductive);
   begin
      Result.Ada_Node := Ada_Node;
      Result.I_Name := Name;
      Set_Link (Result.I_Name, New_Id);
      Result.I_Logic_Type := Logic_Type;
      Set_Link (Result.I_Logic_Type, New_Id);
      pragma Assert (Def'Length > 0);
      Result.I_Def := New_List;
      for J in Def'Range loop
         pragma Assert
           (Inductive_Case_Id_Kind_Valid
            (Def (J)));
         pragma Assert
           (Inductive_Case_Id_Valid
            (Def (J)));
         Append
           (Result.I_Def,
            Def (J));
      end loop;
      Set_Link (Result.I_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Inductive;

   ---------------
   -- New_Axiom --
   ---------------

   function New_Axiom
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id;
      Def      : W_Predicate_Id)
     return W_Axiom_Id
   is
      Result : Why_Node (W_Axiom);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Axiom);
   begin
      Result.Ada_Node := Ada_Node;
      Result.AX_Name := Name;
      Set_Link (Result.AX_Name, New_Id);
      Result.AX_Def := Def;
      Set_Link (Result.AX_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Axiom;

   --------------
   -- New_Goal --
   --------------

   function New_Goal
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id;
      Def      : W_Predicate_Id)
     return W_Goal_Id
   is
      Result : Why_Node (W_Goal);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Goal);
   begin
      Result.Ada_Node := Ada_Node;
      Result.G_Name := Name;
      Set_Link (Result.G_Name, New_Id);
      Result.G_Def := Def;
      Set_Link (Result.G_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Goal;

   ------------------
   -- New_External --
   ------------------

   function New_External
     (Ada_Node : Node_Id := Empty)
     return W_External_Id
   is
      Result : Why_Node (W_External);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_External);
   begin
      Result.Ada_Node := Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_External;

   --------------------
   -- New_Logic_Type --
   --------------------

   function New_Logic_Type
     (Ada_Node    : Node_Id := Empty;
      Arg_Types   : W_Logic_Arg_Type_Array;
      Return_Type : W_Logic_Return_Type_Id)
     return W_Logic_Type_Id
   is
      Result : Why_Node (W_Logic_Type);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Logic_Type);
   begin
      Result.Ada_Node := Ada_Node;
      pragma Assert (Arg_Types'Length > 0);
      Result.LT_Arg_Types := New_List;
      for J in Arg_Types'Range loop
         pragma Assert
           (Logic_Arg_Type_Id_Kind_Valid
            (Arg_Types (J)));
         pragma Assert
           (Logic_Arg_Type_Id_Valid
            (Arg_Types (J)));
         Append
           (Result.LT_Arg_Types,
            Arg_Types (J));
      end loop;
      Set_Link (Result.LT_Arg_Types, New_Id);
      Result.LT_Return_Type := Return_Type;
      Set_Link (Result.LT_Return_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Logic_Type;

   ----------------------
   -- New_Logic_Binder --
   ----------------------

   function New_Logic_Binder
     (Ada_Node   : Node_Id := Empty;
      Name       : W_Identifier_Id;
      Param_Type : W_Primitive_Type_Id)
     return W_Logic_Binder_Id
   is
      Result : Why_Node (W_Logic_Binder);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Logic_Binder);
   begin
      Result.Ada_Node := Ada_Node;
      Result.LB_Name := Name;
      Set_Link (Result.LB_Name, New_Id);
      Result.LB_Param_Type := Param_Type;
      Set_Link (Result.LB_Param_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Logic_Binder;

   ------------------------
   -- New_Inductive_Case --
   ------------------------

   function New_Inductive_Case
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id;
      Pred     : W_Predicate_Id)
     return W_Inductive_Case_Id
   is
      Result : Why_Node (W_Inductive_Case);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Inductive_Case);
   begin
      Result.Ada_Node := Ada_Node;
      Result.IC_Name := Name;
      Set_Link (Result.IC_Name, New_Id);
      Result.IC_Pred := Pred;
      Set_Link (Result.IC_Pred, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Inductive_Case;

   -------------------------------------
   -- New_Transparent_Type_Definition --
   -------------------------------------

   function New_Transparent_Type_Definition
     (Ada_Node        : Node_Id := Empty;
      Type_Definition : W_Primitive_Type_Id)
     return W_Transparent_Type_Definition_Id
   is
      Result : Why_Node (W_Transparent_Type_Definition);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Transparent_Type_Definition);
   begin
      Result.Ada_Node := Ada_Node;
      Result.Tr_Type_Definition := Type_Definition;
      Set_Link (Result.Tr_Type_Definition, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Transparent_Type_Definition;

   ------------------------
   -- New_Adt_Definition --
   ------------------------

   function New_Adt_Definition
     (Ada_Node     : Node_Id := Empty;
      Constructors : W_Constr_Decl_Array)
     return W_Adt_Definition_Id
   is
      Result : Why_Node (W_Adt_Definition);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Adt_Definition);
   begin
      Result.Ada_Node := Ada_Node;
      pragma Assert (Constructors'Length > 0);
      Result.Adt_Constructors := New_List;
      for J in Constructors'Range loop
         pragma Assert
           (Constr_Decl_Id_Kind_Valid
            (Constructors (J)));
         pragma Assert
           (Constr_Decl_Id_Valid
            (Constructors (J)));
         Append
           (Result.Adt_Constructors,
            Constructors (J));
      end loop;
      Set_Link (Result.Adt_Constructors, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Adt_Definition;

   ---------------------
   -- New_Constr_Decl --
   ---------------------

   function New_Constr_Decl
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id;
      Arg_List : W_Primitive_Type_Array := (2 .. 1 => <>))
     return W_Constr_Decl_Id
   is
      Result : Why_Node (W_Constr_Decl);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Constr_Decl);
   begin
      Result.Ada_Node := Ada_Node;
      Result.C_Name := Name;
      Set_Link (Result.C_Name, New_Id);
      Result.C_Arg_List := New_List;
      for J in Arg_List'Range loop
         pragma Assert
           (Primitive_Type_Id_Kind_Valid
            (Arg_List (J)));
         pragma Assert
           (Primitive_Type_Id_Valid
            (Arg_List (J)));
         Append
           (Result.C_Arg_List,
            Arg_List (J));
      end loop;
      Set_Link (Result.C_Arg_List, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Constr_Decl;

   -----------------
   -- New_Effects --
   -----------------

   function New_Effects
     (Ada_Node : Node_Id := Empty;
      Reads    : W_Identifier_Array := (2 .. 1 => <>);
      Writes   : W_Identifier_Array := (2 .. 1 => <>);
      Raises   : W_Identifier_Array := (2 .. 1 => <>))
     return W_Effects_Id
   is
      Result : Why_Node (W_Effects);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Effects);
   begin
      Result.Ada_Node := Ada_Node;
      Result.E_Reads := New_List;
      for J in Reads'Range loop
         pragma Assert
           (Identifier_Id_Kind_Valid
            (Reads (J)));
         pragma Assert
           (Identifier_Id_Valid
            (Reads (J)));
         Append
           (Result.E_Reads,
            Reads (J));
      end loop;
      Set_Link (Result.E_Reads, New_Id);
      Result.E_Writes := New_List;
      for J in Writes'Range loop
         pragma Assert
           (Identifier_Id_Kind_Valid
            (Writes (J)));
         pragma Assert
           (Identifier_Id_Valid
            (Writes (J)));
         Append
           (Result.E_Writes,
            Writes (J));
      end loop;
      Set_Link (Result.E_Writes, New_Id);
      Result.E_Raises := New_List;
      for J in Raises'Range loop
         pragma Assert
           (Identifier_Id_Kind_Valid
            (Raises (J)));
         pragma Assert
           (Identifier_Id_Valid
            (Raises (J)));
         Append
           (Result.E_Raises,
            Raises (J));
      end loop;
      Set_Link (Result.E_Raises, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Effects;

   ----------------------
   -- New_Precondition --
   ----------------------

   function New_Precondition
     (Ada_Node  : Node_Id := Empty;
      Assertion : W_Assertion_Id)
     return W_Precondition_Id
   is
      Result : Why_Node (W_Precondition);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Precondition);
   begin
      Result.Ada_Node := Ada_Node;
      Result.PRE_Assertion := Assertion;
      Set_Link (Result.PRE_Assertion, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Precondition;

   -----------------------
   -- New_Postcondition --
   -----------------------

   function New_Postcondition
     (Ada_Node  : Node_Id := Empty;
      Assertion : W_Assertion_Id;
      Handlers  : W_Exn_Condition_Array := (2 .. 1 => <>))
     return W_Postcondition_Id
   is
      Result : Why_Node (W_Postcondition);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Postcondition);
   begin
      Result.Ada_Node := Ada_Node;
      Result.POST_Assertion := Assertion;
      Set_Link (Result.POST_Assertion, New_Id);
      Result.POST_Handlers := New_List;
      for J in Handlers'Range loop
         pragma Assert
           (Exn_Condition_Id_Kind_Valid
            (Handlers (J)));
         pragma Assert
           (Exn_Condition_Id_Valid
            (Handlers (J)));
         Append
           (Result.POST_Handlers,
            Handlers (J));
      end loop;
      Set_Link (Result.POST_Handlers, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Postcondition;

   -----------------------
   -- New_Exn_Condition --
   -----------------------

   function New_Exn_Condition
     (Ada_Node  : Node_Id := Empty;
      Exn_Case  : W_Identifier_Id;
      Assertion : W_Assertion_Id)
     return W_Exn_Condition_Id
   is
      Result : Why_Node (W_Exn_Condition);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Exn_Condition);
   begin
      Result.Ada_Node := Ada_Node;
      Result.EC_Exn_Case := Exn_Case;
      Set_Link (Result.EC_Exn_Case, New_Id);
      Result.EC_Assertion := Assertion;
      Set_Link (Result.EC_Assertion, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Exn_Condition;

   -------------------
   -- New_Assertion --
   -------------------

   function New_Assertion
     (Ada_Node : Node_Id := Empty;
      Pred     : W_Predicate_Id;
      As       : W_Identifier_OId := Why_Empty)
     return W_Assertion_Id
   is
      Result : Why_Node (W_Assertion);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Assertion);
   begin
      Result.Ada_Node := Ada_Node;
      Result.A_Pred := Pred;
      Set_Link (Result.A_Pred, New_Id);
      Result.A_As := As;
      Set_Link (Result.A_As, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Assertion;

   -----------------------
   -- New_Prog_Constant --
   -----------------------

   function New_Prog_Constant
     (Ada_Node : Node_Id := Empty;
      Def      : W_Constant_Id)
     return W_Prog_Constant_Id
   is
      Result : Why_Node (W_Prog_Constant);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Prog_Constant);
   begin
      Result.Ada_Node := Ada_Node;
      Result.PC_Def := Def;
      Set_Link (Result.PC_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Prog_Constant;

   -------------------------
   -- New_Prog_Identifier --
   -------------------------

   function New_Prog_Identifier
     (Ada_Node : Node_Id := Empty;
      Def      : W_Identifier_Id)
     return W_Prog_Identifier_Id
   is
      Result : Why_Node (W_Prog_Identifier);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Prog_Identifier);
   begin
      Result.Ada_Node := Ada_Node;
      Result.PI_Def := Def;
      Set_Link (Result.PI_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Prog_Identifier;

   ---------------
   -- New_Deref --
   ---------------

   function New_Deref
     (Ada_Node : Node_Id := Empty;
      Ref      : W_Identifier_Id)
     return W_Deref_Id
   is
      Result : Why_Node (W_Deref);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Deref);
   begin
      Result.Ada_Node := Ada_Node;
      Result.D_Ref := Ref;
      Set_Link (Result.D_Ref, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Deref;

   --------------------
   -- New_Assignment --
   --------------------

   function New_Assignment
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id;
      Value    : W_Prog_Id)
     return W_Assignment_Id
   is
      Result : Why_Node (W_Assignment);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Assignment);
   begin
      Result.Ada_Node := Ada_Node;
      Result.A_Name := Name;
      Set_Link (Result.A_Name, New_Id);
      Result.A_Value := Value;
      Set_Link (Result.A_Value, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Assignment;

   ----------------------
   -- New_Array_Access --
   ----------------------

   function New_Array_Access
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id;
      Index    : W_Prog_Id)
     return W_Array_Access_Id
   is
      Result : Why_Node (W_Array_Access);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Array_Access);
   begin
      Result.Ada_Node := Ada_Node;
      Result.AA_Name := Name;
      Set_Link (Result.AA_Name, New_Id);
      Result.AA_Index := Index;
      Set_Link (Result.AA_Index, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Array_Access;

   ----------------------
   -- New_Array_Update --
   ----------------------

   function New_Array_Update
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id;
      Index    : W_Prog_Id;
      Value    : W_Prog_Id)
     return W_Array_Update_Id
   is
      Result : Why_Node (W_Array_Update);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Array_Update);
   begin
      Result.Ada_Node := Ada_Node;
      Result.AU_Name := Name;
      Set_Link (Result.AU_Name, New_Id);
      Result.AU_Index := Index;
      Set_Link (Result.AU_Index, New_Id);
      Result.AU_Value := Value;
      Set_Link (Result.AU_Value, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Array_Update;

   --------------------
   -- New_Infix_Call --
   --------------------

   function New_Infix_Call
     (Ada_Node : Node_Id := Empty;
      Left     : W_Prog_Id;
      Infix    : W_Infix_Id;
      Right    : W_Prog_Id)
     return W_Infix_Call_Id
   is
      Result : Why_Node (W_Infix_Call);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Infix_Call);
   begin
      Result.Ada_Node := Ada_Node;
      Result.IC_Left := Left;
      Set_Link (Result.IC_Left, New_Id);
      Result.IC_Infix := Infix;
      Set_Link (Result.IC_Infix, New_Id);
      Result.IC_Right := Right;
      Set_Link (Result.IC_Right, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Infix_Call;

   ---------------------
   -- New_Prefix_Call --
   ---------------------

   function New_Prefix_Call
     (Ada_Node : Node_Id := Empty;
      Prefix   : W_Prefix_Id;
      Operand  : W_Prog_Id)
     return W_Prefix_Call_Id
   is
      Result : Why_Node (W_Prefix_Call);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Prefix_Call);
   begin
      Result.Ada_Node := Ada_Node;
      Result.PC_Prefix := Prefix;
      Set_Link (Result.PC_Prefix, New_Id);
      Result.PC_Operand := Operand;
      Set_Link (Result.PC_Operand, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Prefix_Call;

   ----------------------
   -- New_Binding_Prog --
   ----------------------

   function New_Binding_Prog
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id;
      Def      : W_Prog_Id;
      Context  : W_Prog_Id)
     return W_Binding_Prog_Id
   is
      Result : Why_Node (W_Binding_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Binding_Prog);
   begin
      Result.Ada_Node := Ada_Node;
      Result.BPG_Name := Name;
      Set_Link (Result.BPG_Name, New_Id);
      Result.BPG_Def := Def;
      Set_Link (Result.BPG_Def, New_Id);
      Result.BPG_Context := Context;
      Set_Link (Result.BPG_Context, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Binding_Prog;

   ---------------------
   -- New_Binding_Ref --
   ---------------------

   function New_Binding_Ref
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id;
      Def      : W_Prog_Id;
      Context  : W_Prog_Id)
     return W_Binding_Ref_Id
   is
      Result : Why_Node (W_Binding_Ref);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Binding_Ref);
   begin
      Result.Ada_Node := Ada_Node;
      Result.BPG_Name := Name;
      Set_Link (Result.BPG_Name, New_Id);
      Result.BPG_Def := Def;
      Set_Link (Result.BPG_Def, New_Id);
      Result.BPG_Context := Context;
      Set_Link (Result.BPG_Context, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Binding_Ref;

   --------------------------
   -- New_Conditional_Prog --
   --------------------------

   function New_Conditional_Prog
     (Ada_Node  : Node_Id := Empty;
      Condition : W_Prog_Id;
      Then_Part : W_Prog_Id;
      Else_Part : W_Prog_OId := Why_Empty)
     return W_Conditional_Prog_Id
   is
      Result : Why_Node (W_Conditional_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Conditional_Prog);
   begin
      Result.Ada_Node := Ada_Node;
      Result.CPG_Condition := Condition;
      Set_Link (Result.CPG_Condition, New_Id);
      Result.CPG_Then_Part := Then_Part;
      Set_Link (Result.CPG_Then_Part, New_Id);
      Result.CPG_Else_Part := Else_Part;
      Set_Link (Result.CPG_Else_Part, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Conditional_Prog;

   --------------------
   -- New_While_Loop --
   --------------------

   function New_While_Loop
     (Ada_Node     : Node_Id := Empty;
      Condition    : W_Prog_Id;
      Annotation   : W_Loop_Annot_Id;
      Loop_Content : W_Prog_Id)
     return W_While_Loop_Id
   is
      Result : Why_Node (W_While_Loop);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_While_Loop);
   begin
      Result.Ada_Node := Ada_Node;
      Result.WL_Condition := Condition;
      Set_Link (Result.WL_Condition, New_Id);
      Result.WL_Annotation := Annotation;
      Set_Link (Result.WL_Annotation, New_Id);
      Result.WL_Loop_Content := Loop_Content;
      Set_Link (Result.WL_Loop_Content, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_While_Loop;

   ----------------------------
   -- New_Statement_Sequence --
   ----------------------------

   function New_Statement_Sequence
     (Ada_Node   : Node_Id := Empty;
      Statements : W_Prog_Array)
     return W_Statement_Sequence_Id
   is
      Result : Why_Node (W_Statement_Sequence);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Statement_Sequence);
   begin
      Result.Ada_Node := Ada_Node;
      pragma Assert (Statements'Length > 0);
      Result.SS_Statements := New_List;
      for J in Statements'Range loop
         pragma Assert
           (Prog_Id_Kind_Valid
            (Statements (J)));
         pragma Assert
           (Prog_Id_Valid
            (Statements (J)));
         Append
           (Result.SS_Statements,
            Statements (J));
      end loop;
      Set_Link (Result.SS_Statements, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Statement_Sequence;

   ---------------
   -- New_Label --
   ---------------

   function New_Label
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id;
      Def      : W_Prog_Id)
     return W_Label_Id
   is
      Result : Why_Node (W_Label);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Label);
   begin
      Result.Ada_Node := Ada_Node;
      Result.L_Name := Name;
      Set_Link (Result.L_Name, New_Id);
      Result.L_Def := Def;
      Set_Link (Result.L_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Label;

   ----------------
   -- New_Assert --
   ----------------

   function New_Assert
     (Ada_Node   : Node_Id := Empty;
      Assertions : W_Assertion_Array;
      Prog       : W_Prog_Id)
     return W_Assert_Id
   is
      Result : Why_Node (W_Assert);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Assert);
   begin
      Result.Ada_Node := Ada_Node;
      pragma Assert (Assertions'Length > 0);
      Result.AS_Assertions := New_List;
      for J in Assertions'Range loop
         pragma Assert
           (Assertion_Id_Kind_Valid
            (Assertions (J)));
         pragma Assert
           (Assertion_Id_Valid
            (Assertions (J)));
         Append
           (Result.AS_Assertions,
            Assertions (J));
      end loop;
      Set_Link (Result.AS_Assertions, New_Id);
      Result.AS_Prog := Prog;
      Set_Link (Result.AS_Prog, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Assert;

   ------------------------
   -- New_Post_Assertion --
   ------------------------

   function New_Post_Assertion
     (Ada_Node : Node_Id := Empty;
      Prog     : W_Prog_Id;
      Post     : W_Postcondition_Id)
     return W_Post_Assertion_Id
   is
      Result : Why_Node (W_Post_Assertion);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Post_Assertion);
   begin
      Result.Ada_Node := Ada_Node;
      Result.PA_Prog := Prog;
      Set_Link (Result.PA_Prog, New_Id);
      Result.PA_Post := Post;
      Set_Link (Result.PA_Post, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Post_Assertion;

   --------------------------
   -- New_Opaque_Assertion --
   --------------------------

   function New_Opaque_Assertion
     (Ada_Node : Node_Id := Empty;
      Prog     : W_Prog_Id;
      Post     : W_Postcondition_Id)
     return W_Opaque_Assertion_Id
   is
      Result : Why_Node (W_Opaque_Assertion);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Opaque_Assertion);
   begin
      Result.Ada_Node := Ada_Node;
      Result.PA_Prog := Prog;
      Set_Link (Result.PA_Prog, New_Id);
      Result.PA_Post := Post;
      Set_Link (Result.PA_Post, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Opaque_Assertion;

   -----------------
   -- New_Fun_Def --
   -----------------

   function New_Fun_Def
     (Ada_Node : Node_Id := Empty;
      Binders  : W_Binders_Id;
      Pre      : W_Precondition_Id;
      Def      : W_Prog_Id)
     return W_Fun_Def_Id
   is
      Result : Why_Node (W_Fun_Def);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Fun_Def);
   begin
      Result.Ada_Node := Ada_Node;
      Result.FD_Binders := Binders;
      Set_Link (Result.FD_Binders, New_Id);
      Result.FD_Pre := Pre;
      Set_Link (Result.FD_Pre, New_Id);
      Result.FD_Def := Def;
      Set_Link (Result.FD_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Fun_Def;

   ---------------------
   -- New_Binding_Fun --
   ---------------------

   function New_Binding_Fun
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id;
      Binders  : W_Binders_Id;
      Pre      : W_Precondition_Id;
      Def      : W_Prog_Id;
      Context  : W_Prog_Id)
     return W_Binding_Fun_Id
   is
      Result : Why_Node (W_Binding_Fun);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Binding_Fun);
   begin
      Result.Ada_Node := Ada_Node;
      Result.BF_Name := Name;
      Set_Link (Result.BF_Name, New_Id);
      Result.BF_Binders := Binders;
      Set_Link (Result.BF_Binders, New_Id);
      Result.BF_Pre := Pre;
      Set_Link (Result.BF_Pre, New_Id);
      Result.BF_Def := Def;
      Set_Link (Result.BF_Def, New_Id);
      Result.BF_Context := Context;
      Set_Link (Result.BF_Context, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Binding_Fun;

   ---------------------
   -- New_Binding_Rec --
   ---------------------

   function New_Binding_Rec
     (Ada_Node : Node_Id := Empty;
      Recfun   : W_Recfun_Id;
      Context  : W_Prog_Id)
     return W_Binding_Rec_Id
   is
      Result : Why_Node (W_Binding_Rec);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Binding_Rec);
   begin
      Result.Ada_Node := Ada_Node;
      Result.BR_Recfun := Recfun;
      Set_Link (Result.BR_Recfun, New_Id);
      Result.BR_Context := Context;
      Set_Link (Result.BR_Context, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Binding_Rec;

   -----------------------
   -- New_Prog_Sequence --
   -----------------------

   function New_Prog_Sequence
     (Ada_Node : Node_Id := Empty;
      Progs    : W_Prog_Array)
     return W_Prog_Sequence_Id
   is
      Result : Why_Node (W_Prog_Sequence);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Prog_Sequence);
   begin
      Result.Ada_Node := Ada_Node;
      pragma Assert (Progs'Length > 0);
      Result.PS_Progs := New_List;
      for J in Progs'Range loop
         pragma Assert
           (Prog_Id_Kind_Valid
            (Progs (J)));
         pragma Assert
           (Prog_Id_Valid
            (Progs (J)));
         Append
           (Result.PS_Progs,
            Progs (J));
      end loop;
      Set_Link (Result.PS_Progs, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Prog_Sequence;

   -------------------------
   -- New_Raise_Statement --
   -------------------------

   function New_Raise_Statement
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id;
      Exn_Type : W_Value_Type_OId := Why_Empty)
     return W_Raise_Statement_Id
   is
      Result : Why_Node (W_Raise_Statement);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Raise_Statement);
   begin
      Result.Ada_Node := Ada_Node;
      Result.RS_Name := Name;
      Set_Link (Result.RS_Name, New_Id);
      Result.RS_Exn_Type := Exn_Type;
      Set_Link (Result.RS_Exn_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Raise_Statement;

   -----------------------------------------
   -- New_Raise_Statement_With_Parameters --
   -----------------------------------------

   function New_Raise_Statement_With_Parameters
     (Ada_Node  : Node_Id := Empty;
      Name      : W_Identifier_Id;
      Parameter : W_Term_Id;
      Exn_Type  : W_Value_Type_OId := Why_Empty)
     return W_Raise_Statement_With_Parameters_Id
   is
      Result : Why_Node (W_Raise_Statement_With_Parameters);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Raise_Statement_With_Parameters);
   begin
      Result.Ada_Node := Ada_Node;
      Result.RSWP_Name := Name;
      Set_Link (Result.RSWP_Name, New_Id);
      Result.RSWP_Parameter := Parameter;
      Set_Link (Result.RSWP_Parameter, New_Id);
      Result.RSWP_Exn_Type := Exn_Type;
      Set_Link (Result.RSWP_Exn_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Raise_Statement_With_Parameters;

   -------------------
   -- New_Try_Block --
   -------------------

   function New_Try_Block
     (Ada_Node : Node_Id := Empty;
      Prog     : W_Prog_Id;
      Handler  : W_Handler_Array)
     return W_Try_Block_Id
   is
      Result : Why_Node (W_Try_Block);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Try_Block);
   begin
      Result.Ada_Node := Ada_Node;
      Result.TB_Prog := Prog;
      Set_Link (Result.TB_Prog, New_Id);
      pragma Assert (Handler'Length > 0);
      Result.TB_Handler := New_List;
      for J in Handler'Range loop
         pragma Assert
           (Handler_Id_Kind_Valid
            (Handler (J)));
         pragma Assert
           (Handler_Id_Valid
            (Handler (J)));
         Append
           (Result.TB_Handler,
            Handler (J));
      end loop;
      Set_Link (Result.TB_Handler, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Try_Block;

   --------------------------
   -- New_Unreachable_Code --
   --------------------------

   function New_Unreachable_Code
     (Ada_Node : Node_Id := Empty;
      Exn_Type : W_Value_Type_OId := Why_Empty)
     return W_Unreachable_Code_Id
   is
      Result : Why_Node (W_Unreachable_Code);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Unreachable_Code);
   begin
      Result.Ada_Node := Ada_Node;
      Result.UC_Exn_Type := Exn_Type;
      Set_Link (Result.UC_Exn_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unreachable_Code;

   ---------------------
   -- New_Begin_Block --
   ---------------------

   function New_Begin_Block
     (Ada_Node : Node_Id := Empty;
      Prog     : W_Prog_Id)
     return W_Begin_Block_Id
   is
      Result : Why_Node (W_Begin_Block);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Begin_Block);
   begin
      Result.Ada_Node := Ada_Node;
      Result.BB_Prog := Prog;
      Set_Link (Result.BB_Prog, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Begin_Block;

   ------------------------
   -- New_Protected_Prog --
   ------------------------

   function New_Protected_Prog
     (Ada_Node : Node_Id := Empty;
      Prog     : W_Prog_Id)
     return W_Protected_Prog_Id
   is
      Result : Why_Node (W_Protected_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Protected_Prog);
   begin
      Result.Ada_Node := Ada_Node;
      Result.BB_Prog := Prog;
      Set_Link (Result.BB_Prog, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Protected_Prog;

   ---------------------
   -- New_Op_Add_Prog --
   ---------------------

   function New_Op_Add_Prog
     (Ada_Node : Node_Id := Empty)
     return W_Op_Add_Prog_Id
   is
      Result : Why_Node (W_Op_Add_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Add_Prog);
   begin
      Result.Ada_Node := Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Op_Add_Prog;

   ---------------------------
   -- New_Op_Substract_Prog --
   ---------------------------

   function New_Op_Substract_Prog
     (Ada_Node : Node_Id := Empty)
     return W_Op_Substract_Prog_Id
   is
      Result : Why_Node (W_Op_Substract_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Substract_Prog);
   begin
      Result.Ada_Node := Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Op_Substract_Prog;

   --------------------------
   -- New_Op_Multiply_Prog --
   --------------------------

   function New_Op_Multiply_Prog
     (Ada_Node : Node_Id := Empty)
     return W_Op_Multiply_Prog_Id
   is
      Result : Why_Node (W_Op_Multiply_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Multiply_Prog);
   begin
      Result.Ada_Node := Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Op_Multiply_Prog;

   ------------------------
   -- New_Op_Divide_Prog --
   ------------------------

   function New_Op_Divide_Prog
     (Ada_Node : Node_Id := Empty)
     return W_Op_Divide_Prog_Id
   is
      Result : Why_Node (W_Op_Divide_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Divide_Prog);
   begin
      Result.Ada_Node := Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Op_Divide_Prog;

   ---------------------
   -- New_Op_Mod_Prog --
   ---------------------

   function New_Op_Mod_Prog
     (Ada_Node : Node_Id := Empty)
     return W_Op_Mod_Prog_Id
   is
      Result : Why_Node (W_Op_Mod_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Mod_Prog);
   begin
      Result.Ada_Node := Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Op_Mod_Prog;

   --------------------
   -- New_Op_Eq_Prog --
   --------------------

   function New_Op_Eq_Prog
     (Ada_Node : Node_Id := Empty)
     return W_Op_Eq_Prog_Id
   is
      Result : Why_Node (W_Op_Eq_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Eq_Prog);
   begin
      Result.Ada_Node := Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Op_Eq_Prog;

   --------------------
   -- New_Op_Ne_Prog --
   --------------------

   function New_Op_Ne_Prog
     (Ada_Node : Node_Id := Empty)
     return W_Op_Ne_Prog_Id
   is
      Result : Why_Node (W_Op_Ne_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Ne_Prog);
   begin
      Result.Ada_Node := Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Op_Ne_Prog;

   --------------------
   -- New_Op_Lt_Prog --
   --------------------

   function New_Op_Lt_Prog
     (Ada_Node : Node_Id := Empty)
     return W_Op_Lt_Prog_Id
   is
      Result : Why_Node (W_Op_Lt_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Lt_Prog);
   begin
      Result.Ada_Node := Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Op_Lt_Prog;

   --------------------
   -- New_Op_Le_Prog --
   --------------------

   function New_Op_Le_Prog
     (Ada_Node : Node_Id := Empty)
     return W_Op_Le_Prog_Id
   is
      Result : Why_Node (W_Op_Le_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Le_Prog);
   begin
      Result.Ada_Node := Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Op_Le_Prog;

   --------------------
   -- New_Op_Gt_Prog --
   --------------------

   function New_Op_Gt_Prog
     (Ada_Node : Node_Id := Empty)
     return W_Op_Gt_Prog_Id
   is
      Result : Why_Node (W_Op_Gt_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Gt_Prog);
   begin
      Result.Ada_Node := Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Op_Gt_Prog;

   --------------------
   -- New_Op_Ge_Prog --
   --------------------

   function New_Op_Ge_Prog
     (Ada_Node : Node_Id := Empty)
     return W_Op_Ge_Prog_Id
   is
      Result : Why_Node (W_Op_Ge_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Ge_Prog);
   begin
      Result.Ada_Node := Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Op_Ge_Prog;

   -------------------------
   -- New_Op_Or_Else_Prog --
   -------------------------

   function New_Op_Or_Else_Prog
     (Ada_Node : Node_Id := Empty)
     return W_Op_Or_Else_Prog_Id
   is
      Result : Why_Node (W_Op_Or_Else_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Or_Else_Prog);
   begin
      Result.Ada_Node := Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Op_Or_Else_Prog;

   --------------------------
   -- New_Op_And_Then_Prog --
   --------------------------

   function New_Op_And_Then_Prog
     (Ada_Node : Node_Id := Empty)
     return W_Op_And_Then_Prog_Id
   is
      Result : Why_Node (W_Op_And_Then_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_And_Then_Prog);
   begin
      Result.Ada_Node := Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Op_And_Then_Prog;

   -----------------------
   -- New_Op_Minus_Prog --
   -----------------------

   function New_Op_Minus_Prog
     (Ada_Node : Node_Id := Empty)
     return W_Op_Minus_Prog_Id
   is
      Result : Why_Node (W_Op_Minus_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Minus_Prog);
   begin
      Result.Ada_Node := Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Op_Minus_Prog;

   ---------------------
   -- New_Op_Not_Prog --
   ---------------------

   function New_Op_Not_Prog
     (Ada_Node : Node_Id := Empty)
     return W_Op_Not_Prog_Id
   is
      Result : Why_Node (W_Op_Not_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Not_Prog);
   begin
      Result.Ada_Node := Ada_Node;
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Op_Not_Prog;

   -----------------
   -- New_Binders --
   -----------------

   function New_Binders
     (Ada_Node : Node_Id := Empty;
      Binders  : W_Binder_Array)
     return W_Binders_Id
   is
      Result : Why_Node (W_Binders);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Binders);
   begin
      Result.Ada_Node := Ada_Node;
      pragma Assert (Binders'Length > 0);
      Result.BS_Binders := New_List;
      for J in Binders'Range loop
         pragma Assert
           (Binder_Id_Kind_Valid
            (Binders (J)));
         pragma Assert
           (Binder_Id_Valid
            (Binders (J)));
         Append
           (Result.BS_Binders,
            Binders (J));
      end loop;
      Set_Link (Result.BS_Binders, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Binders;

   ----------------
   -- New_Binder --
   ----------------

   function New_Binder
     (Ada_Node : Node_Id := Empty;
      Names    : W_Identifier_Array;
      Arg_Type : W_Value_Type_Id)
     return W_Binder_Id
   is
      Result : Why_Node (W_Binder);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Binder);
   begin
      Result.Ada_Node := Ada_Node;
      pragma Assert (Names'Length > 0);
      Result.B_Names := New_List;
      for J in Names'Range loop
         pragma Assert
           (Identifier_Id_Kind_Valid
            (Names (J)));
         pragma Assert
           (Identifier_Id_Valid
            (Names (J)));
         Append
           (Result.B_Names,
            Names (J));
      end loop;
      Set_Link (Result.B_Names, New_Id);
      Result.B_Arg_Type := Arg_Type;
      Set_Link (Result.B_Arg_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Binder;

   ----------------
   -- New_Recfun --
   ----------------

   function New_Recfun
     (Ada_Node    : Node_Id := Empty;
      Name        : W_Identifier_Id;
      Binders     : W_Binders_Id;
      Return_Type : W_Prog_Id;
      Variant     : W_Wf_Arg_Id;
      Pre         : W_Precondition_Id;
      Def         : W_Prog_Id)
     return W_Recfun_Id
   is
      Result : Why_Node (W_Recfun);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Recfun);
   begin
      Result.Ada_Node := Ada_Node;
      Result.RF_Name := Name;
      Set_Link (Result.RF_Name, New_Id);
      Result.RF_Binders := Binders;
      Set_Link (Result.RF_Binders, New_Id);
      Result.RF_Return_Type := Return_Type;
      Set_Link (Result.RF_Return_Type, New_Id);
      Result.RF_Variant := Variant;
      Set_Link (Result.RF_Variant, New_Id);
      Result.RF_Pre := Pre;
      Set_Link (Result.RF_Pre, New_Id);
      Result.RF_Def := Def;
      Set_Link (Result.RF_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Recfun;

   --------------------
   -- New_Loop_Annot --
   --------------------

   function New_Loop_Annot
     (Ada_Node  : Node_Id := Empty;
      Invariant : W_Assertion_OId := Why_Empty;
      Variant   : W_Wf_Arg_OId := Why_Empty)
     return W_Loop_Annot_Id
   is
      Result : Why_Node (W_Loop_Annot);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Loop_Annot);
   begin
      Result.Ada_Node := Ada_Node;
      Result.LA_Invariant := Invariant;
      Set_Link (Result.LA_Invariant, New_Id);
      Result.LA_Variant := Variant;
      Set_Link (Result.LA_Variant, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Loop_Annot;

   ----------------
   -- New_Wf_Arg --
   ----------------

   function New_Wf_Arg
     (Ada_Node : Node_Id := Empty;
      Def      : W_Term_Id;
      For_Id   : W_Identifier_OId := Why_Empty)
     return W_Wf_Arg_Id
   is
      Result : Why_Node (W_Wf_Arg);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Wf_Arg);
   begin
      Result.Ada_Node := Ada_Node;
      Result.WA_Def := Def;
      Set_Link (Result.WA_Def, New_Id);
      Result.WA_For_Id := For_Id;
      Set_Link (Result.WA_For_Id, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Wf_Arg;

   -----------------
   -- New_Handler --
   -----------------

   function New_Handler
     (Ada_Node  : Node_Id := Empty;
      Name      : W_Identifier_Id;
      Parameter : W_Prog_OId := Why_Empty;
      Def       : W_Prog_Id)
     return W_Handler_Id
   is
      Result : Why_Node (W_Handler);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Handler);
   begin
      Result.Ada_Node := Ada_Node;
      Result.H_Name := Name;
      Set_Link (Result.H_Name, New_Id);
      Result.H_Parameter := Parameter;
      Set_Link (Result.H_Parameter, New_Id);
      Result.H_Def := Def;
      Set_Link (Result.H_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Handler;

   --------------
   -- New_File --
   --------------

   function New_File
     (Ada_Node     : Node_Id := Empty;
      Declarations : W_Declaration_Array := (2 .. 1 => <>))
     return W_File_Id
   is
      Result : Why_Node (W_File);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_File);
   begin
      Result.Ada_Node := Ada_Node;
      Result.F_Declarations := New_List;
      for J in Declarations'Range loop
         pragma Assert
           (Declaration_Id_Kind_Valid
            (Declarations (J)));
         pragma Assert
           (Declaration_Id_Valid
            (Declarations (J)));
         Append
           (Result.F_Declarations,
            Declarations (J));
      end loop;
      Set_Link (Result.F_Declarations, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_File;

   ------------------------
   -- New_Global_Binding --
   ------------------------

   function New_Global_Binding
     (Ada_Node : Node_Id := Empty;
      Name     : W_Identifier_Id;
      Binders  : W_Binders_OId := Why_Empty;
      Pre      : W_Precondition_Id;
      Def      : W_Prog_Id)
     return W_Global_Binding_Id
   is
      Result : Why_Node (W_Global_Binding);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Global_Binding);
   begin
      Result.Ada_Node := Ada_Node;
      Result.GB_Name := Name;
      Set_Link (Result.GB_Name, New_Id);
      Result.GB_Binders := Binders;
      Set_Link (Result.GB_Binders, New_Id);
      Result.GB_Pre := Pre;
      Set_Link (Result.GB_Pre, New_Id);
      Result.GB_Def := Def;
      Set_Link (Result.GB_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Global_Binding;

   ----------------------------
   -- New_Global_Rec_Binding --
   ----------------------------

   function New_Global_Rec_Binding
     (Ada_Node : Node_Id := Empty;
      Name     : W_Recfun_Id)
     return W_Global_Rec_Binding_Id
   is
      Result : Why_Node (W_Global_Rec_Binding);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Global_Rec_Binding);
   begin
      Result.Ada_Node := Ada_Node;
      Result.GRB_Name := Name;
      Set_Link (Result.GRB_Name, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Global_Rec_Binding;

   -------------------------------
   -- New_Parameter_Declaration --
   -------------------------------

   function New_Parameter_Declaration
     (Ada_Node       : Node_Id := Empty;
      External       : W_External_Id;
      Names          : W_Identifier_Array;
      Parameter_Type : W_Value_Type_Id)
     return W_Parameter_Declaration_Id
   is
      Result : Why_Node (W_Parameter_Declaration);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Parameter_Declaration);
   begin
      Result.Ada_Node := Ada_Node;
      Result.PD_External := External;
      Set_Link (Result.PD_External, New_Id);
      pragma Assert (Names'Length > 0);
      Result.PD_Names := New_List;
      for J in Names'Range loop
         pragma Assert
           (Identifier_Id_Kind_Valid
            (Names (J)));
         pragma Assert
           (Identifier_Id_Valid
            (Names (J)));
         Append
           (Result.PD_Names,
            Names (J));
      end loop;
      Set_Link (Result.PD_Names, New_Id);
      Result.PD_Parameter_Type := Parameter_Type;
      Set_Link (Result.PD_Parameter_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Parameter_Declaration;

   -------------------------------
   -- New_Exception_Declaration --
   -------------------------------

   function New_Exception_Declaration
     (Ada_Node  : Node_Id := Empty;
      Name      : W_Identifier_Id;
      Parameter : W_Primitive_Type_OId := Why_Empty)
     return W_Exception_Declaration_Id
   is
      Result : Why_Node (W_Exception_Declaration);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Exception_Declaration);
   begin
      Result.Ada_Node := Ada_Node;
      Result.ED_Name := Name;
      Set_Link (Result.ED_Name, New_Id);
      Result.ED_Parameter := Parameter;
      Set_Link (Result.ED_Parameter, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Exception_Declaration;

   ---------------------------
   -- New_Logic_Declaration --
   ---------------------------

   function New_Logic_Declaration
     (Ada_Node : Node_Id := Empty;
      Decl     : W_Logic_Declaration_Class_Id)
     return W_Logic_Declaration_Id
   is
      Result : Why_Node (W_Logic_Declaration);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Logic_Declaration);
   begin
      Result.Ada_Node := Ada_Node;
      Result.LD_Decl := Decl;
      Set_Link (Result.LD_Decl, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := True;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Logic_Declaration;

   ------------------------------
   -- New_Unchecked_Identifier --
   ------------------------------

   function New_Unchecked_Identifier
     (Symbol : Name_Id)
     return W_Identifier_Unchecked_Id
   is
      Result : Why_Node (W_Identifier);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Identifier);
   begin
      Result.Ada_Node := Empty;
      Result.Symbol := Symbol;
      Result.Entity := Why_Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Identifier;

   -----------------------------
   -- New_Unchecked_Type_Prop --
   -----------------------------

   function New_Unchecked_Type_Prop
     return W_Type_Prop_Unchecked_Id
   is
      Result : Why_Node (W_Type_Prop);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Type_Prop);
   begin
      Result.Ada_Node := Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Type_Prop;

   ----------------------------
   -- New_Unchecked_Type_Int --
   ----------------------------

   function New_Unchecked_Type_Int
     return W_Type_Int_Unchecked_Id
   is
      Result : Why_Node (W_Type_Int);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Type_Int);
   begin
      Result.Ada_Node := Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Type_Int;

   -----------------------------
   -- New_Unchecked_Type_Bool --
   -----------------------------

   function New_Unchecked_Type_Bool
     return W_Type_Bool_Unchecked_Id
   is
      Result : Why_Node (W_Type_Bool);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Type_Bool);
   begin
      Result.Ada_Node := Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Type_Bool;

   -----------------------------
   -- New_Unchecked_Type_Real --
   -----------------------------

   function New_Unchecked_Type_Real
     return W_Type_Real_Unchecked_Id
   is
      Result : Why_Node (W_Type_Real);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Type_Real);
   begin
      Result.Ada_Node := Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Type_Real;

   -----------------------------
   -- New_Unchecked_Type_Unit --
   -----------------------------

   function New_Unchecked_Type_Unit
     return W_Type_Unit_Unchecked_Id
   is
      Result : Why_Node (W_Type_Unit);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Type_Unit);
   begin
      Result.Ada_Node := Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Type_Unit;

   ---------------------------------
   -- New_Unchecked_Abstract_Type --
   ---------------------------------

   function New_Unchecked_Abstract_Type
     return W_Abstract_Type_Unchecked_Id
   is
      Result : Why_Node (W_Abstract_Type);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Abstract_Type);
   begin
      Result.Ada_Node := Empty;
      Result.AT_Name := Why_Empty;
      Set_Link (Result.AT_Name, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Abstract_Type;

   ---------------------------------------
   -- New_Unchecked_Generic_Formal_Type --
   ---------------------------------------

   function New_Unchecked_Generic_Formal_Type
     return W_Generic_Formal_Type_Unchecked_Id
   is
      Result : Why_Node (W_Generic_Formal_Type);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Generic_Formal_Type);
   begin
      Result.Ada_Node := Empty;
      Result.GFT_Name := Why_Empty;
      Set_Link (Result.GFT_Name, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Generic_Formal_Type;

   ---------------------------------------------
   -- New_Unchecked_Generic_Actual_Type_Chain --
   ---------------------------------------------

   function New_Unchecked_Generic_Actual_Type_Chain
     return W_Generic_Actual_Type_Chain_Unchecked_Id
   is
      Result : Why_Node (W_Generic_Actual_Type_Chain);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Generic_Actual_Type_Chain);
   begin
      Result.Ada_Node := Empty;
      Result.GATC_Type_Chain := New_List;
      Set_Link (Result.GATC_Type_Chain, New_Id);
      Result.GATC_Name := Why_Empty;
      Set_Link (Result.GATC_Name, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Generic_Actual_Type_Chain;

   ------------------------------
   -- New_Unchecked_Array_Type --
   ------------------------------

   function New_Unchecked_Array_Type
     return W_Array_Type_Unchecked_Id
   is
      Result : Why_Node (W_Array_Type);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Array_Type);
   begin
      Result.Ada_Node := Empty;
      Result.AT_Component_Type := Why_Empty;
      Set_Link (Result.AT_Component_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Array_Type;

   ----------------------------
   -- New_Unchecked_Ref_Type --
   ----------------------------

   function New_Unchecked_Ref_Type
     return W_Ref_Type_Unchecked_Id
   is
      Result : Why_Node (W_Ref_Type);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Ref_Type);
   begin
      Result.Ada_Node := Empty;
      Result.RT_Aliased_Type := Why_Empty;
      Set_Link (Result.RT_Aliased_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Ref_Type;

   ----------------------------------------
   -- New_Unchecked_Protected_Value_Type --
   ----------------------------------------

   function New_Unchecked_Protected_Value_Type
     return W_Protected_Value_Type_Unchecked_Id
   is
      Result : Why_Node (W_Protected_Value_Type);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Protected_Value_Type);
   begin
      Result.Ada_Node := Empty;
      Result.PVT_Value_Type := Why_Empty;
      Set_Link (Result.PVT_Value_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Protected_Value_Type;

   ------------------------------
   -- New_Unchecked_Arrow_Type --
   ------------------------------

   function New_Unchecked_Arrow_Type
     return W_Arrow_Type_Unchecked_Id
   is
      Result : Why_Node (W_Arrow_Type);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Arrow_Type);
   begin
      Result.Ada_Node := Empty;
      Result.NA_Name := Why_Empty;
      Set_Link (Result.NA_Name, New_Id);
      Result.NA_Left := Why_Empty;
      Set_Link (Result.NA_Left, New_Id);
      Result.NA_Right := Why_Empty;
      Set_Link (Result.NA_Right, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Arrow_Type;

   ------------------------------------
   -- New_Unchecked_Computation_Spec --
   ------------------------------------

   function New_Unchecked_Computation_Spec
     return W_Computation_Spec_Unchecked_Id
   is
      Result : Why_Node (W_Computation_Spec);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Computation_Spec);
   begin
      Result.Ada_Node := Empty;
      Result.CS_Precondition := Why_Empty;
      Set_Link (Result.CS_Precondition, New_Id);
      Result.CS_Result_Name := Why_Empty;
      Set_Link (Result.CS_Result_Name, New_Id);
      Result.CS_Return_Type := Why_Empty;
      Set_Link (Result.CS_Return_Type, New_Id);
      Result.CS_Effects := Why_Empty;
      Set_Link (Result.CS_Effects, New_Id);
      Result.CS_Postcondition := Why_Empty;
      Set_Link (Result.CS_Postcondition, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Computation_Spec;

   ------------------------------------
   -- New_Unchecked_Integer_Constant --
   ------------------------------------

   function New_Unchecked_Integer_Constant
     (Value : Uint)
     return W_Integer_Constant_Unchecked_Id
   is
      Result : Why_Node (W_Integer_Constant);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Integer_Constant);
   begin
      Result.Ada_Node := Empty;
      Result.IC_Value := Value;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Integer_Constant;

   ---------------------------------
   -- New_Unchecked_Real_Constant --
   ---------------------------------

   function New_Unchecked_Real_Constant
     (Value : Ureal)
     return W_Real_Constant_Unchecked_Id
   is
      Result : Why_Node (W_Real_Constant);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Real_Constant);
   begin
      Result.Ada_Node := Empty;
      Result.RC_Value := Value;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Real_Constant;

   --------------------------------
   -- New_Unchecked_True_Literal --
   --------------------------------

   function New_Unchecked_True_Literal
     return W_True_Literal_Unchecked_Id
   is
      Result : Why_Node (W_True_Literal);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_True_Literal);
   begin
      Result.Ada_Node := Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_True_Literal;

   ---------------------------------
   -- New_Unchecked_False_Literal --
   ---------------------------------

   function New_Unchecked_False_Literal
     return W_False_Literal_Unchecked_Id
   is
      Result : Why_Node (W_False_Literal);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_False_Literal);
   begin
      Result.Ada_Node := Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_False_Literal;

   --------------------------------
   -- New_Unchecked_Void_Literal --
   --------------------------------

   function New_Unchecked_Void_Literal
     return W_Void_Literal_Unchecked_Id
   is
      Result : Why_Node (W_Void_Literal);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Void_Literal);
   begin
      Result.Ada_Node := Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Void_Literal;

   -----------------------------------
   -- New_Unchecked_Arith_Operation --
   -----------------------------------

   function New_Unchecked_Arith_Operation
     return W_Arith_Operation_Unchecked_Id
   is
      Result : Why_Node (W_Arith_Operation);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Arith_Operation);
   begin
      Result.Ada_Node := Empty;
      Result.AO_Left := Why_Empty;
      Set_Link (Result.AO_Left, New_Id);
      Result.AO_Op := Why_Empty;
      Set_Link (Result.AO_Op, New_Id);
      Result.AO_Right := Why_Empty;
      Set_Link (Result.AO_Right, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Arith_Operation;

   ---------------------------------
   -- New_Unchecked_Negative_Term --
   ---------------------------------

   function New_Unchecked_Negative_Term
     return W_Negative_Term_Unchecked_Id
   is
      Result : Why_Node (W_Negative_Term);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Negative_Term);
   begin
      Result.Ada_Node := Empty;
      Result.NT_Operand := Why_Empty;
      Set_Link (Result.NT_Operand, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Negative_Term;

   ------------------------------------
   -- New_Unchecked_Label_Identifier --
   ------------------------------------

   function New_Unchecked_Label_Identifier
     return W_Label_Identifier_Unchecked_Id
   is
      Result : Why_Node (W_Label_Identifier);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Label_Identifier);
   begin
      Result.Ada_Node := Empty;
      Result.TI_Name := Why_Empty;
      Set_Link (Result.TI_Name, New_Id);
      Result.TI_Label := Why_Empty;
      Set_Link (Result.TI_Label, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Label_Identifier;

   -----------------------------
   -- New_Unchecked_Operation --
   -----------------------------

   function New_Unchecked_Operation
     return W_Operation_Unchecked_Id
   is
      Result : Why_Node (W_Operation);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Operation);
   begin
      Result.Ada_Node := Empty;
      Result.O_Name := Why_Empty;
      Set_Link (Result.O_Name, New_Id);
      Result.O_Parameters := New_List;
      Set_Link (Result.O_Parameters, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Operation;

   ------------------------------
   -- New_Unchecked_Named_Term --
   ------------------------------

   function New_Unchecked_Named_Term
     return W_Named_Term_Unchecked_Id
   is
      Result : Why_Node (W_Named_Term);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Named_Term);
   begin
      Result.Ada_Node := Empty;
      Result.NT_Name := Why_Empty;
      Set_Link (Result.NT_Name, New_Id);
      Result.NT_Term := Why_Empty;
      Set_Link (Result.NT_Term, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Named_Term;

   ------------------------------------
   -- New_Unchecked_Conditional_Term --
   ------------------------------------

   function New_Unchecked_Conditional_Term
     return W_Conditional_Term_Unchecked_Id
   is
      Result : Why_Node (W_Conditional_Term);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Conditional_Term);
   begin
      Result.Ada_Node := Empty;
      Result.CT_Condition := Why_Empty;
      Set_Link (Result.CT_Condition, New_Id);
      Result.CT_Then_Part := Why_Empty;
      Set_Link (Result.CT_Then_Part, New_Id);
      Result.CT_Else_Part := Why_Empty;
      Set_Link (Result.CT_Else_Part, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Conditional_Term;

   ---------------------------------
   -- New_Unchecked_Matching_Term --
   ---------------------------------

   function New_Unchecked_Matching_Term
     return W_Matching_Term_Unchecked_Id
   is
      Result : Why_Node (W_Matching_Term);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Matching_Term);
   begin
      Result.Ada_Node := Empty;
      Result.MT_Term := Why_Empty;
      Set_Link (Result.MT_Term, New_Id);
      Result.MT_Branches := New_List;
      Set_Link (Result.MT_Branches, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Matching_Term;

   --------------------------------
   -- New_Unchecked_Binding_Term --
   --------------------------------

   function New_Unchecked_Binding_Term
     return W_Binding_Term_Unchecked_Id
   is
      Result : Why_Node (W_Binding_Term);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Binding_Term);
   begin
      Result.Ada_Node := Empty;
      Result.BT_Name := Why_Empty;
      Set_Link (Result.BT_Name, New_Id);
      Result.BT_Def := Why_Empty;
      Set_Link (Result.BT_Def, New_Id);
      Result.BT_Context := Why_Empty;
      Set_Link (Result.BT_Context, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Binding_Term;

   ----------------------------------
   -- New_Unchecked_Protected_Term --
   ----------------------------------

   function New_Unchecked_Protected_Term
     return W_Protected_Term_Unchecked_Id
   is
      Result : Why_Node (W_Protected_Term);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Protected_Term);
   begin
      Result.Ada_Node := Empty;
      Result.BT_Term := Why_Empty;
      Set_Link (Result.BT_Term, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Protected_Term;

   --------------------------
   -- New_Unchecked_Op_Add --
   --------------------------

   function New_Unchecked_Op_Add
     return W_Op_Add_Unchecked_Id
   is
      Result : Why_Node (W_Op_Add);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Add);
   begin
      Result.Ada_Node := Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Op_Add;

   --------------------------------
   -- New_Unchecked_Op_Substract --
   --------------------------------

   function New_Unchecked_Op_Substract
     return W_Op_Substract_Unchecked_Id
   is
      Result : Why_Node (W_Op_Substract);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Substract);
   begin
      Result.Ada_Node := Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Op_Substract;

   -------------------------------
   -- New_Unchecked_Op_Multiply --
   -------------------------------

   function New_Unchecked_Op_Multiply
     return W_Op_Multiply_Unchecked_Id
   is
      Result : Why_Node (W_Op_Multiply);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Multiply);
   begin
      Result.Ada_Node := Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Op_Multiply;

   -----------------------------
   -- New_Unchecked_Op_Divide --
   -----------------------------

   function New_Unchecked_Op_Divide
     return W_Op_Divide_Unchecked_Id
   is
      Result : Why_Node (W_Op_Divide);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Divide);
   begin
      Result.Ada_Node := Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Op_Divide;

   -----------------------------
   -- New_Unchecked_Op_Modulo --
   -----------------------------

   function New_Unchecked_Op_Modulo
     return W_Op_Modulo_Unchecked_Id
   is
      Result : Why_Node (W_Op_Modulo);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Modulo);
   begin
      Result.Ada_Node := Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Op_Modulo;

   -------------------------------------
   -- New_Unchecked_True_Literal_Pred --
   -------------------------------------

   function New_Unchecked_True_Literal_Pred
     return W_True_Literal_Pred_Unchecked_Id
   is
      Result : Why_Node (W_True_Literal_Pred);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_True_Literal_Pred);
   begin
      Result.Ada_Node := Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_True_Literal_Pred;

   --------------------------------------
   -- New_Unchecked_False_Literal_Pred --
   --------------------------------------

   function New_Unchecked_False_Literal_Pred
     return W_False_Literal_Pred_Unchecked_Id
   is
      Result : Why_Node (W_False_Literal_Pred);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_False_Literal_Pred);
   begin
      Result.Ada_Node := Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_False_Literal_Pred;

   ----------------------------------------
   -- New_Unchecked_Predicate_Identifier --
   ----------------------------------------

   function New_Unchecked_Predicate_Identifier
     return W_Predicate_Identifier_Unchecked_Id
   is
      Result : Why_Node (W_Predicate_Identifier);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Predicate_Identifier);
   begin
      Result.Ada_Node := Empty;
      Result.PID_Name := Why_Empty;
      Set_Link (Result.PID_Name, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Predicate_Identifier;

   --------------------------------------
   -- New_Unchecked_Predicate_Instance --
   --------------------------------------

   function New_Unchecked_Predicate_Instance
     return W_Predicate_Instance_Unchecked_Id
   is
      Result : Why_Node (W_Predicate_Instance);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Predicate_Instance);
   begin
      Result.Ada_Node := Empty;
      Result.PIN_Name := Why_Empty;
      Set_Link (Result.PIN_Name, New_Id);
      Result.PIN_Parameters := New_List;
      Set_Link (Result.PIN_Parameters, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Predicate_Instance;

   ---------------------------------
   -- New_Unchecked_Related_Terms --
   ---------------------------------

   function New_Unchecked_Related_Terms
     return W_Related_Terms_Unchecked_Id
   is
      Result : Why_Node (W_Related_Terms);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Related_Terms);
   begin
      Result.Ada_Node := Empty;
      Result.RT_Left := Why_Empty;
      Set_Link (Result.RT_Left, New_Id);
      Result.RT_Op := Why_Empty;
      Set_Link (Result.RT_Op, New_Id);
      Result.RT_Right := Why_Empty;
      Set_Link (Result.RT_Right, New_Id);
      Result.RT_Op2 := Why_Empty;
      Set_Link (Result.RT_Op2, New_Id);
      Result.RT_Right2 := Why_Empty;
      Set_Link (Result.RT_Right2, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Related_Terms;

   -------------------------------
   -- New_Unchecked_Implication --
   -------------------------------

   function New_Unchecked_Implication
     return W_Implication_Unchecked_Id
   is
      Result : Why_Node (W_Implication);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Implication);
   begin
      Result.Ada_Node := Empty;
      Result.ITOC_Left := Why_Empty;
      Set_Link (Result.ITOC_Left, New_Id);
      Result.ITOC_Right := Why_Empty;
      Set_Link (Result.ITOC_Right, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Implication;

   -------------------------------
   -- New_Unchecked_Equivalence --
   -------------------------------

   function New_Unchecked_Equivalence
     return W_Equivalence_Unchecked_Id
   is
      Result : Why_Node (W_Equivalence);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Equivalence);
   begin
      Result.Ada_Node := Empty;
      Result.ITOC_Left := Why_Empty;
      Set_Link (Result.ITOC_Left, New_Id);
      Result.ITOC_Right := Why_Empty;
      Set_Link (Result.ITOC_Right, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Equivalence;

   -------------------------------
   -- New_Unchecked_Disjonction --
   -------------------------------

   function New_Unchecked_Disjonction
     return W_Disjonction_Unchecked_Id
   is
      Result : Why_Node (W_Disjonction);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Disjonction);
   begin
      Result.Ada_Node := Empty;
      Result.ITOC_Left := Why_Empty;
      Set_Link (Result.ITOC_Left, New_Id);
      Result.ITOC_Right := Why_Empty;
      Set_Link (Result.ITOC_Right, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Disjonction;

   -------------------------------
   -- New_Unchecked_Conjonction --
   -------------------------------

   function New_Unchecked_Conjonction
     return W_Conjonction_Unchecked_Id
   is
      Result : Why_Node (W_Conjonction);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Conjonction);
   begin
      Result.Ada_Node := Empty;
      Result.ITOC_Left := Why_Empty;
      Set_Link (Result.ITOC_Left, New_Id);
      Result.ITOC_Right := Why_Empty;
      Set_Link (Result.ITOC_Right, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Conjonction;

   ----------------------------
   -- New_Unchecked_Negation --
   ----------------------------

   function New_Unchecked_Negation
     return W_Negation_Unchecked_Id
   is
      Result : Why_Node (W_Negation);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Negation);
   begin
      Result.Ada_Node := Empty;
      Result.N_Operand := Why_Empty;
      Set_Link (Result.N_Operand, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Negation;

   ------------------------------------
   -- New_Unchecked_Conditional_Pred --
   ------------------------------------

   function New_Unchecked_Conditional_Pred
     return W_Conditional_Pred_Unchecked_Id
   is
      Result : Why_Node (W_Conditional_Pred);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Conditional_Pred);
   begin
      Result.Ada_Node := Empty;
      Result.CPD_Condition := Why_Empty;
      Set_Link (Result.CPD_Condition, New_Id);
      Result.CPD_Then_Part := Why_Empty;
      Set_Link (Result.CPD_Then_Part, New_Id);
      Result.CPD_Else_Part := Why_Empty;
      Set_Link (Result.CPD_Else_Part, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Conditional_Pred;

   --------------------------------
   -- New_Unchecked_Binding_Pred --
   --------------------------------

   function New_Unchecked_Binding_Pred
     return W_Binding_Pred_Unchecked_Id
   is
      Result : Why_Node (W_Binding_Pred);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Binding_Pred);
   begin
      Result.Ada_Node := Empty;
      Result.BPD_Name := Why_Empty;
      Set_Link (Result.BPD_Name, New_Id);
      Result.BPD_Def := Why_Empty;
      Set_Link (Result.BPD_Def, New_Id);
      Result.BPD_Context := Why_Empty;
      Set_Link (Result.BPD_Context, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Binding_Pred;

   -------------------------------------
   -- New_Unchecked_Universal_Quantif --
   -------------------------------------

   function New_Unchecked_Universal_Quantif
     return W_Universal_Quantif_Unchecked_Id
   is
      Result : Why_Node (W_Universal_Quantif);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Universal_Quantif);
   begin
      Result.Ada_Node := Empty;
      Result.UQ_Variables := New_List;
      Set_Link (Result.UQ_Variables, New_Id);
      Result.UQ_Var_Type := Why_Empty;
      Set_Link (Result.UQ_Var_Type, New_Id);
      Result.UQ_Triggers := Why_Empty;
      Set_Link (Result.UQ_Triggers, New_Id);
      Result.UQ_Pred := Why_Empty;
      Set_Link (Result.UQ_Pred, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Universal_Quantif;

   ---------------------------------------
   -- New_Unchecked_Existential_Quantif --
   ---------------------------------------

   function New_Unchecked_Existential_Quantif
     return W_Existential_Quantif_Unchecked_Id
   is
      Result : Why_Node (W_Existential_Quantif);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Existential_Quantif);
   begin
      Result.Ada_Node := Empty;
      Result.EQ_Variables := New_List;
      Set_Link (Result.EQ_Variables, New_Id);
      Result.EQ_Var_Type := Why_Empty;
      Set_Link (Result.EQ_Var_Type, New_Id);
      Result.EQ_Pred := Why_Empty;
      Set_Link (Result.EQ_Pred, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Existential_Quantif;

   -----------------------------------
   -- New_Unchecked_Named_Predicate --
   -----------------------------------

   function New_Unchecked_Named_Predicate
     return W_Named_Predicate_Unchecked_Id
   is
      Result : Why_Node (W_Named_Predicate);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Named_Predicate);
   begin
      Result.Ada_Node := Empty;
      Result.NP_Name := Why_Empty;
      Set_Link (Result.NP_Name, New_Id);
      Result.NP_Pred := Why_Empty;
      Set_Link (Result.NP_Pred, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Named_Predicate;

   ---------------------------------------
   -- New_Unchecked_Protected_Predicate --
   ---------------------------------------

   function New_Unchecked_Protected_Predicate
     return W_Protected_Predicate_Unchecked_Id
   is
      Result : Why_Node (W_Protected_Predicate);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Protected_Predicate);
   begin
      Result.Ada_Node := Empty;
      Result.PP_Pred := Why_Empty;
      Set_Link (Result.PP_Pred, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Protected_Predicate;

   ---------------------------
   -- New_Unchecked_Pattern --
   ---------------------------

   function New_Unchecked_Pattern
     return W_Pattern_Unchecked_Id
   is
      Result : Why_Node (W_Pattern);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Pattern);
   begin
      Result.Ada_Node := Empty;
      Result.PAT_Constr := Why_Empty;
      Set_Link (Result.PAT_Constr, New_Id);
      Result.PAT_Args := New_List;
      Set_Link (Result.PAT_Args, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Pattern;

   ------------------------------
   -- New_Unchecked_Match_Case --
   ------------------------------

   function New_Unchecked_Match_Case
     return W_Match_Case_Unchecked_Id
   is
      Result : Why_Node (W_Match_Case);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Match_Case);
   begin
      Result.Ada_Node := Empty;
      Result.MC_Pattern := Why_Empty;
      Set_Link (Result.MC_Pattern, New_Id);
      Result.MC_Term := Why_Empty;
      Set_Link (Result.MC_Term, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Match_Case;

   ----------------------------
   -- New_Unchecked_Triggers --
   ----------------------------

   function New_Unchecked_Triggers
     return W_Triggers_Unchecked_Id
   is
      Result : Why_Node (W_Triggers);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Triggers);
   begin
      Result.Ada_Node := Empty;
      Result.TRS_Triggers := New_List;
      Set_Link (Result.TRS_Triggers, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Triggers;

   ---------------------------
   -- New_Unchecked_Trigger --
   ---------------------------

   function New_Unchecked_Trigger
     return W_Trigger_Unchecked_Id
   is
      Result : Why_Node (W_Trigger);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Trigger);
   begin
      Result.Ada_Node := Empty;
      Result.TRI_Terms := New_List;
      Set_Link (Result.TRI_Terms, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Trigger;

   --------------------------
   -- New_Unchecked_Rel_Eq --
   --------------------------

   function New_Unchecked_Rel_Eq
     return W_Rel_Eq_Unchecked_Id
   is
      Result : Why_Node (W_Rel_Eq);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Rel_Eq);
   begin
      Result.Ada_Node := Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Rel_Eq;

   --------------------------
   -- New_Unchecked_Rel_Ne --
   --------------------------

   function New_Unchecked_Rel_Ne
     return W_Rel_Ne_Unchecked_Id
   is
      Result : Why_Node (W_Rel_Ne);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Rel_Ne);
   begin
      Result.Ada_Node := Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Rel_Ne;

   --------------------------
   -- New_Unchecked_Rel_Lt --
   --------------------------

   function New_Unchecked_Rel_Lt
     return W_Rel_Lt_Unchecked_Id
   is
      Result : Why_Node (W_Rel_Lt);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Rel_Lt);
   begin
      Result.Ada_Node := Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Rel_Lt;

   --------------------------
   -- New_Unchecked_Rel_Le --
   --------------------------

   function New_Unchecked_Rel_Le
     return W_Rel_Le_Unchecked_Id
   is
      Result : Why_Node (W_Rel_Le);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Rel_Le);
   begin
      Result.Ada_Node := Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Rel_Le;

   --------------------------
   -- New_Unchecked_Rel_Gt --
   --------------------------

   function New_Unchecked_Rel_Gt
     return W_Rel_Gt_Unchecked_Id
   is
      Result : Why_Node (W_Rel_Gt);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Rel_Gt);
   begin
      Result.Ada_Node := Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Rel_Gt;

   --------------------------
   -- New_Unchecked_Rel_Ge --
   --------------------------

   function New_Unchecked_Rel_Ge
     return W_Rel_Ge_Unchecked_Id
   is
      Result : Why_Node (W_Rel_Ge);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Rel_Ge);
   begin
      Result.Ada_Node := Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Rel_Ge;

   ------------------------
   -- New_Unchecked_Type --
   ------------------------

   function New_Unchecked_Type
     return W_Type_Unchecked_Id
   is
      Result : Why_Node (W_Type);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Type);
   begin
      Result.Ada_Node := Empty;
      Result.T_External := Why_Empty;
      Set_Link (Result.T_External, New_Id);
      Result.T_Type_Parameters := New_List;
      Set_Link (Result.T_Type_Parameters, New_Id);
      Result.T_Name := Why_Empty;
      Set_Link (Result.T_Name, New_Id);
      Result.T_Definition := Why_Empty;
      Set_Link (Result.T_Definition, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Type;

   -------------------------
   -- New_Unchecked_Logic --
   -------------------------

   function New_Unchecked_Logic
     return W_Logic_Unchecked_Id
   is
      Result : Why_Node (W_Logic);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Logic);
   begin
      Result.Ada_Node := Empty;
      Result.L_External := Why_Empty;
      Set_Link (Result.L_External, New_Id);
      Result.L_Names := New_List;
      Set_Link (Result.L_Names, New_Id);
      Result.L_Logic_Type := Why_Empty;
      Set_Link (Result.L_Logic_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Logic;

   ----------------------------
   -- New_Unchecked_Function --
   ----------------------------

   function New_Unchecked_Function
     return W_Function_Unchecked_Id
   is
      Result : Why_Node (W_Function);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Function);
   begin
      Result.Ada_Node := Empty;
      Result.F_Name := Why_Empty;
      Set_Link (Result.F_Name, New_Id);
      Result.F_Binders := New_List;
      Set_Link (Result.F_Binders, New_Id);
      Result.F_Return_Type := Why_Empty;
      Set_Link (Result.F_Return_Type, New_Id);
      Result.F_Def := Why_Empty;
      Set_Link (Result.F_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Function;

   ----------------------------------------
   -- New_Unchecked_Predicate_Definition --
   ----------------------------------------

   function New_Unchecked_Predicate_Definition
     return W_Predicate_Definition_Unchecked_Id
   is
      Result : Why_Node (W_Predicate_Definition);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Predicate_Definition);
   begin
      Result.Ada_Node := Empty;
      Result.P_Name := Why_Empty;
      Set_Link (Result.P_Name, New_Id);
      Result.P_Binders := New_List;
      Set_Link (Result.P_Binders, New_Id);
      Result.P_Def := Why_Empty;
      Set_Link (Result.P_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Predicate_Definition;

   -----------------------------
   -- New_Unchecked_Inductive --
   -----------------------------

   function New_Unchecked_Inductive
     return W_Inductive_Unchecked_Id
   is
      Result : Why_Node (W_Inductive);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Inductive);
   begin
      Result.Ada_Node := Empty;
      Result.I_Name := Why_Empty;
      Set_Link (Result.I_Name, New_Id);
      Result.I_Logic_Type := Why_Empty;
      Set_Link (Result.I_Logic_Type, New_Id);
      Result.I_Def := New_List;
      Set_Link (Result.I_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Inductive;

   -------------------------
   -- New_Unchecked_Axiom --
   -------------------------

   function New_Unchecked_Axiom
     return W_Axiom_Unchecked_Id
   is
      Result : Why_Node (W_Axiom);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Axiom);
   begin
      Result.Ada_Node := Empty;
      Result.AX_Name := Why_Empty;
      Set_Link (Result.AX_Name, New_Id);
      Result.AX_Def := Why_Empty;
      Set_Link (Result.AX_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Axiom;

   ------------------------
   -- New_Unchecked_Goal --
   ------------------------

   function New_Unchecked_Goal
     return W_Goal_Unchecked_Id
   is
      Result : Why_Node (W_Goal);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Goal);
   begin
      Result.Ada_Node := Empty;
      Result.G_Name := Why_Empty;
      Set_Link (Result.G_Name, New_Id);
      Result.G_Def := Why_Empty;
      Set_Link (Result.G_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Goal;

   ----------------------------
   -- New_Unchecked_External --
   ----------------------------

   function New_Unchecked_External
     return W_External_Unchecked_Id
   is
      Result : Why_Node (W_External);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_External);
   begin
      Result.Ada_Node := Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_External;

   ------------------------------
   -- New_Unchecked_Logic_Type --
   ------------------------------

   function New_Unchecked_Logic_Type
     return W_Logic_Type_Unchecked_Id
   is
      Result : Why_Node (W_Logic_Type);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Logic_Type);
   begin
      Result.Ada_Node := Empty;
      Result.LT_Arg_Types := New_List;
      Set_Link (Result.LT_Arg_Types, New_Id);
      Result.LT_Return_Type := Why_Empty;
      Set_Link (Result.LT_Return_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Logic_Type;

   --------------------------------
   -- New_Unchecked_Logic_Binder --
   --------------------------------

   function New_Unchecked_Logic_Binder
     return W_Logic_Binder_Unchecked_Id
   is
      Result : Why_Node (W_Logic_Binder);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Logic_Binder);
   begin
      Result.Ada_Node := Empty;
      Result.LB_Name := Why_Empty;
      Set_Link (Result.LB_Name, New_Id);
      Result.LB_Param_Type := Why_Empty;
      Set_Link (Result.LB_Param_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Logic_Binder;

   ----------------------------------
   -- New_Unchecked_Inductive_Case --
   ----------------------------------

   function New_Unchecked_Inductive_Case
     return W_Inductive_Case_Unchecked_Id
   is
      Result : Why_Node (W_Inductive_Case);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Inductive_Case);
   begin
      Result.Ada_Node := Empty;
      Result.IC_Name := Why_Empty;
      Set_Link (Result.IC_Name, New_Id);
      Result.IC_Pred := Why_Empty;
      Set_Link (Result.IC_Pred, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Inductive_Case;

   -----------------------------------------------
   -- New_Unchecked_Transparent_Type_Definition --
   -----------------------------------------------

   function New_Unchecked_Transparent_Type_Definition
     return W_Transparent_Type_Definition_Unchecked_Id
   is
      Result : Why_Node (W_Transparent_Type_Definition);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Transparent_Type_Definition);
   begin
      Result.Ada_Node := Empty;
      Result.Tr_Type_Definition := Why_Empty;
      Set_Link (Result.Tr_Type_Definition, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Transparent_Type_Definition;

   ----------------------------------
   -- New_Unchecked_Adt_Definition --
   ----------------------------------

   function New_Unchecked_Adt_Definition
     return W_Adt_Definition_Unchecked_Id
   is
      Result : Why_Node (W_Adt_Definition);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Adt_Definition);
   begin
      Result.Ada_Node := Empty;
      Result.Adt_Constructors := New_List;
      Set_Link (Result.Adt_Constructors, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Adt_Definition;

   -------------------------------
   -- New_Unchecked_Constr_Decl --
   -------------------------------

   function New_Unchecked_Constr_Decl
     return W_Constr_Decl_Unchecked_Id
   is
      Result : Why_Node (W_Constr_Decl);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Constr_Decl);
   begin
      Result.Ada_Node := Empty;
      Result.C_Name := Why_Empty;
      Set_Link (Result.C_Name, New_Id);
      Result.C_Arg_List := New_List;
      Set_Link (Result.C_Arg_List, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Constr_Decl;

   ---------------------------
   -- New_Unchecked_Effects --
   ---------------------------

   function New_Unchecked_Effects
     return W_Effects_Unchecked_Id
   is
      Result : Why_Node (W_Effects);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Effects);
   begin
      Result.Ada_Node := Empty;
      Result.E_Reads := New_List;
      Set_Link (Result.E_Reads, New_Id);
      Result.E_Writes := New_List;
      Set_Link (Result.E_Writes, New_Id);
      Result.E_Raises := New_List;
      Set_Link (Result.E_Raises, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Effects;

   --------------------------------
   -- New_Unchecked_Precondition --
   --------------------------------

   function New_Unchecked_Precondition
     return W_Precondition_Unchecked_Id
   is
      Result : Why_Node (W_Precondition);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Precondition);
   begin
      Result.Ada_Node := Empty;
      Result.PRE_Assertion := Why_Empty;
      Set_Link (Result.PRE_Assertion, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Precondition;

   ---------------------------------
   -- New_Unchecked_Postcondition --
   ---------------------------------

   function New_Unchecked_Postcondition
     return W_Postcondition_Unchecked_Id
   is
      Result : Why_Node (W_Postcondition);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Postcondition);
   begin
      Result.Ada_Node := Empty;
      Result.POST_Assertion := Why_Empty;
      Set_Link (Result.POST_Assertion, New_Id);
      Result.POST_Handlers := New_List;
      Set_Link (Result.POST_Handlers, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Postcondition;

   ---------------------------------
   -- New_Unchecked_Exn_Condition --
   ---------------------------------

   function New_Unchecked_Exn_Condition
     return W_Exn_Condition_Unchecked_Id
   is
      Result : Why_Node (W_Exn_Condition);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Exn_Condition);
   begin
      Result.Ada_Node := Empty;
      Result.EC_Exn_Case := Why_Empty;
      Set_Link (Result.EC_Exn_Case, New_Id);
      Result.EC_Assertion := Why_Empty;
      Set_Link (Result.EC_Assertion, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Exn_Condition;

   -----------------------------
   -- New_Unchecked_Assertion --
   -----------------------------

   function New_Unchecked_Assertion
     return W_Assertion_Unchecked_Id
   is
      Result : Why_Node (W_Assertion);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Assertion);
   begin
      Result.Ada_Node := Empty;
      Result.A_Pred := Why_Empty;
      Set_Link (Result.A_Pred, New_Id);
      Result.A_As := Why_Empty;
      Set_Link (Result.A_As, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Assertion;

   ---------------------------------
   -- New_Unchecked_Prog_Constant --
   ---------------------------------

   function New_Unchecked_Prog_Constant
     return W_Prog_Constant_Unchecked_Id
   is
      Result : Why_Node (W_Prog_Constant);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Prog_Constant);
   begin
      Result.Ada_Node := Empty;
      Result.PC_Def := Why_Empty;
      Set_Link (Result.PC_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Prog_Constant;

   -----------------------------------
   -- New_Unchecked_Prog_Identifier --
   -----------------------------------

   function New_Unchecked_Prog_Identifier
     return W_Prog_Identifier_Unchecked_Id
   is
      Result : Why_Node (W_Prog_Identifier);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Prog_Identifier);
   begin
      Result.Ada_Node := Empty;
      Result.PI_Def := Why_Empty;
      Set_Link (Result.PI_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Prog_Identifier;

   -------------------------
   -- New_Unchecked_Deref --
   -------------------------

   function New_Unchecked_Deref
     return W_Deref_Unchecked_Id
   is
      Result : Why_Node (W_Deref);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Deref);
   begin
      Result.Ada_Node := Empty;
      Result.D_Ref := Why_Empty;
      Set_Link (Result.D_Ref, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Deref;

   ------------------------------
   -- New_Unchecked_Assignment --
   ------------------------------

   function New_Unchecked_Assignment
     return W_Assignment_Unchecked_Id
   is
      Result : Why_Node (W_Assignment);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Assignment);
   begin
      Result.Ada_Node := Empty;
      Result.A_Name := Why_Empty;
      Set_Link (Result.A_Name, New_Id);
      Result.A_Value := Why_Empty;
      Set_Link (Result.A_Value, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Assignment;

   --------------------------------
   -- New_Unchecked_Array_Access --
   --------------------------------

   function New_Unchecked_Array_Access
     return W_Array_Access_Unchecked_Id
   is
      Result : Why_Node (W_Array_Access);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Array_Access);
   begin
      Result.Ada_Node := Empty;
      Result.AA_Name := Why_Empty;
      Set_Link (Result.AA_Name, New_Id);
      Result.AA_Index := Why_Empty;
      Set_Link (Result.AA_Index, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Array_Access;

   --------------------------------
   -- New_Unchecked_Array_Update --
   --------------------------------

   function New_Unchecked_Array_Update
     return W_Array_Update_Unchecked_Id
   is
      Result : Why_Node (W_Array_Update);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Array_Update);
   begin
      Result.Ada_Node := Empty;
      Result.AU_Name := Why_Empty;
      Set_Link (Result.AU_Name, New_Id);
      Result.AU_Index := Why_Empty;
      Set_Link (Result.AU_Index, New_Id);
      Result.AU_Value := Why_Empty;
      Set_Link (Result.AU_Value, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Array_Update;

   ------------------------------
   -- New_Unchecked_Infix_Call --
   ------------------------------

   function New_Unchecked_Infix_Call
     return W_Infix_Call_Unchecked_Id
   is
      Result : Why_Node (W_Infix_Call);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Infix_Call);
   begin
      Result.Ada_Node := Empty;
      Result.IC_Left := Why_Empty;
      Set_Link (Result.IC_Left, New_Id);
      Result.IC_Infix := Why_Empty;
      Set_Link (Result.IC_Infix, New_Id);
      Result.IC_Right := Why_Empty;
      Set_Link (Result.IC_Right, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Infix_Call;

   -------------------------------
   -- New_Unchecked_Prefix_Call --
   -------------------------------

   function New_Unchecked_Prefix_Call
     return W_Prefix_Call_Unchecked_Id
   is
      Result : Why_Node (W_Prefix_Call);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Prefix_Call);
   begin
      Result.Ada_Node := Empty;
      Result.PC_Prefix := Why_Empty;
      Set_Link (Result.PC_Prefix, New_Id);
      Result.PC_Operand := Why_Empty;
      Set_Link (Result.PC_Operand, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Prefix_Call;

   --------------------------------
   -- New_Unchecked_Binding_Prog --
   --------------------------------

   function New_Unchecked_Binding_Prog
     return W_Binding_Prog_Unchecked_Id
   is
      Result : Why_Node (W_Binding_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Binding_Prog);
   begin
      Result.Ada_Node := Empty;
      Result.BPG_Name := Why_Empty;
      Set_Link (Result.BPG_Name, New_Id);
      Result.BPG_Def := Why_Empty;
      Set_Link (Result.BPG_Def, New_Id);
      Result.BPG_Context := Why_Empty;
      Set_Link (Result.BPG_Context, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Binding_Prog;

   -------------------------------
   -- New_Unchecked_Binding_Ref --
   -------------------------------

   function New_Unchecked_Binding_Ref
     return W_Binding_Ref_Unchecked_Id
   is
      Result : Why_Node (W_Binding_Ref);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Binding_Ref);
   begin
      Result.Ada_Node := Empty;
      Result.BPG_Name := Why_Empty;
      Set_Link (Result.BPG_Name, New_Id);
      Result.BPG_Def := Why_Empty;
      Set_Link (Result.BPG_Def, New_Id);
      Result.BPG_Context := Why_Empty;
      Set_Link (Result.BPG_Context, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Binding_Ref;

   ------------------------------------
   -- New_Unchecked_Conditional_Prog --
   ------------------------------------

   function New_Unchecked_Conditional_Prog
     return W_Conditional_Prog_Unchecked_Id
   is
      Result : Why_Node (W_Conditional_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Conditional_Prog);
   begin
      Result.Ada_Node := Empty;
      Result.CPG_Condition := Why_Empty;
      Set_Link (Result.CPG_Condition, New_Id);
      Result.CPG_Then_Part := Why_Empty;
      Set_Link (Result.CPG_Then_Part, New_Id);
      Result.CPG_Else_Part := Why_Empty;
      Set_Link (Result.CPG_Else_Part, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Conditional_Prog;

   ------------------------------
   -- New_Unchecked_While_Loop --
   ------------------------------

   function New_Unchecked_While_Loop
     return W_While_Loop_Unchecked_Id
   is
      Result : Why_Node (W_While_Loop);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_While_Loop);
   begin
      Result.Ada_Node := Empty;
      Result.WL_Condition := Why_Empty;
      Set_Link (Result.WL_Condition, New_Id);
      Result.WL_Annotation := Why_Empty;
      Set_Link (Result.WL_Annotation, New_Id);
      Result.WL_Loop_Content := Why_Empty;
      Set_Link (Result.WL_Loop_Content, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_While_Loop;

   --------------------------------------
   -- New_Unchecked_Statement_Sequence --
   --------------------------------------

   function New_Unchecked_Statement_Sequence
     return W_Statement_Sequence_Unchecked_Id
   is
      Result : Why_Node (W_Statement_Sequence);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Statement_Sequence);
   begin
      Result.Ada_Node := Empty;
      Result.SS_Statements := New_List;
      Set_Link (Result.SS_Statements, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Statement_Sequence;

   -------------------------
   -- New_Unchecked_Label --
   -------------------------

   function New_Unchecked_Label
     return W_Label_Unchecked_Id
   is
      Result : Why_Node (W_Label);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Label);
   begin
      Result.Ada_Node := Empty;
      Result.L_Name := Why_Empty;
      Set_Link (Result.L_Name, New_Id);
      Result.L_Def := Why_Empty;
      Set_Link (Result.L_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Label;

   --------------------------
   -- New_Unchecked_Assert --
   --------------------------

   function New_Unchecked_Assert
     return W_Assert_Unchecked_Id
   is
      Result : Why_Node (W_Assert);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Assert);
   begin
      Result.Ada_Node := Empty;
      Result.AS_Assertions := New_List;
      Set_Link (Result.AS_Assertions, New_Id);
      Result.AS_Prog := Why_Empty;
      Set_Link (Result.AS_Prog, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Assert;

   ----------------------------------
   -- New_Unchecked_Post_Assertion --
   ----------------------------------

   function New_Unchecked_Post_Assertion
     return W_Post_Assertion_Unchecked_Id
   is
      Result : Why_Node (W_Post_Assertion);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Post_Assertion);
   begin
      Result.Ada_Node := Empty;
      Result.PA_Prog := Why_Empty;
      Set_Link (Result.PA_Prog, New_Id);
      Result.PA_Post := Why_Empty;
      Set_Link (Result.PA_Post, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Post_Assertion;

   ------------------------------------
   -- New_Unchecked_Opaque_Assertion --
   ------------------------------------

   function New_Unchecked_Opaque_Assertion
     return W_Opaque_Assertion_Unchecked_Id
   is
      Result : Why_Node (W_Opaque_Assertion);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Opaque_Assertion);
   begin
      Result.Ada_Node := Empty;
      Result.PA_Prog := Why_Empty;
      Set_Link (Result.PA_Prog, New_Id);
      Result.PA_Post := Why_Empty;
      Set_Link (Result.PA_Post, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Opaque_Assertion;

   ---------------------------
   -- New_Unchecked_Fun_Def --
   ---------------------------

   function New_Unchecked_Fun_Def
     return W_Fun_Def_Unchecked_Id
   is
      Result : Why_Node (W_Fun_Def);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Fun_Def);
   begin
      Result.Ada_Node := Empty;
      Result.FD_Binders := Why_Empty;
      Set_Link (Result.FD_Binders, New_Id);
      Result.FD_Pre := Why_Empty;
      Set_Link (Result.FD_Pre, New_Id);
      Result.FD_Def := Why_Empty;
      Set_Link (Result.FD_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Fun_Def;

   -------------------------------
   -- New_Unchecked_Binding_Fun --
   -------------------------------

   function New_Unchecked_Binding_Fun
     return W_Binding_Fun_Unchecked_Id
   is
      Result : Why_Node (W_Binding_Fun);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Binding_Fun);
   begin
      Result.Ada_Node := Empty;
      Result.BF_Name := Why_Empty;
      Set_Link (Result.BF_Name, New_Id);
      Result.BF_Binders := Why_Empty;
      Set_Link (Result.BF_Binders, New_Id);
      Result.BF_Pre := Why_Empty;
      Set_Link (Result.BF_Pre, New_Id);
      Result.BF_Def := Why_Empty;
      Set_Link (Result.BF_Def, New_Id);
      Result.BF_Context := Why_Empty;
      Set_Link (Result.BF_Context, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Binding_Fun;

   -------------------------------
   -- New_Unchecked_Binding_Rec --
   -------------------------------

   function New_Unchecked_Binding_Rec
     return W_Binding_Rec_Unchecked_Id
   is
      Result : Why_Node (W_Binding_Rec);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Binding_Rec);
   begin
      Result.Ada_Node := Empty;
      Result.BR_Recfun := Why_Empty;
      Set_Link (Result.BR_Recfun, New_Id);
      Result.BR_Context := Why_Empty;
      Set_Link (Result.BR_Context, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Binding_Rec;

   ---------------------------------
   -- New_Unchecked_Prog_Sequence --
   ---------------------------------

   function New_Unchecked_Prog_Sequence
     return W_Prog_Sequence_Unchecked_Id
   is
      Result : Why_Node (W_Prog_Sequence);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Prog_Sequence);
   begin
      Result.Ada_Node := Empty;
      Result.PS_Progs := New_List;
      Set_Link (Result.PS_Progs, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Prog_Sequence;

   -----------------------------------
   -- New_Unchecked_Raise_Statement --
   -----------------------------------

   function New_Unchecked_Raise_Statement
     return W_Raise_Statement_Unchecked_Id
   is
      Result : Why_Node (W_Raise_Statement);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Raise_Statement);
   begin
      Result.Ada_Node := Empty;
      Result.RS_Name := Why_Empty;
      Set_Link (Result.RS_Name, New_Id);
      Result.RS_Exn_Type := Why_Empty;
      Set_Link (Result.RS_Exn_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Raise_Statement;

   ---------------------------------------------------
   -- New_Unchecked_Raise_Statement_With_Parameters --
   ---------------------------------------------------

   function New_Unchecked_Raise_Statement_With_Parameters
     return W_Raise_Statement_With_Parameters_Unchecked_Id
   is
      Result : Why_Node (W_Raise_Statement_With_Parameters);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Raise_Statement_With_Parameters);
   begin
      Result.Ada_Node := Empty;
      Result.RSWP_Name := Why_Empty;
      Set_Link (Result.RSWP_Name, New_Id);
      Result.RSWP_Parameter := Why_Empty;
      Set_Link (Result.RSWP_Parameter, New_Id);
      Result.RSWP_Exn_Type := Why_Empty;
      Set_Link (Result.RSWP_Exn_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Raise_Statement_With_Parameters;

   -----------------------------
   -- New_Unchecked_Try_Block --
   -----------------------------

   function New_Unchecked_Try_Block
     return W_Try_Block_Unchecked_Id
   is
      Result : Why_Node (W_Try_Block);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Try_Block);
   begin
      Result.Ada_Node := Empty;
      Result.TB_Prog := Why_Empty;
      Set_Link (Result.TB_Prog, New_Id);
      Result.TB_Handler := New_List;
      Set_Link (Result.TB_Handler, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Try_Block;

   ------------------------------------
   -- New_Unchecked_Unreachable_Code --
   ------------------------------------

   function New_Unchecked_Unreachable_Code
     return W_Unreachable_Code_Unchecked_Id
   is
      Result : Why_Node (W_Unreachable_Code);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Unreachable_Code);
   begin
      Result.Ada_Node := Empty;
      Result.UC_Exn_Type := Why_Empty;
      Set_Link (Result.UC_Exn_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Unreachable_Code;

   -------------------------------
   -- New_Unchecked_Begin_Block --
   -------------------------------

   function New_Unchecked_Begin_Block
     return W_Begin_Block_Unchecked_Id
   is
      Result : Why_Node (W_Begin_Block);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Begin_Block);
   begin
      Result.Ada_Node := Empty;
      Result.BB_Prog := Why_Empty;
      Set_Link (Result.BB_Prog, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Begin_Block;

   ----------------------------------
   -- New_Unchecked_Protected_Prog --
   ----------------------------------

   function New_Unchecked_Protected_Prog
     return W_Protected_Prog_Unchecked_Id
   is
      Result : Why_Node (W_Protected_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Protected_Prog);
   begin
      Result.Ada_Node := Empty;
      Result.BB_Prog := Why_Empty;
      Set_Link (Result.BB_Prog, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Protected_Prog;

   -------------------------------
   -- New_Unchecked_Op_Add_Prog --
   -------------------------------

   function New_Unchecked_Op_Add_Prog
     return W_Op_Add_Prog_Unchecked_Id
   is
      Result : Why_Node (W_Op_Add_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Add_Prog);
   begin
      Result.Ada_Node := Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Op_Add_Prog;

   -------------------------------------
   -- New_Unchecked_Op_Substract_Prog --
   -------------------------------------

   function New_Unchecked_Op_Substract_Prog
     return W_Op_Substract_Prog_Unchecked_Id
   is
      Result : Why_Node (W_Op_Substract_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Substract_Prog);
   begin
      Result.Ada_Node := Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Op_Substract_Prog;

   ------------------------------------
   -- New_Unchecked_Op_Multiply_Prog --
   ------------------------------------

   function New_Unchecked_Op_Multiply_Prog
     return W_Op_Multiply_Prog_Unchecked_Id
   is
      Result : Why_Node (W_Op_Multiply_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Multiply_Prog);
   begin
      Result.Ada_Node := Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Op_Multiply_Prog;

   ----------------------------------
   -- New_Unchecked_Op_Divide_Prog --
   ----------------------------------

   function New_Unchecked_Op_Divide_Prog
     return W_Op_Divide_Prog_Unchecked_Id
   is
      Result : Why_Node (W_Op_Divide_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Divide_Prog);
   begin
      Result.Ada_Node := Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Op_Divide_Prog;

   -------------------------------
   -- New_Unchecked_Op_Mod_Prog --
   -------------------------------

   function New_Unchecked_Op_Mod_Prog
     return W_Op_Mod_Prog_Unchecked_Id
   is
      Result : Why_Node (W_Op_Mod_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Mod_Prog);
   begin
      Result.Ada_Node := Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Op_Mod_Prog;

   ------------------------------
   -- New_Unchecked_Op_Eq_Prog --
   ------------------------------

   function New_Unchecked_Op_Eq_Prog
     return W_Op_Eq_Prog_Unchecked_Id
   is
      Result : Why_Node (W_Op_Eq_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Eq_Prog);
   begin
      Result.Ada_Node := Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Op_Eq_Prog;

   ------------------------------
   -- New_Unchecked_Op_Ne_Prog --
   ------------------------------

   function New_Unchecked_Op_Ne_Prog
     return W_Op_Ne_Prog_Unchecked_Id
   is
      Result : Why_Node (W_Op_Ne_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Ne_Prog);
   begin
      Result.Ada_Node := Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Op_Ne_Prog;

   ------------------------------
   -- New_Unchecked_Op_Lt_Prog --
   ------------------------------

   function New_Unchecked_Op_Lt_Prog
     return W_Op_Lt_Prog_Unchecked_Id
   is
      Result : Why_Node (W_Op_Lt_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Lt_Prog);
   begin
      Result.Ada_Node := Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Op_Lt_Prog;

   ------------------------------
   -- New_Unchecked_Op_Le_Prog --
   ------------------------------

   function New_Unchecked_Op_Le_Prog
     return W_Op_Le_Prog_Unchecked_Id
   is
      Result : Why_Node (W_Op_Le_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Le_Prog);
   begin
      Result.Ada_Node := Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Op_Le_Prog;

   ------------------------------
   -- New_Unchecked_Op_Gt_Prog --
   ------------------------------

   function New_Unchecked_Op_Gt_Prog
     return W_Op_Gt_Prog_Unchecked_Id
   is
      Result : Why_Node (W_Op_Gt_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Gt_Prog);
   begin
      Result.Ada_Node := Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Op_Gt_Prog;

   ------------------------------
   -- New_Unchecked_Op_Ge_Prog --
   ------------------------------

   function New_Unchecked_Op_Ge_Prog
     return W_Op_Ge_Prog_Unchecked_Id
   is
      Result : Why_Node (W_Op_Ge_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Ge_Prog);
   begin
      Result.Ada_Node := Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Op_Ge_Prog;

   -----------------------------------
   -- New_Unchecked_Op_Or_Else_Prog --
   -----------------------------------

   function New_Unchecked_Op_Or_Else_Prog
     return W_Op_Or_Else_Prog_Unchecked_Id
   is
      Result : Why_Node (W_Op_Or_Else_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Or_Else_Prog);
   begin
      Result.Ada_Node := Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Op_Or_Else_Prog;

   ------------------------------------
   -- New_Unchecked_Op_And_Then_Prog --
   ------------------------------------

   function New_Unchecked_Op_And_Then_Prog
     return W_Op_And_Then_Prog_Unchecked_Id
   is
      Result : Why_Node (W_Op_And_Then_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_And_Then_Prog);
   begin
      Result.Ada_Node := Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Op_And_Then_Prog;

   ---------------------------------
   -- New_Unchecked_Op_Minus_Prog --
   ---------------------------------

   function New_Unchecked_Op_Minus_Prog
     return W_Op_Minus_Prog_Unchecked_Id
   is
      Result : Why_Node (W_Op_Minus_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Minus_Prog);
   begin
      Result.Ada_Node := Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Op_Minus_Prog;

   -------------------------------
   -- New_Unchecked_Op_Not_Prog --
   -------------------------------

   function New_Unchecked_Op_Not_Prog
     return W_Op_Not_Prog_Unchecked_Id
   is
      Result : Why_Node (W_Op_Not_Prog);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Op_Not_Prog);
   begin
      Result.Ada_Node := Empty;
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Op_Not_Prog;

   ---------------------------
   -- New_Unchecked_Binders --
   ---------------------------

   function New_Unchecked_Binders
     return W_Binders_Unchecked_Id
   is
      Result : Why_Node (W_Binders);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Binders);
   begin
      Result.Ada_Node := Empty;
      Result.BS_Binders := New_List;
      Set_Link (Result.BS_Binders, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Binders;

   --------------------------
   -- New_Unchecked_Binder --
   --------------------------

   function New_Unchecked_Binder
     return W_Binder_Unchecked_Id
   is
      Result : Why_Node (W_Binder);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Binder);
   begin
      Result.Ada_Node := Empty;
      Result.B_Names := New_List;
      Set_Link (Result.B_Names, New_Id);
      Result.B_Arg_Type := Why_Empty;
      Set_Link (Result.B_Arg_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Binder;

   --------------------------
   -- New_Unchecked_Recfun --
   --------------------------

   function New_Unchecked_Recfun
     return W_Recfun_Unchecked_Id
   is
      Result : Why_Node (W_Recfun);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Recfun);
   begin
      Result.Ada_Node := Empty;
      Result.RF_Name := Why_Empty;
      Set_Link (Result.RF_Name, New_Id);
      Result.RF_Binders := Why_Empty;
      Set_Link (Result.RF_Binders, New_Id);
      Result.RF_Return_Type := Why_Empty;
      Set_Link (Result.RF_Return_Type, New_Id);
      Result.RF_Variant := Why_Empty;
      Set_Link (Result.RF_Variant, New_Id);
      Result.RF_Pre := Why_Empty;
      Set_Link (Result.RF_Pre, New_Id);
      Result.RF_Def := Why_Empty;
      Set_Link (Result.RF_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Recfun;

   ------------------------------
   -- New_Unchecked_Loop_Annot --
   ------------------------------

   function New_Unchecked_Loop_Annot
     return W_Loop_Annot_Unchecked_Id
   is
      Result : Why_Node (W_Loop_Annot);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Loop_Annot);
   begin
      Result.Ada_Node := Empty;
      Result.LA_Invariant := Why_Empty;
      Set_Link (Result.LA_Invariant, New_Id);
      Result.LA_Variant := Why_Empty;
      Set_Link (Result.LA_Variant, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Loop_Annot;

   --------------------------
   -- New_Unchecked_Wf_Arg --
   --------------------------

   function New_Unchecked_Wf_Arg
     return W_Wf_Arg_Unchecked_Id
   is
      Result : Why_Node (W_Wf_Arg);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Wf_Arg);
   begin
      Result.Ada_Node := Empty;
      Result.WA_Def := Why_Empty;
      Set_Link (Result.WA_Def, New_Id);
      Result.WA_For_Id := Why_Empty;
      Set_Link (Result.WA_For_Id, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Wf_Arg;

   ---------------------------
   -- New_Unchecked_Handler --
   ---------------------------

   function New_Unchecked_Handler
     return W_Handler_Unchecked_Id
   is
      Result : Why_Node (W_Handler);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Handler);
   begin
      Result.Ada_Node := Empty;
      Result.H_Name := Why_Empty;
      Set_Link (Result.H_Name, New_Id);
      Result.H_Parameter := Why_Empty;
      Set_Link (Result.H_Parameter, New_Id);
      Result.H_Def := Why_Empty;
      Set_Link (Result.H_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Handler;

   ------------------------
   -- New_Unchecked_File --
   ------------------------

   function New_Unchecked_File
     return W_File_Unchecked_Id
   is
      Result : Why_Node (W_File);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_File);
   begin
      Result.Ada_Node := Empty;
      Result.F_Declarations := New_List;
      Set_Link (Result.F_Declarations, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_File;

   ----------------------------------
   -- New_Unchecked_Global_Binding --
   ----------------------------------

   function New_Unchecked_Global_Binding
     return W_Global_Binding_Unchecked_Id
   is
      Result : Why_Node (W_Global_Binding);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Global_Binding);
   begin
      Result.Ada_Node := Empty;
      Result.GB_Name := Why_Empty;
      Set_Link (Result.GB_Name, New_Id);
      Result.GB_Binders := Why_Empty;
      Set_Link (Result.GB_Binders, New_Id);
      Result.GB_Pre := Why_Empty;
      Set_Link (Result.GB_Pre, New_Id);
      Result.GB_Def := Why_Empty;
      Set_Link (Result.GB_Def, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Global_Binding;

   --------------------------------------
   -- New_Unchecked_Global_Rec_Binding --
   --------------------------------------

   function New_Unchecked_Global_Rec_Binding
     return W_Global_Rec_Binding_Unchecked_Id
   is
      Result : Why_Node (W_Global_Rec_Binding);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Global_Rec_Binding);
   begin
      Result.Ada_Node := Empty;
      Result.GRB_Name := Why_Empty;
      Set_Link (Result.GRB_Name, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Global_Rec_Binding;

   -----------------------------------------
   -- New_Unchecked_Parameter_Declaration --
   -----------------------------------------

   function New_Unchecked_Parameter_Declaration
     return W_Parameter_Declaration_Unchecked_Id
   is
      Result : Why_Node (W_Parameter_Declaration);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Parameter_Declaration);
   begin
      Result.Ada_Node := Empty;
      Result.PD_External := Why_Empty;
      Set_Link (Result.PD_External, New_Id);
      Result.PD_Names := New_List;
      Set_Link (Result.PD_Names, New_Id);
      Result.PD_Parameter_Type := Why_Empty;
      Set_Link (Result.PD_Parameter_Type, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Parameter_Declaration;

   -----------------------------------------
   -- New_Unchecked_Exception_Declaration --
   -----------------------------------------

   function New_Unchecked_Exception_Declaration
     return W_Exception_Declaration_Unchecked_Id
   is
      Result : Why_Node (W_Exception_Declaration);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Exception_Declaration);
   begin
      Result.Ada_Node := Empty;
      Result.ED_Name := Why_Empty;
      Set_Link (Result.ED_Name, New_Id);
      Result.ED_Parameter := Why_Empty;
      Set_Link (Result.ED_Parameter, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Exception_Declaration;

   -------------------------------------
   -- New_Unchecked_Logic_Declaration --
   -------------------------------------

   function New_Unchecked_Logic_Declaration
     return W_Logic_Declaration_Unchecked_Id
   is
      Result : Why_Node (W_Logic_Declaration);
      New_Id : constant Why_Node_Id :=
        New_Why_Node_Id (W_Logic_Declaration);
   begin
      Result.Ada_Node := Empty;
      Result.LD_Decl := Why_Empty;
      Set_Link (Result.LD_Decl, New_Id);
      Result.Link := Why_Empty;
      Result.Checked := False;
      Set_Node (New_Id, Result);
      return New_Id;
   end New_Unchecked_Logic_Declaration;

   --------------------------
   -- Duplicate_Identifier --
   --------------------------

   function Duplicate_Identifier
     (Ada_Node : Node_Id := Empty;
      Id       : W_Identifier_OId)
     return W_Identifier_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Identifier);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Identifier);
         Symbol : constant Name_Id :=
            Identifier_Get_Symbol (Id);
         Entity : constant Why_Node_Id :=
            Identifier_Get_Entity (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Symbol := Symbol;
         Result.Entity := Entity;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Identifier;

   -------------------------
   -- Duplicate_Type_Prop --
   -------------------------

   function Duplicate_Type_Prop
     (Ada_Node : Node_Id := Empty;
      Id       : W_Type_Prop_OId)
     return W_Type_Prop_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Type_Prop);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Type_Prop);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Type_Prop;

   ------------------------
   -- Duplicate_Type_Int --
   ------------------------

   function Duplicate_Type_Int
     (Ada_Node : Node_Id := Empty;
      Id       : W_Type_Int_OId)
     return W_Type_Int_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Type_Int);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Type_Int);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Type_Int;

   -------------------------
   -- Duplicate_Type_Bool --
   -------------------------

   function Duplicate_Type_Bool
     (Ada_Node : Node_Id := Empty;
      Id       : W_Type_Bool_OId)
     return W_Type_Bool_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Type_Bool);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Type_Bool);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Type_Bool;

   -------------------------
   -- Duplicate_Type_Real --
   -------------------------

   function Duplicate_Type_Real
     (Ada_Node : Node_Id := Empty;
      Id       : W_Type_Real_OId)
     return W_Type_Real_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Type_Real);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Type_Real);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Type_Real;

   -------------------------
   -- Duplicate_Type_Unit --
   -------------------------

   function Duplicate_Type_Unit
     (Ada_Node : Node_Id := Empty;
      Id       : W_Type_Unit_OId)
     return W_Type_Unit_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Type_Unit);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Type_Unit);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Type_Unit;

   -----------------------------
   -- Duplicate_Abstract_Type --
   -----------------------------

   function Duplicate_Abstract_Type
     (Ada_Node : Node_Id := Empty;
      Id       : W_Abstract_Type_OId)
     return W_Abstract_Type_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Abstract_Type);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Abstract_Type);
         Name : constant W_Identifier_Id :=
            Abstract_Type_Get_Name (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.AT_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.AT_Name, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Abstract_Type;

   -----------------------------------
   -- Duplicate_Generic_Formal_Type --
   -----------------------------------

   function Duplicate_Generic_Formal_Type
     (Ada_Node : Node_Id := Empty;
      Id       : W_Generic_Formal_Type_OId)
     return W_Generic_Formal_Type_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Generic_Formal_Type);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Generic_Formal_Type);
         Name : constant W_Identifier_Id :=
            Generic_Formal_Type_Get_Name (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.GFT_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.GFT_Name, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Generic_Formal_Type;

   -----------------------------------------
   -- Duplicate_Generic_Actual_Type_Chain --
   -----------------------------------------

   function Duplicate_Generic_Actual_Type_Chain
     (Ada_Node : Node_Id := Empty;
      Id       : W_Generic_Actual_Type_Chain_OId)
     return W_Generic_Actual_Type_Chain_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Generic_Actual_Type_Chain);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Generic_Actual_Type_Chain);
         Type_Chain : constant W_Primitive_Type_List :=
            Generic_Actual_Type_Chain_Get_Type_Chain (Id);
         Name       : constant W_Identifier_Id :=
            Generic_Actual_Type_Chain_Get_Name (Id);
      begin
         Result.Ada_Node := Ada_Node;
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Type_Chain);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Primitive_Type_Id := Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.GATC_Type_Chain := NL;
         end;
         Set_Link (Result.GATC_Type_Chain, New_Id);
         Result.GATC_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.GATC_Name, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Generic_Actual_Type_Chain;

   --------------------------
   -- Duplicate_Array_Type --
   --------------------------

   function Duplicate_Array_Type
     (Ada_Node : Node_Id := Empty;
      Id       : W_Array_Type_OId)
     return W_Array_Type_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Array_Type);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Array_Type);
         Component_Type : constant W_Primitive_Type_Id :=
            Array_Type_Get_Component_Type (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.AT_Component_Type :=
           Duplicate_Primitive_Type
           (Id => Component_Type);
         Set_Link (Result.AT_Component_Type, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Array_Type;

   ------------------------
   -- Duplicate_Ref_Type --
   ------------------------

   function Duplicate_Ref_Type
     (Ada_Node : Node_Id := Empty;
      Id       : W_Ref_Type_OId)
     return W_Ref_Type_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Ref_Type);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Ref_Type);
         Aliased_Type : constant W_Primitive_Type_Id :=
            Ref_Type_Get_Aliased_Type (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.RT_Aliased_Type :=
           Duplicate_Primitive_Type
           (Id => Aliased_Type);
         Set_Link (Result.RT_Aliased_Type, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Ref_Type;

   ------------------------------------
   -- Duplicate_Protected_Value_Type --
   ------------------------------------

   function Duplicate_Protected_Value_Type
     (Ada_Node : Node_Id := Empty;
      Id       : W_Protected_Value_Type_OId)
     return W_Protected_Value_Type_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Protected_Value_Type);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Protected_Value_Type);
         Value_Type : constant W_Value_Type_Id :=
            Protected_Value_Type_Get_Value_Type (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.PVT_Value_Type :=
           Duplicate_Value_Type
           (Id => Value_Type);
         Set_Link (Result.PVT_Value_Type, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Protected_Value_Type;

   --------------------------
   -- Duplicate_Arrow_Type --
   --------------------------

   function Duplicate_Arrow_Type
     (Ada_Node : Node_Id := Empty;
      Id       : W_Arrow_Type_OId)
     return W_Arrow_Type_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Arrow_Type);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Arrow_Type);
         Name  : constant W_Identifier_OId :=
            Arrow_Type_Get_Name (Id);
         Left  : constant W_Simple_Value_Type_Id :=
            Arrow_Type_Get_Left (Id);
         Right : constant W_Computation_Type_Id :=
            Arrow_Type_Get_Right (Id);
      begin
         Result.Ada_Node := Ada_Node;
         if Name = Why_Empty then
            Result.NA_Name := Why_Empty;
         else
            Result.NA_Name :=
              Duplicate_Identifier
              (Id => Name);
         end if;
         Set_Link (Result.NA_Name, New_Id);
         Result.NA_Left :=
           Duplicate_Simple_Value_Type
           (Id => Left);
         Set_Link (Result.NA_Left, New_Id);
         Result.NA_Right :=
           Duplicate_Computation_Type
           (Id => Right);
         Set_Link (Result.NA_Right, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Arrow_Type;

   --------------------------------
   -- Duplicate_Computation_Spec --
   --------------------------------

   function Duplicate_Computation_Spec
     (Ada_Node : Node_Id := Empty;
      Id       : W_Computation_Spec_OId)
     return W_Computation_Spec_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Computation_Spec);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Computation_Spec);
         Precondition  : constant W_Precondition_OId :=
            Computation_Spec_Get_Precondition (Id);
         Result_Name   : constant W_Identifier_OId :=
            Computation_Spec_Get_Result_Name (Id);
         Return_Type   : constant W_Value_Type_Id :=
            Computation_Spec_Get_Return_Type (Id);
         Effects       : constant W_Effects_Id :=
            Computation_Spec_Get_Effects (Id);
         Postcondition : constant W_Postcondition_OId :=
            Computation_Spec_Get_Postcondition (Id);
      begin
         Result.Ada_Node := Ada_Node;
         if Precondition = Why_Empty then
            Result.CS_Precondition := Why_Empty;
         else
            Result.CS_Precondition :=
              Duplicate_Precondition
              (Id => Precondition);
         end if;
         Set_Link (Result.CS_Precondition, New_Id);
         if Result_Name = Why_Empty then
            Result.CS_Result_Name := Why_Empty;
         else
            Result.CS_Result_Name :=
              Duplicate_Identifier
              (Id => Result_Name);
         end if;
         Set_Link (Result.CS_Result_Name, New_Id);
         Result.CS_Return_Type :=
           Duplicate_Value_Type
           (Id => Return_Type);
         Set_Link (Result.CS_Return_Type, New_Id);
         Result.CS_Effects :=
           Duplicate_Effects
           (Id => Effects);
         Set_Link (Result.CS_Effects, New_Id);
         if Postcondition = Why_Empty then
            Result.CS_Postcondition := Why_Empty;
         else
            Result.CS_Postcondition :=
              Duplicate_Postcondition
              (Id => Postcondition);
         end if;
         Set_Link (Result.CS_Postcondition, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Computation_Spec;

   --------------------------------
   -- Duplicate_Integer_Constant --
   --------------------------------

   function Duplicate_Integer_Constant
     (Ada_Node : Node_Id := Empty;
      Id       : W_Integer_Constant_OId)
     return W_Integer_Constant_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Integer_Constant);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Integer_Constant);
         Value : constant Uint :=
            Integer_Constant_Get_Value (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.IC_Value := Value;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Integer_Constant;

   -----------------------------
   -- Duplicate_Real_Constant --
   -----------------------------

   function Duplicate_Real_Constant
     (Ada_Node : Node_Id := Empty;
      Id       : W_Real_Constant_OId)
     return W_Real_Constant_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Real_Constant);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Real_Constant);
         Value : constant Ureal :=
            Real_Constant_Get_Value (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.RC_Value := Value;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Real_Constant;

   ----------------------------
   -- Duplicate_True_Literal --
   ----------------------------

   function Duplicate_True_Literal
     (Ada_Node : Node_Id := Empty;
      Id       : W_True_Literal_OId)
     return W_True_Literal_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_True_Literal);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_True_Literal);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_True_Literal;

   -----------------------------
   -- Duplicate_False_Literal --
   -----------------------------

   function Duplicate_False_Literal
     (Ada_Node : Node_Id := Empty;
      Id       : W_False_Literal_OId)
     return W_False_Literal_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_False_Literal);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_False_Literal);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_False_Literal;

   ----------------------------
   -- Duplicate_Void_Literal --
   ----------------------------

   function Duplicate_Void_Literal
     (Ada_Node : Node_Id := Empty;
      Id       : W_Void_Literal_OId)
     return W_Void_Literal_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Void_Literal);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Void_Literal);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Void_Literal;

   -------------------------------
   -- Duplicate_Arith_Operation --
   -------------------------------

   function Duplicate_Arith_Operation
     (Ada_Node : Node_Id := Empty;
      Id       : W_Arith_Operation_OId)
     return W_Arith_Operation_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Arith_Operation);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Arith_Operation);
         Left  : constant W_Term_Id :=
            Arith_Operation_Get_Left (Id);
         Op    : constant W_Arith_Op_Id :=
            Arith_Operation_Get_Op (Id);
         Right : constant W_Term_Id :=
            Arith_Operation_Get_Right (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.AO_Left :=
           Duplicate_Term
           (Id => Left);
         Set_Link (Result.AO_Left, New_Id);
         Result.AO_Op :=
           Duplicate_Arith_Op
           (Id => Op);
         Set_Link (Result.AO_Op, New_Id);
         Result.AO_Right :=
           Duplicate_Term
           (Id => Right);
         Set_Link (Result.AO_Right, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Arith_Operation;

   -----------------------------
   -- Duplicate_Negative_Term --
   -----------------------------

   function Duplicate_Negative_Term
     (Ada_Node : Node_Id := Empty;
      Id       : W_Negative_Term_OId)
     return W_Negative_Term_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Negative_Term);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Negative_Term);
         Operand : constant W_Term_Id :=
            Negative_Term_Get_Operand (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.NT_Operand :=
           Duplicate_Term
           (Id => Operand);
         Set_Link (Result.NT_Operand, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Negative_Term;

   --------------------------------
   -- Duplicate_Label_Identifier --
   --------------------------------

   function Duplicate_Label_Identifier
     (Ada_Node : Node_Id := Empty;
      Id       : W_Label_Identifier_OId)
     return W_Label_Identifier_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Label_Identifier);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Label_Identifier);
         Name  : constant W_Identifier_Id :=
            Label_Identifier_Get_Name (Id);
         Label : constant W_Identifier_OId :=
            Label_Identifier_Get_Label (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.TI_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.TI_Name, New_Id);
         if Label = Why_Empty then
            Result.TI_Label := Why_Empty;
         else
            Result.TI_Label :=
              Duplicate_Identifier
              (Id => Label);
         end if;
         Set_Link (Result.TI_Label, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Label_Identifier;

   -------------------------
   -- Duplicate_Operation --
   -------------------------

   function Duplicate_Operation
     (Ada_Node : Node_Id := Empty;
      Id       : W_Operation_OId)
     return W_Operation_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Operation);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Operation);
         Name       : constant W_Identifier_Id :=
            Operation_Get_Name (Id);
         Parameters : constant W_Term_List :=
            Operation_Get_Parameters (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.O_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.O_Name, New_Id);
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Parameters);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Term_Id := Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.O_Parameters := NL;
         end;
         Set_Link (Result.O_Parameters, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Operation;

   --------------------------
   -- Duplicate_Named_Term --
   --------------------------

   function Duplicate_Named_Term
     (Ada_Node : Node_Id := Empty;
      Id       : W_Named_Term_OId)
     return W_Named_Term_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Named_Term);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Named_Term);
         Name : constant W_Label_Identifier_Id :=
            Named_Term_Get_Name (Id);
         Term : constant W_Term_Id :=
            Named_Term_Get_Term (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.NT_Name :=
           Duplicate_Label_Identifier
           (Id => Name);
         Set_Link (Result.NT_Name, New_Id);
         Result.NT_Term :=
           Duplicate_Term
           (Id => Term);
         Set_Link (Result.NT_Term, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Named_Term;

   --------------------------------
   -- Duplicate_Conditional_Term --
   --------------------------------

   function Duplicate_Conditional_Term
     (Ada_Node : Node_Id := Empty;
      Id       : W_Conditional_Term_OId)
     return W_Conditional_Term_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Conditional_Term);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Conditional_Term);
         Condition : constant W_Term_Id :=
            Conditional_Term_Get_Condition (Id);
         Then_Part : constant W_Term_Id :=
            Conditional_Term_Get_Then_Part (Id);
         Else_Part : constant W_Term_Id :=
            Conditional_Term_Get_Else_Part (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.CT_Condition :=
           Duplicate_Term
           (Id => Condition);
         Set_Link (Result.CT_Condition, New_Id);
         Result.CT_Then_Part :=
           Duplicate_Term
           (Id => Then_Part);
         Set_Link (Result.CT_Then_Part, New_Id);
         Result.CT_Else_Part :=
           Duplicate_Term
           (Id => Else_Part);
         Set_Link (Result.CT_Else_Part, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Conditional_Term;

   -----------------------------
   -- Duplicate_Matching_Term --
   -----------------------------

   function Duplicate_Matching_Term
     (Ada_Node : Node_Id := Empty;
      Id       : W_Matching_Term_OId)
     return W_Matching_Term_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Matching_Term);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Matching_Term);
         Term     : constant W_Term_Id :=
            Matching_Term_Get_Term (Id);
         Branches : constant W_Match_Case_List :=
            Matching_Term_Get_Branches (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.MT_Term :=
           Duplicate_Term
           (Id => Term);
         Set_Link (Result.MT_Term, New_Id);
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Branches);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Match_Case_Id := Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.MT_Branches := NL;
         end;
         Set_Link (Result.MT_Branches, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Matching_Term;

   ----------------------------
   -- Duplicate_Binding_Term --
   ----------------------------

   function Duplicate_Binding_Term
     (Ada_Node : Node_Id := Empty;
      Id       : W_Binding_Term_OId)
     return W_Binding_Term_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Binding_Term);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Binding_Term);
         Name    : constant W_Identifier_Id :=
            Binding_Term_Get_Name (Id);
         Def     : constant W_Term_Id :=
            Binding_Term_Get_Def (Id);
         Context : constant W_Term_Id :=
            Binding_Term_Get_Context (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.BT_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.BT_Name, New_Id);
         Result.BT_Def :=
           Duplicate_Term
           (Id => Def);
         Set_Link (Result.BT_Def, New_Id);
         Result.BT_Context :=
           Duplicate_Term
           (Id => Context);
         Set_Link (Result.BT_Context, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Binding_Term;

   ------------------------------
   -- Duplicate_Protected_Term --
   ------------------------------

   function Duplicate_Protected_Term
     (Ada_Node : Node_Id := Empty;
      Id       : W_Protected_Term_OId)
     return W_Protected_Term_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Protected_Term);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Protected_Term);
         Term : constant W_Term_Id :=
            Protected_Term_Get_Term (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.BT_Term :=
           Duplicate_Term
           (Id => Term);
         Set_Link (Result.BT_Term, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Protected_Term;

   ----------------------
   -- Duplicate_Op_Add --
   ----------------------

   function Duplicate_Op_Add
     (Ada_Node : Node_Id := Empty;
      Id       : W_Op_Add_OId)
     return W_Op_Add_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Op_Add);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Op_Add);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Op_Add;

   ----------------------------
   -- Duplicate_Op_Substract --
   ----------------------------

   function Duplicate_Op_Substract
     (Ada_Node : Node_Id := Empty;
      Id       : W_Op_Substract_OId)
     return W_Op_Substract_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Op_Substract);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Op_Substract);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Op_Substract;

   ---------------------------
   -- Duplicate_Op_Multiply --
   ---------------------------

   function Duplicate_Op_Multiply
     (Ada_Node : Node_Id := Empty;
      Id       : W_Op_Multiply_OId)
     return W_Op_Multiply_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Op_Multiply);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Op_Multiply);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Op_Multiply;

   -------------------------
   -- Duplicate_Op_Divide --
   -------------------------

   function Duplicate_Op_Divide
     (Ada_Node : Node_Id := Empty;
      Id       : W_Op_Divide_OId)
     return W_Op_Divide_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Op_Divide);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Op_Divide);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Op_Divide;

   -------------------------
   -- Duplicate_Op_Modulo --
   -------------------------

   function Duplicate_Op_Modulo
     (Ada_Node : Node_Id := Empty;
      Id       : W_Op_Modulo_OId)
     return W_Op_Modulo_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Op_Modulo);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Op_Modulo);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Op_Modulo;

   ---------------------------------
   -- Duplicate_True_Literal_Pred --
   ---------------------------------

   function Duplicate_True_Literal_Pred
     (Ada_Node : Node_Id := Empty;
      Id       : W_True_Literal_Pred_OId)
     return W_True_Literal_Pred_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_True_Literal_Pred);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_True_Literal_Pred);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_True_Literal_Pred;

   ----------------------------------
   -- Duplicate_False_Literal_Pred --
   ----------------------------------

   function Duplicate_False_Literal_Pred
     (Ada_Node : Node_Id := Empty;
      Id       : W_False_Literal_Pred_OId)
     return W_False_Literal_Pred_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_False_Literal_Pred);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_False_Literal_Pred);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_False_Literal_Pred;

   ------------------------------------
   -- Duplicate_Predicate_Identifier --
   ------------------------------------

   function Duplicate_Predicate_Identifier
     (Ada_Node : Node_Id := Empty;
      Id       : W_Predicate_Identifier_OId)
     return W_Predicate_Identifier_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Predicate_Identifier);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Predicate_Identifier);
         Name : constant W_Identifier_Id :=
            Predicate_Identifier_Get_Name (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.PID_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.PID_Name, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Predicate_Identifier;

   ----------------------------------
   -- Duplicate_Predicate_Instance --
   ----------------------------------

   function Duplicate_Predicate_Instance
     (Ada_Node : Node_Id := Empty;
      Id       : W_Predicate_Instance_OId)
     return W_Predicate_Instance_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Predicate_Instance);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Predicate_Instance);
         Name       : constant W_Identifier_Id :=
            Predicate_Instance_Get_Name (Id);
         Parameters : constant W_Term_List :=
            Predicate_Instance_Get_Parameters (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.PIN_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.PIN_Name, New_Id);
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Parameters);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Term_Id := Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.PIN_Parameters := NL;
         end;
         Set_Link (Result.PIN_Parameters, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Predicate_Instance;

   -----------------------------
   -- Duplicate_Related_Terms --
   -----------------------------

   function Duplicate_Related_Terms
     (Ada_Node : Node_Id := Empty;
      Id       : W_Related_Terms_OId)
     return W_Related_Terms_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Related_Terms);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Related_Terms);
         Left   : constant W_Term_Id :=
            Related_Terms_Get_Left (Id);
         Op     : constant W_Relation_Id :=
            Related_Terms_Get_Op (Id);
         Right  : constant W_Term_Id :=
            Related_Terms_Get_Right (Id);
         Op2    : constant W_Relation_OId :=
            Related_Terms_Get_Op2 (Id);
         Right2 : constant W_Term_OId :=
            Related_Terms_Get_Right2 (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.RT_Left :=
           Duplicate_Term
           (Id => Left);
         Set_Link (Result.RT_Left, New_Id);
         Result.RT_Op :=
           Duplicate_Relation
           (Id => Op);
         Set_Link (Result.RT_Op, New_Id);
         Result.RT_Right :=
           Duplicate_Term
           (Id => Right);
         Set_Link (Result.RT_Right, New_Id);
         if Op2 = Why_Empty then
            Result.RT_Op2 := Why_Empty;
         else
            Result.RT_Op2 :=
              Duplicate_Relation
              (Id => Op2);
         end if;
         Set_Link (Result.RT_Op2, New_Id);
         if Right2 = Why_Empty then
            Result.RT_Right2 := Why_Empty;
         else
            Result.RT_Right2 :=
              Duplicate_Term
              (Id => Right2);
         end if;
         Set_Link (Result.RT_Right2, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Related_Terms;

   ---------------------------
   -- Duplicate_Implication --
   ---------------------------

   function Duplicate_Implication
     (Ada_Node : Node_Id := Empty;
      Id       : W_Implication_OId)
     return W_Implication_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Implication);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Implication);
         Left  : constant W_Predicate_Id :=
            Implication_Get_Left (Id);
         Right : constant W_Predicate_Id :=
            Implication_Get_Right (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.ITOC_Left :=
           Duplicate_Predicate
           (Id => Left);
         Set_Link (Result.ITOC_Left, New_Id);
         Result.ITOC_Right :=
           Duplicate_Predicate
           (Id => Right);
         Set_Link (Result.ITOC_Right, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Implication;

   ---------------------------
   -- Duplicate_Equivalence --
   ---------------------------

   function Duplicate_Equivalence
     (Ada_Node : Node_Id := Empty;
      Id       : W_Equivalence_OId)
     return W_Equivalence_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Equivalence);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Equivalence);
         Left  : constant W_Predicate_Id :=
            Equivalence_Get_Left (Id);
         Right : constant W_Predicate_Id :=
            Equivalence_Get_Right (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.ITOC_Left :=
           Duplicate_Predicate
           (Id => Left);
         Set_Link (Result.ITOC_Left, New_Id);
         Result.ITOC_Right :=
           Duplicate_Predicate
           (Id => Right);
         Set_Link (Result.ITOC_Right, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Equivalence;

   ---------------------------
   -- Duplicate_Disjonction --
   ---------------------------

   function Duplicate_Disjonction
     (Ada_Node : Node_Id := Empty;
      Id       : W_Disjonction_OId)
     return W_Disjonction_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Disjonction);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Disjonction);
         Left  : constant W_Predicate_Id :=
            Disjonction_Get_Left (Id);
         Right : constant W_Predicate_Id :=
            Disjonction_Get_Right (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.ITOC_Left :=
           Duplicate_Predicate
           (Id => Left);
         Set_Link (Result.ITOC_Left, New_Id);
         Result.ITOC_Right :=
           Duplicate_Predicate
           (Id => Right);
         Set_Link (Result.ITOC_Right, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Disjonction;

   ---------------------------
   -- Duplicate_Conjonction --
   ---------------------------

   function Duplicate_Conjonction
     (Ada_Node : Node_Id := Empty;
      Id       : W_Conjonction_OId)
     return W_Conjonction_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Conjonction);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Conjonction);
         Left  : constant W_Predicate_Id :=
            Conjonction_Get_Left (Id);
         Right : constant W_Predicate_Id :=
            Conjonction_Get_Right (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.ITOC_Left :=
           Duplicate_Predicate
           (Id => Left);
         Set_Link (Result.ITOC_Left, New_Id);
         Result.ITOC_Right :=
           Duplicate_Predicate
           (Id => Right);
         Set_Link (Result.ITOC_Right, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Conjonction;

   ------------------------
   -- Duplicate_Negation --
   ------------------------

   function Duplicate_Negation
     (Ada_Node : Node_Id := Empty;
      Id       : W_Negation_OId)
     return W_Negation_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Negation);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Negation);
         Operand : constant W_Predicate_Id :=
            Negation_Get_Operand (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.N_Operand :=
           Duplicate_Predicate
           (Id => Operand);
         Set_Link (Result.N_Operand, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Negation;

   --------------------------------
   -- Duplicate_Conditional_Pred --
   --------------------------------

   function Duplicate_Conditional_Pred
     (Ada_Node : Node_Id := Empty;
      Id       : W_Conditional_Pred_OId)
     return W_Conditional_Pred_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Conditional_Pred);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Conditional_Pred);
         Condition : constant W_Term_Id :=
            Conditional_Pred_Get_Condition (Id);
         Then_Part : constant W_Predicate_Id :=
            Conditional_Pred_Get_Then_Part (Id);
         Else_Part : constant W_Predicate_Id :=
            Conditional_Pred_Get_Else_Part (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.CPD_Condition :=
           Duplicate_Term
           (Id => Condition);
         Set_Link (Result.CPD_Condition, New_Id);
         Result.CPD_Then_Part :=
           Duplicate_Predicate
           (Id => Then_Part);
         Set_Link (Result.CPD_Then_Part, New_Id);
         Result.CPD_Else_Part :=
           Duplicate_Predicate
           (Id => Else_Part);
         Set_Link (Result.CPD_Else_Part, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Conditional_Pred;

   ----------------------------
   -- Duplicate_Binding_Pred --
   ----------------------------

   function Duplicate_Binding_Pred
     (Ada_Node : Node_Id := Empty;
      Id       : W_Binding_Pred_OId)
     return W_Binding_Pred_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Binding_Pred);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Binding_Pred);
         Name    : constant W_Identifier_Id :=
            Binding_Pred_Get_Name (Id);
         Def     : constant W_Term_Id :=
            Binding_Pred_Get_Def (Id);
         Context : constant W_Predicate_Id :=
            Binding_Pred_Get_Context (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.BPD_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.BPD_Name, New_Id);
         Result.BPD_Def :=
           Duplicate_Term
           (Id => Def);
         Set_Link (Result.BPD_Def, New_Id);
         Result.BPD_Context :=
           Duplicate_Predicate
           (Id => Context);
         Set_Link (Result.BPD_Context, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Binding_Pred;

   ---------------------------------
   -- Duplicate_Universal_Quantif --
   ---------------------------------

   function Duplicate_Universal_Quantif
     (Ada_Node : Node_Id := Empty;
      Id       : W_Universal_Quantif_OId)
     return W_Universal_Quantif_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Universal_Quantif);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Universal_Quantif);
         Variables : constant W_Identifier_List :=
            Universal_Quantif_Get_Variables (Id);
         Var_Type  : constant W_Primitive_Type_Id :=
            Universal_Quantif_Get_Var_Type (Id);
         Triggers  : constant W_Triggers_OId :=
            Universal_Quantif_Get_Triggers (Id);
         Pred      : constant W_Predicate_Id :=
            Universal_Quantif_Get_Pred (Id);
      begin
         Result.Ada_Node := Ada_Node;
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Variables);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Identifier_Id := Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.UQ_Variables := NL;
         end;
         Set_Link (Result.UQ_Variables, New_Id);
         Result.UQ_Var_Type :=
           Duplicate_Primitive_Type
           (Id => Var_Type);
         Set_Link (Result.UQ_Var_Type, New_Id);
         if Triggers = Why_Empty then
            Result.UQ_Triggers := Why_Empty;
         else
            Result.UQ_Triggers :=
              Duplicate_Triggers
              (Id => Triggers);
         end if;
         Set_Link (Result.UQ_Triggers, New_Id);
         Result.UQ_Pred :=
           Duplicate_Predicate
           (Id => Pred);
         Set_Link (Result.UQ_Pred, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Universal_Quantif;

   -----------------------------------
   -- Duplicate_Existential_Quantif --
   -----------------------------------

   function Duplicate_Existential_Quantif
     (Ada_Node : Node_Id := Empty;
      Id       : W_Existential_Quantif_OId)
     return W_Existential_Quantif_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Existential_Quantif);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Existential_Quantif);
         Variables : constant W_Identifier_List :=
            Existential_Quantif_Get_Variables (Id);
         Var_Type  : constant W_Primitive_Type_Id :=
            Existential_Quantif_Get_Var_Type (Id);
         Pred      : constant W_Predicate_Id :=
            Existential_Quantif_Get_Pred (Id);
      begin
         Result.Ada_Node := Ada_Node;
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Variables);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Identifier_Id := Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.EQ_Variables := NL;
         end;
         Set_Link (Result.EQ_Variables, New_Id);
         Result.EQ_Var_Type :=
           Duplicate_Primitive_Type
           (Id => Var_Type);
         Set_Link (Result.EQ_Var_Type, New_Id);
         Result.EQ_Pred :=
           Duplicate_Predicate
           (Id => Pred);
         Set_Link (Result.EQ_Pred, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Existential_Quantif;

   -------------------------------
   -- Duplicate_Named_Predicate --
   -------------------------------

   function Duplicate_Named_Predicate
     (Ada_Node : Node_Id := Empty;
      Id       : W_Named_Predicate_OId)
     return W_Named_Predicate_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Named_Predicate);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Named_Predicate);
         Name : constant W_Identifier_Id :=
            Named_Predicate_Get_Name (Id);
         Pred : constant W_Predicate_Id :=
            Named_Predicate_Get_Pred (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.NP_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.NP_Name, New_Id);
         Result.NP_Pred :=
           Duplicate_Predicate
           (Id => Pred);
         Set_Link (Result.NP_Pred, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Named_Predicate;

   -----------------------------------
   -- Duplicate_Protected_Predicate --
   -----------------------------------

   function Duplicate_Protected_Predicate
     (Ada_Node : Node_Id := Empty;
      Id       : W_Protected_Predicate_OId)
     return W_Protected_Predicate_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Protected_Predicate);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Protected_Predicate);
         Pred : constant W_Predicate_Id :=
            Protected_Predicate_Get_Pred (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.PP_Pred :=
           Duplicate_Predicate
           (Id => Pred);
         Set_Link (Result.PP_Pred, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Protected_Predicate;

   -----------------------
   -- Duplicate_Pattern --
   -----------------------

   function Duplicate_Pattern
     (Ada_Node : Node_Id := Empty;
      Id       : W_Pattern_OId)
     return W_Pattern_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Pattern);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Pattern);
         Constr : constant W_Identifier_Id :=
            Pattern_Get_Constr (Id);
         Args   : constant W_Identifier_OList :=
            Pattern_Get_Args (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.PAT_Constr :=
           Duplicate_Identifier
           (Id => Constr);
         Set_Link (Result.PAT_Constr, New_Id);
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Args);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Identifier_Id := Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.PAT_Args := NL;
         end;
         Set_Link (Result.PAT_Args, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Pattern;

   --------------------------
   -- Duplicate_Match_Case --
   --------------------------

   function Duplicate_Match_Case
     (Ada_Node : Node_Id := Empty;
      Id       : W_Match_Case_OId)
     return W_Match_Case_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Match_Case);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Match_Case);
         Pattern : constant W_Pattern_Id :=
            Match_Case_Get_Pattern (Id);
         Term    : constant W_Term_Id :=
            Match_Case_Get_Term (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.MC_Pattern :=
           Duplicate_Pattern
           (Id => Pattern);
         Set_Link (Result.MC_Pattern, New_Id);
         Result.MC_Term :=
           Duplicate_Term
           (Id => Term);
         Set_Link (Result.MC_Term, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Match_Case;

   ------------------------
   -- Duplicate_Triggers --
   ------------------------

   function Duplicate_Triggers
     (Ada_Node : Node_Id := Empty;
      Id       : W_Triggers_OId)
     return W_Triggers_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Triggers);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Triggers);
         Triggers : constant W_Trigger_List :=
            Triggers_Get_Triggers (Id);
      begin
         Result.Ada_Node := Ada_Node;
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Triggers);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Trigger_Id := Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.TRS_Triggers := NL;
         end;
         Set_Link (Result.TRS_Triggers, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Triggers;

   -----------------------
   -- Duplicate_Trigger --
   -----------------------

   function Duplicate_Trigger
     (Ada_Node : Node_Id := Empty;
      Id       : W_Trigger_OId)
     return W_Trigger_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Trigger);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Trigger);
         Terms : constant W_Term_List :=
            Trigger_Get_Terms (Id);
      begin
         Result.Ada_Node := Ada_Node;
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Terms);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Term_Id := Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.TRI_Terms := NL;
         end;
         Set_Link (Result.TRI_Terms, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Trigger;

   ----------------------
   -- Duplicate_Rel_Eq --
   ----------------------

   function Duplicate_Rel_Eq
     (Ada_Node : Node_Id := Empty;
      Id       : W_Rel_Eq_OId)
     return W_Rel_Eq_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Rel_Eq);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Rel_Eq);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Rel_Eq;

   ----------------------
   -- Duplicate_Rel_Ne --
   ----------------------

   function Duplicate_Rel_Ne
     (Ada_Node : Node_Id := Empty;
      Id       : W_Rel_Ne_OId)
     return W_Rel_Ne_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Rel_Ne);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Rel_Ne);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Rel_Ne;

   ----------------------
   -- Duplicate_Rel_Lt --
   ----------------------

   function Duplicate_Rel_Lt
     (Ada_Node : Node_Id := Empty;
      Id       : W_Rel_Lt_OId)
     return W_Rel_Lt_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Rel_Lt);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Rel_Lt);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Rel_Lt;

   ----------------------
   -- Duplicate_Rel_Le --
   ----------------------

   function Duplicate_Rel_Le
     (Ada_Node : Node_Id := Empty;
      Id       : W_Rel_Le_OId)
     return W_Rel_Le_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Rel_Le);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Rel_Le);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Rel_Le;

   ----------------------
   -- Duplicate_Rel_Gt --
   ----------------------

   function Duplicate_Rel_Gt
     (Ada_Node : Node_Id := Empty;
      Id       : W_Rel_Gt_OId)
     return W_Rel_Gt_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Rel_Gt);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Rel_Gt);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Rel_Gt;

   ----------------------
   -- Duplicate_Rel_Ge --
   ----------------------

   function Duplicate_Rel_Ge
     (Ada_Node : Node_Id := Empty;
      Id       : W_Rel_Ge_OId)
     return W_Rel_Ge_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Rel_Ge);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Rel_Ge);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Rel_Ge;

   --------------------
   -- Duplicate_Type --
   --------------------

   function Duplicate_Type
     (Ada_Node : Node_Id := Empty;
      Id       : W_Type_OId)
     return W_Type_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Type);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Type);
         External        : constant W_External_OId :=
            Type_Get_External (Id);
         Type_Parameters : constant W_Identifier_OList :=
            Type_Get_Type_Parameters (Id);
         Name            : constant W_Identifier_Id :=
            Type_Get_Name (Id);
         Definition      : constant W_Type_Definition_OId :=
            Type_Get_Definition (Id);
      begin
         Result.Ada_Node := Ada_Node;
         if External = Why_Empty then
            Result.T_External := Why_Empty;
         else
            Result.T_External :=
              Duplicate_External
              (Id => External);
         end if;
         Set_Link (Result.T_External, New_Id);
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Type_Parameters);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Identifier_Id := Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.T_Type_Parameters := NL;
         end;
         Set_Link (Result.T_Type_Parameters, New_Id);
         Result.T_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.T_Name, New_Id);
         if Definition = Why_Empty then
            Result.T_Definition := Why_Empty;
         else
            Result.T_Definition :=
              Duplicate_Type_Definition
              (Id => Definition);
         end if;
         Set_Link (Result.T_Definition, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Type;

   ---------------------
   -- Duplicate_Logic --
   ---------------------

   function Duplicate_Logic
     (Ada_Node : Node_Id := Empty;
      Id       : W_Logic_OId)
     return W_Logic_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Logic);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Logic);
         External   : constant W_External_OId :=
            Logic_Get_External (Id);
         Names      : constant W_Identifier_List :=
            Logic_Get_Names (Id);
         Logic_Type : constant W_Logic_Type_Id :=
            Logic_Get_Logic_Type (Id);
      begin
         Result.Ada_Node := Ada_Node;
         if External = Why_Empty then
            Result.L_External := Why_Empty;
         else
            Result.L_External :=
              Duplicate_External
              (Id => External);
         end if;
         Set_Link (Result.L_External, New_Id);
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Names);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Identifier_Id := Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.L_Names := NL;
         end;
         Set_Link (Result.L_Names, New_Id);
         Result.L_Logic_Type :=
           Duplicate_Logic_Type
           (Id => Logic_Type);
         Set_Link (Result.L_Logic_Type, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Logic;

   ------------------------
   -- Duplicate_Function --
   ------------------------

   function Duplicate_Function
     (Ada_Node : Node_Id := Empty;
      Id       : W_Function_OId)
     return W_Function_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Function);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Function);
         Name        : constant W_Identifier_Id :=
            Function_Get_Name (Id);
         Binders     : constant W_Logic_Binder_List :=
            Function_Get_Binders (Id);
         Return_Type : constant W_Primitive_Type_Id :=
            Function_Get_Return_Type (Id);
         Def         : constant W_Term_Id :=
            Function_Get_Def (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.F_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.F_Name, New_Id);
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Binders);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Logic_Binder_Id := Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.F_Binders := NL;
         end;
         Set_Link (Result.F_Binders, New_Id);
         Result.F_Return_Type :=
           Duplicate_Primitive_Type
           (Id => Return_Type);
         Set_Link (Result.F_Return_Type, New_Id);
         Result.F_Def :=
           Duplicate_Term
           (Id => Def);
         Set_Link (Result.F_Def, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Function;

   ------------------------------------
   -- Duplicate_Predicate_Definition --
   ------------------------------------

   function Duplicate_Predicate_Definition
     (Ada_Node : Node_Id := Empty;
      Id       : W_Predicate_Definition_OId)
     return W_Predicate_Definition_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Predicate_Definition);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Predicate_Definition);
         Name    : constant W_Identifier_Id :=
            Predicate_Definition_Get_Name (Id);
         Binders : constant W_Logic_Binder_List :=
            Predicate_Definition_Get_Binders (Id);
         Def     : constant W_Predicate_Id :=
            Predicate_Definition_Get_Def (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.P_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.P_Name, New_Id);
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Binders);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Logic_Binder_Id := Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.P_Binders := NL;
         end;
         Set_Link (Result.P_Binders, New_Id);
         Result.P_Def :=
           Duplicate_Predicate
           (Id => Def);
         Set_Link (Result.P_Def, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Predicate_Definition;

   -------------------------
   -- Duplicate_Inductive --
   -------------------------

   function Duplicate_Inductive
     (Ada_Node : Node_Id := Empty;
      Id       : W_Inductive_OId)
     return W_Inductive_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Inductive);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Inductive);
         Name       : constant W_Identifier_Id :=
            Inductive_Get_Name (Id);
         Logic_Type : constant W_Logic_Type_Id :=
            Inductive_Get_Logic_Type (Id);
         Def        : constant W_Inductive_Case_List :=
            Inductive_Get_Def (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.I_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.I_Name, New_Id);
         Result.I_Logic_Type :=
           Duplicate_Logic_Type
           (Id => Logic_Type);
         Set_Link (Result.I_Logic_Type, New_Id);
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Def);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Inductive_Case_Id := Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.I_Def := NL;
         end;
         Set_Link (Result.I_Def, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Inductive;

   ---------------------
   -- Duplicate_Axiom --
   ---------------------

   function Duplicate_Axiom
     (Ada_Node : Node_Id := Empty;
      Id       : W_Axiom_OId)
     return W_Axiom_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Axiom);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Axiom);
         Name : constant W_Identifier_Id :=
            Axiom_Get_Name (Id);
         Def  : constant W_Predicate_Id :=
            Axiom_Get_Def (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.AX_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.AX_Name, New_Id);
         Result.AX_Def :=
           Duplicate_Predicate
           (Id => Def);
         Set_Link (Result.AX_Def, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Axiom;

   --------------------
   -- Duplicate_Goal --
   --------------------

   function Duplicate_Goal
     (Ada_Node : Node_Id := Empty;
      Id       : W_Goal_OId)
     return W_Goal_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Goal);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Goal);
         Name : constant W_Identifier_Id :=
            Goal_Get_Name (Id);
         Def  : constant W_Predicate_Id :=
            Goal_Get_Def (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.G_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.G_Name, New_Id);
         Result.G_Def :=
           Duplicate_Predicate
           (Id => Def);
         Set_Link (Result.G_Def, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Goal;

   ------------------------
   -- Duplicate_External --
   ------------------------

   function Duplicate_External
     (Ada_Node : Node_Id := Empty;
      Id       : W_External_OId)
     return W_External_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_External);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_External);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_External;

   --------------------------
   -- Duplicate_Logic_Type --
   --------------------------

   function Duplicate_Logic_Type
     (Ada_Node : Node_Id := Empty;
      Id       : W_Logic_Type_OId)
     return W_Logic_Type_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Logic_Type);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Logic_Type);
         Arg_Types   : constant W_Logic_Arg_Type_List :=
            Logic_Type_Get_Arg_Types (Id);
         Return_Type : constant W_Logic_Return_Type_Id :=
            Logic_Type_Get_Return_Type (Id);
      begin
         Result.Ada_Node := Ada_Node;
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Arg_Types);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Logic_Arg_Type_Id := Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.LT_Arg_Types := NL;
         end;
         Set_Link (Result.LT_Arg_Types, New_Id);
         Result.LT_Return_Type :=
           Duplicate_Logic_Return_Type
           (Id => Return_Type);
         Set_Link (Result.LT_Return_Type, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Logic_Type;

   ----------------------------
   -- Duplicate_Logic_Binder --
   ----------------------------

   function Duplicate_Logic_Binder
     (Ada_Node : Node_Id := Empty;
      Id       : W_Logic_Binder_OId)
     return W_Logic_Binder_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Logic_Binder);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Logic_Binder);
         Name       : constant W_Identifier_Id :=
            Logic_Binder_Get_Name (Id);
         Param_Type : constant W_Primitive_Type_Id :=
            Logic_Binder_Get_Param_Type (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.LB_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.LB_Name, New_Id);
         Result.LB_Param_Type :=
           Duplicate_Primitive_Type
           (Id => Param_Type);
         Set_Link (Result.LB_Param_Type, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Logic_Binder;

   ------------------------------
   -- Duplicate_Inductive_Case --
   ------------------------------

   function Duplicate_Inductive_Case
     (Ada_Node : Node_Id := Empty;
      Id       : W_Inductive_Case_OId)
     return W_Inductive_Case_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Inductive_Case);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Inductive_Case);
         Name : constant W_Identifier_Id :=
            Inductive_Case_Get_Name (Id);
         Pred : constant W_Predicate_Id :=
            Inductive_Case_Get_Pred (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.IC_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.IC_Name, New_Id);
         Result.IC_Pred :=
           Duplicate_Predicate
           (Id => Pred);
         Set_Link (Result.IC_Pred, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Inductive_Case;

   -------------------------------------------
   -- Duplicate_Transparent_Type_Definition --
   -------------------------------------------

   function Duplicate_Transparent_Type_Definition
     (Ada_Node : Node_Id := Empty;
      Id       : W_Transparent_Type_Definition_OId)
     return W_Transparent_Type_Definition_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Transparent_Type_Definition);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Transparent_Type_Definition);
         Type_Definition : constant W_Primitive_Type_Id :=
            Transparent_Type_Definition_Get_Type_Definition (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Tr_Type_Definition :=
           Duplicate_Primitive_Type
           (Id => Type_Definition);
         Set_Link (Result.Tr_Type_Definition, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Transparent_Type_Definition;

   ------------------------------
   -- Duplicate_Adt_Definition --
   ------------------------------

   function Duplicate_Adt_Definition
     (Ada_Node : Node_Id := Empty;
      Id       : W_Adt_Definition_OId)
     return W_Adt_Definition_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Adt_Definition);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Adt_Definition);
         Constructors : constant W_Constr_Decl_List :=
            Adt_Definition_Get_Constructors (Id);
      begin
         Result.Ada_Node := Ada_Node;
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Constructors);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Constr_Decl_Id := Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.Adt_Constructors := NL;
         end;
         Set_Link (Result.Adt_Constructors, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Adt_Definition;

   ---------------------------
   -- Duplicate_Constr_Decl --
   ---------------------------

   function Duplicate_Constr_Decl
     (Ada_Node : Node_Id := Empty;
      Id       : W_Constr_Decl_OId)
     return W_Constr_Decl_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Constr_Decl);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Constr_Decl);
         Name     : constant W_Identifier_Id :=
            Constr_Decl_Get_Name (Id);
         Arg_List : constant W_Primitive_Type_OList :=
            Constr_Decl_Get_Arg_List (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.C_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.C_Name, New_Id);
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Arg_List);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Primitive_Type_Id := Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.C_Arg_List := NL;
         end;
         Set_Link (Result.C_Arg_List, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Constr_Decl;

   -----------------------
   -- Duplicate_Effects --
   -----------------------

   function Duplicate_Effects
     (Ada_Node : Node_Id := Empty;
      Id       : W_Effects_OId)
     return W_Effects_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Effects);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Effects);
         Reads  : constant W_Identifier_OList :=
            Effects_Get_Reads (Id);
         Writes : constant W_Identifier_OList :=
            Effects_Get_Writes (Id);
         Raises : constant W_Identifier_OList :=
            Effects_Get_Raises (Id);
      begin
         Result.Ada_Node := Ada_Node;
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Reads);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Identifier_Id := Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.E_Reads := NL;
         end;
         Set_Link (Result.E_Reads, New_Id);
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Writes);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Identifier_Id := Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.E_Writes := NL;
         end;
         Set_Link (Result.E_Writes, New_Id);
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Raises);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Identifier_Id := Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.E_Raises := NL;
         end;
         Set_Link (Result.E_Raises, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Effects;

   ----------------------------
   -- Duplicate_Precondition --
   ----------------------------

   function Duplicate_Precondition
     (Ada_Node : Node_Id := Empty;
      Id       : W_Precondition_OId)
     return W_Precondition_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Precondition);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Precondition);
         Assertion : constant W_Assertion_Id :=
            Precondition_Get_Assertion (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.PRE_Assertion :=
           Duplicate_Assertion
           (Id => Assertion);
         Set_Link (Result.PRE_Assertion, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Precondition;

   -----------------------------
   -- Duplicate_Postcondition --
   -----------------------------

   function Duplicate_Postcondition
     (Ada_Node : Node_Id := Empty;
      Id       : W_Postcondition_OId)
     return W_Postcondition_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Postcondition);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Postcondition);
         Assertion : constant W_Assertion_Id :=
            Postcondition_Get_Assertion (Id);
         Handlers  : constant W_Exn_Condition_OList :=
            Postcondition_Get_Handlers (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.POST_Assertion :=
           Duplicate_Assertion
           (Id => Assertion);
         Set_Link (Result.POST_Assertion, New_Id);
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Handlers);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Exn_Condition_Id := Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.POST_Handlers := NL;
         end;
         Set_Link (Result.POST_Handlers, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Postcondition;

   -----------------------------
   -- Duplicate_Exn_Condition --
   -----------------------------

   function Duplicate_Exn_Condition
     (Ada_Node : Node_Id := Empty;
      Id       : W_Exn_Condition_OId)
     return W_Exn_Condition_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Exn_Condition);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Exn_Condition);
         Exn_Case  : constant W_Identifier_Id :=
            Exn_Condition_Get_Exn_Case (Id);
         Assertion : constant W_Assertion_Id :=
            Exn_Condition_Get_Assertion (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.EC_Exn_Case :=
           Duplicate_Identifier
           (Id => Exn_Case);
         Set_Link (Result.EC_Exn_Case, New_Id);
         Result.EC_Assertion :=
           Duplicate_Assertion
           (Id => Assertion);
         Set_Link (Result.EC_Assertion, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Exn_Condition;

   -------------------------
   -- Duplicate_Assertion --
   -------------------------

   function Duplicate_Assertion
     (Ada_Node : Node_Id := Empty;
      Id       : W_Assertion_OId)
     return W_Assertion_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Assertion);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Assertion);
         Pred : constant W_Predicate_Id :=
            Assertion_Get_Pred (Id);
         As   : constant W_Identifier_OId :=
            Assertion_Get_As (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.A_Pred :=
           Duplicate_Predicate
           (Id => Pred);
         Set_Link (Result.A_Pred, New_Id);
         if As = Why_Empty then
            Result.A_As := Why_Empty;
         else
            Result.A_As :=
              Duplicate_Identifier
              (Id => As);
         end if;
         Set_Link (Result.A_As, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Assertion;

   -----------------------------
   -- Duplicate_Prog_Constant --
   -----------------------------

   function Duplicate_Prog_Constant
     (Ada_Node : Node_Id := Empty;
      Id       : W_Prog_Constant_OId)
     return W_Prog_Constant_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Prog_Constant);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Prog_Constant);
         Def : constant W_Constant_Id :=
            Prog_Constant_Get_Def (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.PC_Def :=
           Duplicate_Constant
           (Id => Def);
         Set_Link (Result.PC_Def, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Prog_Constant;

   -------------------------------
   -- Duplicate_Prog_Identifier --
   -------------------------------

   function Duplicate_Prog_Identifier
     (Ada_Node : Node_Id := Empty;
      Id       : W_Prog_Identifier_OId)
     return W_Prog_Identifier_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Prog_Identifier);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Prog_Identifier);
         Def : constant W_Identifier_Id :=
            Prog_Identifier_Get_Def (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.PI_Def :=
           Duplicate_Identifier
           (Id => Def);
         Set_Link (Result.PI_Def, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Prog_Identifier;

   ---------------------
   -- Duplicate_Deref --
   ---------------------

   function Duplicate_Deref
     (Ada_Node : Node_Id := Empty;
      Id       : W_Deref_OId)
     return W_Deref_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Deref);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Deref);
         Ref : constant W_Identifier_Id :=
            Deref_Get_Ref (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.D_Ref :=
           Duplicate_Identifier
           (Id => Ref);
         Set_Link (Result.D_Ref, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Deref;

   --------------------------
   -- Duplicate_Assignment --
   --------------------------

   function Duplicate_Assignment
     (Ada_Node : Node_Id := Empty;
      Id       : W_Assignment_OId)
     return W_Assignment_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Assignment);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Assignment);
         Name  : constant W_Identifier_Id :=
            Assignment_Get_Name (Id);
         Value : constant W_Prog_Id :=
            Assignment_Get_Value (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.A_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.A_Name, New_Id);
         Result.A_Value :=
           Duplicate_Prog
           (Id => Value);
         Set_Link (Result.A_Value, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Assignment;

   ----------------------------
   -- Duplicate_Array_Access --
   ----------------------------

   function Duplicate_Array_Access
     (Ada_Node : Node_Id := Empty;
      Id       : W_Array_Access_OId)
     return W_Array_Access_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Array_Access);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Array_Access);
         Name  : constant W_Identifier_Id :=
            Array_Access_Get_Name (Id);
         Index : constant W_Prog_Id :=
            Array_Access_Get_Index (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.AA_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.AA_Name, New_Id);
         Result.AA_Index :=
           Duplicate_Prog
           (Id => Index);
         Set_Link (Result.AA_Index, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Array_Access;

   ----------------------------
   -- Duplicate_Array_Update --
   ----------------------------

   function Duplicate_Array_Update
     (Ada_Node : Node_Id := Empty;
      Id       : W_Array_Update_OId)
     return W_Array_Update_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Array_Update);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Array_Update);
         Name  : constant W_Identifier_Id :=
            Array_Update_Get_Name (Id);
         Index : constant W_Prog_Id :=
            Array_Update_Get_Index (Id);
         Value : constant W_Prog_Id :=
            Array_Update_Get_Value (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.AU_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.AU_Name, New_Id);
         Result.AU_Index :=
           Duplicate_Prog
           (Id => Index);
         Set_Link (Result.AU_Index, New_Id);
         Result.AU_Value :=
           Duplicate_Prog
           (Id => Value);
         Set_Link (Result.AU_Value, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Array_Update;

   --------------------------
   -- Duplicate_Infix_Call --
   --------------------------

   function Duplicate_Infix_Call
     (Ada_Node : Node_Id := Empty;
      Id       : W_Infix_Call_OId)
     return W_Infix_Call_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Infix_Call);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Infix_Call);
         Left  : constant W_Prog_Id :=
            Infix_Call_Get_Left (Id);
         Infix : constant W_Infix_Id :=
            Infix_Call_Get_Infix (Id);
         Right : constant W_Prog_Id :=
            Infix_Call_Get_Right (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.IC_Left :=
           Duplicate_Prog
           (Id => Left);
         Set_Link (Result.IC_Left, New_Id);
         Result.IC_Infix :=
           Duplicate_Infix
           (Id => Infix);
         Set_Link (Result.IC_Infix, New_Id);
         Result.IC_Right :=
           Duplicate_Prog
           (Id => Right);
         Set_Link (Result.IC_Right, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Infix_Call;

   ---------------------------
   -- Duplicate_Prefix_Call --
   ---------------------------

   function Duplicate_Prefix_Call
     (Ada_Node : Node_Id := Empty;
      Id       : W_Prefix_Call_OId)
     return W_Prefix_Call_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Prefix_Call);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Prefix_Call);
         Prefix  : constant W_Prefix_Id :=
            Prefix_Call_Get_Prefix (Id);
         Operand : constant W_Prog_Id :=
            Prefix_Call_Get_Operand (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.PC_Prefix :=
           Duplicate_Prefix
           (Id => Prefix);
         Set_Link (Result.PC_Prefix, New_Id);
         Result.PC_Operand :=
           Duplicate_Prog
           (Id => Operand);
         Set_Link (Result.PC_Operand, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Prefix_Call;

   ----------------------------
   -- Duplicate_Binding_Prog --
   ----------------------------

   function Duplicate_Binding_Prog
     (Ada_Node : Node_Id := Empty;
      Id       : W_Binding_Prog_OId)
     return W_Binding_Prog_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Binding_Prog);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Binding_Prog);
         Name    : constant W_Identifier_Id :=
            Binding_Prog_Get_Name (Id);
         Def     : constant W_Prog_Id :=
            Binding_Prog_Get_Def (Id);
         Context : constant W_Prog_Id :=
            Binding_Prog_Get_Context (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.BPG_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.BPG_Name, New_Id);
         Result.BPG_Def :=
           Duplicate_Prog
           (Id => Def);
         Set_Link (Result.BPG_Def, New_Id);
         Result.BPG_Context :=
           Duplicate_Prog
           (Id => Context);
         Set_Link (Result.BPG_Context, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Binding_Prog;

   ---------------------------
   -- Duplicate_Binding_Ref --
   ---------------------------

   function Duplicate_Binding_Ref
     (Ada_Node : Node_Id := Empty;
      Id       : W_Binding_Ref_OId)
     return W_Binding_Ref_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Binding_Ref);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Binding_Ref);
         Name    : constant W_Identifier_Id :=
            Binding_Ref_Get_Name (Id);
         Def     : constant W_Prog_Id :=
            Binding_Ref_Get_Def (Id);
         Context : constant W_Prog_Id :=
            Binding_Ref_Get_Context (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.BPG_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.BPG_Name, New_Id);
         Result.BPG_Def :=
           Duplicate_Prog
           (Id => Def);
         Set_Link (Result.BPG_Def, New_Id);
         Result.BPG_Context :=
           Duplicate_Prog
           (Id => Context);
         Set_Link (Result.BPG_Context, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Binding_Ref;

   --------------------------------
   -- Duplicate_Conditional_Prog --
   --------------------------------

   function Duplicate_Conditional_Prog
     (Ada_Node : Node_Id := Empty;
      Id       : W_Conditional_Prog_OId)
     return W_Conditional_Prog_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Conditional_Prog);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Conditional_Prog);
         Condition : constant W_Prog_Id :=
            Conditional_Prog_Get_Condition (Id);
         Then_Part : constant W_Prog_Id :=
            Conditional_Prog_Get_Then_Part (Id);
         Else_Part : constant W_Prog_OId :=
            Conditional_Prog_Get_Else_Part (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.CPG_Condition :=
           Duplicate_Prog
           (Id => Condition);
         Set_Link (Result.CPG_Condition, New_Id);
         Result.CPG_Then_Part :=
           Duplicate_Prog
           (Id => Then_Part);
         Set_Link (Result.CPG_Then_Part, New_Id);
         if Else_Part = Why_Empty then
            Result.CPG_Else_Part := Why_Empty;
         else
            Result.CPG_Else_Part :=
              Duplicate_Prog
              (Id => Else_Part);
         end if;
         Set_Link (Result.CPG_Else_Part, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Conditional_Prog;

   --------------------------
   -- Duplicate_While_Loop --
   --------------------------

   function Duplicate_While_Loop
     (Ada_Node : Node_Id := Empty;
      Id       : W_While_Loop_OId)
     return W_While_Loop_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_While_Loop);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_While_Loop);
         Condition    : constant W_Prog_Id :=
            While_Loop_Get_Condition (Id);
         Annotation   : constant W_Loop_Annot_Id :=
            While_Loop_Get_Annotation (Id);
         Loop_Content : constant W_Prog_Id :=
            While_Loop_Get_Loop_Content (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.WL_Condition :=
           Duplicate_Prog
           (Id => Condition);
         Set_Link (Result.WL_Condition, New_Id);
         Result.WL_Annotation :=
           Duplicate_Loop_Annot
           (Id => Annotation);
         Set_Link (Result.WL_Annotation, New_Id);
         Result.WL_Loop_Content :=
           Duplicate_Prog
           (Id => Loop_Content);
         Set_Link (Result.WL_Loop_Content, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_While_Loop;

   ----------------------------------
   -- Duplicate_Statement_Sequence --
   ----------------------------------

   function Duplicate_Statement_Sequence
     (Ada_Node : Node_Id := Empty;
      Id       : W_Statement_Sequence_OId)
     return W_Statement_Sequence_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Statement_Sequence);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Statement_Sequence);
         Statements : constant W_Prog_List :=
            Statement_Sequence_Get_Statements (Id);
      begin
         Result.Ada_Node := Ada_Node;
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Statements);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Prog_Id := Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.SS_Statements := NL;
         end;
         Set_Link (Result.SS_Statements, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Statement_Sequence;

   ---------------------
   -- Duplicate_Label --
   ---------------------

   function Duplicate_Label
     (Ada_Node : Node_Id := Empty;
      Id       : W_Label_OId)
     return W_Label_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Label);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Label);
         Name : constant W_Identifier_Id :=
            Label_Get_Name (Id);
         Def  : constant W_Prog_Id :=
            Label_Get_Def (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.L_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.L_Name, New_Id);
         Result.L_Def :=
           Duplicate_Prog
           (Id => Def);
         Set_Link (Result.L_Def, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Label;

   ----------------------
   -- Duplicate_Assert --
   ----------------------

   function Duplicate_Assert
     (Ada_Node : Node_Id := Empty;
      Id       : W_Assert_OId)
     return W_Assert_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Assert);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Assert);
         Assertions : constant W_Assertion_List :=
            Assert_Get_Assertions (Id);
         Prog       : constant W_Prog_Id :=
            Assert_Get_Prog (Id);
      begin
         Result.Ada_Node := Ada_Node;
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Assertions);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Assertion_Id := Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.AS_Assertions := NL;
         end;
         Set_Link (Result.AS_Assertions, New_Id);
         Result.AS_Prog :=
           Duplicate_Prog
           (Id => Prog);
         Set_Link (Result.AS_Prog, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Assert;

   ------------------------------
   -- Duplicate_Post_Assertion --
   ------------------------------

   function Duplicate_Post_Assertion
     (Ada_Node : Node_Id := Empty;
      Id       : W_Post_Assertion_OId)
     return W_Post_Assertion_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Post_Assertion);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Post_Assertion);
         Prog : constant W_Prog_Id :=
            Post_Assertion_Get_Prog (Id);
         Post : constant W_Postcondition_Id :=
            Post_Assertion_Get_Post (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.PA_Prog :=
           Duplicate_Prog
           (Id => Prog);
         Set_Link (Result.PA_Prog, New_Id);
         Result.PA_Post :=
           Duplicate_Postcondition
           (Id => Post);
         Set_Link (Result.PA_Post, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Post_Assertion;

   --------------------------------
   -- Duplicate_Opaque_Assertion --
   --------------------------------

   function Duplicate_Opaque_Assertion
     (Ada_Node : Node_Id := Empty;
      Id       : W_Opaque_Assertion_OId)
     return W_Opaque_Assertion_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Opaque_Assertion);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Opaque_Assertion);
         Prog : constant W_Prog_Id :=
            Opaque_Assertion_Get_Prog (Id);
         Post : constant W_Postcondition_Id :=
            Opaque_Assertion_Get_Post (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.PA_Prog :=
           Duplicate_Prog
           (Id => Prog);
         Set_Link (Result.PA_Prog, New_Id);
         Result.PA_Post :=
           Duplicate_Postcondition
           (Id => Post);
         Set_Link (Result.PA_Post, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Opaque_Assertion;

   -----------------------
   -- Duplicate_Fun_Def --
   -----------------------

   function Duplicate_Fun_Def
     (Ada_Node : Node_Id := Empty;
      Id       : W_Fun_Def_OId)
     return W_Fun_Def_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Fun_Def);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Fun_Def);
         Binders : constant W_Binders_Id :=
            Fun_Def_Get_Binders (Id);
         Pre     : constant W_Precondition_Id :=
            Fun_Def_Get_Pre (Id);
         Def     : constant W_Prog_Id :=
            Fun_Def_Get_Def (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.FD_Binders :=
           Duplicate_Binders
           (Id => Binders);
         Set_Link (Result.FD_Binders, New_Id);
         Result.FD_Pre :=
           Duplicate_Precondition
           (Id => Pre);
         Set_Link (Result.FD_Pre, New_Id);
         Result.FD_Def :=
           Duplicate_Prog
           (Id => Def);
         Set_Link (Result.FD_Def, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Fun_Def;

   ---------------------------
   -- Duplicate_Binding_Fun --
   ---------------------------

   function Duplicate_Binding_Fun
     (Ada_Node : Node_Id := Empty;
      Id       : W_Binding_Fun_OId)
     return W_Binding_Fun_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Binding_Fun);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Binding_Fun);
         Name    : constant W_Identifier_Id :=
            Binding_Fun_Get_Name (Id);
         Binders : constant W_Binders_Id :=
            Binding_Fun_Get_Binders (Id);
         Pre     : constant W_Precondition_Id :=
            Binding_Fun_Get_Pre (Id);
         Def     : constant W_Prog_Id :=
            Binding_Fun_Get_Def (Id);
         Context : constant W_Prog_Id :=
            Binding_Fun_Get_Context (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.BF_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.BF_Name, New_Id);
         Result.BF_Binders :=
           Duplicate_Binders
           (Id => Binders);
         Set_Link (Result.BF_Binders, New_Id);
         Result.BF_Pre :=
           Duplicate_Precondition
           (Id => Pre);
         Set_Link (Result.BF_Pre, New_Id);
         Result.BF_Def :=
           Duplicate_Prog
           (Id => Def);
         Set_Link (Result.BF_Def, New_Id);
         Result.BF_Context :=
           Duplicate_Prog
           (Id => Context);
         Set_Link (Result.BF_Context, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Binding_Fun;

   ---------------------------
   -- Duplicate_Binding_Rec --
   ---------------------------

   function Duplicate_Binding_Rec
     (Ada_Node : Node_Id := Empty;
      Id       : W_Binding_Rec_OId)
     return W_Binding_Rec_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Binding_Rec);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Binding_Rec);
         Recfun  : constant W_Recfun_Id :=
            Binding_Rec_Get_Recfun (Id);
         Context : constant W_Prog_Id :=
            Binding_Rec_Get_Context (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.BR_Recfun :=
           Duplicate_Recfun
           (Id => Recfun);
         Set_Link (Result.BR_Recfun, New_Id);
         Result.BR_Context :=
           Duplicate_Prog
           (Id => Context);
         Set_Link (Result.BR_Context, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Binding_Rec;

   -----------------------------
   -- Duplicate_Prog_Sequence --
   -----------------------------

   function Duplicate_Prog_Sequence
     (Ada_Node : Node_Id := Empty;
      Id       : W_Prog_Sequence_OId)
     return W_Prog_Sequence_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Prog_Sequence);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Prog_Sequence);
         Progs : constant W_Prog_List :=
            Prog_Sequence_Get_Progs (Id);
      begin
         Result.Ada_Node := Ada_Node;
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Progs);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Prog_Id := Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.PS_Progs := NL;
         end;
         Set_Link (Result.PS_Progs, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Prog_Sequence;

   -------------------------------
   -- Duplicate_Raise_Statement --
   -------------------------------

   function Duplicate_Raise_Statement
     (Ada_Node : Node_Id := Empty;
      Id       : W_Raise_Statement_OId)
     return W_Raise_Statement_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Raise_Statement);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Raise_Statement);
         Name     : constant W_Identifier_Id :=
            Raise_Statement_Get_Name (Id);
         Exn_Type : constant W_Value_Type_OId :=
            Raise_Statement_Get_Exn_Type (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.RS_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.RS_Name, New_Id);
         if Exn_Type = Why_Empty then
            Result.RS_Exn_Type := Why_Empty;
         else
            Result.RS_Exn_Type :=
              Duplicate_Value_Type
              (Id => Exn_Type);
         end if;
         Set_Link (Result.RS_Exn_Type, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Raise_Statement;

   -----------------------------------------------
   -- Duplicate_Raise_Statement_With_Parameters --
   -----------------------------------------------

   function Duplicate_Raise_Statement_With_Parameters
     (Ada_Node : Node_Id := Empty;
      Id       : W_Raise_Statement_With_Parameters_OId)
     return W_Raise_Statement_With_Parameters_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Raise_Statement_With_Parameters);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Raise_Statement_With_Parameters);
         Name      : constant W_Identifier_Id :=
            Raise_Statement_With_Parameters_Get_Name (Id);
         Parameter : constant W_Term_Id :=
            Raise_Statement_With_Parameters_Get_Parameter (Id);
         Exn_Type  : constant W_Value_Type_OId :=
            Raise_Statement_With_Parameters_Get_Exn_Type (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.RSWP_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.RSWP_Name, New_Id);
         Result.RSWP_Parameter :=
           Duplicate_Term
           (Id => Parameter);
         Set_Link (Result.RSWP_Parameter, New_Id);
         if Exn_Type = Why_Empty then
            Result.RSWP_Exn_Type := Why_Empty;
         else
            Result.RSWP_Exn_Type :=
              Duplicate_Value_Type
              (Id => Exn_Type);
         end if;
         Set_Link (Result.RSWP_Exn_Type, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Raise_Statement_With_Parameters;

   -------------------------
   -- Duplicate_Try_Block --
   -------------------------

   function Duplicate_Try_Block
     (Ada_Node : Node_Id := Empty;
      Id       : W_Try_Block_OId)
     return W_Try_Block_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Try_Block);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Try_Block);
         Prog    : constant W_Prog_Id :=
            Try_Block_Get_Prog (Id);
         Handler : constant W_Handler_List :=
            Try_Block_Get_Handler (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.TB_Prog :=
           Duplicate_Prog
           (Id => Prog);
         Set_Link (Result.TB_Prog, New_Id);
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Handler);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Handler_Id := Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.TB_Handler := NL;
         end;
         Set_Link (Result.TB_Handler, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Try_Block;

   --------------------------------
   -- Duplicate_Unreachable_Code --
   --------------------------------

   function Duplicate_Unreachable_Code
     (Ada_Node : Node_Id := Empty;
      Id       : W_Unreachable_Code_OId)
     return W_Unreachable_Code_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Unreachable_Code);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Unreachable_Code);
         Exn_Type : constant W_Value_Type_OId :=
            Unreachable_Code_Get_Exn_Type (Id);
      begin
         Result.Ada_Node := Ada_Node;
         if Exn_Type = Why_Empty then
            Result.UC_Exn_Type := Why_Empty;
         else
            Result.UC_Exn_Type :=
              Duplicate_Value_Type
              (Id => Exn_Type);
         end if;
         Set_Link (Result.UC_Exn_Type, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Unreachable_Code;

   ---------------------------
   -- Duplicate_Begin_Block --
   ---------------------------

   function Duplicate_Begin_Block
     (Ada_Node : Node_Id := Empty;
      Id       : W_Begin_Block_OId)
     return W_Begin_Block_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Begin_Block);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Begin_Block);
         Prog : constant W_Prog_Id :=
            Begin_Block_Get_Prog (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.BB_Prog :=
           Duplicate_Prog
           (Id => Prog);
         Set_Link (Result.BB_Prog, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Begin_Block;

   ------------------------------
   -- Duplicate_Protected_Prog --
   ------------------------------

   function Duplicate_Protected_Prog
     (Ada_Node : Node_Id := Empty;
      Id       : W_Protected_Prog_OId)
     return W_Protected_Prog_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Protected_Prog);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Protected_Prog);
         Prog : constant W_Prog_Id :=
            Protected_Prog_Get_Prog (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.BB_Prog :=
           Duplicate_Prog
           (Id => Prog);
         Set_Link (Result.BB_Prog, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Protected_Prog;

   ---------------------------
   -- Duplicate_Op_Add_Prog --
   ---------------------------

   function Duplicate_Op_Add_Prog
     (Ada_Node : Node_Id := Empty;
      Id       : W_Op_Add_Prog_OId)
     return W_Op_Add_Prog_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Op_Add_Prog);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Op_Add_Prog);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Op_Add_Prog;

   ---------------------------------
   -- Duplicate_Op_Substract_Prog --
   ---------------------------------

   function Duplicate_Op_Substract_Prog
     (Ada_Node : Node_Id := Empty;
      Id       : W_Op_Substract_Prog_OId)
     return W_Op_Substract_Prog_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Op_Substract_Prog);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Op_Substract_Prog);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Op_Substract_Prog;

   --------------------------------
   -- Duplicate_Op_Multiply_Prog --
   --------------------------------

   function Duplicate_Op_Multiply_Prog
     (Ada_Node : Node_Id := Empty;
      Id       : W_Op_Multiply_Prog_OId)
     return W_Op_Multiply_Prog_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Op_Multiply_Prog);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Op_Multiply_Prog);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Op_Multiply_Prog;

   ------------------------------
   -- Duplicate_Op_Divide_Prog --
   ------------------------------

   function Duplicate_Op_Divide_Prog
     (Ada_Node : Node_Id := Empty;
      Id       : W_Op_Divide_Prog_OId)
     return W_Op_Divide_Prog_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Op_Divide_Prog);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Op_Divide_Prog);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Op_Divide_Prog;

   ---------------------------
   -- Duplicate_Op_Mod_Prog --
   ---------------------------

   function Duplicate_Op_Mod_Prog
     (Ada_Node : Node_Id := Empty;
      Id       : W_Op_Mod_Prog_OId)
     return W_Op_Mod_Prog_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Op_Mod_Prog);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Op_Mod_Prog);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Op_Mod_Prog;

   --------------------------
   -- Duplicate_Op_Eq_Prog --
   --------------------------

   function Duplicate_Op_Eq_Prog
     (Ada_Node : Node_Id := Empty;
      Id       : W_Op_Eq_Prog_OId)
     return W_Op_Eq_Prog_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Op_Eq_Prog);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Op_Eq_Prog);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Op_Eq_Prog;

   --------------------------
   -- Duplicate_Op_Ne_Prog --
   --------------------------

   function Duplicate_Op_Ne_Prog
     (Ada_Node : Node_Id := Empty;
      Id       : W_Op_Ne_Prog_OId)
     return W_Op_Ne_Prog_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Op_Ne_Prog);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Op_Ne_Prog);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Op_Ne_Prog;

   --------------------------
   -- Duplicate_Op_Lt_Prog --
   --------------------------

   function Duplicate_Op_Lt_Prog
     (Ada_Node : Node_Id := Empty;
      Id       : W_Op_Lt_Prog_OId)
     return W_Op_Lt_Prog_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Op_Lt_Prog);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Op_Lt_Prog);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Op_Lt_Prog;

   --------------------------
   -- Duplicate_Op_Le_Prog --
   --------------------------

   function Duplicate_Op_Le_Prog
     (Ada_Node : Node_Id := Empty;
      Id       : W_Op_Le_Prog_OId)
     return W_Op_Le_Prog_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Op_Le_Prog);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Op_Le_Prog);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Op_Le_Prog;

   --------------------------
   -- Duplicate_Op_Gt_Prog --
   --------------------------

   function Duplicate_Op_Gt_Prog
     (Ada_Node : Node_Id := Empty;
      Id       : W_Op_Gt_Prog_OId)
     return W_Op_Gt_Prog_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Op_Gt_Prog);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Op_Gt_Prog);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Op_Gt_Prog;

   --------------------------
   -- Duplicate_Op_Ge_Prog --
   --------------------------

   function Duplicate_Op_Ge_Prog
     (Ada_Node : Node_Id := Empty;
      Id       : W_Op_Ge_Prog_OId)
     return W_Op_Ge_Prog_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Op_Ge_Prog);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Op_Ge_Prog);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Op_Ge_Prog;

   -------------------------------
   -- Duplicate_Op_Or_Else_Prog --
   -------------------------------

   function Duplicate_Op_Or_Else_Prog
     (Ada_Node : Node_Id := Empty;
      Id       : W_Op_Or_Else_Prog_OId)
     return W_Op_Or_Else_Prog_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Op_Or_Else_Prog);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Op_Or_Else_Prog);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Op_Or_Else_Prog;

   --------------------------------
   -- Duplicate_Op_And_Then_Prog --
   --------------------------------

   function Duplicate_Op_And_Then_Prog
     (Ada_Node : Node_Id := Empty;
      Id       : W_Op_And_Then_Prog_OId)
     return W_Op_And_Then_Prog_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Op_And_Then_Prog);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Op_And_Then_Prog);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Op_And_Then_Prog;

   -----------------------------
   -- Duplicate_Op_Minus_Prog --
   -----------------------------

   function Duplicate_Op_Minus_Prog
     (Ada_Node : Node_Id := Empty;
      Id       : W_Op_Minus_Prog_OId)
     return W_Op_Minus_Prog_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Op_Minus_Prog);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Op_Minus_Prog);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Op_Minus_Prog;

   ---------------------------
   -- Duplicate_Op_Not_Prog --
   ---------------------------

   function Duplicate_Op_Not_Prog
     (Ada_Node : Node_Id := Empty;
      Id       : W_Op_Not_Prog_OId)
     return W_Op_Not_Prog_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Op_Not_Prog);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Op_Not_Prog);
      begin
         Result.Ada_Node := Ada_Node;
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Op_Not_Prog;

   -----------------------
   -- Duplicate_Binders --
   -----------------------

   function Duplicate_Binders
     (Ada_Node : Node_Id := Empty;
      Id       : W_Binders_OId)
     return W_Binders_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Binders);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Binders);
         Binders : constant W_Binder_List :=
            Binders_Get_Binders (Id);
      begin
         Result.Ada_Node := Ada_Node;
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Binders);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Binder_Id := Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.BS_Binders := NL;
         end;
         Set_Link (Result.BS_Binders, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Binders;

   ----------------------
   -- Duplicate_Binder --
   ----------------------

   function Duplicate_Binder
     (Ada_Node : Node_Id := Empty;
      Id       : W_Binder_OId)
     return W_Binder_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Binder);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Binder);
         Names    : constant W_Identifier_List :=
            Binder_Get_Names (Id);
         Arg_Type : constant W_Value_Type_Id :=
            Binder_Get_Arg_Type (Id);
      begin
         Result.Ada_Node := Ada_Node;
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Names);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Identifier_Id := Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.B_Names := NL;
         end;
         Set_Link (Result.B_Names, New_Id);
         Result.B_Arg_Type :=
           Duplicate_Value_Type
           (Id => Arg_Type);
         Set_Link (Result.B_Arg_Type, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Binder;

   ----------------------
   -- Duplicate_Recfun --
   ----------------------

   function Duplicate_Recfun
     (Ada_Node : Node_Id := Empty;
      Id       : W_Recfun_OId)
     return W_Recfun_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Recfun);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Recfun);
         Name        : constant W_Identifier_Id :=
            Recfun_Get_Name (Id);
         Binders     : constant W_Binders_Id :=
            Recfun_Get_Binders (Id);
         Return_Type : constant W_Prog_Id :=
            Recfun_Get_Return_Type (Id);
         Variant     : constant W_Wf_Arg_Id :=
            Recfun_Get_Variant (Id);
         Pre         : constant W_Precondition_Id :=
            Recfun_Get_Pre (Id);
         Def         : constant W_Prog_Id :=
            Recfun_Get_Def (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.RF_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.RF_Name, New_Id);
         Result.RF_Binders :=
           Duplicate_Binders
           (Id => Binders);
         Set_Link (Result.RF_Binders, New_Id);
         Result.RF_Return_Type :=
           Duplicate_Prog
           (Id => Return_Type);
         Set_Link (Result.RF_Return_Type, New_Id);
         Result.RF_Variant :=
           Duplicate_Wf_Arg
           (Id => Variant);
         Set_Link (Result.RF_Variant, New_Id);
         Result.RF_Pre :=
           Duplicate_Precondition
           (Id => Pre);
         Set_Link (Result.RF_Pre, New_Id);
         Result.RF_Def :=
           Duplicate_Prog
           (Id => Def);
         Set_Link (Result.RF_Def, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Recfun;

   --------------------------
   -- Duplicate_Loop_Annot --
   --------------------------

   function Duplicate_Loop_Annot
     (Ada_Node : Node_Id := Empty;
      Id       : W_Loop_Annot_OId)
     return W_Loop_Annot_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Loop_Annot);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Loop_Annot);
         Invariant : constant W_Assertion_OId :=
            Loop_Annot_Get_Invariant (Id);
         Variant   : constant W_Wf_Arg_OId :=
            Loop_Annot_Get_Variant (Id);
      begin
         Result.Ada_Node := Ada_Node;
         if Invariant = Why_Empty then
            Result.LA_Invariant := Why_Empty;
         else
            Result.LA_Invariant :=
              Duplicate_Assertion
              (Id => Invariant);
         end if;
         Set_Link (Result.LA_Invariant, New_Id);
         if Variant = Why_Empty then
            Result.LA_Variant := Why_Empty;
         else
            Result.LA_Variant :=
              Duplicate_Wf_Arg
              (Id => Variant);
         end if;
         Set_Link (Result.LA_Variant, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Loop_Annot;

   ----------------------
   -- Duplicate_Wf_Arg --
   ----------------------

   function Duplicate_Wf_Arg
     (Ada_Node : Node_Id := Empty;
      Id       : W_Wf_Arg_OId)
     return W_Wf_Arg_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Wf_Arg);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Wf_Arg);
         Def    : constant W_Term_Id :=
            Wf_Arg_Get_Def (Id);
         For_Id : constant W_Identifier_OId :=
            Wf_Arg_Get_For_Id (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.WA_Def :=
           Duplicate_Term
           (Id => Def);
         Set_Link (Result.WA_Def, New_Id);
         if For_Id = Why_Empty then
            Result.WA_For_Id := Why_Empty;
         else
            Result.WA_For_Id :=
              Duplicate_Identifier
              (Id => For_Id);
         end if;
         Set_Link (Result.WA_For_Id, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Wf_Arg;

   -----------------------
   -- Duplicate_Handler --
   -----------------------

   function Duplicate_Handler
     (Ada_Node : Node_Id := Empty;
      Id       : W_Handler_OId)
     return W_Handler_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Handler);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Handler);
         Name      : constant W_Identifier_Id :=
            Handler_Get_Name (Id);
         Parameter : constant W_Prog_OId :=
            Handler_Get_Parameter (Id);
         Def       : constant W_Prog_Id :=
            Handler_Get_Def (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.H_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.H_Name, New_Id);
         if Parameter = Why_Empty then
            Result.H_Parameter := Why_Empty;
         else
            Result.H_Parameter :=
              Duplicate_Prog
              (Id => Parameter);
         end if;
         Set_Link (Result.H_Parameter, New_Id);
         Result.H_Def :=
           Duplicate_Prog
           (Id => Def);
         Set_Link (Result.H_Def, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Handler;

   --------------------
   -- Duplicate_File --
   --------------------

   function Duplicate_File
     (Ada_Node : Node_Id := Empty;
      Id       : W_File_OId)
     return W_File_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_File);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_File);
         Declarations : constant W_Declaration_OList :=
            File_Get_Declarations (Id);
      begin
         Result.Ada_Node := Ada_Node;
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Declarations);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Declaration_Id := Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.F_Declarations := NL;
         end;
         Set_Link (Result.F_Declarations, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_File;

   ------------------------------
   -- Duplicate_Global_Binding --
   ------------------------------

   function Duplicate_Global_Binding
     (Ada_Node : Node_Id := Empty;
      Id       : W_Global_Binding_OId)
     return W_Global_Binding_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Global_Binding);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Global_Binding);
         Name    : constant W_Identifier_Id :=
            Global_Binding_Get_Name (Id);
         Binders : constant W_Binders_OId :=
            Global_Binding_Get_Binders (Id);
         Pre     : constant W_Precondition_Id :=
            Global_Binding_Get_Pre (Id);
         Def     : constant W_Prog_Id :=
            Global_Binding_Get_Def (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.GB_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.GB_Name, New_Id);
         if Binders = Why_Empty then
            Result.GB_Binders := Why_Empty;
         else
            Result.GB_Binders :=
              Duplicate_Binders
              (Id => Binders);
         end if;
         Set_Link (Result.GB_Binders, New_Id);
         Result.GB_Pre :=
           Duplicate_Precondition
           (Id => Pre);
         Set_Link (Result.GB_Pre, New_Id);
         Result.GB_Def :=
           Duplicate_Prog
           (Id => Def);
         Set_Link (Result.GB_Def, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Global_Binding;

   ----------------------------------
   -- Duplicate_Global_Rec_Binding --
   ----------------------------------

   function Duplicate_Global_Rec_Binding
     (Ada_Node : Node_Id := Empty;
      Id       : W_Global_Rec_Binding_OId)
     return W_Global_Rec_Binding_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Global_Rec_Binding);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Global_Rec_Binding);
         Name : constant W_Recfun_Id :=
            Global_Rec_Binding_Get_Name (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.GRB_Name :=
           Duplicate_Recfun
           (Id => Name);
         Set_Link (Result.GRB_Name, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Global_Rec_Binding;

   -------------------------------------
   -- Duplicate_Parameter_Declaration --
   -------------------------------------

   function Duplicate_Parameter_Declaration
     (Ada_Node : Node_Id := Empty;
      Id       : W_Parameter_Declaration_OId)
     return W_Parameter_Declaration_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Parameter_Declaration);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Parameter_Declaration);
         External       : constant W_External_Id :=
            Parameter_Declaration_Get_External (Id);
         Names          : constant W_Identifier_List :=
            Parameter_Declaration_Get_Names (Id);
         Parameter_Type : constant W_Value_Type_Id :=
            Parameter_Declaration_Get_Parameter_Type (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.PD_External :=
           Duplicate_External
           (Id => External);
         Set_Link (Result.PD_External, New_Id);
         declare
            use Node_Lists;

            Nodes    : constant List := Get_List (Names);
            Position : Cursor := First (Nodes);
            NL       : constant Why_Node_List := New_List;
         begin
            while Position /= No_Element loop
               declare
                  Node : constant W_Identifier_Id := Element (Position);
               begin
                  Append (NL,  Node);
               end;
               Position := Next (Position);
            end loop;
            Result.PD_Names := NL;
         end;
         Set_Link (Result.PD_Names, New_Id);
         Result.PD_Parameter_Type :=
           Duplicate_Value_Type
           (Id => Parameter_Type);
         Set_Link (Result.PD_Parameter_Type, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Parameter_Declaration;

   -------------------------------------
   -- Duplicate_Exception_Declaration --
   -------------------------------------

   function Duplicate_Exception_Declaration
     (Ada_Node : Node_Id := Empty;
      Id       : W_Exception_Declaration_OId)
     return W_Exception_Declaration_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Exception_Declaration);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Exception_Declaration);
         Name      : constant W_Identifier_Id :=
            Exception_Declaration_Get_Name (Id);
         Parameter : constant W_Primitive_Type_OId :=
            Exception_Declaration_Get_Parameter (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.ED_Name :=
           Duplicate_Identifier
           (Id => Name);
         Set_Link (Result.ED_Name, New_Id);
         if Parameter = Why_Empty then
            Result.ED_Parameter := Why_Empty;
         else
            Result.ED_Parameter :=
              Duplicate_Primitive_Type
              (Id => Parameter);
         end if;
         Set_Link (Result.ED_Parameter, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Exception_Declaration;

   ---------------------------------
   -- Duplicate_Logic_Declaration --
   ---------------------------------

   function Duplicate_Logic_Declaration
     (Ada_Node : Node_Id := Empty;
      Id       : W_Logic_Declaration_OId)
     return W_Logic_Declaration_Id
   is
   begin
      if Id = Why_Empty then
         return Why_Empty;
      end if;

      declare
         Result : Why_Node (W_Logic_Declaration);
         New_Id : constant Why_Node_Id :=
           New_Why_Node_Id (W_Logic_Declaration);
         Decl : constant W_Logic_Declaration_Class_Id :=
            Logic_Declaration_Get_Decl (Id);
      begin
         Result.Ada_Node := Ada_Node;
         Result.LD_Decl :=
           Duplicate_Logic_Declaration_Class
           (Id => Decl);
         Set_Link (Result.LD_Decl, New_Id);
         Result.Link := Why_Empty;
         Result.Checked := True;
         Set_Node (New_Id, Result);
         return New_Id;
      end;
   end Duplicate_Logic_Declaration;

end Why.Atree.Builders;

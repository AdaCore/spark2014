------------------------------------------------------------------------------
--                                                                          --
--                            GNAT2WHY COMPONENTS                           --
--                                                                          --
--                     W H Y - A T R E E - S P R I N T                      --
--                                                                          --
--                                 B o d y                                  --
--                                                                          --
--                       Copyright (C) 2010-2011, AdaCore                   --
--                                                                          --
-- gnat2why is  free  software;  you can redistribute  it and/or  modify it --
-- under terms of the  GNU General Public License as published  by the Free --
-- Software  Foundation;  either version 3,  or (at your option)  any later --
-- version.  gnat2why is distributed  in the hope that  it will be  useful, --
-- but WITHOUT ANY WARRANTY; without even the implied warranty of  MERCHAN- --
-- TABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public --
-- License for  more details.  You should have  received  a copy of the GNU --
-- General  Public License  distributed with  gnat2why;  see file COPYING3. --
-- If not,  go to  http://www.gnu.org/licenses  for a complete  copy of the --
-- license.                                                                 --
--                                                                          --
-- gnat2why is maintained by AdaCore (http://www.adacore.com)               --
--                                                                          --
------------------------------------------------------------------------------

with Ada.Containers; use Ada.Containers;

with Namet;  use Namet;
with Uintp;  use Uintp;

with Why.Images;          use Why.Images;
with Why.Conversions;     use Why.Conversions;
with Why.Atree.Accessors; use Why.Atree.Accessors;

package body Why.Atree.Sprint is

   O : Output_Id := Stdout;

   procedure Print_List
     (State     : in out Printer_State'Class;
      List_Id   : Why_Node_List;
      Separator : String := ", ");
   --  Print a node list on current output, separating each element
   --  by a given separator.

   ----------------
   -- Print_List --
   ----------------

   procedure Print_List
     (State     : in out Printer_State'Class;
      List_Id   : Why_Node_List;
      Separator : String := ", ")
   is
      use Node_Lists;

      Nodes    : constant List := Get_List (List_Id);
      Position : Cursor := First (Nodes);
   begin
      while Position /= No_Element loop
         declare
            Node : constant Why_Node_Id := Element (Position);
         begin
            Traverse (State, Node);
         end;

         Position := Next (Position);

         if Position /= No_Element then
            P (O, Separator);
         end if;
      end loop;
   end Print_List;

   ---------------------
   -- Sprint_Why_Node --
   ---------------------

   procedure Sprint_Why_Node (Node : Why_Node_Id; To : Output_Id := Stdout) is
      PS : Printer_State := (Control => Continue);
   begin
      O := To;
      Traverse (PS, +Node);
   end Sprint_Why_Node;

   ---------
   -- wpg --
   ---------

   procedure wpg (Node : Why_Node_Id) is
   begin
      Sprint_Why_Node (Node, Stdout);
   end wpg;

   ----------------------------------------
   -- Pre-operations and post-operations --
   ----------------------------------------

   --  Note: the following subprograms have been written from the stub
   --  generated by the xtree; the order of generation has been kept. That
   --  explains why these are not in alphabetical order.

   ----------------------
   -- Base_Type_Pre_Op --
   ----------------------

   procedure Base_Type_Pre_Op
     (State : in out Printer_State;
      Node  : W_Base_Type_Valid_Id)
   is
      pragma Unreferenced (State);
   begin
      P (O, Base_Type_Get_Base_Type (Node));
   end Base_Type_Pre_Op;

   --------------------------------
   -- Generic_Formal_Type_Pre_Op --
   --------------------------------

   procedure Generic_Formal_Type_Pre_Op
     (State : in out Printer_State;
      Node  : W_Generic_Formal_Type_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, "'");
   end Generic_Formal_Type_Pre_Op;

   --------------------------------------
   -- Generic_Actual_Type_Chain_Pre_Op --
   --------------------------------------

   procedure Generic_Actual_Type_Chain_Pre_Op
     (State : in out Printer_State;
      Node  : W_Generic_Actual_Type_Chain_Valid_Id)
   is
      use Node_Lists;
      Args     : constant List :=
                   Get_List (Generic_Actual_Type_Chain_Get_Type_Chain (Node));
      Nb_Args  : constant Count_Type := Length (Args);
   begin
      if Is_Why3 then
         if Nb_Args >= 1 then
            P (O, "(");
         end if;

         Traverse (State, Generic_Actual_Type_Chain_Get_Name (Node));

         if Nb_Args > 1 then
            P (O, " (");
         elsif Nb_Args = 1 then
            P (O, " ");
         end if;

         Print_List (State,
                     Generic_Actual_Type_Chain_Get_Type_Chain (Node), " ");

         if Nb_Args > 1 then
            P (O, ")");
         end if;

         if Nb_Args >= 1 then
            P (O, ")");
         end if;

         State.Control := Abandon_Children;

      else
         if Nb_Args > 1 then
            P (O, "(");
         end if;

         Print_List (State,
                     Generic_Actual_Type_Chain_Get_Type_Chain (Node));
         if Nb_Args > 1 then
            P (O, ") ");
         elsif Nb_Args = 1 then
            P (O, " ");
         end if;

         Traverse (State, Generic_Actual_Type_Chain_Get_Name (Node));
         State.Control := Abandon_Children;
      end if;
   end Generic_Actual_Type_Chain_Pre_Op;

   ------------------------
   -- Array_Type_Pre_Op --
   ------------------------

   procedure Array_Type_Pre_Op
     (State : in out Printer_State;
      Node  : W_Array_Type_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      if Is_Why3 then
         P (O, "array ");
      end if;
   end Array_Type_Pre_Op;

   ------------------------
   -- Array_Type_Post_Op --
   ------------------------

   procedure Array_Type_Post_Op
     (State : in out Printer_State;
      Node  : W_Array_Type_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      if not Is_Why3 then
         P (O, " array");
      end if;
   end Array_Type_Post_Op;

   ---------------------
   -- Ref_Type_Pre_Op --
   ---------------------

   procedure Ref_Type_Pre_Op
     (State : in out Printer_State;
      Node  : W_Ref_Type_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      if Is_Why3 then
         P (O, "ref ");
      end if;
   end Ref_Type_Pre_Op;

   ----------------------
   -- Ref_Type_Post_Op --
   ----------------------

   procedure Ref_Type_Post_Op
     (State : in out Printer_State;
      Node  : W_Ref_Type_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      if not Is_Why3 then
         P (O, " ref");
      end if;
   end Ref_Type_Post_Op;

   -----------------------------
   -- Computation_Type_Pre_Op --
   -----------------------------

   procedure Computation_Type_Pre_Op
     (State : in out Printer_State;
      Node  : W_Computation_Type_Valid_Id)
   is
      Binders     : constant W_Binder_OList :=
                      Get_Binders (+Node);
      Result      : constant W_Binder_Id :=
                      Get_Result (+Node);
      Result_Type : constant W_Simple_Value_Type_Id :=
                      Get_Arg_Type (Result);
      Pre         : constant W_Pred_Id :=
                      Get_Pre (+Node);
      Domain      : constant EW_Domain := Get_Domain (+Node);
   begin
      case Domain is
         when EW_Prog =>
            if not (Is_Empty (+Binders)) then
               Print_List (State, +Binders, " ->" & ASCII.LF);
               PL (O, " ->");
            end if;

            P (O, "{ ");
            Traverse (State, +Pre);
            P (O, " }");
            NL (O);
            Relative_Indent (O, 1);
            Traverse (State, +Result_Type);
            NL (O);
            Traverse (State, Computation_Type_Get_Effects (Node));
            Relative_Indent (O, -1);
            P (O, "{ ");
            Traverse (State, Computation_Type_Get_Post (Node));
            P (O, " }");

         when EW_Term =>
            declare
               use Node_Lists;
               Nodes    : constant List := Get_List (+Binders);
               Position : Cursor := First (Nodes);
            begin
               while Position /= No_Element loop
                  declare
                     Binder   : constant W_Binder_Id := +Element (Position);
                  begin
                     Traverse (State, +Get_Arg_Type (Binder));
                  end;
                  Next (Position);

                  if Position /= No_Element then
                     PL (O, ",");
                  else
                     P (O, " -> ");
                  end if;
               end loop;

               Traverse (State, +Result_Type);
            end;

         when EW_Pred =>
            pragma Assert (False);
            null;
      end case;

      State.Control := Abandon_Children;
   end Computation_Type_Pre_Op;

   --------------------
   -- Effects_Pre_Op --
   --------------------

   procedure Effects_Pre_Op
     (State : in out Printer_State;
      Node  : W_Effects_Valid_Id)
   is
      Reads  : constant W_Identifier_List :=
                 Get_Reads (+Node);
      Writes : constant W_Identifier_List :=
                 Get_Writes (+Node);
      Raises : constant W_Identifier_List :=
                 Get_Raises (+Node);
   begin
      if not Is_Empty (+Reads) then
         P (O, "reads ");

         if Is_Why3 then
            Print_List (State, +Reads, " ");
         else
            Print_List (State, +Reads);
         end if;

         NL (O);
      end if;

      if not Is_Empty (+Writes) then
         P (O, "writes ");

         if Is_Why3 then
            Print_List (State, +Writes, " ");
         else
            Print_List (State, +Writes);
         end if;

         NL (O);
      end if;

      if not Is_Empty (+Raises) then
         P (O, "raises ");

         if Is_Why3 then
            Print_List (State, +Raises, " ");
         else
            Print_List (State, +Raises);
         end if;

         NL (O);
      end if;

      State.Control := Abandon_Children;
   end Effects_Pre_Op;

   -------------------
   -- Binder_Pre_Op --
   -------------------

   procedure Binder_Pre_Op
     (State : in out Printer_State;
      Node  : W_Binder_Valid_Id)
   is
   begin
      if Is_Why3 then
         P (O, "(");
      end if;

      Traverse (State, Binder_Get_Name (Node));
      P (O, " : ");
      Traverse (State, Binder_Get_Arg_Type (Node));

      if Is_Why3 then
         P (O, ")");
      end if;

      State.Control := Abandon_Children;
   end Binder_Pre_Op;

   ------------------------
   -- Constr_Decl_Pre_Op --
   ------------------------

   procedure Constr_Decl_Pre_Op
      (State : in out Printer_State;
       Node : W_Constr_Decl_Valid_Id)
   is
      Args : constant W_Primitive_Type_List :=
               Get_Arg_List (+Node);
      Name : constant W_Identifier_Id :=
               +Constr_Decl_Get_Name (Node);
   begin
      P (O, "| ");
      Traverse (State, +Name);

      if not Is_Empty (+Args) then
         P (O, "( ");
         Print_List (State, +Args, ", ");
         Traverse_List (State, +Args);
         P (O, ") ");
      end if;

      NL (O);
      State.Control := Abandon_Children;
   end Constr_Decl_Pre_Op;

   ---------------------
   -- Triggers_Pre_Op --
   ---------------------

   procedure Triggers_Pre_Op
     (State : in out Printer_State;
      Node  : W_Triggers_Valid_Id)
   is
      Triggers : constant W_Trigger_List :=
                   Get_Triggers (+Node);
   begin
      P (O, "[");
      Print_List (State, +Triggers, " | ");
      P (O, "]");
      State.Control := Abandon_Children;
   end Triggers_Pre_Op;

   --------------------
   -- Trigger_Pre_Op --
   --------------------

   procedure Trigger_Pre_Op
     (State : in out Printer_State;
      Node  : W_Trigger_Valid_Id)
   is
      Terms    : constant W_Term_List :=
                   Get_Terms (+Node);
   begin
      Print_List (State, +Terms);
      State.Control := Abandon_Children;
   end Trigger_Pre_Op;

   --------------------
   -- Pattern_Pre_Op --
   --------------------

   procedure Pattern_Pre_Op
     (State : in out Printer_State;
      Node  : W_Pattern_Valid_Id)
   is
      Args : constant W_Identifier_OList := +Pattern_Get_Args (Node);
   begin
      Traverse (State, Pattern_Get_Constr (Node));

      if not (Is_Empty (+Args)) then
         P (O, "(");
         Print_List (State, +Args);
         P (O, ")");
      end if;

      State.Control := Abandon_Children;
   end Pattern_Pre_Op;

   -----------------------
   -- Match_Case_Pre_Op --
   -----------------------

   procedure Match_Case_Pre_Op
     (State : in out Printer_State;
      Node  : W_Match_Case_Valid_Id)
   is
   begin
      P (O, "| ");
      Traverse (State, Match_Case_Get_Pattern (Node));
      P (O, " -> ");
      NL (O);
      Relative_Indent (O, 1);
      Traverse (State, Match_Case_Get_Term (Node));
      Relative_Indent (O, -1);
      NL (O);
      State.Control := Abandon_Children;
   end Match_Case_Pre_Op;

   --------------------------
   -- Postcondition_Pre_Op --
   --------------------------

   procedure Postcondition_Pre_Op
     (State : in out Printer_State;
      Node  : W_Postcondition_Valid_Id)
   is
      Handlers : constant W_Exn_Condition_OList :=
                   Get_Handlers (+Node);
   begin
      Traverse
        (State,
         Postcondition_Get_Pred (Node));

      if not Is_Empty (+Handlers) then
         NL (O);
         Relative_Indent (O, 1);
         Print_List (State, +Handlers, "" & ASCII.LF);
         Relative_Indent (O, -1);
      end if;

      State.Control := Abandon_Children;
   end Postcondition_Pre_Op;

   --------------------------
   -- Exn_Condition_Pre_Op --
   --------------------------

   procedure Exn_Condition_Pre_Op
     (State : in out Printer_State;
      Node  : W_Exn_Condition_Valid_Id)
   is
   begin
      P (O, "| ");
      Traverse
        (State,
         Exn_Condition_Get_Exn_Case (Node));
      P (O, " => ");
      Traverse
        (State,
         Exn_Condition_Get_Pred (Node));
      State.Control := Abandon_Children;
   end Exn_Condition_Pre_Op;

   -----------------------
   -- Loop_Annot_Pre_Op --
   -----------------------

   procedure Loop_Annot_Pre_Op
     (State : in out Printer_State;
      Node  : W_Loop_Annot_Valid_Id)
   is
      Invariant : constant W_Pred_OId :=
                    Get_Invariant (+Node);
      Variant   : constant W_Wf_Arg_OId :=
                    Get_Variant (+Node);
   begin
      if not Is_Why3 then
         PL (O, "{ ");
         Relative_Indent (O, 1);
      end if;

      if Invariant /= Why_Empty then
         P (O, "invariant ");

         if Is_Why3 then
            PL (O, "{ ");
            Relative_Indent (O, -1);
         end if;

         Traverse (State, +Invariant);
         NL (O);

         if Is_Why3 then
            Relative_Indent (O, -1);
            P (O, " }");
         end if;
      end if;

      if Variant /= Why_Empty then
         P (O, "variant ");
         Traverse (State, +Variant);
         NL (O);
      end if;

      if not Is_Why3 then
         Relative_Indent (O, -1);
         P (O, " }");
      end if;

      State.Control := Abandon_Children;
   end Loop_Annot_Pre_Op;

   -------------------
   -- Wf_Arg_Pre_Op --
   -------------------

   procedure Wf_Arg_Pre_Op
     (State : in out Printer_State;
      Node  : W_Wf_Arg_Valid_Id)
   is
      For_Id : constant W_Identifier_OId :=
                 Get_For_Id (+Node);
   begin
      Traverse
        (State,
         Wf_Arg_Get_Def (Node));

      if For_Id /= Why_Empty then
         P (O, " for ");
         Traverse (State, +For_Id);
      end if;

      State.Control := Abandon_Children;
   end Wf_Arg_Pre_Op;

   --------------------
   -- Handler_Pre_Op --
   --------------------

   procedure Handler_Pre_Op
     (State : in out Printer_State;
      Node  : W_Handler_Valid_Id)
   is
      Arg : constant W_Prog_OId :=
              Get_Arg (+Node);
   begin
      Traverse
        (State,
         Handler_Get_Name (Node));

      if Arg /= Why_Empty then
         P (O, " ");
         Traverse (State, +Arg);
      end if;

      P (O, " -> ");
      Traverse
        (State,
         Handler_Get_Def (Node));
      State.Control := Abandon_Children;
   end Handler_Pre_Op;

   ------------------------------
   -- Universal_Quantif_Pre_Op --
   ------------------------------

   procedure Universal_Quantif_Pre_Op
     (State : in out Printer_State;
      Node  : W_Universal_Quantif_Valid_Id)
   is
      Variables       : constant W_Identifier_List :=
                          +Universal_Quantif_Get_Variables (Node);
      Var_Type        : constant W_Primitive_Type_Id :=
                          +Universal_Quantif_Get_Var_Type (Node);
      Triggers        : constant W_Triggers_OId :=
                          Get_Triggers (+Node);
      Pred            : constant W_Pred_Id :=
                          +Universal_Quantif_Get_Pred (Node);
      Forall_Sequence : constant Boolean :=
                          Get_Kind (+Pred) = W_Universal_Quantif;
   begin
      P (O, "(forall ");

      if Is_Why3 then
         Print_List (State, +Variables, " ");
      else
         Print_List (State, +Variables);
      end if;

      P (O, " : ");
      Traverse (State, +Var_Type);

      if Triggers /= Why_Empty then
         P (O, " ");
         Traverse (State, +Triggers);
      end if;

      PL (O, ".");

      if not Forall_Sequence then
         Relative_Indent (O, 1);
      end if;

      Traverse (State, +Pred);

      if not Forall_Sequence then
         Relative_Indent (O, -1);
      end if;
      P (O, ")");
      State.Control := Abandon_Children;
   end Universal_Quantif_Pre_Op;

   --------------------------------
   -- Existential_Quantif_Pre_Op --
   --------------------------------

   procedure Existential_Quantif_Pre_Op
     (State : in out Printer_State;
      Node  : W_Existential_Quantif_Valid_Id)
   is
      Variables       : constant W_Identifier_List :=
                          +Existential_Quantif_Get_Variables (Node);
      Var_Type        : constant W_Primitive_Type_Id :=
                          +Existential_Quantif_Get_Var_Type (Node);
      Pred            : constant W_Pred_Id :=
                          +Existential_Quantif_Get_Pred (Node);
      Exists_Sequence : constant Boolean :=
                          Get_Kind (+Pred) = W_Existential_Quantif;
   begin
      P (O, "exists ");

      if Is_Why3 then
         Print_List (State, +Variables, " ");
      else
         Print_List (State, +Variables);
      end if;

      P (O, " : ");
      Traverse (State, +Var_Type);
      PL (O, ".");

      if not Exists_Sequence then
         Relative_Indent (O, 1);
      end if;

      Traverse (State, +Pred);

      if not Exists_Sequence then
         Relative_Indent (O, -1);
      end if;

      State.Control := Abandon_Children;
   end Existential_Quantif_Pre_Op;

   ----------------
   -- Not_Pre_Op --
   ----------------

   procedure Not_Pre_Op
     (State : in out Printer_State;
      Node  : W_Not_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, "not ");
   end Not_Pre_Op;

   ---------------------
   -- Relation_Pre_Op --
   ---------------------

   procedure Relation_Pre_Op
     (State : in out Printer_State;
      Node  : W_Relation_Valid_Id)
   is
      Left   : constant W_Prog_Id := Get_Left (+Node);
      Op     : constant EW_Relation := Relation_Get_Op (Node);
      Right  : constant W_Prog_Id := Get_Right (+Node);
      Op2    : constant EW_Relation := Relation_Get_Op2 (Node);
      Right2 : constant W_Prog_OId := Get_Right2 (+Node);
   begin
      Traverse (State, +Left);
      P (O, " ");
      P (O, Op);
      P (O, " ");
      Traverse (State, +Right);

      if Op2 /= EW_None then
         P (O, " ");
         P (O, Op2);
         P (O, " ");
         Traverse (State, +Right2);
      end if;

      State.Control := Abandon_Children;
   end Relation_Pre_Op;

   ------------------------
   -- Connection_Pre_Op --
   ------------------------

   procedure Connection_Pre_Op
     (State : in out Printer_State;
      Node  : W_Connection_Valid_Id)
   is
   begin
      P (O, "( ");
      Traverse
        (State,
         Connection_Get_Left (Node));
      P (O, " ");
      P (O, Connection_Get_Op (Node));
      P (O, " ");
      Traverse
        (State,
         Connection_Get_Right (Node));
      P (O, " )");
      State.Control := Abandon_Children;
   end Connection_Pre_Op;

   -----------------------
   -- Identifier_Pre_Op --
   -----------------------

   procedure Identifier_Pre_Op
     (State : in out Printer_State;
      Node  : W_Identifier_Valid_Id)
   is
      pragma Unreferenced (State);
      Symbol : constant Name_Id := Identifier_Get_Symbol (Node);
      Label  : constant Name_Id := Identifier_Get_Label (Node);
   begin
      if Is_Why3 then
         if Label = No_Name then
            P (O, Symbol);

         elsif Get_Name_String (Label) /= "" then
            P (O, "(at !");
            P (O, Symbol);
            P (O, " ");
            P (O, Label);
            P (O, ")");

         else
            P (O, "(old !");
            P (O, Symbol);
            P (O, ")");
         end if;

      else
         P (O, Symbol);

         if Label /= No_Name then
            P (O, "@");
            P (O, Label);
         end if;
      end if;
   end Identifier_Pre_Op;

   -----------------
   -- Call_Pre_Op --
   -----------------

   procedure Call_Pre_Op
     (State : in out Printer_State;
      Node  : W_Call_Valid_Id)
   is
      Name : constant W_Identifier_Id := +Call_Get_Name (Node);
      Args : constant W_Expr_OList := +Call_Get_Args (Node);
   begin
      case Get_Domain (Node) is
         when EW_Term | EW_Pred =>
            if Is_Why3 then
               P (O, "(");
               Traverse (State, +Name);
               P (O, " ");
               Print_List (State, +Args, " ");
               P (O, ")");

            else
               Traverse (State, +Name);

               if not Is_Empty (+Args) then
                  P (O, " (");
                  Print_List (State, +Args);
                  P (O, ")");
               end if;
            end if;

         when EW_Prog =>
            Traverse (State, +Name);

            if not Is_Empty (+Args) then
               P (O, "(");
               Print_List (State, +Args, ") (");
               P (O, ")");
            end if;
      end case;

      State.Control := Abandon_Children;
   end Call_Pre_Op;

   --------------------
   -- Literal_Pre_Op --
   --------------------

   procedure Literal_Pre_Op
     (State : in out Printer_State;
      Node  : W_Literal_Valid_Id)
   is
      pragma Unreferenced (State);
   begin
      P (O, Literal_Get_Value (Node));
   end Literal_Pre_Op;

   ------------------------
   -- Conditional_Pre_Op --
   ------------------------

   procedure Conditional_Pre_Op
     (State : in out Printer_State;
      Node  : W_Conditional_Valid_Id)
   is
      Condition : constant W_Prog_Id :=
                    +Conditional_Get_Condition (Node);
      Then_Part : constant W_Expr_Id :=
                    Get_Then_Part (+Node);
      Else_Part : constant W_Expr_OId :=
                    Get_Else_Part (+Node);
      Has_Else  : constant Boolean := Else_Part /= Why_Empty;
      Has_Elsif : constant Boolean :=
                    (Has_Else
                     and then Get_Kind (+Else_Part) = W_Conditional);
   begin
      P (O, "if (");
      Traverse (State, +Condition);
      PL (O, ") then (");
      Relative_Indent (O, 1);
      Traverse (State, +Then_Part);
      Relative_Indent (O, -1);

      if Has_Else then
         P (O, ") else (");

         if not Has_Elsif then
            NL (O);
            Relative_Indent (O, 1);
         end if;

         Traverse (State, +Else_Part);

         if not Has_Elsif then
            Relative_Indent (O, -1);
         end if;
         P (O, ")");
      else
         pragma Assert (Get_Domain (Node) = EW_Prog);
         P (O, ")");
      end if;

      State.Control := Abandon_Children;
   end Conditional_Pre_Op;

   -----------------------------
   -- Integer_Constant_Pre_Op --
   -----------------------------

   procedure Integer_Constant_Pre_Op
     (State : in out Printer_State;
      Node  : W_Integer_Constant_Valid_Id)
   is
      pragma Unreferenced (State);
      Value : constant Uint := Integer_Constant_Get_Value (Node);
   begin
      if Value < Uint_0 then
         P (O, "( ");
         P (O, Value);
         P (O, " )");
      else
         P (O, Value);
      end if;
   end Integer_Constant_Pre_Op;

   --------------------------
   -- Real_Constant_Pre_Op --
   --------------------------

   procedure Real_Constant_Pre_Op
     (State : in out Printer_State;
      Node  : W_Real_Constant_Valid_Id)
   is
      pragma Unreferenced (State);
   begin
      P (O, Real_Constant_Get_Value (Node));
   end Real_Constant_Pre_Op;

   -----------------
   -- Void_Pre_Op --
   -----------------

   procedure Void_Pre_Op
     (State : in out Printer_State;
      Node  : W_Void_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      if Is_Why3 then
         P (O, "()");
      else
         P (O, "void");
      end if;
   end Void_Pre_Op;

   ----------------------
   -- Binary_Op_Pre_Op --
   ----------------------

   procedure Binary_Op_Pre_Op
     (State : in out Printer_State;
      Node  : W_Binary_Op_Valid_Id)
   is
   begin
      P (O, "( ");
      Traverse (State, Binary_Op_Get_Left (Node));
      P (O, " ");
      P (O, Binary_Op_Get_Op (Node), Binary_Op_Get_Op_Type (Node));
      P (O, " ");
      Traverse (State, Binary_Op_Get_Right (Node));
      P (O, " )");
      State.Control := Abandon_Children;
   end Binary_Op_Pre_Op;

   ---------------------
   -- Unary_Op_Pre_Op --
   ---------------------

   procedure Unary_Op_Pre_Op
     (State : in out Printer_State;
      Node  : W_Unary_Op_Valid_Id)
   is
      Op     : constant EW_Unary_Op := Unary_Op_Get_Op (Node);
      Domain : constant EW_Domain := Get_Domain (Node);
   begin
      P (O, "( ");

      if Is_Why3 or else Op /= EW_Deref or else Domain /= EW_Term then
         P (O, Op);
         P (O, " ");
      end if;

      Traverse (State, Unary_Op_Get_Right (Node));
      P (O, " )");
      State.Control := Abandon_Children;
   end Unary_Op_Pre_Op;

   ------------------
   -- Match_Pre_Op --
   ------------------

   procedure Match_Pre_Op
     (State : in out Printer_State;
      Node  : W_Match_Valid_Id)
   is
   begin
      P (O, "match ");
      Traverse (State, Match_Get_Term (Node));
      P (O, " with ");
      NL (O);
      Relative_Indent (O, 1);
      Traverse_List (State, Match_Get_Branches (Node));
      Relative_Indent (O, -1);
      P (O, "end");
      NL (O);
      State.Control := Abandon_Children;
   end Match_Pre_Op;

   --------------------
   -- Binding_Pre_Op --
   --------------------

   procedure Binding_Pre_Op
     (State : in out Printer_State;
      Node  : W_Binding_Valid_Id)
   is
      Name             : constant W_Identifier_Id :=
                           +Binding_Get_Name (Node);
      Def              : constant W_Prog_Id :=
                           +Binding_Get_Def (Node);
      Context          : constant W_Expr_Id :=
                           Get_Context (+Node);
      Binding_Sequence : constant Boolean :=
                           Get_Kind (+Context) = W_Binding;
   begin
      P (O, "let ");
      Traverse (State, +Name);
      P (O, " = ");
      Traverse (State, +Def);

      if Is_Why3 then
         PL (O, " in (");
      else
         PL (O, " in");
      end if;

      if not Binding_Sequence then
         Relative_Indent (O, 1);
      end if;

      Traverse (State, +Context);

      if not Binding_Sequence then
         Relative_Indent (O, -1);
      end if;

      if Is_Why3 then
         PL (O, ")");
      end if;

      State.Control := Abandon_Children;
   end Binding_Pre_Op;

   -------------------------
   -- Array_Access_Pre_Op --
   -------------------------

   procedure Array_Access_Pre_Op
     (State : in out Printer_State;
      Node  : W_Array_Access_Valid_Id)
   is
   begin
      Traverse
        (State,
         Array_Access_Get_Name (Node));
      P (O, " [");
      Traverse
        (State,
         Array_Access_Get_Index (Node));
      P (O, "]");
      State.Control := Abandon_Children;
   end Array_Access_Pre_Op;

   ---------------------
   -- Any_Expr_Pre_Op --
   ---------------------

   procedure Any_Expr_Pre_Op
     (State : in out Printer_State;
      Node  : W_Any_Expr_Valid_Id)
   is
      Ty : constant W_Computation_Type_Id := Get_Any_Type (+Node);
   begin
      if Is_Why3 then
         P (O, "(any ");
      else
         P (O, "[ ");
      end if;

      Traverse (State, +Ty);

      if Is_Why3 then
         P (O, ")");
      else
         P (O, " ]");
      end if;

      State.Control := Abandon_Children;
   end Any_Expr_Pre_Op;

   -----------------------
   -- Assignment_Pre_Op --
   -----------------------

   procedure Assignment_Pre_Op
     (State : in out Printer_State;
      Node  : W_Assignment_Valid_Id)
   is
   begin
      Traverse (State, Assignment_Get_Name (Node));
      P (O, " := ( ");
      Traverse (State, Assignment_Get_Value (Node));
      P (O, " )");
      State.Control := Abandon_Children;
   end Assignment_Pre_Op;

   -------------------------
   -- Array_Update_Pre_Op --
   -------------------------

   procedure Array_Update_Pre_Op
     (State : in out Printer_State;
      Node  : W_Array_Update_Valid_Id)
   is
   begin
      Traverse
        (State,
         Array_Update_Get_Name (Node));
      P (O, " [");
      Traverse
        (State,
         Array_Update_Get_Index (Node));
      P (O, "] := ");
      Traverse
        (State,
         Array_Update_Get_Value (Node));
      State.Control := Abandon_Children;
   end Array_Update_Pre_Op;

   ------------------------
   -- Binding_Ref_Pre_Op --
   ------------------------

   procedure Binding_Ref_Pre_Op
     (State : in out Printer_State;
      Node  : W_Binding_Ref_Valid_Id)
   is
      Context          : constant W_Prog_Id :=
                           Get_Context (+Node);
      Binding_Sequence : constant Boolean :=
                           Get_Kind (+Context) = W_Binding_Ref;
   begin
      P (O, "let ");
      Traverse
        (State,
         Binding_Ref_Get_Name (Node));
      P (O, " = ref ");
      Traverse
        (State,
         Binding_Ref_Get_Def (Node));
      PL (O, " in ");

      if not Binding_Sequence then
         Relative_Indent (O, 1);
      end if;

      Traverse (State, +Context);

      if not Binding_Sequence then
         Relative_Indent (O, -1);
      end if;

      State.Control := Abandon_Children;
   end Binding_Ref_Pre_Op;

   -----------------------
   -- While_Loop_Pre_Op --
   -----------------------

   procedure While_Loop_Pre_Op
     (State : in out Printer_State;
      Node  : W_While_Loop_Valid_Id)
   is
      Condition    : constant W_Prog_Id :=
                       +While_Loop_Get_Condition (Node);
      Annotation   : constant W_Loop_Annot_OId :=
                       Get_Annotation (+Node);
      Loop_Content : constant W_Prog_Id :=
                       Get_Loop_Content (+Node);
   begin
      P (O, "while ");
      Traverse (State, +Condition);
      PL (O, " do");
      Relative_Indent (O, 1);

      if Annotation /= Why_Empty then
         Traverse (State, +Annotation);
         NL (O);
      end if;

      Traverse (State, +Loop_Content);
      Relative_Indent (O, 1);
      NL (O);
      P (O, "done");
      State.Control := Abandon_Children;
   end While_Loop_Pre_Op;

   -------------------------------
   -- Statement_Sequence_Pre_Op --
   -------------------------------

   procedure Statement_Sequence_Pre_Op
     (State : in out Printer_State;
      Node  : W_Statement_Sequence_Valid_Id)
   is
   begin
      Print_List (State,
                  Statement_Sequence_Get_Statements (Node),
                  ";" & ASCII.LF);
      State.Control := Abandon_Children;
   end Statement_Sequence_Pre_Op;

   ------------------
   -- Label_Pre_Op --
   ------------------

   procedure Label_Pre_Op
     (State : in out Printer_State;
      Node  : W_Label_Valid_Id)
   is
   begin
      if Is_Why3 then
         P (O, "( """);
      else
         P (O, "( ");
      end if;

      Traverse
        (State,
         Label_Get_Name (Node));

      if Is_Why3 then
         P (O, """ ");
      else
         P (O, " : ");
      end if;

      Traverse
        (State,
         Label_Get_Def (Node));
      P (O, " )");
      State.Control := Abandon_Children;
   end Label_Pre_Op;

   -------------------
   -- Assert_Pre_Op --
   -------------------

   procedure Assert_Pre_Op
     (State : in out Printer_State;
      Node  : W_Assert_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, "assert { ");
   end Assert_Pre_Op;

   --------------------
   -- Assert_Post_Op --
   --------------------

   procedure Assert_Post_Op
     (State : in out Printer_State;
      Node  : W_Assert_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, " } ; void");
   end Assert_Post_Op;

   ------------------
   -- Raise_Pre_Op --
   ------------------

   procedure Raise_Pre_Op
     (State : in out Printer_State;
      Node  : W_Raise_Valid_Id)
   is
      Exn_Type : constant W_Simple_Value_Type_OId :=
                   +Raise_Get_Exn_Type (Node);
   begin
      if Is_Why3 then
         P (O, "raise Gnatprove_Exception__");
      else
         P (O, "raise ");
      end if;

      Traverse
        (State,
         Raise_Get_Name (Node));

      if Exn_Type /= Why_Empty then
         P (O, " : ");
         Traverse (State, +Exn_Type);
      end if;

      State.Control := Abandon_Children;
   end Raise_Pre_Op;

   ----------------------
   -- Try_Block_Pre_Op --
   ----------------------

   procedure Try_Block_Pre_Op
     (State : in out Printer_State;
      Node  : W_Try_Block_Valid_Id)
   is
   begin
      PL (O, "try");
      Relative_Indent (O, 1);
      Traverse
        (State,
         Try_Block_Get_Prog (Node));
      Relative_Indent (O, -1);
      NL (O);
      PL (O, "with ");
      Relative_Indent (O, 1);

      if Is_Why3 then
         P (O, "Gnatprove_Exception__");
         Print_List
           (State,
            Try_Block_Get_Handler (Node),
            ", Gnatprove_Exception__" & ASCII.LF);
      else
         Print_List
           (State,
            Try_Block_Get_Handler (Node),
            "," & ASCII.LF);
      end if;

      Relative_Indent (O, -1);
      NL (O);
      P (O, "end");
      State.Control := Abandon_Children;
   end Try_Block_Pre_Op;

   -----------------------------
   -- Unreachable_Code_Pre_Op --
   -----------------------------

   procedure Unreachable_Code_Pre_Op
     (State : in out Printer_State;
      Node  : W_Unreachable_Code_Valid_Id)
   is
      Exn_Type : constant W_Simple_Value_Type_OId :=
                   +Unreachable_Code_Get_Exn_Type (Node);
   begin
      P (O, "absurd");

      if Exn_Type /= Why_Empty then
         P (O, " : ");
         Traverse (State, +Exn_Type);
      end if;

      State.Control := Abandon_Children;
   end Unreachable_Code_Pre_Op;

   --------------------------
   -- Function_Decl_Pre_Op --
   --------------------------

   procedure Function_Decl_Pre_Op
     (State : in out Printer_State;
      Node  : W_Function_Decl_Valid_Id)
   is
      Name      : constant W_Identifier_Id := +Function_Decl_Get_Name (Node);
      Func_Type : constant W_Computation_Type_Id :=
                    Get_Func_Type (+Node);
   begin
      if Function_Decl_Get_External (Node) then
         P (O, "external ");
      end if;

      case Get_Domain (Node) is
         when EW_Term =>
            if Is_Why3 then
               P (O, "function ");
            else
               P (O, "logic ");
            end if;

            Traverse (State, +Name);

            if not Is_Why3 then
               P (O, " :");
            end if;

            NL (O);
            Relative_Indent (O, 1);
            Traverse (State, +Func_Type);
            Relative_Indent (O, -1);
            NL (O);

         when EW_Prog =>
            if Is_Why3 then
               P (O, "val ");
            else
               P (O, "parameter ");
            end if;

            Traverse (State, +Name);
            P (O, " :");

            Relative_Indent (O, 1);
            NL (O);
            Traverse (State, +Func_Type);
            Relative_Indent (O, -1);
            NL (O);

         when EW_Pred =>
            pragma Assert (False);
            null;
      end case;

      State.Control := Abandon_Children;
   end Function_Decl_Pre_Op;

   -------------------------
   -- Function_Def_Pre_Op --
   -------------------------

   procedure Function_Def_Pre_Op
     (State : in out Printer_State;
      Node  : W_Function_Def_Valid_Id)
   is
      Spec        : constant W_Function_Decl_Id :=
                      Get_Spec (+Node);
      Func_Type   : constant W_Computation_Type_Id :=
                      Get_Func_Type (Spec);
      Def         : constant W_Expr_Id :=
                      +Function_Def_Get_Def (Node);
      Name        : constant W_Identifier_Id :=
                      Get_Name (Spec);
      Binders     : constant W_Binder_OList :=
                      Get_Binders (Func_Type);
      Result      : constant W_Binder_Id :=
                      Get_Result (Func_Type);
      Result_Type : constant W_Simple_Value_Type_OId :=
                      Get_Arg_Type (Result);
      Pre         : constant W_Pred_OId :=
                      Get_Pre (Func_Type);
      Post        : constant W_Pred_OId :=
                      Get_Post (Func_Type);
   begin
      case Get_Domain (Node) is
         when EW_Pred =>
            P (O, "predicate ");
            Traverse (State, +Name);

            if Is_Why3 then
               P (O, " ");
               Print_List (State, +Binders, " ");
               PL (O, " =");
            else
               P (O, " (");
               Print_List (State, +Binders);
               PL (O, ") =");
            end if;

            Relative_Indent (O, 1);
            Traverse (State, +Def);
            Relative_Indent (O, -1);
            NL (O);

         when EW_Term =>
            P (O, "function ");
            Traverse (State, +Name);

            if Is_Why3 then
               P (O, " ");
               Print_List (State, +Binders, " ");
               P (O, " : ");
            else
               P (O, " (");
               Print_List (State, +Binders);
               P (O, ") : ");
            end if;

            Traverse (State, +Result_Type);
            PL (O, " =");
            Relative_Indent (O, 1);
            Traverse (State, +Def);
            Relative_Indent (O, -1);
            NL (O);

         when EW_Prog =>
            P (O, "let ");
            Traverse (State, +Name);

            if not Is_Empty (+Binders) then
               P (O, " (");
               Print_List (State, +Binders, ") (");
               P (O, ")");
            end if;

            PL (O, " =");
            NL (O);
            Relative_Indent (O, 1);

            if Pre = Why_Empty then
               PL (O, "{ }");
            else
               PL (O, "{ ");
               Traverse (State, +Pre);
               PL (O, " }");
            end if;

            NL (O);
            Relative_Indent (O, 1);
            Traverse (State, +Def);
            Relative_Indent (O, -1);
            NL (O);

            if Post = Why_Empty then
               PL (O, "{ true }");
            else
               PL (O, "{ ");
               Traverse (State, +Post);
               PL (O, " }");
            end if;
      end case;

      State.Control := Abandon_Children;
   end Function_Def_Pre_Op;

   ------------------
   -- Axiom_Pre_Op --
   ------------------

   procedure Axiom_Pre_Op
     (State : in out Printer_State;
      Node  : W_Axiom_Valid_Id)
   is
   begin
      P (O, "axiom ");
      Traverse
        (State,
         Axiom_Get_Name (Node));
      PL (O, " :");
      Relative_Indent (O, 1);
      Traverse
        (State,
         Axiom_Get_Def (Node));
      Relative_Indent (O, -1);
      NL (O);
      State.Control := Abandon_Children;
   end Axiom_Pre_Op;

   -----------------
   -- Goal_Pre_Op --
   -----------------

   procedure Goal_Pre_Op
     (State : in out Printer_State;
      Node  : W_Goal_Valid_Id)
   is
   begin
      P (O, "goal ");
      Traverse
        (State,
         +Goal_Get_Name (Node));
      PL (O, " :");
      Relative_Indent (O, 1);
      Traverse
        (State,
         Goal_Get_Def (Node));
      Relative_Indent (O, -1);
      NL (O);
      State.Control := Abandon_Children;
   end Goal_Pre_Op;

   -----------------
   -- Type_Pre_Op --
   -----------------

   procedure Type_Pre_Op
     (State : in out Printer_State;
      Node  : W_Type_Valid_Id)
   is
      use Node_Lists;

      External   : constant Boolean := Type_Get_External (Node);
      Args       : constant List :=
                     Get_List (Type_Get_Args (Node));
      Nb_Args    : constant Count_Type := Length (Args);
      Position   : Cursor := First (Args);
      Name       : constant W_Identifier_Id := +Type_Get_Name (Node);
      Definition : constant W_Type_Definition_Id :=
                     Get_Definition (+Node);
   begin
      if External then
         P (O, "external ");
      end if;

      P (O, "type ");

      if Is_Why3 then
         Traverse (State, +Name);

         if Nb_Args > 1 then
            P (O, " (");
         end if;

         if Nb_Args > 0 then
            P (O, " ");
         end if;

      else
         if Nb_Args > 1 then
            P (O, "(");
         end if;
      end if;

      while Position /= No_Element loop
         P (O, "'");

         declare
            Param : constant Why_Node_Id := Element (Position);
         begin
            Traverse (State, Param);
         end;

         Position := Next (Position);

         if Position /= No_Element then
            P (O, ", ");
         end if;
      end loop;

      if Nb_Args > 1 then
         P (O, ")");
      end if;

      if not Is_Why3 then
         if Nb_Args > 0 then
            P (O, " ");
         end if;

         Traverse (State, +Name);
      end if;

      if Definition /= Why_Empty then
         P (O, " = ");
         NL (O);
         Relative_Indent (O, 1);
         Traverse (State, +Definition);
         Relative_Indent (O, -1);
      end if;

      NL (O);
      State.Control := Abandon_Children;
   end Type_Pre_Op;

   -----------------------------------
   -- Global_Ref_Declaration_Pre_Op --
   -----------------------------------

   procedure Global_Ref_Declaration_Pre_Op
     (State : in out Printer_State;
      Node  : W_Global_Ref_Declaration_Valid_Id)
   is
   begin
      if Is_Why3 then
         P (O, "val ");
      else
         P (O, "parameter ");
      end if;

      Traverse (State, Global_Ref_Declaration_Get_Name (Node));
      P (O, " : ");

      if Is_Why3 then
         P (O, " ref ");
         Traverse (State, Global_Ref_Declaration_Get_Ref_Type (Node));
      else
         Traverse (State, Global_Ref_Declaration_Get_Ref_Type (Node));
         P (O, " ref");
      end if;

      NL (O);
      State.Control := Abandon_Children;
   end Global_Ref_Declaration_Pre_Op;

   ----------------------------------
   -- Exception_Declaration_Pre_Op --
   ----------------------------------

   procedure Exception_Declaration_Pre_Op
     (State : in out Printer_State;
      Node  : W_Exception_Declaration_Valid_Id)
   is
      Arg : constant W_Primitive_Type_OId :=
              +Exception_Declaration_Get_Arg (Node);
   begin
      if Is_Why3 then
         P (O, "exception Gnatprove_Exception__");
      else
         P (O, "exception ");
      end if;

      Traverse
        (State,
         Exception_Declaration_Get_Name (Node));

      if Arg /= Why_Empty then
         P (O, "of ");
         Traverse (State, +Arg);
      end if;

      State.Control := Abandon_Children;
   end Exception_Declaration_Pre_Op;

   --------------------------------
   -- Include_Declaration_Pre_Op --
   --------------------------------

   procedure Include_Declaration_Pre_Op
     (State : in out Printer_State;
      Node  : W_Include_Declaration_Valid_Id)
   is
   begin
      if Is_Why3 then
         P (O, "use export module ");
      else
         P (O, "include """);
      end if;

      Traverse
        (State,
         Include_Declaration_Get_Name (Node));

      if Is_Why3 then
         P (O, ".Main");
      else
         P (O, ".mlw""");
      end if;

      NL (O);
      State.Control := Abandon_Children;
   end Include_Declaration_Pre_Op;

   -----------------
   -- File_Pre_Op --
   -----------------

   procedure File_Pre_Op
     (State : in out Printer_State;
      Node  : W_File_Valid_Id)
   is
   begin
      if Is_Why3 then
         PL (O, "module Main");
         PL (O, "use import int.Int");
         PL (O, "use import module ref.Ref");
      end if;

      Print_List
        (State,
         File_Get_Declarations (Node),
         "" & ASCII.LF);

      if Is_Why3 then
         PL (O, "end");
      end if;

      State.Control := Abandon_Children;
   end File_Pre_Op;

end Why.Atree.Sprint;

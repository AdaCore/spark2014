------------------------------------------------------------------------------
--                                                                          --
--                            GNAT2WHY COMPONENTS                           --
--                                                                          --
--                     W H Y - A T R E E - S P R I N T                      --
--                                                                          --
--                                 B o d y                                  --
--                                                                          --
--                       Copyright (C) 2010-2011, AdaCore                   --
--                                                                          --
-- gnat2why is  free  software;  you can redistribute it and/or modify it   --
-- under terms of the  GNU General Public License as published  by the Free --
-- Software Foundation;  either version  2,  or  (at your option) any later --
-- version. gnat2why is distributed in the hope that it will  be  useful,   --
-- but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHAN-  --
-- TABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public --
-- License  for more details. You  should  have  received a copy of the GNU --
-- General Public License  distributed with GNAT; see file COPYING. If not, --
-- write to the Free Software Foundation,  51 Franklin Street, Fifth Floor, --
-- Boston,                                                                  --
--                                                                          --
-- gnat2why is maintained by AdaCore (http://www.adacore.com)               --
--                                                                          --
------------------------------------------------------------------------------

with Ada.Containers; use Ada.Containers;

with Namet;  use Namet;
with Uintp;  use Uintp;
with Urealp; use Urealp;

with Why.Images;          use Why.Images;
with Why.Conversions;     use Why.Conversions;
with Why.Atree.Accessors; use Why.Atree.Accessors;

package body Why.Atree.Sprint is

   O : Output_Id := Stdout;

   procedure Print_List
     (State     : in out Printer_State'Class;
      List_Id   : Why_Node_List;
      Separator : String := ", ");
   --  Print a node list on current output, separating each element
   --  by a given separator.

   ----------------
   -- Print_List --
   ----------------

   procedure Print_List
     (State     : in out Printer_State'Class;
      List_Id   : Why_Node_List;
      Separator : String := ", ")
   is
      use Node_Lists;

      Nodes    : constant List := Get_List (List_Id);
      Position : Cursor := First (Nodes);
   begin
      while Position /= No_Element loop
         declare
            Node : constant Why_Node_Id := Element (Position);
         begin
            Traverse (State, Node);
         end;

         Position := Next (Position);

         if Position /= No_Element then
            P (O, Separator);
         end if;
      end loop;
   end Print_List;

   ---------------------
   -- Sprint_Why_Node --
   ---------------------

   procedure Sprint_Why_Node (Node : Why_Node_Id; To : Output_Id := Stdout) is
      PS : Printer_State := (Control => Continue);
   begin
      O := To;
      Traverse (PS, +Node);
   end Sprint_Why_Node;

   ---------
   -- wpg --
   ---------

   procedure wpg (Node : Why_Node_Id) is
   begin
      Sprint_Why_Node (Node, Stdout);
   end wpg;

   ----------------------------------------
   -- Pre-operations and post-operations --
   ----------------------------------------

   --  Note: the following subprograms have been written from the stub
   --  generated by the xtree; the order of generation has been kept. That
   --  explains why these are not in alphabetical order.

   -----------------------
   -- Identifier_Pre_Op --
   -----------------------

   procedure Identifier_Pre_Op
     (State : in out Printer_State;
      Node  : W_Identifier_Valid_Id)
   is
      pragma Unreferenced (State);
   begin
      P (O, Get_Name_String (Identifier_Get_Symbol (Node)));
   end Identifier_Pre_Op;

   ----------------------
   -- Type_Prop_Pre_Op --
   ----------------------

   procedure Type_Prop_Pre_Op
     (State : in out Printer_State;
      Node  : W_Type_Prop_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, "prop");
   end Type_Prop_Pre_Op;

   ---------------------
   -- Type_Int_Pre_Op --
   ---------------------

   procedure Type_Int_Pre_Op
     (State : in out Printer_State;
      Node  : W_Type_Int_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, "int");
   end Type_Int_Pre_Op;

   ----------------------
   -- Type_Bool_Pre_Op --
   ----------------------

   procedure Type_Bool_Pre_Op
     (State : in out Printer_State;
      Node  : W_Type_Bool_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, "bool");
   end Type_Bool_Pre_Op;

   ----------------------
   -- Type_Real_Pre_Op --
   ----------------------

   procedure Type_Real_Pre_Op
     (State : in out Printer_State;
      Node  : W_Type_Real_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, "real");
   end Type_Real_Pre_Op;

   ----------------------
   -- Type_Unit_Pre_Op --
   ----------------------

   procedure Type_Unit_Pre_Op
     (State : in out Printer_State;
      Node  : W_Type_Unit_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, "unit");
   end Type_Unit_Pre_Op;

   --------------------------------
   -- Generic_Formal_Type_Pre_Op --
   --------------------------------

   procedure Generic_Formal_Type_Pre_Op
     (State : in out Printer_State;
      Node  : W_Generic_Formal_Type_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, "'");
   end Generic_Formal_Type_Pre_Op;

   --------------------------------------
   -- Generic_Actual_Type_Chain_Pre_Op --
   --------------------------------------

   procedure Generic_Actual_Type_Chain_Pre_Op
     (State : in out Printer_State;
      Node  : W_Generic_Actual_Type_Chain_Valid_Id)
   is
   begin
      Print_List (State,
                  Generic_Actual_Type_Chain_Get_Type_Chain (Node), " ");
      P (O, " ");

      Traverse
        (State,
         Generic_Actual_Type_Chain_Get_Name (Node));

      State.Control := Abandon_Children;
   end Generic_Actual_Type_Chain_Pre_Op;

   ------------------------
   -- Array_Type_Post_Op --
   ------------------------

   procedure Array_Type_Post_Op
     (State : in out Printer_State;
      Node  : W_Array_Type_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, " array");
   end Array_Type_Post_Op;

   ----------------------
   -- Ref_Type_Post_Op --
   ----------------------

   procedure Ref_Type_Post_Op
     (State : in out Printer_State;
      Node  : W_Ref_Type_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, " ref");
   end Ref_Type_Post_Op;

   ---------------------------------
   -- Protected_Value_Type_Pre_Op --
   ---------------------------------

   procedure Protected_Value_Type_Pre_Op
     (State : in out Printer_State;
      Node  : W_Protected_Value_Type_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, "(");
   end Protected_Value_Type_Pre_Op;

   ----------------------------------
   -- Protected_Value_Type_Post_Op --
   ----------------------------------

   procedure Protected_Value_Type_Post_Op
     (State : in out Printer_State;
      Node  : W_Protected_Value_Type_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, ")");
   end Protected_Value_Type_Post_Op;

   -----------------------
   -- Arrow_Type_Pre_Op --
   -----------------------

   procedure Arrow_Type_Pre_Op
     (State : in out Printer_State;
      Node  : W_Arrow_Type_Valid_Id)
   is
      Name  : constant W_Identifier_OId := Arrow_Type_Get_Name (+Node);
      Right : constant W_Computation_Type_Id := Arrow_Type_Get_Right (+Node);
   begin
      if Name /= Why_Empty then
         Traverse (State, +Name);
         P (O, " : ");
      end if;

      Traverse
        (State,
         Arrow_Type_Get_Left (Node));
      P (O, " ->");

      if Get_Kind (+Right) = W_Computation_Spec then
         NL (O);
      else
         P (O, " ");
      end if;

      Traverse (State, +Right);

      State.Control := Abandon_Children;
   end Arrow_Type_Pre_Op;

   -------------------------
   -- Precondition_Pre_Op --
   -------------------------

   procedure Precondition_Pre_Op
     (State : in out Printer_State;
      Node  : W_Precondition_Valid_Id)
   is
   begin
      P (O, "{ ");
      Traverse (State, Precondition_Get_Assertion (Node));
      PL (O, " }");
      State.Control := Abandon_Children;
   end Precondition_Pre_Op;

   -----------------------------
   -- Computation_Spec_Pre_Op --
   -----------------------------

   procedure Computation_Spec_Pre_Op
     (State : in out Printer_State;
      Node  : W_Computation_Spec_Valid_Id)
   is
      Result : constant W_Identifier_OId :=
                 Computation_Spec_Get_Result_Name (+Node);
      Pre    : constant W_Precondition_OId :=
                 Computation_Spec_Get_Precondition (+Node);
   begin
      if Pre = Why_Empty then
         P (O, " { } ");
      else
         Traverse (State, +Pre);
      end if;

      Relative_Indent (O, 1);

      if  Result /= Why_Empty then
         P (O, "returns ");
         Traverse
           (State,
            Computation_Spec_Get_Result_Name (Node));
         P (O, " : ");
      end if;

      Traverse
        (State,
         Computation_Spec_Get_Return_Type (Node));
      NL (O);

      Traverse
        (State,
         Computation_Spec_Get_Effects (Node));

      Relative_Indent (O, -1);
      P (O, "{ ");
      Traverse
        (State,
         Computation_Spec_Get_Postcondition (Node));
      P (O, " }");

      State.Control := Abandon_Children;
   end Computation_Spec_Pre_Op;

   -----------------------------
   -- Integer_Constant_Pre_Op --
   -----------------------------

   procedure Integer_Constant_Pre_Op
     (State : in out Printer_State;
      Node  : W_Integer_Constant_Valid_Id)
   is
      pragma Unreferenced (State);
      Value : constant Uint := Integer_Constant_Get_Value (Node);
   begin
      --  ??? The Why Reference does not give any detail about
      --  the syntax of integer constants. We shall suppose that
      --  it is similar to Ocaml's integer litterals:
      --
      --  IntegerLiteral ::=
      --     [-]  UnprefixedIntegerLiteral
      --
      --  UnprefixedIntegerLiteral ::=
      --      DecimalLiteral
      --      HexadecimalLiteral
      --      OctalLiteral
      --      BinaryLiteral
      --
      --  DecimalLiteral ::=
      --      DecimalLiteral  Digit
      --      DecimalLiteral  _
      --      Digit
      --
      --  HexadecimalLiteral ::=
      --      HexadecimalLiteral  HexadecimalDigit
      --      HexadecimalLiteral  _
      --      0x  HexadecimalDigit
      --      0X  HexadecimalDigit
      --
      --  OctalLiteral ::=
      --      OctalLiteral  OctalDigit
      --      OctalLiteral  _
      --      0o  OctalDigit
      --      0O  OctalDigit
      --
      --  BinaryLiteral ::=
      --      BinaryLiteral  BinaryDigit
      --      BinaryLiteral  _
      --      0b  BinaryDigit
      --      0B  BinaryDigit
      --
      --  Digit ::=
      --      DecimalDigit
      --
      --  HexadecimalDigit ::=  { 0123456789abcdefABCDEF }
      --
      --  DecimalDigit ::=  { 0123456789 }
      --
      --  OctalDigit ::=  { 01234567 }
      --
      --  BinaryDigit ::=  { 01 }
      if Value < Uint_0 then
         P (O, "( ");
         P (O, Img (Value));
         P (O, " )");
      else
         P (O, Img (Value));
      end if;
   end Integer_Constant_Pre_Op;

   --------------------------
   -- Real_Constant_Pre_Op --
   --------------------------

   procedure Real_Constant_Pre_Op
     (State : in out Printer_State;
      Node  : W_Real_Constant_Valid_Id)
   is
      pragma Unreferenced (State);
      UR   : constant Ureal := Real_Constant_Get_Value (Node);
      Num  : constant Uint := Numerator (UR);
      Den  : constant Uint := Denominator (UR);
      Base : constant Nat := Rbase (UR);
   begin
      --  ??? Same remark as in the case of integer constants:
      --  I suppose that Why's real constants follows the same syntax
      --  as Ocaml's floating-point literals:
      --
      --      FloatingPointLiteral ::=
      --        [-]  UnprefixedFloatingPointLiteral
      --
      --      UnprefixedFloatingPointLiteral ::=
      --        DecimalLiteral  FractionalPart  ExponentPart
      --        DecimalLiteral  FractionalPart
      --        DecimalLiteral  ExponentPart
      --
      --      FractionalPart ::=
      --        FractionalPart  Digit
      --        FractionalPart  _
      --        .
      --
      --      ExponentPart ::=
      --        ExponentLetter  +  DecimalLiteral
      --        ExponentLetter  -  DecimalLiteral
      --        ExponentLetter     DecimalLiteral
      --
      --       ExponentLetter ::=  { eE }

      if UR_Is_Negative (UR) then
         P (O, "-");
      end if;

      if Base = 0 then
         P (O, Img (Num));
         P (O, "/");
         P (O, Img (Den));

      elsif Base = 10 then
         P (O, Img (Num));
         P (O, "E-");
         P (O, Img (Den));

      else
         P (O, Img (Num));

         if UI_To_Int (Den) > 0 then
            P (O, "/");
            P (O, Img ((UI_Expon (Den, Base))));

         elsif UI_To_Int (Den) < 0 then
            P (O, "*");
            P (O, Img ((UI_Expon (UI_Negate (Den), Base))));
         end if;
      end if;
   end Real_Constant_Pre_Op;

   -------------------------
   -- True_Literal_Pre_Op --
   -------------------------

   procedure True_Literal_Pre_Op
     (State : in out Printer_State;
      Node  : W_True_Literal_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, "true");
   end True_Literal_Pre_Op;

   --------------------------
   -- False_Literal_Pre_Op --
   --------------------------

   procedure False_Literal_Pre_Op
     (State : in out Printer_State;
      Node  : W_False_Literal_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, "false");
   end False_Literal_Pre_Op;

   -------------------------
   -- Void_Literal_Pre_Op --
   -------------------------

   procedure Void_Literal_Pre_Op
     (State : in out Printer_State;
      Node  : W_Void_Literal_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, "void");
   end Void_Literal_Pre_Op;

   ----------------------------
   -- Arith_Operation_Pre_Op --
   ----------------------------

   procedure Arith_Operation_Pre_Op
     (State : in out Printer_State;
      Node  : W_Arith_Operation_Valid_Id)
   is
   begin
      P (O, "( ");
      Traverse
        (State,
         Arith_Operation_Get_Left (Node));
      P (O, " ");
      Traverse
        (State,
         Arith_Operation_Get_Op (Node));
      P (O, " ");
      Traverse
        (State,
         Arith_Operation_Get_Right (Node));
      P (O, " )");

      State.Control := Abandon_Children;
   end Arith_Operation_Pre_Op;

   --------------------------
   -- Negative_Term_Pre_Op --
   --------------------------

   procedure Negative_Term_Pre_Op
     (State : in out Printer_State;
      Node  : W_Negative_Term_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, "-");
   end Negative_Term_Pre_Op;

   -----------------------------
   -- Label_Identifier_Pre_Op --
   -----------------------------

   procedure Term_Identifier_Pre_Op
     (State : in out Printer_State;
      Node  : W_Term_Identifier_Valid_Id)
   is
      Label : constant W_Identifier_OId := Term_Identifier_Get_Label (+Node);
   begin
      Traverse
        (State,
         Term_Identifier_Get_Name (Node));

      if Label /= Why_Empty then
         P (O, "@");
         Traverse (State, +Label);
      end if;

      State.Control := Abandon_Children;
   end Term_Identifier_Pre_Op;

   ----------------------
   -- Operation_Pre_Op --
   ----------------------

   procedure Operation_Pre_Op
     (State : in out Printer_State;
      Node  : W_Operation_Valid_Id)
   is
   begin
      Traverse
        (State,
         Operation_Get_Name (Node));
      P (O, " (");
      Print_List
        (State,
         Operation_Get_Parameters (Node));
      P (O, ")");
      State.Control := Abandon_Children;
   end Operation_Pre_Op;

   -----------------------
   -- Named_Term_Pre_Op --
   -----------------------

   procedure Named_Term_Pre_Op
     (State : in out Printer_State;
      Node  : W_Named_Term_Valid_Id)
   is
   begin
      Traverse
        (State,
         Named_Term_Get_Name (Node));
      P (O, " [");
      Traverse
        (State,
         Named_Term_Get_Term (Node));
      P (O, "]");
      State.Control := Abandon_Children;
   end Named_Term_Pre_Op;

   --------------------------
   -- Matching_Term_Pre_Op --
   --------------------------

   procedure Matching_Term_Pre_Op
     (State : in out Printer_State;
      Node  : W_Matching_Term_Valid_Id)
   is
   begin
      P (O, "match ");
      Traverse (State, Matching_Term_Get_Term (Node));
      P (O, " with ");
      NL (O);
      Relative_Indent (O, 1);
      Traverse_List (State, Matching_Term_Get_Branches (Node));
      Relative_Indent (O, -1);
      P (O, "end");
      NL (O);
      State.Control := Abandon_Children;
   end Matching_Term_Pre_Op;

   -----------------------
   -- Match_Case_Pre_Op --
   -----------------------

   procedure Match_Case_Pre_Op
     (State : in out Printer_State;
      Node  : W_Match_Case_Valid_Id)
   is
   begin
      P (O, "| ");
      Traverse (State, Match_Case_Get_Pattern (Node));
      P (O, " -> ");
      NL (O);
      Relative_Indent (O, 1);
      Traverse (State, Match_Case_Get_Term (Node));
      Relative_Indent (O, -1);
      NL (O);
      State.Control := Abandon_Children;
   end Match_Case_Pre_Op;

   procedure Pattern_Pre_Op
     (State : in out Printer_State;
      Node  : W_Pattern_Valid_Id)
   is
      Args : constant W_Identifier_OList := Pattern_Get_Args (+Node);
   begin
      Traverse (State, Pattern_Get_Constr (Node));
      if not (Is_Empty (+Args)) then
         P (O, "(");
         Print_List (State, +Args);
         P (O, ")");
      end if;
      State.Control := Abandon_Children;
   end Pattern_Pre_Op;

   -----------------------------
   -- Conditional_Term_Pre_Op --
   -----------------------------

   procedure Conditional_Term_Pre_Op
     (State : in out Printer_State;
      Node  : W_Conditional_Term_Valid_Id)
   is
      Condition : constant W_Term_Id :=
                    Conditional_Term_Get_Condition (+Node);
      Then_Part : constant W_Term_Id :=
                    Conditional_Term_Get_Then_Part (+Node);
      Else_Part : constant W_Term_Id :=
                    Conditional_Term_Get_Else_Part (+Node);
      Has_Elsif : constant Boolean :=
                    Get_Kind (+Else_Part) /= W_Conditional_Term;
   begin
      P (O, "if ");
      Traverse (State, +Condition);
      PL (O, " then");
      Relative_Indent (O, 1);
      Traverse (State, +Then_Part);
      NL (O);
      Relative_Indent (O, -1);
      P (O, " else");

      if not Has_Elsif then
         NL (O);
         Relative_Indent (O, 1);
      end if;

      Traverse (State, +Else_Part);

      if not Has_Elsif then
         Relative_Indent (O, -1);
      end if;

      State.Control := Abandon_Children;
   end Conditional_Term_Pre_Op;

   -------------------------
   -- Binding_Term_Pre_Op --
   -------------------------

   procedure Binding_Term_Pre_Op
     (State : in out Printer_State;
      Node  : W_Binding_Term_Valid_Id)
   is
      Name             : constant W_Identifier_Id :=
                           Binding_Term_Get_Name (+Node);
      Def              : constant W_Term_Id :=
                           Binding_Term_Get_Def (+Node);
      Context          : constant W_Term_Id :=
                           Binding_Term_Get_Context (+Node);
      Binding_Sequence : constant Boolean :=
                           Get_Kind (+Context) = W_Binding_Term;
   begin
      P (O, "let ");
      Traverse (State, +Name);
      P (O, " = ");
      Traverse (State, +Def);
      PL (O, " in");

      if not Binding_Sequence then
         Relative_Indent (O, 1);
      end if;

      Traverse (State, +Context);

      if not Binding_Sequence then
         Relative_Indent (O, -1);
      end if;

      State.Control := Abandon_Children;
   end Binding_Term_Pre_Op;

   ---------------------------
   -- Protected_Term_Pre_Op --
   ---------------------------

   procedure Protected_Term_Pre_Op
     (State : in out Printer_State;
      Node  : W_Protected_Term_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, "(");
   end Protected_Term_Pre_Op;

   ----------------------------
   -- Protected_Term_Post_Op --
   ----------------------------

   procedure Protected_Term_Post_Op
     (State : in out Printer_State;
      Node  : W_Protected_Term_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, ")");
   end Protected_Term_Post_Op;

   -------------------
   -- Op_Add_Pre_Op --
   -------------------

   procedure Op_Add_Pre_Op
     (State : in out Printer_State;
      Node  : W_Op_Add_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, "+");
   end Op_Add_Pre_Op;

   -------------------------
   -- Op_Substract_Pre_Op --
   -------------------------

   procedure Op_Substract_Pre_Op
     (State : in out Printer_State;
      Node  : W_Op_Substract_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, "-");
   end Op_Substract_Pre_Op;

   ------------------------
   -- Op_Multiply_Pre_Op --
   ------------------------

   procedure Op_Multiply_Pre_Op
     (State : in out Printer_State;
      Node  : W_Op_Multiply_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, "*");
   end Op_Multiply_Pre_Op;

   ----------------------
   -- Op_Divide_Pre_Op --
   ----------------------

   procedure Op_Divide_Pre_Op
     (State : in out Printer_State;
      Node  : W_Op_Divide_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, "/");
   end Op_Divide_Pre_Op;

   ----------------------
   -- Op_Modulo_Pre_Op --
   ----------------------

   procedure Op_Modulo_Pre_Op
     (State : in out Printer_State;
      Node  : W_Op_Modulo_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, "%");
   end Op_Modulo_Pre_Op;

   ------------------------------
   -- True_Literal_Pred_Pre_Op --
   ------------------------------

   procedure True_Literal_Pred_Pre_Op
     (State : in out Printer_State;
      Node  : W_True_Literal_Pred_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, "true");
   end True_Literal_Pred_Pre_Op;

   -------------------------------
   -- False_Literal_Pred_Pre_Op --
   -------------------------------

   procedure False_Literal_Pred_Pre_Op
     (State : in out Printer_State;
      Node  : W_False_Literal_Pred_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, "false");
   end False_Literal_Pred_Pre_Op;

   -------------------------------
   -- Predicate_Instance_Pre_Op --
   -------------------------------

   procedure Predicate_Instance_Pre_Op
     (State : in out Printer_State;
      Node  : W_Predicate_Instance_Valid_Id)
   is
   begin
      Traverse
        (State,
         Predicate_Instance_Get_Name (Node));
      P (O, " (");
      Print_List
        (State,
         Predicate_Instance_Get_Parameters (Node));
      P (O, ")");
      State.Control := Abandon_Children;
   end Predicate_Instance_Pre_Op;

   --------------------------
   -- Related_Terms_Pre_Op --
   --------------------------

   procedure Related_Terms_Pre_Op
     (State : in out Printer_State;
      Node  : W_Related_Terms_Valid_Id)
   is
      Left   : constant W_Term_Id := Related_Terms_Get_Left (+Node);
      Op     : constant W_Relation_Id := Related_Terms_Get_Op (+Node);
      Right  : constant W_Term_Id := Related_Terms_Get_Right (+Node);
      Op2    : constant W_Relation_OId := Related_Terms_Get_Op2 (+Node);
      Right2 : constant W_Term_OId := Related_Terms_Get_Right2 (+Node);
   begin
      Traverse (State, +Left);
      P (O, " ");
      Traverse (State, +Op);
      P (O, " ");
      Traverse (State, +Right);

      if Op2 /= Why_Empty then
         P (O, " ");
         Traverse (State, +Op2);
         P (O, " ");
         Traverse (State, +Right2);
      end if;

      State.Control := Abandon_Children;
   end Related_Terms_Pre_Op;

   ------------------------
   -- Implication_Pre_Op --
   ------------------------

   procedure Implication_Pre_Op
     (State : in out Printer_State;
      Node  : W_Implication_Valid_Id)
   is
   begin
      P (O, "( ");
      Traverse
        (State,
         Implication_Get_Left (Node));
      P (O, " -> ");
      Traverse
        (State,
         Implication_Get_Right (Node));
      P (O, " )");
      State.Control := Abandon_Children;
   end Implication_Pre_Op;

   ------------------------
   -- Equivalence_Pre_Op --
   ------------------------

   procedure Equivalence_Pre_Op
     (State : in out Printer_State;
      Node  : W_Equivalence_Valid_Id)
   is
   begin
      Traverse
        (State,
         Equivalence_Get_Left (Node));
      P (O, " <-> ");
      Traverse
        (State,
         Equivalence_Get_Right (Node));
      State.Control := Abandon_Children;
   end Equivalence_Pre_Op;

   ------------------------
   -- Disjunction_Pre_Op --
   ------------------------

   procedure Disjunction_Pre_Op
     (State : in out Printer_State;
      Node  : W_Disjunction_Valid_Id)
   is
   begin
      Traverse
        (State,
         Disjunction_Get_Left (Node));
      P (O, " or ");
      Traverse
        (State,
         Disjunction_Get_Right (Node));
      State.Control := Abandon_Children;
   end Disjunction_Pre_Op;

   ------------------------
   -- Conjunction_Pre_Op --
   ------------------------

   procedure Conjunction_Pre_Op
     (State : in out Printer_State;
      Node  : W_Conjunction_Valid_Id)
   is
   begin
      Traverse
        (State,
         Conjunction_Get_Left (Node));
      P (O, " and ");
      Traverse
        (State,
         Conjunction_Get_Right (Node));
      State.Control := Abandon_Children;
   end Conjunction_Pre_Op;

   ---------------------
   -- Negation_Pre_Op --
   ---------------------

   procedure Negation_Pre_Op
     (State : in out Printer_State;
      Node  : W_Negation_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, "not ");
   end Negation_Pre_Op;

   -----------------------------
   -- Conditional_Pred_Pre_Op --
   -----------------------------

   procedure Conditional_Pred_Pre_Op
     (State : in out Printer_State;
      Node  : W_Conditional_Pred_Valid_Id)
   is
      Condition : constant W_Term_Id :=
                    Conditional_Pred_Get_Condition (+Node);
      Then_Part : constant W_Predicate_Id :=
                    Conditional_Pred_Get_Then_Part (+Node);
      Else_Part : constant W_Predicate_Id :=
                    Conditional_Pred_Get_Else_Part (+Node);
      Has_Elsif : constant Boolean :=
                   Get_Kind (+Else_Part) = W_Conditional_Pred;
   begin
      P (O, "if ");
      Traverse (State, +Condition);
      PL (O, " then");
      Relative_Indent (O, 1);
      Traverse (State, +Then_Part);
      Relative_Indent (O, -1);
      P (O, " else");

      if not Has_Elsif then
         NL (O);
         Relative_Indent (O, 1);
      end if;

      Traverse (State, +Else_Part);

      if not Has_Elsif then
         Relative_Indent (O, -1);
      end if;

      State.Control := Abandon_Children;
   end Conditional_Pred_Pre_Op;

   -------------------------
   -- Binding_Pred_Pre_Op --
   -------------------------

   procedure Binding_Pred_Pre_Op
     (State : in out Printer_State;
      Node  : W_Binding_Pred_Valid_Id)
   is
      Name             : constant W_Identifier_Id :=
                           Binding_Pred_Get_Name (+Node);
      Def              : constant W_Term_Id :=
                           Binding_Pred_Get_Def (+Node);
      Context          : constant W_Predicate_Id :=
                           Binding_Pred_Get_Context (+Node);
      Binding_Sequence : constant Boolean :=
                           Get_Kind (+Context) = W_Binding_Pred;
   begin
      P (O, "let ");
      Traverse (State, +Name);
      P (O, " = ");
      Traverse (State, +Def);
      PL (O, " in");

      if not Binding_Sequence then
         Relative_Indent (O, 1);
      end if;

      Traverse (State, +Context);

      if not Binding_Sequence then
         Relative_Indent (O, -1);
      end if;

      State.Control := Abandon_Children;
   end Binding_Pred_Pre_Op;

   ------------------------------
   -- Universal_Quantif_Pre_Op --
   ------------------------------

   procedure Universal_Quantif_Pre_Op
     (State : in out Printer_State;
      Node  : W_Universal_Quantif_Valid_Id)
   is
      Variables       : constant W_Identifier_List :=
                          Universal_Quantif_Get_Variables (+Node);
      Var_Type        : constant W_Primitive_Type_Id :=
                          Universal_Quantif_Get_Var_Type (+Node);
      Triggers        : constant W_Triggers_OId :=
                          Universal_Quantif_Get_Triggers (+Node);
      Pred            : constant W_Predicate_Id :=
                          Universal_Quantif_Get_Pred (+Node);
      Forall_Sequence : constant Boolean :=
                          Get_Kind (+Pred) = W_Universal_Quantif;
   begin
      P (O, "forall ");
      Print_List (State, +Variables);
      P (O, " : ");
      Traverse (State, +Var_Type);

      if Triggers /= Why_Empty then
         P (O, " ");
         Traverse (State, +Triggers);
      end if;

      PL (O, ".");

      if not Forall_Sequence then
         Relative_Indent (O, 1);
      end if;

      Traverse (State, +Pred);

      if not Forall_Sequence then
         Relative_Indent (O, -1);
      end if;

      State.Control := Abandon_Children;
   end Universal_Quantif_Pre_Op;

   --------------------------------
   -- Existential_Quantif_Pre_Op --
   --------------------------------

   procedure Existential_Quantif_Pre_Op
     (State : in out Printer_State;
      Node  : W_Existential_Quantif_Valid_Id)
   is
      Variables       : constant W_Identifier_List :=
                          Existential_Quantif_Get_Variables (+Node);
      Var_Type        : constant W_Primitive_Type_Id :=
                          Existential_Quantif_Get_Var_Type (+Node);
      Pred            : constant W_Predicate_Id :=
                          Existential_Quantif_Get_Pred (+Node);
      Exists_Sequence : constant Boolean :=
                          Get_Kind (+Pred) = W_Existential_Quantif;
   begin
      P (O, "exists ");
      Print_List (State, +Variables);
      P (O, " : ");
      Traverse (State, +Var_Type);
      PL (O, ".");

      if not Exists_Sequence then
         Relative_Indent (O, 1);
      end if;

      Traverse (State, +Pred);

      if not Exists_Sequence then
         Relative_Indent (O, -1);
      end if;

      State.Control := Abandon_Children;
   end Existential_Quantif_Pre_Op;

   ----------------------------
   -- Named_Predicate_Pre_Op --
   ----------------------------

   procedure Named_Predicate_Pre_Op
     (State : in out Printer_State;
      Node  : W_Named_Predicate_Valid_Id)
   is
   begin
      Traverse
        (State,
         Named_Predicate_Get_Name (Node));
      P (O, " : ");
      Traverse
        (State,
         Named_Predicate_Get_Pred (Node));
      State.Control := Abandon_Children;
   end Named_Predicate_Pre_Op;

   --------------------------------
   -- Protected_Predicate_Pre_Op --
   --------------------------------

   procedure Protected_Predicate_Pre_Op
     (State : in out Printer_State;
      Node  : W_Protected_Predicate_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, "(");
   end Protected_Predicate_Pre_Op;

   ---------------------------------
   -- Protected_Predicate_Post_Op --
   ---------------------------------

   procedure Protected_Predicate_Post_Op
     (State : in out Printer_State;
      Node  : W_Protected_Predicate_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, ")");
   end Protected_Predicate_Post_Op;

   ---------------------
   -- Triggers_Pre_Op --
   ---------------------

   procedure Triggers_Pre_Op
     (State : in out Printer_State;
      Node  : W_Triggers_Valid_Id)
   is
      Triggers : constant W_Trigger_List :=
                   Triggers_Get_Triggers (+Node);
   begin
      P (O, "[");
      Print_List (State, +Triggers, " | ");
      P (O, "]");

      State.Control := Abandon_Children;
   end Triggers_Pre_Op;

   --------------------
   -- Trigger_Pre_Op --
   --------------------

   procedure Trigger_Pre_Op
     (State : in out Printer_State;
      Node  : W_Trigger_Valid_Id)
   is
      Terms    : constant W_Term_List :=
                   Trigger_Get_Terms (+Node);
   begin
      Print_List (State, +Terms);
      State.Control := Abandon_Children;
   end Trigger_Pre_Op;

   -------------------
   -- Rel_Eq_Pre_Op --
   -------------------

   procedure Rel_Eq_Pre_Op
     (State : in out Printer_State;
      Node  : W_Rel_Eq_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, "=");
   end Rel_Eq_Pre_Op;

   -------------------
   -- Rel_Ne_Pre_Op --
   -------------------

   procedure Rel_Ne_Pre_Op
     (State : in out Printer_State;
      Node  : W_Rel_Ne_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, "<>");
   end Rel_Ne_Pre_Op;

   -------------------
   -- Rel_Lt_Pre_Op --
   -------------------

   procedure Rel_Lt_Pre_Op
     (State : in out Printer_State;
      Node  : W_Rel_Lt_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, "<");
   end Rel_Lt_Pre_Op;

   -------------------
   -- Rel_Le_Pre_Op --
   -------------------

   procedure Rel_Le_Pre_Op
     (State : in out Printer_State;
      Node  : W_Rel_Le_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, "<=");
   end Rel_Le_Pre_Op;

   -------------------
   -- Rel_Gt_Pre_Op --
   -------------------

   procedure Rel_Gt_Pre_Op
     (State : in out Printer_State;
      Node  : W_Rel_Gt_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, ">");
   end Rel_Gt_Pre_Op;

   -------------------
   -- Rel_Ge_Pre_Op --
   -------------------

   procedure Rel_Ge_Pre_Op
     (State : in out Printer_State;
      Node  : W_Rel_Ge_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, ">=");
   end Rel_Ge_Pre_Op;

   -----------------
   -- Type_Pre_Op --
   -----------------

   procedure Type_Pre_Op
     (State : in out Printer_State;
      Node  : W_Type_Valid_Id)
   is
      use Node_Lists;

      External   : constant W_External_OId := Type_Get_External (+Node);
      Params     : constant List :=
                     Get_List (Type_Get_Type_Parameters (Node));
      Nb_Params  : constant Count_Type := Length (Params);
      Position   : Cursor := First (Params);
      Name       : constant W_Identifier_Id := Type_Get_Name (+Node);
      Definition : constant W_Type_Definition_Id :=
                   Type_Get_Definition (+Node);
   begin
      if External /= Why_Empty then
         P (O, "external ");
      end if;

      P (O, "type ");

      if Nb_Params > 1 then
         P (O, "(");
      end if;

      while Position /= No_Element loop
         P (O, "'");

         declare
            Param : constant Why_Node_Id := Element (Position);
         begin
            Traverse (State, Param);
         end;

         Position := Next (Position);

         if Position /= No_Element then
            P (O, ", ");
         end if;
      end loop;

      if Nb_Params > 1 then
         P (O, ")");
      end if;

      Traverse (State, +Name);
      if Definition /= Why_Empty then
         P (O, " = ");
         NL (O);
         Relative_Indent (O, 1);
         Traverse (State, +Definition);
         Relative_Indent (O, -1);
      end if;

      NL (O);
      State.Control := Abandon_Children;
   end Type_Pre_Op;

   procedure Constr_Decl_Pre_Op
      (State : in out Printer_State;
       Node : W_Constr_Decl_Valid_Id)
   is
      Args : constant W_Primitive_Type_List :=
               Constr_Decl_Get_Arg_List (+Node);
      Name : constant W_Identifier_Id :=
               Constr_Decl_Get_Name (+Node);
   begin
      P (O, "| ");
      Traverse (State, +Name);
      if not Is_Empty (+Args) then
         P (O, "( ");
         Print_List (State, +Args, ", ");
         Traverse_List (State, +Args);
         P (O, ") ");
      end if;
      NL (O);
      State.Control := Abandon_Children;
   end Constr_Decl_Pre_Op;

   ------------------
   -- Logic_Pre_Op --
   ------------------

   procedure Logic_Pre_Op
     (State : in out Printer_State;
      Node  : W_Logic_Valid_Id)
   is
      External   : constant W_External_OId :=
                     Logic_Get_External (+Node);
      Names      : constant W_Identifier_List :=
                     Logic_Get_Names (+Node);
      Logic_Type : constant W_Logic_Type_Id :=
                    Logic_Get_Logic_Type (+Node);
   begin
      if External /= Why_Empty then
         P (O, "external ");
      end if;

      P (O, "logic ");
      Print_List (State, +Names);
      P (O, " :");
      NL (O);
      Relative_Indent (O, 1);
      Traverse (State, +Logic_Type);
      Relative_Indent (O, -1);
      NL (O);
      State.Control := Abandon_Children;
   end Logic_Pre_Op;

   ---------------------
   -- Function_Pre_Op --
   ---------------------

   procedure Function_Pre_Op
     (State : in out Printer_State;
      Node  : W_Function_Valid_Id)
   is
      Binders  : constant W_Logic_Binder_List :=
                   Function_Get_Binders (+Node);
   begin
      P (O, "function ");
      Traverse
        (State,
         Function_Get_Name (Node));
      P (O, " (");
      Print_List (State, +Binders);
      P (O, ") : ");
      Traverse
        (State,
         Function_Get_Return_Type (Node));
      PL (O, " =");
      Relative_Indent (O, 1);
      Traverse
        (State,
         Function_Get_Def (Node));
      Relative_Indent (O, -1);
      NL (O);
      State.Control := Abandon_Children;
   end Function_Pre_Op;

   ---------------------------------
   -- Predicate_Definition_Pre_Op --
   ---------------------------------

   procedure Predicate_Definition_Pre_Op
     (State : in out Printer_State;
      Node  : W_Predicate_Definition_Valid_Id)
   is
      Binders  : constant W_Logic_Binder_List :=
                   Predicate_Definition_Get_Binders (+Node);
   begin
      P (O, "predicate ");
      Traverse
        (State,
         Predicate_Definition_Get_Name (Node));
      P (O, " (");
      Print_List (State, +Binders);
      PL (O, ") =");
      Relative_Indent (O, 1);
      Traverse
        (State,
         Predicate_Definition_Get_Def (Node));
      Relative_Indent (O, -1);
      NL (O);
      State.Control := Abandon_Children;
   end Predicate_Definition_Pre_Op;

   ----------------------
   -- Inductive_Pre_Op --
   ----------------------

   procedure Inductive_Pre_Op
     (State : in out Printer_State;
      Node  : W_Inductive_Valid_Id)
   is
   begin
      P (O, "inductive ");
      Traverse
        (State,
         Inductive_Get_Name (Node));
      P (O, " : ");
      Traverse
        (State,
         Inductive_Get_Logic_Type (Node));
      PL (O, " =");
      Relative_Indent (O, 1);
      Traverse_List
        (State,
         Inductive_Get_Def (Node));
      Relative_Indent (O, -1);
      State.Control := Abandon_Children;
   end Inductive_Pre_Op;

   ------------------
   -- Axiom_Pre_Op --
   ------------------

   procedure Axiom_Pre_Op
     (State : in out Printer_State;
      Node  : W_Axiom_Valid_Id)
   is
   begin
      P (O, "axiom ");
      Traverse
        (State,
         Axiom_Get_Name (Node));
      PL (O, " :");
      Relative_Indent (O, 1);
      Traverse
        (State,
         Axiom_Get_Def (Node));
      Relative_Indent (O, -1);
      NL (O);
      State.Control := Abandon_Children;
   end Axiom_Pre_Op;

   -----------------
   -- Goal_Pre_Op --
   -----------------

   procedure Goal_Pre_Op
     (State : in out Printer_State;
      Node  : W_Goal_Valid_Id)
   is
   begin
      P (O, "goal ");
      Traverse
        (State,
         +Goal_Get_Name (Node));
      PL (O, " :");
      Relative_Indent (O, 1);
      Traverse
        (State,
         Goal_Get_Def (Node));
      Relative_Indent (O, -1);
      NL (O);
      State.Control := Abandon_Children;
   end Goal_Pre_Op;

   ---------------------
   -- External_Pre_Op --
   ---------------------

   procedure External_Pre_Op
     (State : in out Printer_State;
      Node  : W_External_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, "external");
   end External_Pre_Op;

   -----------------------
   -- Logic_Type_Pre_Op --
   -----------------------

   procedure Logic_Type_Pre_Op
     (State : in out Printer_State;
      Node  : W_Logic_Type_Valid_Id)
   is
      Arg_Types : constant W_Logic_Arg_Type_List :=
                    Logic_Type_Get_Arg_Types (+Node);
   begin
      Print_List (State, +Arg_Types);
      P (O, " -> ");
      Traverse
        (State,
         Logic_Type_Get_Return_Type (Node));
      State.Control := Abandon_Children;
   end Logic_Type_Pre_Op;

   -------------------------
   -- Logic_Binder_Pre_Op --
   -------------------------

   procedure Logic_Binder_Pre_Op
     (State : in out Printer_State;
      Node  : W_Logic_Binder_Valid_Id)
   is
   begin
      Traverse
        (State,
         Logic_Binder_Get_Name (Node));
      P (O, " : ");
      Traverse
        (State,
         Logic_Binder_Get_Param_Type (Node));
      State.Control := Abandon_Children;
   end Logic_Binder_Pre_Op;

   ---------------------------
   -- Inductive_Case_Pre_Op --
   ---------------------------

   procedure Inductive_Case_Pre_Op
     (State : in out Printer_State;
      Node  : W_Inductive_Case_Valid_Id)
   is
   begin
      P (O, " | ");
      Traverse
        (State,
         Inductive_Case_Get_Name (Node));
      P (O, " : ");
      Traverse
        (State,
         Inductive_Case_Get_Pred (Node));
      NL (O);
      State.Control := Abandon_Children;
   end Inductive_Case_Pre_Op;

   --------------------
   -- Effects_Pre_Op --
   --------------------

   procedure Effects_Pre_Op
     (State : in out Printer_State;
      Node  : W_Effects_Valid_Id)
   is
      Reads  : constant W_Identifier_List :=
                 Effects_Get_Reads (+Node);
      Writes : constant W_Identifier_List :=
                 Effects_Get_Writes (+Node);
      Raises : constant W_Identifier_List :=
                 Effects_Get_Raises (+Node);
   begin
      if not Is_Empty (+Reads) then
         P (O, "reads ");
         Print_List (State, +Reads);
         NL (O);
      end if;

      if not Is_Empty (+Writes) then
         P (O, "writes ");
         Print_List (State, +Writes);
         NL (O);
      end if;

      if not Is_Empty (+Raises) then
         P (O, "raises ");
         Print_List (State, +Raises);
         NL (O);
      end if;

      State.Control := Abandon_Children;
   end Effects_Pre_Op;

   --------------------------
   -- Postcondition_Pre_Op --
   --------------------------

   procedure Postcondition_Pre_Op
     (State : in out Printer_State;
      Node  : W_Postcondition_Valid_Id)
   is
      Handlers : constant W_Exn_Condition_OList :=
                   Postcondition_Get_Handlers (+Node);
   begin
      Traverse
        (State,
         Postcondition_Get_Assertion (Node));

      if not Is_Empty (+Handlers) then
         NL (O);
         Relative_Indent (O, 1);
         Print_List (State, +Handlers, "" & ASCII.LF);
         Relative_Indent (O, -1);
      end if;

      State.Control := Abandon_Children;
   end Postcondition_Pre_Op;

   --------------------------
   -- Exn_Condition_Pre_Op --
   --------------------------

   procedure Exn_Condition_Pre_Op
     (State : in out Printer_State;
      Node  : W_Exn_Condition_Valid_Id)
   is
   begin
      P (O, "| ");
      Traverse
        (State,
         Exn_Condition_Get_Exn_Case (Node));
      P (O, " => ");
      Traverse
        (State,
         Exn_Condition_Get_Assertion (Node));
      State.Control := Abandon_Children;
   end Exn_Condition_Pre_Op;

   ----------------------
   -- Assertion_Pre_Op --
   ----------------------

   procedure Assertion_Pre_Op
     (State : in out Printer_State;
      Node  : W_Assertion_Valid_Id)
   is
      As : constant W_Identifier_OId :=
             Assertion_Get_As (+Node);
   begin
      Traverse
        (State,
         Assertion_Get_Pred (Node));

      if As /= Why_Empty then
         P (O, " as ");
         Traverse (State, +As);
      end if;

      State.Control := Abandon_Children;
   end Assertion_Pre_Op;

   ---------------------
   -- Any_Expr_Pre_Op --
   ---------------------

   procedure Any_Expr_Pre_Op
     (State : in out Printer_State;
      Node  : W_Any_Expr_Valid_Id)
   is
      Ty : constant W_Computation_Type_Id := Any_Expr_Get_Any_Type (+Node);
   begin
      P (O, "[ ");
      Traverse (State, +Ty);
      P (O, " ]");
      State.Control := Abandon_Children;
   end Any_Expr_Pre_Op;

   ------------------
   -- Deref_Pre_Op --
   ------------------

   procedure Deref_Pre_Op
     (State : in out Printer_State;
      Node  : W_Deref_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, "!");
   end Deref_Pre_Op;

   -----------------------
   -- Assignment_Pre_Op --
   -----------------------

   procedure Assignment_Pre_Op
     (State : in out Printer_State;
      Node  : W_Assignment_Valid_Id)
   is
   begin
      Traverse (State, Assignment_Get_Name (Node));
      P (O, " := ( ");
      Traverse (State, Assignment_Get_Value (Node));
      P (O, " )");
      State.Control := Abandon_Children;
   end Assignment_Pre_Op;

   -------------------------
   -- Array_Access_Pre_Op --
   -------------------------

   procedure Array_Access_Pre_Op
     (State : in out Printer_State;
      Node  : W_Array_Access_Valid_Id)
   is
   begin
      Traverse
        (State,
         Array_Access_Get_Name (Node));
      P (O, " [");
      Traverse
        (State,
         Array_Access_Get_Index (Node));
      P (O, "]");
      State.Control := Abandon_Children;
   end Array_Access_Pre_Op;

   -------------------------
   -- Array_Update_Pre_Op --
   -------------------------

   procedure Array_Update_Pre_Op
     (State : in out Printer_State;
      Node  : W_Array_Update_Valid_Id)
   is
   begin
      Traverse
        (State,
         Array_Update_Get_Name (Node));
      P (O, " [");
      Traverse
        (State,
         Array_Update_Get_Index (Node));
      P (O, "] := ");
      Traverse
        (State,
         Array_Update_Get_Value (Node));
      State.Control := Abandon_Children;
   end Array_Update_Pre_Op;

   -----------------------
   -- Infix_Call_Pre_Op --
   -----------------------

   procedure Infix_Call_Pre_Op
     (State : in out Printer_State;
      Node  : W_Infix_Call_Valid_Id)
   is
   begin
      P (O, "( ");
      Traverse
        (State,
         Infix_Call_Get_Left (Node));
      P (O, " ");
      Traverse
        (State,
         Infix_Call_Get_Infix (Node));
      P (O, " ");
      Traverse
        (State,
         Infix_Call_Get_Right (Node));
      P (O, " )");
      State.Control := Abandon_Children;
   end Infix_Call_Pre_Op;

   ------------------------
   -- Prefix_Call_Pre_Op --
   ------------------------

   procedure Prefix_Call_Pre_Op
     (State : in out Printer_State;
      Node  : W_Prefix_Call_Valid_Id)
   is
   begin
      Traverse
        (State,
         Prefix_Call_Get_Prefix (Node));
      P (O, " ");
      Traverse
        (State,
         Prefix_Call_Get_Operand (Node));
      State.Control := Abandon_Children;
   end Prefix_Call_Pre_Op;

   -------------------------
   -- Binding_Prog_Pre_Op --
   -------------------------

   procedure Binding_Prog_Pre_Op
     (State : in out Printer_State;
      Node  : W_Binding_Prog_Valid_Id)
   is
      Context          : constant W_Prog_Id :=
                           Binding_Prog_Get_Context (+Node);
      Binding_Sequence : constant Boolean :=
                           Get_Kind (+Context) = W_Binding_Prog;
   begin
      P (O, "let ");
      Traverse
        (State,
         Binding_Prog_Get_Name (Node));
      P (O, " = ");
      Traverse
        (State,
         Binding_Prog_Get_Def (Node));
      PL (O, " in ");

      if not Binding_Sequence then
         Relative_Indent (O, 1);
      end if;

      Traverse (State, +Context);

      if not Binding_Sequence then
         Relative_Indent (O, -1);
      end if;

      State.Control := Abandon_Children;
   end Binding_Prog_Pre_Op;

   ------------------------
   -- Binding_Ref_Pre_Op --
   ------------------------

   procedure Binding_Ref_Pre_Op
     (State : in out Printer_State;
      Node  : W_Binding_Ref_Valid_Id)
   is
      Context          : constant W_Prog_Id :=
                           Binding_Ref_Get_Context (+Node);
      Binding_Sequence : constant Boolean :=
                           Get_Kind (+Context) = W_Binding_Ref;
   begin
      P (O, "let ");
      Traverse
        (State,
         Binding_Ref_Get_Name (Node));
      P (O, " = ref ");
      Traverse
        (State,
         Binding_Ref_Get_Def (Node));
      PL (O, " in ");

      if not Binding_Sequence then
         Relative_Indent (O, 1);
      end if;

      Traverse (State, +Context);

      if not Binding_Sequence then
         Relative_Indent (O, -1);
      end if;

      State.Control := Abandon_Children;
   end Binding_Ref_Pre_Op;

   -----------------------------
   -- Conditional_Prog_Pre_Op --
   -----------------------------

   procedure Conditional_Prog_Pre_Op
     (State : in out Printer_State;
      Node  : W_Conditional_Prog_Valid_Id)
   is
      Condition : constant W_Prog_Id :=
                    Conditional_Prog_Get_Condition (+Node);
      Then_Part : constant W_Prog_Id :=
                    Conditional_Prog_Get_Then_Part (+Node);
      Else_Part : constant W_Prog_OId :=
                    Conditional_Prog_Get_Else_Part (+Node);
      Has_Else  : constant Boolean := Else_Part /= Why_Empty;
      Has_Elsif : constant Boolean :=
                    (Has_Else
                     and then Get_Kind (+Else_Part) = W_Conditional_Prog);
   begin
      P (O, "if ");
      Traverse (State, +Condition);
      PL (O, " then (");
      Relative_Indent (O, 1);
      Traverse (State, +Then_Part);
      Relative_Indent (O, -1);

      if Has_Else then
         P (O, ") else (");

         if not Has_Elsif then
            NL (O);
            Relative_Indent (O, 1);
         end if;

         Traverse (State, +Else_Part);

         if not Has_Elsif then
            Relative_Indent (O, -1);
         end if;
         P (O, ")");
      else
         P (O, ")");
      end if;

      State.Control := Abandon_Children;
   end Conditional_Prog_Pre_Op;

   -----------------------
   -- While_Loop_Pre_Op --
   -----------------------

   procedure While_Loop_Pre_Op
     (State : in out Printer_State;
      Node  : W_While_Loop_Valid_Id)
   is
      Condition    : constant W_Prog_Id :=
                       While_Loop_Get_Condition (+Node);
      Annotation   : constant W_Loop_Annot_OId :=
                       While_Loop_Get_Annotation (+Node);
      Loop_Content : constant W_Prog_Id :=
                       While_Loop_Get_Loop_Content (+Node);
   begin
      P (O, "while ");
      Traverse (State, +Condition);
      PL (O, " do");
      Relative_Indent (O, 1);

      if Annotation /= Why_Empty then
         Traverse (State, +Annotation);
         NL (O);
      end if;

      Traverse (State, +Loop_Content);
      Relative_Indent (O, 1);
      NL (O);
      P (O, "done");
      State.Control := Abandon_Children;
   end While_Loop_Pre_Op;

   -------------------------------
   -- Statement_Sequence_Pre_Op --
   -------------------------------

   procedure Statement_Sequence_Pre_Op
     (State : in out Printer_State;
      Node  : W_Statement_Sequence_Valid_Id)
   is
   begin
      Print_List (State,
                  Statement_Sequence_Get_Statements (Node),
                  ";" & ASCII.LF);
      State.Control := Abandon_Children;
   end Statement_Sequence_Pre_Op;

   ------------------
   -- Label_Pre_Op --
   ------------------

   procedure Label_Pre_Op
     (State : in out Printer_State;
      Node  : W_Label_Valid_Id)
   is
   begin
      P (O, "( ");
      Traverse
        (State,
         Label_Get_Name (Node));
      P (O, " : ");
      Traverse
        (State,
         Label_Get_Def (Node));
      P (O, " )");
      State.Control := Abandon_Children;
   end Label_Pre_Op;

   -------------------
   -- Assert_Pre_Op --
   -------------------

   procedure Assert_Pre_Op
     (State : in out Printer_State;
      Node  : W_Assert_Valid_Id)
   is
   begin
      P (O, "assert { ");
      Print_List (State, Assert_Get_Assertions (Node), " } { ");
      P (O, "};");
      NL (O);
      Traverse
        (State,
         Assert_Get_Prog (Node));
      State.Control := Abandon_Children;
   end Assert_Pre_Op;

   ---------------------------
   -- Post_Assertion_Pre_Op --
   ---------------------------

   procedure Post_Assertion_Pre_Op
     (State : in out Printer_State;
      Node  : W_Post_Assertion_Valid_Id)
   is
   begin
      Traverse
        (State,
         Post_Assertion_Get_Prog (Node));
      NL (O);
      P (O, "{ ");
      Traverse
        (State,
         Post_Assertion_Get_Post (Node));
      P (O, " }");
      State.Control := Abandon_Children;
   end Post_Assertion_Pre_Op;

   -----------------------------
   -- Opaque_Assertion_Pre_Op --
   -----------------------------

   procedure Opaque_Assertion_Pre_Op
     (State : in out Printer_State;
      Node  : W_Opaque_Assertion_Valid_Id)
   is
   begin
      Traverse
        (State,
         Opaque_Assertion_Get_Prog (Node));
      NL (O);
      P (O, "{{ ");
      Traverse
        (State,
         Opaque_Assertion_Get_Post (Node));
      P (O, " }}");
      State.Control := Abandon_Children;
   end Opaque_Assertion_Pre_Op;

   --------------------
   -- Fun_Def_Pre_Op --
   --------------------

   procedure Fun_Def_Pre_Op
     (State : in out Printer_State;
      Node  : W_Fun_Def_Valid_Id)
   is
   begin
      P (O, "fun ");
      Print_List (State, Fun_Def_Get_Binders (Node), " ");
      P (O, " ->");
      NL (O);
      Relative_Indent (O, 1);
      Traverse
        (State,
         Fun_Def_Get_Def (Node));
      Relative_Indent (O, -1);
      State.Control := Abandon_Children;
   end Fun_Def_Pre_Op;

   ------------------------
   -- Binding_Fun_Pre_Op --
   ------------------------

   procedure Binding_Fun_Pre_Op
     (State : in out Printer_State;
      Node  : W_Binding_Fun_Valid_Id)
   is
   begin
      P (O, "let ");
      Traverse
        (State,
         Binding_Fun_Get_Name (Node));
      P (O, " ");
      Print_List (State, +Binding_Fun_Get_Binders (Node), " ");
      PL (O, " =");
      Relative_Indent (O, 1);
      Traverse
        (State,
         Binding_Fun_Get_Def (Node));
      Relative_Indent (O, -1);
      NL (O);
      PL (O, "in");
      Relative_Indent (O, 1);
      Traverse
        (State,
         Binding_Fun_Get_Context (Node));
      Relative_Indent (O, -1);
      State.Control := Abandon_Children;
   end Binding_Fun_Pre_Op;

   ------------------------
   -- Binding_Rec_Pre_Op --
   ------------------------

   procedure Binding_Rec_Pre_Op
     (State : in out Printer_State;
      Node  : W_Binding_Rec_Valid_Id)
   is
      Context : constant W_Prog_OId :=
                  Binding_Rec_Get_Context (+Node);
   begin
      P (O, "let rec ");
      Traverse
        (State,
         Binding_Rec_Get_Recfun (Node));

      if Context /= Why_Empty then
         P (O, " in");
         Relative_Indent (O, 1);
         Traverse (State, +Context);
         Relative_Indent (O, -1);
      end if;

      State.Control := Abandon_Children;
   end Binding_Rec_Pre_Op;

   --------------------------
   -- Prog_Sequence_Pre_Op --
   --------------------------

   procedure Prog_Call_Pre_Op
     (State : in out Printer_State;
      Node  : W_Prog_Call_Valid_Id)
   is
      use Node_Lists;
      Name     : constant W_Identifier_Id := Prog_Call_Get_Name (+Node);
      Progs    : constant W_Prog_List := Prog_Call_Get_Progs (+Node);
      Nodes    : constant List := Get_List (+Progs);
      Position : Cursor := First (Nodes);
   begin
      Traverse (State, +Name);
      P (O, " ");
      while Position /= No_Element loop
         declare
            Node : constant Why_Node_Id := Element (Position);
         begin
            --  We have to protect complex subprograms by parentheses
            case Get_Kind (+Node) is
               when W_Prog_Constant .. W_Deref =>
                  Traverse (State, Node);
               when others =>
                  P (O, "(");
                  Traverse (State, Node);
                  P (O, ")");
            end case;
         end;
         Next (Position);

         if Position /= No_Element then
            P (O, " ");
         end if;
      end loop;
      State.Control := Abandon_Children;
   end Prog_Call_Pre_Op;

   ----------------------------
   -- Raise_Statement_Pre_Op --
   ----------------------------

   procedure Raise_Statement_Pre_Op
     (State : in out Printer_State;
      Node  : W_Raise_Statement_Valid_Id)
   is
      Exn_Type : constant W_Value_Type_OId :=
                   Raise_Statement_Get_Exn_Type (+Node);
   begin
      P (O, "raise ");
      Traverse
        (State,
         Raise_Statement_Get_Name (Node));

      if Exn_Type /= Why_Empty then
         P (O, " : ");
         Traverse (State, +Exn_Type);
      end if;

      State.Control := Abandon_Children;
   end Raise_Statement_Pre_Op;

   --------------------------------------------
   -- Raise_Statement_With_Parameters_Pre_Op --
   --------------------------------------------

   procedure Raise_Statement_With_Parameters_Pre_Op
     (State : in out Printer_State;
      Node  : W_Raise_Statement_With_Parameters_Valid_Id)
   is
      Exn_Type : constant W_Value_Type_OId :=
                   Raise_Statement_With_Parameters_Get_Exn_Type (+Node);
   begin
      P (O, "raise ");
      Traverse
        (State,
         Raise_Statement_With_Parameters_Get_Name (Node));
      P (O, " ");
      Traverse
        (State,
         Raise_Statement_With_Parameters_Get_Parameter (Node));

      if Exn_Type /= Why_Empty then
         P (O, " : ");
         Traverse (State, +Exn_Type);
      end if;

      State.Control := Abandon_Children;
   end Raise_Statement_With_Parameters_Pre_Op;

   ----------------------
   -- Try_Block_Pre_Op --
   ----------------------

   procedure Try_Block_Pre_Op
     (State : in out Printer_State;
      Node  : W_Try_Block_Valid_Id)
   is
   begin
      PL (O, "try");
      Relative_Indent (O, 1);
      Traverse
        (State,
         Try_Block_Get_Prog (Node));
      Relative_Indent (O, -1);
      NL (O);
      PL (O, "with");
      Relative_Indent (O, 1);
      Print_List
        (State,
         Try_Block_Get_Handler (Node),
         "," & ASCII.LF);
      Relative_Indent (O, -1);
      NL (O);
      P (O, "end");
      State.Control := Abandon_Children;
   end Try_Block_Pre_Op;

   -----------------------------
   -- Unreachable_Code_Pre_Op --
   -----------------------------

   procedure Unreachable_Code_Pre_Op
     (State : in out Printer_State;
      Node  : W_Unreachable_Code_Valid_Id)
   is
      Exn_Type : constant W_Value_Type_OId :=
                   Unreachable_Code_Get_Exn_Type (+Node);
   begin
      P (O, "absurd");

      if Exn_Type /= Why_Empty then
         P (O, " : ");
         Traverse (State, +Exn_Type);
      end if;

      State.Control := Abandon_Children;
   end Unreachable_Code_Pre_Op;

   ------------------------
   -- Begin_Block_Pre_Op --
   ------------------------

   procedure Begin_Block_Pre_Op
     (State : in out Printer_State;
      Node  : W_Begin_Block_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      PL (O, "begin");
      Relative_Indent (O, 1);
   end Begin_Block_Pre_Op;

   -------------------------
   -- Begin_Block_Post_Op --
   -------------------------

   procedure Begin_Block_Post_Op
     (State : in out Printer_State;
      Node  : W_Begin_Block_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      Relative_Indent (O, -1);
      NL (O);
      P (O, "end");
   end Begin_Block_Post_Op;

   ---------------------------
   -- Protected_Prog_Pre_Op --
   ---------------------------

   procedure Protected_Prog_Pre_Op
     (State : in out Printer_State;
      Node  : W_Protected_Prog_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, "(");
   end Protected_Prog_Pre_Op;

   ----------------------------
   -- Protected_Prog_Post_Op --
   ----------------------------

   procedure Protected_Prog_Post_Op
     (State : in out Printer_State;
      Node  : W_Protected_Prog_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, ")");
   end Protected_Prog_Post_Op;

   ------------------------
   -- Op_Add_Prog_Pre_Op --
   ------------------------

   procedure Op_Add_Prog_Pre_Op
     (State : in out Printer_State;
      Node  : W_Op_Add_Prog_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, "+");
   end Op_Add_Prog_Pre_Op;

   ------------------------------
   -- Op_Substract_Prog_Pre_Op --
   ------------------------------

   procedure Op_Substract_Prog_Pre_Op
     (State : in out Printer_State;
      Node  : W_Op_Substract_Prog_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, "-");
   end Op_Substract_Prog_Pre_Op;

   -----------------------------
   -- Op_Multiply_Prog_Pre_Op --
   -----------------------------

   procedure Op_Multiply_Prog_Pre_Op
     (State : in out Printer_State;
      Node  : W_Op_Multiply_Prog_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, "*");
   end Op_Multiply_Prog_Pre_Op;

   ---------------------------
   -- Op_Divide_Prog_Pre_Op --
   ---------------------------

   procedure Op_Divide_Prog_Pre_Op
     (State : in out Printer_State;
      Node  : W_Op_Divide_Prog_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, "/");
   end Op_Divide_Prog_Pre_Op;

   ------------------------
   -- Op_Mod_Prog_Pre_Op --
   ------------------------

   procedure Op_Mod_Prog_Pre_Op
     (State : in out Printer_State;
      Node  : W_Op_Mod_Prog_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, "%");
   end Op_Mod_Prog_Pre_Op;

   -----------------------
   -- Op_Eq_Prog_Pre_Op --
   -----------------------

   procedure Op_Eq_Prog_Pre_Op
     (State : in out Printer_State;
      Node  : W_Op_Eq_Prog_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, "=");
   end Op_Eq_Prog_Pre_Op;

   -----------------------
   -- Op_Ne_Prog_Pre_Op --
   -----------------------

   procedure Op_Ne_Prog_Pre_Op
     (State : in out Printer_State;
      Node  : W_Op_Ne_Prog_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, "<>");
   end Op_Ne_Prog_Pre_Op;

   -----------------------
   -- Op_Lt_Prog_Pre_Op --
   -----------------------

   procedure Op_Lt_Prog_Pre_Op
     (State : in out Printer_State;
      Node  : W_Op_Lt_Prog_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, "<");
   end Op_Lt_Prog_Pre_Op;

   -----------------------
   -- Op_Le_Prog_Pre_Op --
   -----------------------

   procedure Op_Le_Prog_Pre_Op
     (State : in out Printer_State;
      Node  : W_Op_Le_Prog_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, "<=");
   end Op_Le_Prog_Pre_Op;

   -----------------------
   -- Op_Gt_Prog_Pre_Op --
   -----------------------

   procedure Op_Gt_Prog_Pre_Op
     (State : in out Printer_State;
      Node  : W_Op_Gt_Prog_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, ">");
   end Op_Gt_Prog_Pre_Op;

   -----------------------
   -- Op_Ge_Prog_Pre_Op --
   -----------------------

   procedure Op_Ge_Prog_Pre_Op
     (State : in out Printer_State;
      Node  : W_Op_Ge_Prog_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, ">=");
   end Op_Ge_Prog_Pre_Op;

   ----------------------------
   -- Op_Or_Else_Prog_Pre_Op --
   ----------------------------

   procedure Op_Or_Else_Prog_Pre_Op
     (State : in out Printer_State;
      Node  : W_Op_Or_Else_Prog_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, "||");
   end Op_Or_Else_Prog_Pre_Op;

   -----------------------------
   -- Op_And_Then_Prog_Pre_Op --
   -----------------------------

   procedure Op_And_Then_Prog_Pre_Op
     (State : in out Printer_State;
      Node  : W_Op_And_Then_Prog_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, "&&");
   end Op_And_Then_Prog_Pre_Op;

   --------------------------
   -- Op_Minus_Prog_Pre_Op --
   --------------------------

   procedure Op_Minus_Prog_Pre_Op
     (State : in out Printer_State;
      Node  : W_Op_Minus_Prog_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, "-");
   end Op_Minus_Prog_Pre_Op;

   ------------------------
   -- Op_Not_Prog_Pre_Op --
   ------------------------

   procedure Op_Not_Prog_Pre_Op
     (State : in out Printer_State;
      Node  : W_Op_Not_Prog_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, "not");
   end Op_Not_Prog_Pre_Op;

   -------------------
   -- Binder_Pre_Op --
   -------------------

   procedure Binder_Pre_Op
     (State : in out Printer_State;
      Node  : W_Binder_Valid_Id)
   is
   begin
      P (O, "(");
      Print_List
        (State,
         Binder_Get_Names (Node),
         ", ");
      P (O, " : ");
      Traverse
        (State,
         Binder_Get_Arg_Type (Node));
      P (O, ")");
      State.Control := Abandon_Children;
   end Binder_Pre_Op;

   -------------------
   -- Recfun_Pre_Op --
   -------------------

   procedure Recfun_Pre_Op
     (State : in out Printer_State;
      Node  : W_Recfun_Valid_Id)
   is
   begin
      Traverse
        (State,
         Recfun_Get_Name (Node));
      P (O, " ");
      Print_List (State, Recfun_Get_Binders (Node), " ");
      P (O, " : ");
      Traverse
        (State,
         Recfun_Get_Return_Type (Node));
      NL (O);
      P (O, "{ variant ");
      Traverse
        (State,
         Recfun_Get_Variant (Node));
      PL (O, " } =");
      Relative_Indent (O, 1);
      Traverse
        (State,
         Recfun_Get_Def (Node));
      Relative_Indent (O, -1);
      State.Control := Abandon_Children;
   end Recfun_Pre_Op;

   -----------------------
   -- Loop_Annot_Pre_Op --
   -----------------------

   procedure Loop_Annot_Pre_Op
     (State : in out Printer_State;
      Node  : W_Loop_Annot_Valid_Id)
   is
      Invariant : constant W_Assertion_OId :=
                    Loop_Annot_Get_Invariant (+Node);
      Variant   : constant W_Wf_Arg_OId :=
                    Loop_Annot_Get_Variant (+Node);
   begin
      PL (O, "{ ");
      Relative_Indent (O, 1);

      if Invariant /= Why_Empty then
         P (O, "invariant ");
         Traverse (State, +Invariant);
         NL (O);
      end if;

      if Variant /= Why_Empty then
         P (O, "variant ");
         Traverse (State, +Variant);
         NL (O);
      end if;

      Relative_Indent (O, -1);
      P (O, " }");
      State.Control := Abandon_Children;
   end Loop_Annot_Pre_Op;

   -------------------
   -- Wf_Arg_Pre_Op --
   -------------------

   procedure Wf_Arg_Pre_Op
     (State : in out Printer_State;
      Node  : W_Wf_Arg_Valid_Id)
   is
      For_Id : constant W_Identifier_OId :=
                 Wf_Arg_Get_For_Id (+Node);
   begin
      Traverse
        (State,
         Wf_Arg_Get_Def (Node));

      if For_Id /= Why_Empty then
         P (O, " for ");
         Traverse (State, +For_Id);
      end if;

      State.Control := Abandon_Children;
   end Wf_Arg_Pre_Op;

   --------------------
   -- Handler_Pre_Op --
   --------------------

   procedure Handler_Pre_Op
     (State : in out Printer_State;
      Node  : W_Handler_Valid_Id)
   is
      Parameter : constant W_Prog_OId :=
                    Handler_Get_Parameter (+Node);
   begin
      Traverse
        (State,
         Handler_Get_Name (Node));

      if Parameter /= Why_Empty then
         P (O, " ");
         Traverse (State, +Parameter);
      end if;

      P (O, " -> ");
      Traverse
        (State,
         Handler_Get_Def (Node));
      State.Control := Abandon_Children;
   end Handler_Pre_Op;

   -----------------
   -- File_Pre_Op --
   -----------------

   procedure File_Pre_Op
     (State : in out Printer_State;
      Node  : W_File_Valid_Id)
   is
   begin
      Print_List
        (State,
         File_Get_Declarations (Node),
         "" & ASCII.LF);
      State.Control := Abandon_Children;
   end File_Pre_Op;

   ---------------------------
   -- Global_Binding_Pre_Op --
   ---------------------------

   procedure Global_Binding_Pre_Op
     (State : in out Printer_State;
      Node  : W_Global_Binding_Valid_Id)
   is
      Binders : constant W_Binder_OList :=
                  Global_Binding_Get_Binders (+Node);
   begin
      P (O, "let ");
      Traverse
        (State,
         Global_Binding_Get_Name (Node));

      if not Is_Empty (+Binders) then
         P (O, " ");
         Print_List (State, +Binders, " ");
      end if;

      PL (O, " =");
      Traverse (State, Global_Binding_Get_Pre (Node));
      Relative_Indent (O, 1);
      Traverse
        (State,
         Global_Binding_Get_Def (Node));
      Relative_Indent (O, -1);
      State.Control := Abandon_Children;
   end Global_Binding_Pre_Op;

   -------------------------------
   -- Global_Rec_Binding_Pre_Op --
   -------------------------------

   procedure Global_Rec_Binding_Pre_Op
     (State : in out Printer_State;
      Node  : W_Global_Rec_Binding_Valid_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, "let rec ");
   end Global_Rec_Binding_Pre_Op;

   ----------------------------------
   -- Parameter_Declaration_Pre_Op --
   ----------------------------------

   procedure Parameter_Declaration_Pre_Op
     (State : in out Printer_State;
      Node  : W_Parameter_Declaration_Valid_Id)
   is
      External   : constant W_External_OId :=
                     Parameter_Declaration_Get_External (+Node);
   begin
      if External /= Why_Empty then
         P (O, "external ");
      end if;

      P (O, "parameter ");
      Print_List
        (State,
         Parameter_Declaration_Get_Names (Node));
      P (O, " :");

      Relative_Indent (O, 1);
      NL (O);
      Traverse
        (State,
         Parameter_Declaration_Get_Parameter_Type (Node));
      Relative_Indent (O, -1);
      NL (O);
      State.Control := Abandon_Children;
   end Parameter_Declaration_Pre_Op;

   ----------------------------------
   -- Exception_Declaration_Pre_Op --
   ----------------------------------

   procedure Exception_Declaration_Pre_Op
     (State : in out Printer_State;
      Node  : W_Exception_Declaration_Valid_Id)
   is
      Param : constant W_Primitive_Type_OId :=
                Exception_Declaration_Get_Parameter (+Node);
   begin
      P (O, "exception ");
      Traverse
        (State,
         Exception_Declaration_Get_Name (Node));

      if Param /= Why_Empty then
         P (O, "of ");
         Traverse (State, +Param);
      end if;

      State.Control := Abandon_Children;
   end Exception_Declaration_Pre_Op;

   --------------------------------
   -- Include_Declaration_Pre_Op --
   --------------------------------

   procedure Include_Declaration_Pre_Op
     (State : in out Printer_State;
      Node  : W_Include_Declaration_Valid_Id)
   is
   begin
      P (O, "include """);
      Traverse
        (State,
         Include_Declaration_Get_Name (Node));
      P (O, ".why""");
      NL (O);
      State.Control := Abandon_Children;
   end Include_Declaration_Pre_Op;

end Why.Atree.Sprint;

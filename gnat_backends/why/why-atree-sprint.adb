------------------------------------------------------------------------------
--                                                                          --
--                            GNAT2WHY COMPONENTS                           --
--                                                                          --
--                     W H Y - A T R E E - S P R I N T                      --
--                                                                          --
--                                 B o d y                                  --
--                                                                          --
--                       Copyright (C) 2010-2011, AdaCore                   --
--                                                                          --
-- gnat2why is  free  software;  you can redistribute  it and/or  modify it --
-- under terms of the  GNU General Public License as published  by the Free --
-- Software  Foundation;  either version 3,  or (at your option)  any later --
-- version.  gnat2why is distributed  in the hope that  it will be  useful, --
-- but WITHOUT ANY WARRANTY; without even the implied warranty of  MERCHAN- --
-- TABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public --
-- License for  more details.  You should have  received  a copy of the GNU --
-- General  Public License  distributed with  gnat2why;  see file COPYING3. --
-- If not,  go to  http://www.gnu.org/licenses  for a complete  copy of the --
-- license.                                                                 --
--                                                                          --
-- gnat2why is maintained by AdaCore (http://www.adacore.com)               --
--                                                                          --
------------------------------------------------------------------------------

with Ada.Containers; use Ada.Containers;

with Namet;  use Namet;
with Uintp;  use Uintp;

with Why.Inter;           use Why.Inter;
with Why.Images;          use Why.Images;
with Why.Conversions;     use Why.Conversions;
with Why.Atree.Accessors; use Why.Atree.Accessors;

package body Why.Atree.Sprint is

   O : Output_Id := Stdout;

   procedure Print_List
     (State     : in out Printer_State'Class;
      List_Id   : Why_Node_List;
      Separator : String := ", ");
   --  Print a node list on current output, separating each element
   --  by a given separator.

   ----------------
   -- Print_List --
   ----------------

   procedure Print_List
     (State     : in out Printer_State'Class;
      List_Id   : Why_Node_List;
      Separator : String := ", ")
   is
      use Node_Lists;

      Nodes    : constant List := Get_List (List_Id);
      Position : Cursor := First (Nodes);
   begin
      while Position /= No_Element loop
         declare
            Node : constant Why_Node_Id := Element (Position);
         begin
            Traverse (State, Node);
         end;

         Position := Next (Position);

         if Position /= No_Element then
            P (O, Separator);
         end if;
      end loop;
   end Print_List;

   ---------------------
   -- Sprint_Why_Node --
   ---------------------

   procedure Sprint_Why_Node (Node : Why_Node_Id; To : Output_Id := Stdout) is
      PS : Printer_State := (Control => Continue);
   begin
      O := To;
      Traverse (PS, +Node);
   end Sprint_Why_Node;

   ---------
   -- wpg --
   ---------

   procedure wpg (Node : Why_Node_Id) is
   begin
      Sprint_Why_Node (Node, Stdout);
   end wpg;

   ----------------------------------------
   -- Pre-operations and post-operations --
   ----------------------------------------

   --  Note: the following subprograms have been written from the stub
   --  generated by the xtree; the order of generation has been kept. That
   --  explains why these are not in alphabetical order.

   ----------------------
   -- Base_Type_Pre_Op --
   ----------------------

   procedure Base_Type_Pre_Op
     (State : in out Printer_State;
      Node  : W_Base_Type_Id)
   is
      pragma Unreferenced (State);
      Base_Type : constant EW_Type := Get_Base_Type (Node);
   begin
      if Base_Type = EW_Abstract then
         P (O, Full_Name (Get_Ada_Node (+Node)));
      else
         P (O, Base_Type);
      end if;
   end Base_Type_Pre_Op;

   --------------------------------
   -- Generic_Formal_Type_Pre_Op --
   --------------------------------

   procedure Generic_Formal_Type_Pre_Op
     (State : in out Printer_State;
      Node  : W_Generic_Formal_Type_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, "'");
   end Generic_Formal_Type_Pre_Op;

   --------------------------------------
   -- Generic_Actual_Type_Chain_Pre_Op --
   --------------------------------------

   procedure Generic_Actual_Type_Chain_Pre_Op
     (State : in out Printer_State;
      Node  : W_Generic_Actual_Type_Chain_Id)
   is
      use Node_Lists;
      Args     : constant List := Get_List (+Get_Type_Chain (Node));
      Nb_Args  : constant Count_Type := Length (Args);
   begin
      if Nb_Args >= 1 then
         P (O, "(");
      end if;

      Traverse (State, +Get_Name (Node));

      if Nb_Args > 1 then
         P (O, " (");
      elsif Nb_Args = 1 then
         P (O, " ");
      end if;

      Print_List (State, +Get_Type_Chain (Node), " ");

      if Nb_Args > 1 then
         P (O, ")");
      end if;

      if Nb_Args >= 1 then
         P (O, ")");
      end if;

      State.Control := Abandon_Children;

   end Generic_Actual_Type_Chain_Pre_Op;

   ------------------------
   -- Array_Type_Pre_Op --
   ------------------------

   procedure Array_Type_Pre_Op
     (State : in out Printer_State;
      Node  : W_Array_Type_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, "array ");
   end Array_Type_Pre_Op;

   ---------------------
   -- Ref_Type_Pre_Op --
   ---------------------

   procedure Ref_Type_Pre_Op
     (State : in out Printer_State;
      Node  : W_Ref_Type_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, "ref ");
   end Ref_Type_Pre_Op;

   -----------------------------
   -- Computation_Type_Pre_Op --
   -----------------------------

   procedure Computation_Type_Pre_Op
     (State : in out Printer_State;
      Node  : W_Computation_Type_Id)
   is
      Binders     : constant W_Binder_OList := Get_Binders (Node);
      Result      : constant W_Binder_Id := Get_Result (Node);
      Result_Type : constant W_Simple_Value_Type_Id := Get_Arg_Type (Result);
      Pre         : constant W_Pred_Id := Get_Pre (Node);
      Domain      : constant EW_Domain := Get_Domain (+Node);
   begin
      case Domain is
         when EW_Prog =>
            if not (Is_Empty (+Binders)) then
               Print_List (State, +Binders, " ->" & ASCII.LF);
               PL (O, " ->");
            end if;

            P (O, "{ ");
            Traverse (State, +Pre);
            P (O, " }");
            NL (O);
            Relative_Indent (O, 1);
            Traverse (State, +Result_Type);
            NL (O);
            Traverse (State, +Get_Effects (Node));
            Relative_Indent (O, -1);
            P (O, "{ ");
            Traverse (State, +Get_Post (Node));
            P (O, " }");

         when EW_Term =>
            declare
               use Node_Lists;
               Nodes    : constant List := Get_List (+Binders);
               Position : Cursor := First (Nodes);
            begin
               while Position /= No_Element loop
                  declare
                     Binder   : constant W_Binder_Id := +Element (Position);
                  begin
                     Traverse (State, +Get_Arg_Type (Binder));
                  end;
                  Next (Position);

                  if Position /= No_Element then
                     PL (O, ",");
                  else
                     P (O, " -> ");
                  end if;
               end loop;

               Traverse (State, +Result_Type);
            end;

         when EW_Pred =>
            pragma Assert (False);
            null;
      end case;

      State.Control := Abandon_Children;
   end Computation_Type_Pre_Op;

   --------------------
   -- Effects_Pre_Op --
   --------------------

   procedure Effects_Pre_Op
     (State : in out Printer_State;
      Node  : W_Effects_Id)
   is
      Reads  : constant W_Identifier_List := Get_Reads (Node);
      Writes : constant W_Identifier_List := Get_Writes (Node);
      Raises : constant W_Identifier_List := Get_Raises (Node);
   begin
      if not Is_Empty (+Reads) then
         P (O, "reads ");
         Print_List (State, +Reads, " ");
         NL (O);
      end if;

      if not Is_Empty (+Writes) then
         P (O, "writes ");
         Print_List (State, +Writes, " ");
         NL (O);
      end if;

      if not Is_Empty (+Raises) then
         P (O, "raises ");
         Print_List (State, +Raises, " ");
         NL (O);
      end if;

      State.Control := Abandon_Children;
   end Effects_Pre_Op;

   -------------------
   -- Binder_Pre_Op --
   -------------------

   procedure Binder_Pre_Op
     (State : in out Printer_State;
      Node  : W_Binder_Id)
   is
   begin
      Traverse (State, +Get_Name (Node));
      P (O, " : ");
      Traverse (State, +Get_Arg_Type (Node));

      State.Control := Abandon_Children;
   end Binder_Pre_Op;

   ------------------------
   -- Constr_Decl_Pre_Op --
   ------------------------

   procedure Constr_Decl_Pre_Op
      (State : in out Printer_State;
       Node : W_Constr_Decl_Id)
   is
      Args : constant W_Primitive_Type_List := Get_Arg_List (Node);
      Name : constant W_Identifier_Id := Get_Name (Node);
   begin
      P (O, "| ");
      Traverse (State, +Name);

      if not Is_Empty (+Args) then
         P (O, "( ");
         Print_List (State, +Args, ", ");
         Traverse_List (State, +Args);
         P (O, ") ");
      end if;

      NL (O);
      State.Control := Abandon_Children;
   end Constr_Decl_Pre_Op;

   ------------------------------
   -- Record_Definition_Pre_Op --
   ------------------------------

   procedure Record_Definition_Pre_Op
      (State : in out Printer_State;
       Node : W_Record_Definition_Id)
   is
   begin
      P (O, "{| ");
      Print_List (State, +Get_Fields (Node), "; ");
      P (O, " |}");
      State.Control := Abandon_Children;
   end Record_Definition_Pre_Op;

   ---------------------
   -- Triggers_Pre_Op --
   ---------------------

   procedure Triggers_Pre_Op
     (State : in out Printer_State;
      Node  : W_Triggers_Id)
   is
      Triggers : constant W_Trigger_List := Get_Triggers (Node);
   begin
      P (O, "[");
      Print_List (State, +Triggers, " | ");
      P (O, "]");
      State.Control := Abandon_Children;
   end Triggers_Pre_Op;

   --------------------
   -- Trigger_Pre_Op --
   --------------------

   procedure Trigger_Pre_Op
     (State : in out Printer_State;
      Node  : W_Trigger_Id)
   is
      Terms    : constant W_Term_List := Get_Terms (Node);
   begin
      Print_List (State, +Terms);
      State.Control := Abandon_Children;
   end Trigger_Pre_Op;

   --------------------
   -- Pattern_Pre_Op --
   --------------------

   procedure Pattern_Pre_Op
     (State : in out Printer_State;
      Node  : W_Pattern_Id)
   is
      Args : constant W_Identifier_OList := Get_Args (Node);
   begin
      Traverse (State, +Get_Constr (Node));

      if not (Is_Empty (+Args)) then
         P (O, "(");
         Print_List (State, +Args);
         P (O, ")");
      end if;

      State.Control := Abandon_Children;
   end Pattern_Pre_Op;

   -----------------------
   -- Match_Case_Pre_Op --
   -----------------------

   procedure Match_Case_Pre_Op
     (State : in out Printer_State;
      Node  : W_Match_Case_Id)
   is
   begin
      P (O, "| ");
      Traverse (State, +Get_Pattern (Node));
      P (O, " -> ");
      NL (O);
      Relative_Indent (O, 1);
      Traverse (State, +Get_Term (Node));
      Relative_Indent (O, -1);
      NL (O);
      State.Control := Abandon_Children;
   end Match_Case_Pre_Op;

   --------------------------
   -- Postcondition_Pre_Op --
   --------------------------

   procedure Postcondition_Pre_Op
     (State : in out Printer_State;
      Node  : W_Postcondition_Id)
   is
      Handlers : constant W_Exn_Condition_OList := Get_Handlers (Node);
   begin
      Traverse (State, +Get_Pred (Node));

      if not Is_Empty (+Handlers) then
         NL (O);
         Relative_Indent (O, 1);
         Print_List (State, +Handlers, "" & ASCII.LF);
         Relative_Indent (O, -1);
      end if;

      State.Control := Abandon_Children;
   end Postcondition_Pre_Op;

   --------------------------
   -- Exn_Condition_Pre_Op --
   --------------------------

   procedure Exn_Condition_Pre_Op
     (State : in out Printer_State;
      Node  : W_Exn_Condition_Id)
   is
   begin
      P (O, "| ");
      Traverse (State, +Get_Exn_Case (Node));
      P (O, " => ");
      Traverse (State, +Get_Pred (Node));
      State.Control := Abandon_Children;
   end Exn_Condition_Pre_Op;

   -----------------------
   -- Loop_Annot_Pre_Op --
   -----------------------

   procedure Loop_Annot_Pre_Op
     (State : in out Printer_State;
      Node  : W_Loop_Annot_Id)
   is
      Invariant : constant W_Pred_OId := Get_Invariant (Node);
      Variant   : constant W_Wf_Arg_OId := Get_Variant (Node);
   begin
      if Invariant /= Why_Empty then
         P (O, "invariant ");
         PL (O, "{ ");
         Relative_Indent (O, -1);
         Traverse (State, +Invariant);
         NL (O);
         Relative_Indent (O, -1);
         P (O, " }");
      end if;

      if Variant /= Why_Empty then
         P (O, "variant ");
         Traverse (State, +Variant);
         NL (O);
      end if;

      State.Control := Abandon_Children;
   end Loop_Annot_Pre_Op;

   -------------------
   -- Wf_Arg_Pre_Op --
   -------------------

   procedure Wf_Arg_Pre_Op
     (State : in out Printer_State;
      Node  : W_Wf_Arg_Id)
   is
      For_Id : constant W_Identifier_OId := Get_For_Id (Node);
   begin
      Traverse (State, +Get_Def (Node));

      if For_Id /= Why_Empty then
         P (O, " for ");
         Traverse (State, +For_Id);
      end if;

      State.Control := Abandon_Children;
   end Wf_Arg_Pre_Op;

   --------------------
   -- Handler_Pre_Op --
   --------------------

   procedure Handler_Pre_Op
     (State : in out Printer_State;
      Node  : W_Handler_Id)
   is
      Arg : constant W_Prog_OId := Get_Arg (Node);
   begin
      Traverse (State, +Get_Name (Node));

      if Arg /= Why_Empty then
         P (O, " ");
         Traverse (State, +Arg);
      end if;

      P (O, " -> ");
      Traverse (State, +Get_Def (Node));
      State.Control := Abandon_Children;
   end Handler_Pre_Op;

   ------------------------------
   -- Universal_Quantif_Pre_Op --
   ------------------------------

   procedure Universal_Quantif_Pre_Op
     (State : in out Printer_State;
      Node  : W_Universal_Quantif_Id)
   is
      Variables       : constant W_Identifier_List := Get_Variables (Node);
      Var_Type        : constant W_Primitive_Type_Id := Get_Var_Type (Node);
      Triggers        : constant W_Triggers_OId := Get_Triggers (Node);
      Pred            : constant W_Pred_Id := Get_Pred (Node);
      Forall_Sequence : constant Boolean :=
                          Get_Kind (+Pred) = W_Universal_Quantif;
   begin
      P (O, "(forall ");
      Print_List (State, +Variables, " ");
      P (O, " : ");
      Traverse (State, +Var_Type);

      if Triggers /= Why_Empty then
         P (O, " ");
         Traverse (State, +Triggers);
      end if;

      PL (O, ".");

      if not Forall_Sequence then
         Relative_Indent (O, 1);
      end if;

      Traverse (State, +Pred);

      if not Forall_Sequence then
         Relative_Indent (O, -1);
      end if;
      P (O, ")");
      State.Control := Abandon_Children;
   end Universal_Quantif_Pre_Op;

   --------------------------------
   -- Existential_Quantif_Pre_Op --
   --------------------------------

   procedure Existential_Quantif_Pre_Op
     (State : in out Printer_State;
      Node  : W_Existential_Quantif_Id)
   is
      Variables       : constant W_Identifier_List := Get_Variables (Node);
      Var_Type        : constant W_Primitive_Type_Id := Get_Var_Type (Node);
      Pred            : constant W_Pred_Id := Get_Pred (Node);
      Exists_Sequence : constant Boolean :=
                          Get_Kind (+Pred) = W_Existential_Quantif;
   begin
      P (O, "exists ");
      Print_List (State, +Variables, " ");

      P (O, " : ");
      Traverse (State, +Var_Type);
      PL (O, ".");

      if not Exists_Sequence then
         Relative_Indent (O, 1);
      end if;

      Traverse (State, +Pred);

      if not Exists_Sequence then
         Relative_Indent (O, -1);
      end if;

      State.Control := Abandon_Children;
   end Existential_Quantif_Pre_Op;

   ----------------
   -- Not_Pre_Op --
   ----------------

   procedure Not_Pre_Op
     (State : in out Printer_State;
      Node  : W_Not_Id)
   is
      Pred : constant W_Expr_Id := +Not_Get_Right (+Node);
   begin
      P (O, "not ( ");
      Traverse (State, +Pred);
      P (O, " )");
      State.Control := Abandon_Children;
   end Not_Pre_Op;

   ---------------------
   -- Relation_Pre_Op --
   ---------------------

   procedure Relation_Pre_Op
     (State : in out Printer_State;
      Node  : W_Relation_Id)
   is
      Left   : constant W_Prog_Id := Get_Left (Node);
      Op     : constant EW_Relation := Get_Op (Node);
      Right  : constant W_Prog_Id := Get_Right (Node);
      Op2    : constant EW_Relation := Get_Op2 (Node);
      Right2 : constant W_Prog_OId := Get_Right2 (Node);
   begin
      Traverse (State, +Left);
      P (O, " ");
      P (O, Op, Get_Op_Type (Node));
      P (O, " ");
      Traverse (State, +Right);

      if Op2 /= EW_None then
         P (O, " ");
         P (O, Op2, Get_Op_Type (Node));
         P (O, " ");
         Traverse (State, +Right2);
      end if;

      State.Control := Abandon_Children;
   end Relation_Pre_Op;

   ------------------------
   -- Connection_Pre_Op --
   ------------------------

   procedure Connection_Pre_Op
     (State : in out Printer_State;
      Node  : W_Connection_Id)
   is
   begin
      P (O, "( ");
      Traverse (State, +Get_Left (Node));
      P (O, " ");
      P (O, Get_Op (Node));
      P (O, " ");
      Traverse (State, +Get_Right (Node));
      P (O, " )");
      State.Control := Abandon_Children;
   end Connection_Pre_Op;

   -----------------------
   -- Identifier_Pre_Op --
   -----------------------

   procedure Identifier_Pre_Op
     (State : in out Printer_State;
      Node  : W_Identifier_Id) is
   begin
      P (O, Get_Symbol (Node));
      State.Control := Abandon_Children;
   end Identifier_Pre_Op;

   -----------------------
   -- Tagged_Pre_Op --
   -----------------------

   procedure Tagged_Pre_Op
     (State : in out Printer_State;
      Node  : W_Tagged_Id)
   is
      Tag    : constant Name_Id := Get_Tag (Node);
   begin
      if Tag = No_Name then
         Traverse (State, +Get_Def (Node));

      elsif Get_Name_String (Tag) /= "" then
         P (O, "(at ");
         Traverse (State, +Get_Def (Node));
         P (O, " ");
         P (O, Tag);
         P (O, " )");
      else
         P (O, "(old ");
         Traverse (State, +Get_Def (Node));
         P (O, " )");
      end if;
      State.Control := Abandon_Children;
   end Tagged_Pre_Op;

   -----------------
   -- Call_Pre_Op --
   -----------------

   procedure Call_Pre_Op
     (State : in out Printer_State;
      Node  : W_Call_Id)
   is
      Name : constant W_Identifier_Id := Get_Name (Node);
      Args : constant W_Expr_OList := Get_Args (Node);
   begin
      case Get_Domain (+Node) is
         when EW_Term | EW_Pred =>
            P (O, "(");
            Traverse (State, +Name);
            P (O, " ");
            Print_List (State, +Args, " ");
            P (O, ")");

         when EW_Prog =>
            Traverse (State, +Name);

            if not Is_Empty (+Args) then
               P (O, "(");
               Print_List (State, +Args, ") (");
               P (O, ")");
            end if;
      end case;

      State.Control := Abandon_Children;
   end Call_Pre_Op;

   --------------------
   -- Literal_Pre_Op --
   --------------------

   procedure Literal_Pre_Op
     (State : in out Printer_State;
      Node  : W_Literal_Id)
   is
      pragma Unreferenced (State);
   begin
      P (O, Get_Value (Node), Get_Domain (+Node));
   end Literal_Pre_Op;

   ------------------------
   -- Conditional_Pre_Op --
   ------------------------

   procedure Conditional_Pre_Op
     (State : in out Printer_State;
      Node  : W_Conditional_Id)
   is
      Condition : constant W_Prog_Id := Get_Condition (Node);
      Then_Part : constant W_Expr_Id := Get_Then_Part (Node);
      Else_Part : constant W_Expr_OId := Get_Else_Part (Node);
      Has_Else  : constant Boolean := Else_Part /= Why_Empty;
      Has_Elsif : constant Boolean :=
                    (Has_Else
                     and then Get_Kind (+Else_Part) = W_Conditional);
   begin
      P (O, "(if (");
      Traverse (State, +Condition);

      PL (O, ") then (");
      Relative_Indent (O, 1);
      Traverse (State, +Then_Part);
      Relative_Indent (O, -1);

      if Has_Else then
         P (O, ") else (");

         if not Has_Elsif then
            NL (O);
            Relative_Indent (O, 1);
         end if;

         Traverse (State, +Else_Part);

         if not Has_Elsif then
            Relative_Indent (O, -1);
         end if;
         P (O, ")");
      else
         pragma Assert (Get_Domain (+Node) = EW_Prog);
         P (O, ")");
      end if;
      P (O, ")");

      State.Control := Abandon_Children;
   end Conditional_Pre_Op;

   -----------------------------
   -- Integer_Constant_Pre_Op --
   -----------------------------

   procedure Integer_Constant_Pre_Op
     (State : in out Printer_State;
      Node  : W_Integer_Constant_Id)
   is
      pragma Unreferenced (State);
      Value : constant Uint := Get_Value (Node);
   begin
      if Value < Uint_0 then
         P (O, "( ");
         P (O, Value);
         P (O, " )");
      else
         P (O, Value);
      end if;
   end Integer_Constant_Pre_Op;

   --------------------------
   -- Real_Constant_Pre_Op --
   --------------------------

   procedure Real_Constant_Pre_Op
     (State : in out Printer_State;
      Node  : W_Real_Constant_Id)
   is
      pragma Unreferenced (State);
   begin
      P (O, "(");
      P (O, Get_Value (Node));
      P (O, ")");
   end Real_Constant_Pre_Op;

   -----------------
   -- Void_Pre_Op --
   -----------------

   procedure Void_Pre_Op
     (State : in out Printer_State;
      Node  : W_Void_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, "()");
   end Void_Pre_Op;

   ----------------------
   -- Binary_Op_Pre_Op --
   ----------------------

   procedure Binary_Op_Pre_Op
     (State : in out Printer_State;
      Node  : W_Binary_Op_Id)
   is
   begin
      P (O, "( ");
      Traverse (State, +Get_Left (Node));
      P (O, " ");
      P (O, Get_Op (Node), Get_Op_Type (Node));
      P (O, " ");
      Traverse (State, +Get_Right (Node));
      P (O, " )");
      State.Control := Abandon_Children;
   end Binary_Op_Pre_Op;

   ---------------------
   -- Unary_Op_Pre_Op --
   ---------------------

   procedure Unary_Op_Pre_Op
     (State : in out Printer_State;
      Node  : W_Unary_Op_Id)
   is
      Op     : constant EW_Unary_Op := Get_Op (Node);
   begin
      P (O, "( ");
      P (O, Op, Get_Op_Type (Node));
      P (O, " ");
      Traverse (State, +Get_Right (Node));
      P (O, " )");
      State.Control := Abandon_Children;
   end Unary_Op_Pre_Op;

   ------------------
   -- Match_Pre_Op --
   ------------------

   procedure Match_Pre_Op
     (State : in out Printer_State;
      Node  : W_Match_Id)
   is
   begin
      P (O, "match ");
      Traverse (State, +Get_Term (Node));
      P (O, " with ");
      NL (O);
      Relative_Indent (O, 1);
      Traverse_List (State, +Get_Branches (Node));
      Relative_Indent (O, -1);
      P (O, "end");
      NL (O);
      State.Control := Abandon_Children;
   end Match_Pre_Op;

   --------------------
   -- Binding_Pre_Op --
   --------------------

   procedure Binding_Pre_Op
     (State : in out Printer_State;
      Node  : W_Binding_Id)
   is
      Name             : constant W_Identifier_Id := Get_Name (Node);
      Def              : constant W_Prog_Id := Get_Def (Node);
      Context          : constant W_Expr_Id := Get_Context (Node);
      Binding_Sequence : constant Boolean := Get_Kind (+Context) = W_Binding;
   begin
      P (O, "let ");
      Traverse (State, +Name);
      P (O, " = ");
      Traverse (State, +Def);
      PL (O, " in (");

      if not Binding_Sequence then
         Relative_Indent (O, 1);
      end if;

      Traverse (State, +Context);

      if not Binding_Sequence then
         Relative_Indent (O, -1);
      end if;

      PL (O, ")");

      State.Control := Abandon_Children;
   end Binding_Pre_Op;

   -------------------------
   -- Array_Access_Pre_Op --
   -------------------------

   procedure Array_Access_Pre_Op
     (State : in out Printer_State;
      Node  : W_Array_Access_Id)
   is
   begin
      Traverse (State, +Get_Name (Node));
      P (O, " [");
      Traverse (State, +Get_Index (Node));
      P (O, "]");
      State.Control := Abandon_Children;
   end Array_Access_Pre_Op;

   --------------------
   -- Epsilon_Pre_Op --
   --------------------

   procedure Epsilon_Pre_Op
     (State : in out Printer_State;
      Node  : W_Epsilon_Id)
   is
   begin
      P (O, "(epsilon ");
      Traverse (State, +Get_Binder (Node));
      P (O, " . ");
      Traverse (State, +Get_Pred (Node));
      P (O, ") ");
      State.Control := Abandon_Children;
   end Epsilon_Pre_Op;

   --------------------------
   -- Record_Access_Pre_Op --
   --------------------------

   procedure Record_Access_Pre_Op
     (State : in out Printer_State;
      Node  : W_Record_Access_Id)
   is
   begin
      Traverse (State, +Get_Name (Node));
      P (O, ".");
      Traverse (State, +Get_Field (Node));
      State.Control := Abandon_Children;
   end Record_Access_Pre_Op;

   --------------------------
   -- Record_Update_Pre_Op --
   --------------------------

   procedure Record_Update_Pre_Op
     (State : in out Printer_State;
      Node  : W_Record_Update_Id)
   is
   begin
      P (O, "{| ");
      Traverse (State, +Get_Name (Node));
      P (O, " with ");
      Traverse (State, +Get_Field (Node));
      P (O, " = ");
      Traverse (State, +Get_Value (Node));
      P (O, " |}");
      State.Control := Abandon_Children;
   end Record_Update_Pre_Op;

   -----------------------------
   -- Record_Aggregate_Pre_Op --
   -----------------------------

   procedure Record_Aggregate_Pre_Op
     (State : in out Printer_State;
      Node  : W_Record_Aggregate_Id)
   is
   begin
      P (O, "{| ");
      Print_List (State, +Get_Associations (Node), "; ");
      P (O, " |}");
      State.Control := Abandon_Children;
   end Record_Aggregate_Pre_Op;

   -----------------------------
   -- Field_Association_Pre_Op --
   -----------------------------

   procedure Field_Association_Pre_Op
     (State : in out Printer_State;
      Node  : W_Field_Association_Id)
   is
   begin
      Traverse (State, +Get_Field (Node));
      P (O, " = ");
      Traverse (State, +Get_Value (Node));
      State.Control := Abandon_Children;
   end Field_Association_Pre_Op;
   ---------------------
   -- Any_Expr_Pre_Op --
   ---------------------

   procedure Any_Expr_Pre_Op
     (State : in out Printer_State;
      Node  : W_Any_Expr_Id)
   is
      Ty : constant W_Computation_Type_Id := Get_Any_Type (Node);
   begin
      P (O, "(any ");
      Traverse (State, +Ty);
      P (O, ")");
      State.Control := Abandon_Children;
   end Any_Expr_Pre_Op;

   -----------------------
   -- Assignment_Pre_Op --
   -----------------------

   procedure Assignment_Pre_Op
     (State : in out Printer_State;
      Node  : W_Assignment_Id)
   is
   begin
      Traverse (State, +Get_Name (Node));
      P (O, " := ( ");
      Traverse (State, +Get_Value (Node));
      P (O, " )");
      State.Control := Abandon_Children;
   end Assignment_Pre_Op;

   -------------------------
   -- Array_Update_Pre_Op --
   -------------------------

   procedure Array_Update_Pre_Op
     (State : in out Printer_State;
      Node  : W_Array_Update_Id)
   is
   begin
      Traverse (State, +Get_Name (Node));
      P (O, " [");
      Traverse (State, +Get_Index (Node));
      P (O, "] := ");
      Traverse (State, +Get_Value (Node));
      State.Control := Abandon_Children;
   end Array_Update_Pre_Op;

   ------------------------
   -- Binding_Ref_Pre_Op --
   ------------------------

   procedure Binding_Ref_Pre_Op
     (State : in out Printer_State;
      Node  : W_Binding_Ref_Id)
   is
      Context          : constant W_Prog_Id := Get_Context (Node);
      Binding_Sequence : constant Boolean :=
                           Get_Kind (+Context) = W_Binding_Ref;
   begin
      P (O, "let ");
      Traverse (State, +Get_Name (Node));
      P (O, " = ref ");
      Traverse (State, +Get_Def (Node));
      PL (O, " in ");

      if not Binding_Sequence then
         Relative_Indent (O, 1);
      end if;

      Traverse (State, +Context);

      if not Binding_Sequence then
         Relative_Indent (O, -1);
      end if;

      State.Control := Abandon_Children;
   end Binding_Ref_Pre_Op;

   -----------------------
   -- While_Loop_Pre_Op --
   -----------------------

   procedure While_Loop_Pre_Op
     (State : in out Printer_State;
      Node  : W_While_Loop_Id)
   is
      Condition    : constant W_Prog_Id := Get_Condition (Node);
      Annotation   : constant W_Loop_Annot_OId := Get_Annotation (Node);
      Loop_Content : constant W_Prog_Id := Get_Loop_Content (Node);
   begin
      P (O, "while ");
      Traverse (State, +Condition);
      PL (O, " do");
      Relative_Indent (O, 1);

      if Annotation /= Why_Empty then
         Traverse (State, +Annotation);
         NL (O);
      end if;

      Traverse (State, +Loop_Content);
      Relative_Indent (O, 1);
      NL (O);
      P (O, "done");
      State.Control := Abandon_Children;
   end While_Loop_Pre_Op;

   -------------------------------
   -- Statement_Sequence_Pre_Op --
   -------------------------------

   procedure Statement_Sequence_Pre_Op
     (State : in out Printer_State;
      Node  : W_Statement_Sequence_Id)
   is
   begin
      Print_List (State, +Get_Statements (Node), ";" & ASCII.LF);
      State.Control := Abandon_Children;
   end Statement_Sequence_Pre_Op;

   ------------------
   -- Label_Pre_Op --
   ------------------

   procedure Label_Pre_Op
     (State : in out Printer_State;
      Node  : W_Label_Id)
   is
   begin
      P (O, "( ");
      Traverse (State, +Get_Name (Node));
      P (O, " ");

      Traverse (State, +Get_Def (Node));
      P (O, " )");
      State.Control := Abandon_Children;
   end Label_Pre_Op;

   -------------------
   -- Assert_Pre_Op --
   -------------------

   procedure Assert_Pre_Op
     (State : in out Printer_State;
      Node  : W_Assert_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, "assert { ");
   end Assert_Pre_Op;

   --------------------
   -- Assert_Post_Op --
   --------------------

   procedure Assert_Post_Op
     (State : in out Printer_State;
      Node  : W_Assert_Id)
   is
      pragma Unreferenced (State);
      pragma Unreferenced (Node);
   begin
      P (O, " }");
   end Assert_Post_Op;

   ------------------
   -- Raise_Pre_Op --
   ------------------

   procedure Raise_Pre_Op
     (State : in out Printer_State;
      Node  : W_Raise_Id)
   is
      Exn_Type : constant W_Simple_Value_Type_OId := Get_Exn_Type (Node);
   begin
      P (O, "raise Gnatprove_Exception__");

      Traverse (State, +Get_Name (Node));

      if Exn_Type /= Why_Empty then
         P (O, " : ");
         Traverse (State, +Exn_Type);
      end if;

      State.Control := Abandon_Children;
   end Raise_Pre_Op;

   ----------------------
   -- Try_Block_Pre_Op --
   ----------------------

   procedure Try_Block_Pre_Op
     (State : in out Printer_State;
      Node  : W_Try_Block_Id)
   is
   begin
      PL (O, "try");
      Relative_Indent (O, 1);
      Traverse (State, +Get_Prog (Node));
      Relative_Indent (O, -1);
      NL (O);
      PL (O, "with ");
      Relative_Indent (O, 1);
      P (O, "Gnatprove_Exception__");
      Print_List
        (State,
         +Get_Handler (Node),
         ", Gnatprove_Exception__" & ASCII.LF);

      Relative_Indent (O, -1);
      NL (O);
      P (O, "end");
      State.Control := Abandon_Children;
   end Try_Block_Pre_Op;

   -----------------------------
   -- Unreachable_Code_Pre_Op --
   -----------------------------

   procedure Unreachable_Code_Pre_Op
     (State : in out Printer_State;
      Node  : W_Unreachable_Code_Id)
   is
      Exn_Type : constant W_Simple_Value_Type_OId :=
                   Get_Exn_Type (Node);
   begin
      P (O, "absurd");

      if Exn_Type /= Why_Empty then
         P (O, " : ");
         Traverse (State, +Exn_Type);
      end if;

      State.Control := Abandon_Children;
   end Unreachable_Code_Pre_Op;

   --------------------------
   -- Function_Decl_Pre_Op --
   --------------------------

   procedure Function_Decl_Pre_Op
     (State : in out Printer_State;
      Node  : W_Function_Decl_Id)
   is
      Name      : constant W_Identifier_Id := Get_Name (Node);
      Func_Type : constant W_Computation_Type_Id := Get_Func_Type (Node);
   begin
      if Get_External (Node) then
         P (O, "external ");
      end if;

      case Get_Domain (+Node) is
         when EW_Term =>
            P (O, "function ");

            Traverse (State, +Name);

            NL (O);
            Relative_Indent (O, 1);

            declare
               Binders     : constant W_Binder_OList :=
                               Get_Binders (Func_Type);
               Result      : constant W_Binder_Id := Get_Result (Func_Type);
               Result_Type : constant W_Simple_Value_Type_Id :=
                               Get_Arg_Type (Result);
            begin
               if not Is_Empty (+Binders) then
                  P (O, " (");
                  Print_List (State, +Binders, ") (");
                  P (O, ") ");
               end if;
               P (O, " :");
               Traverse (State, +Result_Type);
            end;

            Relative_Indent (O, -1);
            NL (O);

         when EW_Prog =>
            P (O, "val ");

            Traverse (State, +Name);
            P (O, " :");

            Relative_Indent (O, 1);
            NL (O);
            Traverse (State, +Func_Type);
            Relative_Indent (O, -1);
            NL (O);

         when EW_Pred =>
            pragma Assert (False);
            null;
      end case;

      State.Control := Abandon_Children;
   end Function_Decl_Pre_Op;

   -------------------------
   -- Function_Def_Pre_Op --
   -------------------------

   procedure Function_Def_Pre_Op
     (State : in out Printer_State;
      Node  : W_Function_Def_Id)
   is
      Spec        : constant W_Function_Decl_Id := Get_Spec (Node);
      Func_Type   : constant W_Computation_Type_Id := Get_Func_Type (Spec);
      Def         : constant W_Expr_Id := Get_Def (Node);
      Name        : constant W_Identifier_Id := Get_Name (Spec);
      Binders     : constant W_Binder_OList := Get_Binders (Func_Type);
      Result      : constant W_Binder_Id := Get_Result (Func_Type);
      Result_Type : constant W_Simple_Value_Type_OId := Get_Arg_Type (Result);
      Pre         : constant W_Pred_OId := Get_Pre (Func_Type);
      Post        : constant W_Pred_OId := Get_Post (Func_Type);
   begin
      case Get_Domain (+Node) is
         when EW_Pred =>
            P (O, "predicate ");
            Traverse (State, +Name);

            P (O, " (");
            Print_List (State, +Binders, ") (");
            PL (O, ") =");

            Relative_Indent (O, 1);
            Traverse (State, +Def);
            Relative_Indent (O, -1);
            NL (O);

         when EW_Term =>
            P (O, "function ");
            Traverse (State, +Name);

            P (O, " (");
            Print_List (State, +Binders, ") (");
            P (O, ") : ");

            Traverse (State, +Result_Type);
            PL (O, " =");
            Relative_Indent (O, 1);
            Traverse (State, +Def);
            Relative_Indent (O, -1);
            NL (O);

         when EW_Prog =>
            P (O, "let ");
            Traverse (State, +Name);

            if not Is_Empty (+Binders) then
               P (O, " (");
               Print_List (State, +Binders, ") (");
               P (O, ") ");
            end if;

            PL (O, " =");
            NL (O);
            Relative_Indent (O, 1);

            if Pre = Why_Empty then
               PL (O, "{ }");
            else
               PL (O, "{ ");
               Traverse (State, +Pre);
               PL (O, " }");
            end if;

            NL (O);
            Relative_Indent (O, 1);
            Traverse (State, +Def);
            Relative_Indent (O, -1);
            NL (O);

            if Post = Why_Empty then
               PL (O, "{ true }");
            else
               PL (O, "{ ");
               Traverse (State, +Post);
               PL (O, " }");
            end if;
            Relative_Indent (O, -1);
      end case;

      State.Control := Abandon_Children;
   end Function_Def_Pre_Op;

   ------------------
   -- Axiom_Pre_Op --
   ------------------

   procedure Axiom_Pre_Op
     (State : in out Printer_State;
      Node  : W_Axiom_Id)
   is
   begin
      P (O, "axiom ");
      Traverse (State, +Get_Name (Node));
      PL (O, " :");
      Relative_Indent (O, 1);
      Traverse (State, +Get_Def (Node));
      Relative_Indent (O, -1);
      NL (O);
      State.Control := Abandon_Children;
   end Axiom_Pre_Op;

   -----------------
   -- Goal_Pre_Op --
   -----------------

   procedure Goal_Pre_Op
     (State : in out Printer_State;
      Node  : W_Goal_Id)
   is
   begin
      P (O, "goal ");
      Traverse (State, +Get_Name (Node));
      PL (O, " :");
      Relative_Indent (O, 1);
      Traverse (State, +Get_Def (Node));
      Relative_Indent (O, -1);
      NL (O);
      State.Control := Abandon_Children;
   end Goal_Pre_Op;

   -----------------
   -- Type_Pre_Op --
   -----------------

   procedure Type_Pre_Op
     (State : in out Printer_State;
      Node  : W_Type_Id)
   is
      use Node_Lists;

      External   : constant Boolean := Get_External (Node);
      Args       : constant List := Get_List (+Get_Args (Node));
      Nb_Args    : constant Count_Type := Length (Args);
      Position   : Cursor := First (Args);
      Name       : constant W_Identifier_Id := Get_Name (Node);
      Definition : constant W_Type_Definition_Id := Get_Definition (Node);
   begin
      if External then
         P (O, "external ");
      end if;

      P (O, "type ");

      Traverse (State, +Name);

      if Nb_Args > 1 then
         P (O, " (");
      end if;

      if Nb_Args > 0 then
         P (O, " ");
      end if;

      while Position /= No_Element loop
         P (O, "'");

         declare
            Param : constant Why_Node_Id := Element (Position);
         begin
            Traverse (State, Param);
         end;

         Position := Next (Position);

         if Position /= No_Element then
            P (O, ", ");
         end if;
      end loop;

      if Nb_Args > 1 then
         P (O, ")");
      end if;

      if Definition /= Why_Empty then
         P (O, " = ");
         NL (O);
         Relative_Indent (O, 1);
         Traverse (State, +Definition);
         Relative_Indent (O, -1);
      end if;

      NL (O);
      State.Control := Abandon_Children;
   end Type_Pre_Op;

   -----------------------------------
   -- Global_Ref_Declaration_Pre_Op --
   -----------------------------------

   procedure Global_Ref_Declaration_Pre_Op
     (State : in out Printer_State;
      Node  : W_Global_Ref_Declaration_Id)
   is
   begin
      P (O, "val ");
      Traverse (State, +Get_Name (Node));
      P (O, " : ref ");
      Traverse (State, +Get_Ref_Type (Node));
      NL (O);
      State.Control := Abandon_Children;
   end Global_Ref_Declaration_Pre_Op;

   ----------------------------------
   -- Exception_Declaration_Pre_Op --
   ----------------------------------

   procedure Exception_Declaration_Pre_Op
     (State : in out Printer_State;
      Node  : W_Exception_Declaration_Id)
   is
      Arg : constant W_Primitive_Type_OId := Get_Arg (Node);
   begin
      P (O, "exception Gnatprove_Exception__");
      Traverse (State, +Get_Name (Node));

      if Arg /= Why_Empty then
         P (O, "of ");
         Traverse (State, +Arg);
      end if;

      State.Control := Abandon_Children;
   end Exception_Declaration_Pre_Op;

   --------------------------------
   -- Include_Declaration_Pre_Op --
   --------------------------------

   procedure Include_Declaration_Pre_Op
     (State : in out Printer_State;
      Node  : W_Include_Declaration_Id)
   is
   begin
      P (O, "use export module """);
      Traverse (State, +Get_Name (Node));
      P (O, """.Main");

      NL (O);
      State.Control := Abandon_Children;
   end Include_Declaration_Pre_Op;

   ------------------------------
   -- Clone_Declaration_Pre_Op --
   ------------------------------

   procedure Clone_Declaration_Pre_Op
      (State : in out Printer_State;
       Node  : W_Clone_Declaration_Id)
   is
      As_Name    : constant W_Identifier_OId := +Get_As_Name (Node);
      Subst_List : constant W_Clone_Substitution_OList :=
                        +Get_Substitutions (Node);
   begin
      P (O, "clone ");
      P (O, Get_Clone_Kind (Node));
      P (O, " ");
      Traverse (State, +Get_Origin (Node));
      if As_Name /= Why_Empty then
         P (O, " as ");
         Traverse (State, +As_Name);
      end if;
      if not Is_Empty (+Subst_List) then
         P (O, " with ");
         Print_List (State, +Subst_List, ", " & ASCII.LF);
      end if;
      State.Control := Abandon_Children;
   end Clone_Declaration_Pre_Op;

   -------------------------------
   -- Clone_Substitution_Pre_Op --
   -------------------------------

   procedure Clone_Substitution_Pre_Op
      (State : in out Printer_State;
       Node  : W_Clone_Substitution_Id)
   is
   begin
      P (O, Get_Kind (Node));
      P (O, " ");
      Traverse (State, +Get_Orig_Name (Node));
      P (O, " = ");
      Traverse (State, +Get_Image (Node));
      State.Control := Abandon_Children;
   end Clone_Substitution_Pre_Op;

   -----------------
   -- File_Pre_Op --
   -----------------

   procedure File_Pre_Op
     (State : in out Printer_State;
      Node  : W_File_Id)
   is
   begin
      PL (O, "module Main");
      PL (O, "use import int.Int");
      PL (O, "use import module ref.Ref");

      Print_List (State, +Get_Declarations (Node), "" & ASCII.LF);

      PL (O, "end");

      State.Control := Abandon_Children;
   end File_Pre_Op;

end Why.Atree.Sprint;

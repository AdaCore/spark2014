(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)
Require Export Reals.

(*Why logic*) Definition lt_real : R -> R -> Prop.
Admitted.

(*Why logic*) Definition le_real : R -> R -> Prop.
Admitted.

(*Why logic*) Definition gt_real : R -> R -> Prop.
Admitted.

(*Why logic*) Definition ge_real : R -> R -> Prop.
Admitted.

(*Why logic*) Definition eq_real : R -> R -> Prop.
Admitted.

(*Why logic*) Definition neq_real : R -> R -> Prop.
Admitted.

(*Why logic*) Definition add_real : R -> R -> R.
Admitted.

(*Why logic*) Definition sub_real : R -> R -> R.
Admitted.

(*Why logic*) Definition mul_real : R -> R -> R.
Admitted.

(*Why logic*) Definition div_real : R -> R -> R.
Admitted.

(*Why logic*) Definition neg_real : R -> R.
Admitted.

(*Why logic*) Definition real_of_int : Z -> R.
Admitted.

(*Why axiom*) Lemma real_of_int_zero : (eq (IZR 0) (0)%R).
Admitted.

(*Why axiom*) Lemma real_of_int_one : (eq (IZR 1) (1)%R).
Admitted.

(*Why axiom*) Lemma real_of_int_add :
  (forall (x:Z), (forall (y:Z), (eq (IZR (x + y)) (Rplus (IZR x) (IZR y))))).
Admitted.

(*Why axiom*) Lemma real_of_int_sub :
  (forall (x:Z), (forall (y:Z), (eq (IZR (x - y)) (Rminus (IZR x) (IZR y))))).
Admitted.

(*Why logic*) Definition truncate_real_to_int : R -> Z.
Admitted.

(*Why axiom*) Lemma truncate_down_pos :
  (forall (x:R),
   ((Rge x (0)%R) -> (Rle (IZR (truncate_real_to_int x)) x) /\
    (Rlt x (IZR ((truncate_real_to_int x) + 1))))).
Admitted.

(*Why axiom*) Lemma truncate_up_neg :
  (forall (x:R),
   ((Rle x (0)%R) -> (Rlt (IZR ((truncate_real_to_int x) - 1)) x) /\
    (Rle x (IZR (truncate_real_to_int x))))).
Admitted.

(*Why logic*) Definition floor_real_to_int : R -> Z.
Admitted.

(*Why logic*) Definition ceil_real_to_int : R -> Z.
Admitted.

(*Why logic*) Definition lt_real_bool : R -> R -> bool.
Admitted.

(*Why logic*) Definition le_real_bool : R -> R -> bool.
Admitted.

(*Why logic*) Definition gt_real_bool : R -> R -> bool.
Admitted.

(*Why logic*) Definition ge_real_bool : R -> R -> bool.
Admitted.

(*Why logic*) Definition eq_real_bool : R -> R -> bool.
Admitted.

(*Why logic*) Definition neq_real_bool : R -> R -> bool.
Admitted.

(*Why axiom*) Lemma lt_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((lt_real_bool x y) = true <-> (Rlt x y)))).
Admitted.

(*Why axiom*) Lemma le_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((le_real_bool x y) = true <-> (Rle x y)))).
Admitted.

(*Why axiom*) Lemma gt_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((gt_real_bool x y) = true <-> (Rgt x y)))).
Admitted.

(*Why axiom*) Lemma ge_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((ge_real_bool x y) = true <-> (Rge x y)))).
Admitted.

(*Why axiom*) Lemma eq_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((eq_real_bool x y) = true <-> (eq x y)))).
Admitted.

(*Why axiom*) Lemma neq_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((neq_real_bool x y) = true <-> ~(eq x y)))).
Admitted.

(*Why logic*) Definition real_max : R -> R -> R.
Admitted.

(*Why logic*) Definition real_min : R -> R -> R.
Admitted.

(*Why axiom*) Lemma real_max_is_ge :
  (forall (x:R),
   (forall (y:R), (Rge (real_max x y) x) /\ (Rge (real_max x y) y))).
Admitted.

(*Why axiom*) Lemma real_max_is_some :
  (forall (x:R),
   (forall (y:R), (eq (real_max x y) x) \/ (eq (real_max x y) y))).
Admitted.

(*Why axiom*) Lemma real_min_is_le :
  (forall (x:R),
   (forall (y:R), (Rle (real_min x y) x) /\ (Rle (real_min x y) y))).
Admitted.

(*Why axiom*) Lemma real_min_is_some :
  (forall (x:R),
   (forall (y:R), (eq (real_min x y) x) \/ (eq (real_min x y) y))).
Admitted.

(*Why function*) Definition sqr_real  (x:R) := (Rmult x x).

(*Why logic*) Definition sqrt_real : R -> R.
Admitted.

(*Why axiom*) Lemma sqrt_pos :
  (forall (x:R), ((Rge x (0)%R) -> (Rge (sqrt x) (0)%R))).
Admitted.

(*Why axiom*) Lemma sqrt_sqr :
  (forall (x:R), ((Rge x (0)%R) -> (eq (sqr_real (sqrt x)) x))).
Admitted.

(*Why axiom*) Lemma sqr_sqrt :
  (forall (x:R), ((Rge x (0)%R) -> (eq (sqrt (Rmult x x)) x))).
Admitted.

(*Why logic*) Definition pow_real : R -> R -> R.
Admitted.

(*Why logic*) Definition abs_real : R -> R.
Admitted.

(*Why axiom*) Lemma abs_real_pos :
  (forall (x:R), ((Rge x (0)%R) -> (eq (Rabs x) x))).
Admitted.

(*Why axiom*) Lemma abs_real_neg :
  (forall (x:R), ((Rle x (0)%R) -> (eq (Rabs x) (Ropp x)))).
Admitted.

(*Why logic*) Definition exp : R -> R.
Admitted.

(*Why logic*) Definition log : R -> R.
Admitted.

(*Why logic*) Definition log10 : R -> R.
Admitted.

(*Why axiom*) Lemma log_exp : (forall (x:R), (eq (log (exp x)) x)).
Admitted.

(*Why axiom*) Lemma exp_log :
  (forall (x:R), ((Rgt x (0)%R) -> (eq (exp (log x)) x))).
Admitted.

(*Why logic*) Definition cos : R -> R.
Admitted.

(*Why logic*) Definition sin : R -> R.
Admitted.

(*Why logic*) Definition tan : R -> R.
Admitted.

(*Why logic*) Definition pi : R.
Admitted.

(*Why logic*) Definition cosh : R -> R.
Admitted.

(*Why logic*) Definition sinh : R -> R.
Admitted.

(*Why logic*) Definition tanh : R -> R.
Admitted.

(*Why logic*) Definition acos : R -> R.
Admitted.

(*Why logic*) Definition asin : R -> R.
Admitted.

(*Why logic*) Definition atan : R -> R.
Admitted.

(*Why logic*) Definition atan2 : R -> R -> R.
Admitted.

(*Why logic*) Definition hypot : R -> R -> R.
Admitted.

(*Why axiom*) Lemma prod_pos :
  (forall (x:R),
   (forall (y:R),
    (((Rgt x (0)%R) /\ (Rgt y (0)%R) -> (Rgt (Rmult x y) (0)%R))) /\
    (((Rlt x (0)%R) /\ (Rlt y (0)%R) -> (Rgt (Rmult x y) (0)%R))))).
Admitted.

(*Why axiom*) Lemma abs_minus :
  (forall (x:R), (eq (Rabs (Ropp x)) (Rabs x))).
Admitted.

(**************************************************************************)
Require "set_raw".
Require Import ZArith.
Open Scope Z_scope.

Module Type Element_Type.

Parameter Inline key_t : Set.

Parameter Inline k_nl : key_t.

Parameter Inline element_t : Set.

Parameter Inline e_nl : element_t.

Parameter Inline witness : key_t -> R.

End Element_Type.

Module HMap (Elt : Element_Type).

Module ROrder.

Definition lt_real_bool : R -> R -> bool := lt_real_bool.

Definition le_real_bool : R -> R -> bool := le_real_bool.

Definition gt_real_bool : R -> R -> bool := gt_real_bool.

Definition ge_real_bool : R -> R -> bool := ge_real_bool.

Definition eq_real_bool : R -> R -> bool := eq_real_bool.

Definition neq_real_bool : R -> R -> bool := neq_real_bool.

Lemma lt_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((lt_real_bool x y) = true <-> (Rlt x y)))).
apply lt_real_bool_axiom.
Qed.

Lemma le_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((le_real_bool x y) = true <-> (Rle x y)))).
apply le_real_bool_axiom.
Qed.

Lemma gt_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((gt_real_bool x y) = true <-> (Rgt x y)))).
apply gt_real_bool_axiom.
Qed.

Lemma ge_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((ge_real_bool x y) = true <-> (Rge x y)))).
apply ge_real_bool_axiom.
Qed.

Lemma eq_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((eq_real_bool x y) = true <-> (eq x y)))).
apply eq_real_bool_axiom.
Qed.

Lemma neq_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((neq_real_bool x y) = true <-> ~(eq x y)))).
apply neq_real_bool_axiom.
Qed.

End ROrder.

Module Element.

Definition element_t : Set := prod Elt.key_t Elt.element_t.

Definition e_nl : element_t := (Elt.k_nl, Elt.e_nl).

Definition witness (e : element_t) : R := Elt.witness (fst e).

End Element.

Module Raw_Set := (set_raw.Raw_Set (Element)) (ROrder).
Import Raw_Set.

(*Why type*) Definition cursor: Set.
exact Raw_List.cursor.
Defined.

(*Why type*) Definition map: Set.
exact hset.
Defined.

(*Why type*) Definition element_t: Set.
exact Elt.element_t.
Defined.

(*Why type*) Definition key_t: Set.
exact Elt.key_t.
Defined.

(*Why logic*) Definition no_element : cursor.
exact O.
Defined.

(*Why logic*) Definition empty_ : map.
exact hempty.
Defined.

(*Why logic*) Definition length_ : map -> Z.
exact (fun l => Z_of_nat (Raw_List.length l)).
Defined.

(*Why axiom*) Lemma length_gte_zero : (forall (co:map), 0 <= (length_ co)).
intro l; unfold length_.
apply Zle_0_nat.
Qed.

(*Why logic*) Definition witness : key_t -> R.
exact Elt.witness.
Defined.

(*Why logic*) Definition position_ : map -> cursor -> Z.
exact (fun l cu => Z_of_nat(Raw_List.position l cu)).
Defined.

(*Why axiom*) Lemma position_gte_zero :
  (forall (co:map),
   (forall (cu:cursor), 0 <= (position_ co cu) /\ (position_ co cu) <=
    (length_ co))).
unfold position_.
unfold length_.
split.
apply Zle_0_nat.
apply inj_le; simpl.
apply Raw_List.position_length.
Qed.

(*Why axiom*) Lemma position_no_element :
  (forall (co:map), (position_ co no_element) = 0).
intro l; unfold position_; unfold no_element;
rewrite <- inj_0; apply inj_eq.
apply Raw_List.position_no_element.
Qed.

(*Why axiom*) Lemma position_eq :
  (forall (co:map),
   (forall (cu1:cursor),
    (forall (cu2:cursor),
     ((position_ co cu1) > 0 ->
      ((position_ co cu1) = (position_ co cu2) -> cu1 = cu2))))).
intros l cu1 cu2; unfold position_; rewrite <- inj_0;
intros Hpos Heq.
apply inj_gt_rev in Hpos.
apply inj_eq_rev in Heq.
apply (Raw_List.position_eq l cu1 cu2 Hpos Heq).
Qed.

(*Why predicate*) Definition is_empty_  (co:map)
  := (forall (cu:cursor), (position_ co cu) = 0).

(*Why axiom*) Lemma length_is_empty :
  (forall (co:map), ((is_empty_ co) -> (length_ co) = 0)).
intro l; unfold is_empty_; unfold length_; unfold position_.
intro H; rewrite <- inj_0; apply inj_eq;
apply Raw_List.length_position.
intro cu; apply inj_eq_rev; rewrite inj_0; apply H.
Qed.

(*Why axiom*) Lemma empty_is_empty : (is_empty_ empty_).
unfold is_empty_; unfold empty_; unfold position_;
unfold Raw_List.empty; simpl; auto.
Qed.

(*Why predicate*) Definition next__  (co:map) (cu1:cursor) (cu2:cursor)
  := (((length_ co) > (position_ co cu1) /\ (position_ co cu1) > 0 \/
       (position_ co cu2) > 0 -> (position_ co cu2) =
       ((position_ co cu1) + 1))) /\
     (((length_ co) > 0 /\ (position_ co cu1) = (length_ co) \/
       cu1 = no_element -> cu2 = no_element)).

(*Why logic*) Definition next_ : map -> cursor -> cursor.
exact Raw_List.next.
Defined.

(*Why axiom*) Lemma next_next :
  (forall (co:map), (forall (cu:cursor), (next__ co cu (next_ co cu)))).
intros l cu; unfold next__; unfold next_; unfold position_;
unfold no_element; unfold length_.
assert (Z_of_nat (1) = 1).
auto.
split.
intros HH.
destruct HH as [[Hlength Hpos] | HH];
[apply inj_gt_rev in Hlength;
rewrite <- inj_0 in Hpos; apply inj_gt_rev in Hpos|
rewrite <- inj_0 in HH; apply inj_gt_rev in HH;
apply Raw_List.next_has_element_inv in HH;
destruct HH as [Hpos Hlength]];
rewrite <- H; rewrite <- inj_plus;
apply inj_eq;
apply (Raw_List.next_position_gen l cu Hlength Hpos).
intros [[_ HH] | HH]; [apply inj_eq_rev in HH |].
apply Raw_List.next_position_last; exact HH.
rewrite HH; apply Raw_List.next_position_O.
Qed.

(*Why predicate*) Definition first__  (co:map) (cu:cursor)
  := ((~(is_empty_ co) -> (position_ co cu) = 1)) /\
     (((is_empty_ co) -> cu = no_element)).

Lemma is_empty_length : 
forall l : map, not (is_empty_ l) -> (Raw_List.length l <> 0)%nat.
unfold is_empty_; unfold length_; unfold position_;
intros l H.
intro Hl; apply H.
intro cu; rewrite <- inj_0; apply inj_eq.
symmetry; apply le_n_O_eq.
rewrite <- Hl.
apply Raw_List.position_length.
Qed.

(*Why logic*) Definition first_ : map -> cursor.
exact Raw_List.first.
Defined.

(*Why axiom*) Lemma first_first :
  (forall (co:map), (first__ co (first_ co))).
intro l; unfold first__; unfold first_; unfold position_;
unfold no_element; unfold length_.
assert (Z_of_nat (1) = 1).
auto.
split;
[rewrite <- H; intro HH; apply inj_eq;
apply is_empty_length in HH |
unfold is_empty_; unfold length_; unfold position_;
intros Hl; apply length_is_empty in Hl;
rewrite <- inj_0 in Hl; apply inj_eq_rev in Hl].
apply Raw_List.position_first_gen; exact HH.
apply Raw_List.first_nil; exact Hl.
Qed.

(*Why logic*) Definition key_ : map -> cursor -> key_t.
exact (fun m cu => fst (Raw_List.element m cu)).
Defined.

(*Why logic*) Definition find_ : map -> R -> cursor.
exact Raw_List.find.
Defined.

(*Why predicate*) Definition find__  (co:map) (i:R) (cu:cursor)
  := cu = no_element /\
     (forall (cun:cursor),
      ((position_ co cun) > 0 -> ~(eq (witness (key_ co cun)) i))) \/
     (position_ co cu) > 0 /\ (eq (witness (key_ co cu)) i) /\
     (forall (cun:cursor),
      ((position_ co cun) > 0 ->
       (~(cu = cun) -> ~(eq (witness (key_ co cun)) i)))).

(*Why axiom*) Lemma find_find_val :
  (forall (co:map),
   (forall (i:R), (find__ co i (find_ co i)) /\
    (((is_empty_ co) -> (find_ co i) = no_element)))).
intros m r; unfold find__; unfold find_; unfold is_empty_;
unfold position_; unfold no_element; unfold key_; unfold first_.
split.
destruct (gt_O_eq (Raw_List.position m (Raw_List.find m r))) as [Hf | Hf];
[right | left]; split.
rewrite <- inj_0; apply inj_gt; exact Hf.
split.
apply Raw_List.find_element; exact Hf.
intros cun Hpos Hs Hw.
contradict Hs.
rewrite <- Hw.
apply (Raw_List.position_eq m); [rewrite Hw; exact Hf|].
rewrite <- inj_0 in Hpos; apply inj_gt_rev in Hpos.
apply (find_position_inv m (hwf m) cun Hpos).
apply (Raw_List.find_position); symmetry; exact Hf.
symmetry in Hf; apply Raw_List.find_position in Hf.
intros cun Hpos Hw; rewrite <- inj_0 in Hpos;
apply inj_gt_rev in Hpos; rewrite <- Hw in Hf.
destruct (gt_O_eq (Raw_List.position m
                      (Raw_List.find m
                          (witness
                             (fst (Raw_List.element m cun)))
          ))) as [Hpf|Hpf].
simpl in Hpf;
rewrite Hf in Hpf; rewrite Raw_List.position_no_element in Hpf;
contradict Hpf; apply gt_irrefl.
unfold witness in Hpf;
rewrite (find_position_inv m (hwf m) cun Hpos) in Hpf;
contradict Hpos; simpl in Hpf; rewrite <- Hpf; apply gt_irrefl.
intros Hemp; apply length_is_empty in Hemp.
unfold length_ in Hemp; rewrite <- inj_0 in Hemp;
apply inj_eq_rev in Hemp.
apply (Raw_List.find_nil m _ Hemp).
Qed.

(*Why logic*) Definition element_ : map -> cursor -> element_t.
exact (fun m cu => snd (Raw_List.element m cu)).
Defined.

(*Why function*) Definition element__  (m:map) (i:R)
  := (element_ m (find_ m i)).

(*Why predicate*) Definition left_pos  (co:map) (i:Z) (col:map)
  := (forall (cu:cursor),
      ((i <= (position_ co cu) -> (position_ col cu) = 0)) /\
      ((i > (position_ co cu) -> (position_ col cu) = (position_ co cu) /\
        (key_ col cu) = (key_ co cu) /\ (element_ col cu) = (element_ co cu))) /\
      (((position_ col cu) > 0 -> (position_ co cu) = (position_ col cu)))).

(*Why predicate*) Definition left_find  (co:map) (i:Z) (col:map)
  := (forall (w:R),
      (i > (position_ co (find_ co w)) /\ (position_ co (find_ co w)) > 0 \/
       (position_ col (find_ col w)) > 0 -> (find_ co w) = (find_ col w))).

(*Why predicate*) Definition left__  (co:map) (cu:cursor) (col:map)
  := ((cu = no_element -> col = co)) /\
     (((position_ co cu) > 0 -> (length_ col) = ((position_ co cu) - 1) /\
       (left_pos co (position_ co cu) col) /\
       (left_find co (position_ co cu) col))).

(*Why logic*) Definition left_ : map -> cursor -> map.
exact hleft.
Defined.

(*Why axiom*) Lemma left_left :
  (forall (co:map), (forall (cu:cursor), (left__ co cu (left_ co cu)))).
intros m cu; unfold left__; unfold left_; unfold left_pos;
unfold left_find; unfold find_; unfold position_; unfold length_;
unfold no_element; unfold key_; unfold element_; unfold first_.
split.
intro HO; rewrite  HO; unfold hleft; simpl; reflexivity.
unfold hleft; case_eq (beq_nat cu O); [intros Heq Hko;
apply beq_nat_true in Heq; rewrite Heq in Hko;
rewrite (Raw_List.position_no_element) in Hko; rewrite <- inj_0 in Hko;
apply inj_gt_rev in Hko; contradict Hko; apply gt_irrefl|intros _].
assert (Z_of_nat (1) = 1). auto.
intro Hpos; rewrite <- inj_0 in Hpos; apply inj_gt_rev in Hpos;
split.
rewrite <- H.
rewrite <- (inj_minus1 (Raw_List.position m cu) 1
(gt_le_S 0 (Raw_List.position m cu) Hpos)); apply inj_eq.
apply (Raw_List.left_length m cu Hpos).
split.
intro cun; split.
intro HH; apply inj_le_rev in HH;
rewrite <- inj_0; apply inj_eq.
apply (Raw_List.left_position_out m cu Hpos cun HH).
split.
intro HH; apply inj_gt_rev in HH; split.
apply inj_eq.
apply (Raw_List.left_position_in m cu Hpos cun HH).
apply (Raw_List.left_element_in m cu Hpos cun) in HH.
simpl; rewrite HH; split; reflexivity.
intro HH; rewrite <- inj_0 in HH; apply inj_gt_rev in HH;
apply inj_eq.
apply (Raw_List.left_position_inv m cu Hpos cun HH).
intros w [[Hsup Hpf] | Hpf].
rewrite <- inj_0 in Hpf; apply inj_gt_rev in Hsup;
apply inj_gt_rev in Hpf.
apply (left_find_in m cu w Hpos Hsup).
rewrite <- inj_0 in Hpf; apply inj_gt_rev in Hpf.
apply (left_find_rev m cu w Hpos Hpf).
Qed.

(*Why predicate*) Definition right_pos  (co:map) (i:Z) (cor:map)
  := (forall (cu:cursor),
      ((i > (position_ co cu) -> (position_ cor cu) = 0)) /\
      ((i <= (position_ co cu) -> (position_ cor cu) =
        ((position_ co cu) - i + 1) /\ (key_ cor cu) = (key_ co cu) /\
        (element_ cor cu) = (element_ co cu))) /\
      (((position_ cor cu) > 0 -> (position_ co cu) =
        ((position_ cor cu) + i - 1)))).

(*Why predicate*) Definition right_find  (co:map) (i:Z) (cor:map)
  := (forall (w:R),
      (i <= (position_ co (find_ co w)) /\ i > 0 \/
       (position_ cor (find_ cor w)) > 0 -> (find_ co w) = (find_ cor w))).

(*Why predicate*) Definition right__  (co:map) (cu:cursor) (cor:map)
  := ((cu = no_element -> cor = empty_)) /\
     (((position_ co cu) > 0 -> (length_ cor) =
       ((length_ co) - (position_ co cu) + 1) /\
       (right_pos co (position_ co cu) cor) /\
       (right_find co (position_ co cu) cor))) /\
     (forall (cun:cursor),
      ((position_ cor cun) > 0 -> (position_ co cun) > 0)).

(*Why logic*) Definition right_ : map -> cursor -> map.
exact hright.
Defined.

(*Why axiom*) Lemma right_right :
  (forall (co:map), (forall (cu:cursor), (right__ co cu (right_ co cu)))).
intros m cu; unfold right__; unfold right_pos; unfold right_find;
unfold right_; unfold find_; unfold position_; unfold length_;
unfold no_element; unfold key_; unfold element_; unfold empty_;
unfold hright; unfold first_.
assert (Z_of_nat (1) = 1). auto.
split; [intro HH; rewrite HH; unfold oright; simpl; reflexivity|].
split.
case_eq (beq_nat cu O); [intros Heq Hko;
apply beq_nat_true in Heq; rewrite Heq in Hko;
rewrite (Raw_List.position_no_element) in Hko; rewrite <- inj_0 in Hko;
apply inj_gt_rev in Hko; contradict Hko; apply gt_irrefl|intros _].
intro Hpos; rewrite <- inj_0 in Hpos; apply inj_gt_rev in Hpos;
split.
rewrite <- (inj_minus1 (Raw_List.length m) (Raw_List.position m cu)
(Raw_List.position_length m cu));
rewrite <- H; rewrite <- inj_plus; apply inj_eq.
simpl; apply (Raw_List.right_length m cu Hpos).
split.
intro cun; split.
intro Hs; apply inj_gt_rev in Hs; rewrite <- inj_0;
apply inj_eq.
apply (Raw_List.right_position_out m cu Hpos cun Hs).
split.
intro Hs; apply inj_le_rev in Hs; split.
rewrite <- H;
rewrite <- (inj_minus1 (Raw_List.position m cun) (Raw_List.position m cu) Hs);
rewrite <- inj_plus; apply inj_eq.
apply (Raw_List.right_position_in m cu Hpos cun Hs).
apply (Raw_List.right_element_in m cu Hpos cun) in Hs.
simpl; rewrite Hs; split; reflexivity.
intro HH; rewrite <- inj_0 in HH; apply inj_gt_rev in HH.
rewrite <- H;
rewrite <- inj_plus.
rewrite <- (inj_minus1 _ 1 (gt_le_S _ _
(le_gt_trans _ _ _ (le_plus_l _ _) HH))).
apply inj_eq.
apply (Raw_List.right_position_inv m cu Hpos cun HH).
intros w [[Hinf _] | Hpf].
apply inj_le_rev in Hinf.
apply (right_find_in m cu w Hpos Hinf).
rewrite <- inj_0 in Hpf; apply inj_gt_rev in Hpf.
apply (right_find_rev m cu w Hpos Hpf).
case (beq_nat cu 0); simpl.
intros cun Hko; contradict Hko; apply Zgt_irrefl.
intros cun Hpos; rewrite <- inj_0 in Hpos;
apply inj_gt_rev in Hpos; rewrite <- inj_0;
apply inj_gt.
apply (Raw_List.has_element_right m cu cun Hpos).
Qed.

(*Why predicate*) Definition replace_  (co1:map) (k:key_t) (e:element_t) (co2:map)
  := (position_ co1 (find_ co1 (witness k))) > 0 /\ (length_ co1) =
     (length_ co2) /\ (key_ co2 (find_ co1 (witness k))) = k /\
     (element_ co2 (find_ co1 (witness k))) = e /\
     (forall (cun:cursor), (position_ co2 cun) = (position_ co1 cun) /\
      ((~cun = (find_ co1 (witness k)) -> (key_ co2 cun) = (key_ co1 cun) /\
        (element_ co2 cun) = (element_ co1 cun)))) /\
     (forall (w:R), (find_ co1 w) = (find_ co2 w)).

(*Why predicate*) Definition replace_element_  (co1:map) (cu:cursor) (e:element_t) (co2:map)
  := (position_ co1 cu) > 0 /\ (element_ co2 cu) = e /\ (length_ co1) =
     (length_ co2) /\
     (forall (cun:cursor), (position_ co1 cun) = (position_ co2 cun) /\
      (((position_ co1 cun) > 0 -> (key_ co2 cun) = (key_ co1 cun) /\
        ((~(cu = cun) -> (element_ co2 cun) = (element_ co1 cun)))))) /\
     (forall (w:R), (find_ co1 w) = (find_ co2 w)).

(*Why predicate*) Definition insert_find  (co1:map) (k:key_t) (e:element_t) (co2:map)
  := (forall (w:R),
      ((~(eq (witness k) w) -> (find_ co1 w) = (find_ co2 w))) /\
      (((eq (witness k) w) -> (find_ co1 w) = no_element /\
        (position_ co2 (find_ co2 w)) > 0))).

(*Why predicate*) Definition insert_pos  (co1:map) (k:key_t) (e:element_t) (co2:map)
  := (forall (cun:cursor),
      (((position_ co1 cun) > 0 -> (position_ co2 cun) > 0 /\
        (key_ co1 cun) = (key_ co2 cun) /\
        (element_ co1 cun) = (element_ co2 cun))) /\
      (((position_ co1 cun) = 0 -> (position_ co2 cun) = 0 \/
        (position_ co2 cun) > 0 /\ (key_ co2 cun) = k /\
        (element_ co2 cun) = e))).

(*Why predicate*) Definition insert_inv  (co1:map) (k:key_t) (e:element_t) (co2:map)
  := (forall (cun:cursor),
      (((position_ co2 cun) > 0 -> (position_ co1 cun) = 0 /\
        (key_ co2 cun) = k /\ (element_ co2 cun) = e \/ (position_ co1 cun) >
        0 /\ (element_ co1 cun) = (element_ co2 cun) /\
        (key_ co1 cun) = (key_ co2 cun))) /\
      (((position_ co2 cun) = 0 -> (position_ co1 cun) = 0))).

(*Why predicate*) Definition insert_  (co1:map) (k:key_t) (e:element_t) (co2:map)
  := (position_ co2 (find_ co2 (witness k))) > 0 /\ (length_ co2) =
     ((length_ co1) + 1) /\ (insert_pos co1 k e co2) /\
     (insert_inv co1 k e co2) /\ (insert_find co1 k e co2).

(*Why predicate*) Definition delete_find  (co1:map) (k:key_t) (co2:map)
  := (forall (w:R),
      ((~(eq (witness k) w) -> (find_ co1 w) = (find_ co2 w))) /\
      (((eq (witness k) w) -> (find_ co2 w) = no_element))).

(*Why predicate*) Definition delete_pos  (co1:map) (i:Z) (co2:map)
  := (forall (cun:cursor),
      (((position_ co1 cun) = i -> (position_ co2 cun) = 0)) /\
      (((position_ co1 cun) > 0 /\ (position_ co1 cun) <> i ->
        (position_ co2 cun) > 0 /\ (key_ co2 cun) = (key_ co1 cun) /\
        (element_ co2 cun) = (element_ co1 cun)))).

(*Why predicate*) Definition delete_inv  (co1:map) (i:Z) (co2:map)
  := (forall (cun:cursor),
      ((position_ co2 cun) > 0 -> (position_ co1 cun) > 0 /\
       (key_ co1 cun) = (key_ co2 cun) /\
       (element_ co2 cun) = (element_ co1 cun))).

(*Why predicate*) Definition delete_  (co1:map) (cu:cursor) (co2:map)
  := (find_ co2 (witness (key_ co1 cu))) = no_element /\ (position_ co1 cu) >
     0 /\ (length_ co2) = ((length_ co1) - 1) /\
     (delete_pos co1 (position_ co1 cu) co2) /\
     (delete_inv co1 (position_ co1 cu) co2) /\
     (delete_find co1 (key_ co1 cu) co2).

(*Why predicate*) Definition include__  (co1:map) (k:key_t) (e:element_t) (co2:map)
  := (((position_ co1 (find_ co1 (witness k))) > 0 -> (replace_ co1 k e co2))) /\
     (((find_ co1 (witness k)) = no_element -> (insert_ co1 k e co2))).

(*Why predicate*) Definition exclude_  (co1:map) (k:key_t) (co2:map)
  := (((position_ co1 (find_ co1 (witness k))) > 0 ->
       (delete_ co1 (find_ co1 (witness k)) co2))) /\
     (((find_ co1 (witness k)) = no_element -> co1 = co2)).

(*Why predicate*) Definition has_element_  (co:map) (cu:cursor)
  := (position_ co cu) > 0.

(*Why predicate*) Definition contains_  (co:map) (i:R)
  := (position_ co (find_ co i)) > 0.

(*Why axiom*) Lemma empty_contains :
  (forall (s:map), ((forall (i:R), ~(contains_ s i)) -> (is_empty_ s))).
unfold contains_; unfold is_empty_; intros m Hc cu.
generalize (Hc (Elt.witness(key_ m cu))).
intros Hpf; destruct(gt_O_eq (Raw_List.position m cu)) as [Hpo | Heq].
contradict Hpf; unfold position_; unfold key_; unfold find_;
unfold first_; rewrite <- inj_0; apply inj_gt.
rewrite (find_position_inv m (hwf m)); apply Hpo.
unfold position_; rewrite <- inj_0; apply inj_eq;
symmetry; exact Heq.
Qed.

(*Why predicate*) Definition equal_  (co1:map) (co2:map)
  := (forall (cu:cursor), (position_ co1 cu) = (position_ co2 cu) /\
      (((position_ co1 cu) > 0 -> (key_ co1 cu) = (key_ co2 cu) /\
        (element_ co2 cu) = (element_ co1 cu)))).

(*Why predicate*) Definition equivalent_  (co1:map) (co2:map)
  := (forall (i:R),
      ((contains_ co1 i) -> (contains_ co2 i) /\
       (element__ co1 i) = (element__ co2 i))) /\
     (length_ co1) = (length_ co2).

(*Why axiom*) Lemma equivalent_sym :
  (forall (co1:map),
   (forall (co2:map), ((equivalent_ co1 co2) -> (equivalent_ co2 co1)))).
unfold equivalent_; unfold contains_; unfold find_; unfold position_;
unfold first_; intros m1 m2 [He Hl]; split;
[|symmetry; exact Hl].
intros w Hc.
assert (Raw_List.has_element m1
(Raw_List.find m1 w) = true).
rewrite <- inj_0 in Hc; apply inj_gt_rev in Hc;
apply (Raw_List.has_element_position) in Hc.
apply (equivalent_find m1 m2).
simpl; intros i.
intros Hh1; apply (Raw_List.position_has_element) in Hh1;
apply inj_gt in Hh1; rewrite inj_0 in Hh1;
destruct (He i Hh1) as [Hh2 _].
apply (Raw_List.has_element_position); apply inj_gt_rev;
rewrite inj_0; exact Hh2.
simpl; unfold length_ in Hl; apply inj_eq_rev; exact Hl.
simpl; exact Hc.
apply (Raw_List.position_has_element) in H; apply inj_gt in H;
rewrite inj_0 in H.
destruct (He w H) as [_ Hel].
split; [exact H|symmetry; exact Hel].
Qed.

(*Why predicate*) Definition no_overlaping  (co1:map) (co2:map)
  := (forall (i:R), ~(contains_ co1 i) \/ ~(contains_ co2 i)).

(*** TESTS ***)

Definition insert : map -> key_t -> element_t -> map.
exact (fun m k e => Ins.insert m (k, e)).
Defined.

Lemma insert_insert :
forall (l : map), forall (k : key_t),
forall (e : element_t),
not (contains_ l (witness k)) ->
insert_ l k e (insert l k e).
intros l k e; unfold insert_; unfold contains_; unfold has_element_;
unfold insert_pos; unfold insert_find; unfold insert_inv; unfold length_;
unfold position_; unfold no_element; unfold insert; unfold oinsert;
unfold element_; unfold key_; unfold find_; unfold first_; simpl.
assert (Z_of_nat (1) = 1); [auto|].
assert (witness k = Elt.witness (fst (k, e))); [auto|].
intro Hnfind; destruct (Raw_List.find_has_element l (witness k))
as [Hko|Hfind];
[contradict Hnfind; rewrite <- inj_0; apply inj_gt;
apply (Raw_List.position_has_element _ _ Hko)|].
assert(Raw_List.find l (Elt.witness (fst (k, e))) = 0%nat).
simpl; exact Hfind.
split; clear Hnfind.
rewrite <- inj_0; apply inj_gt.
rewrite H0;
rewrite <- (Ins.insert_element_new l (k, e) H1) at 3; rewrite <- H1.
rewrite (find_position_inv (Ins.insert l _)
(hwf (Ins.insert l _))); [rewrite H1|]; simpl;
apply Ins.insert_has_element_new; exact H1.
split; [rewrite <- H; rewrite <- inj_plus;
apply inj_eq; apply (Ins.insert_length l _ H1)|].
split;[intros cu; split; intro Hpos|split;
[intros cu; split; intro Hipos|intros w; split; intro Hw]].
rewrite <- inj_0 in Hpos; apply inj_gt_rev in Hpos;
generalize (Ins.insert_has_element_rev l (k, e) cu H1 Hpos).
intro Hipos; split; [rewrite <- inj_0; apply inj_gt; exact Hipos|
rewrite (Ins.insert_element_old l _ _ H1 Hpos); split; reflexivity].
rewrite <- inj_0;
destruct (gt_O_eq (Raw_List.position (Ins.insert l (k,e)) cu)) as [Hip|HO];
[right|left; symmetry; apply inj_eq; exact HO].
split; [apply inj_gt; exact Hip|].
destruct (Ins.insert_has_element _ _ _ H1 Hip) as [Heq|Hko].
rewrite Heq; rewrite (Ins.insert_element_new l _ H1); split; reflexivity.
contradict Hko;  rewrite <- inj_0 in Hpos; apply inj_eq_rev in Hpos;
rewrite <- Hpos; apply gt_irrefl.
rewrite <- inj_0 in Hipos; apply inj_gt_rev in Hipos;
destruct (Ins.insert_has_element _ _ _ H1 Hipos) as [Heq|Hpos];
[left; rewrite Heq|right].
split; [| rewrite (Ins.insert_element_new l _ H1); split; reflexivity].
rewrite <- inj_0; apply inj_eq;
destruct (gt_O_eq (Raw_List.position l cu)) as [Hko|Hex];
[apply Raw_List.has_element_position in Hko; contradict Hko;
rewrite Heq; rewrite Raw_List.New_Max.new_has_element;
apply Bool.diff_false_true| symmetry; rewrite <- Heq; exact Hex].
split; [rewrite <- inj_0; apply inj_gt; exact Hpos |
rewrite (Ins.insert_element_old l (k,e) cu H1 Hpos); split; reflexivity].
rewrite <- inj_0; apply inj_eq;
destruct (gt_O_eq (Raw_List.position l cu)) as [Hko|Hex];
[apply (Ins.insert_has_element_rev l (k,e) _ H1) in Hko;
contradict Hko; rewrite <- H1; rewrite <- inj_0 in Hipos;
apply inj_eq_rev in Hipos; rewrite Hipos; rewrite H1; apply gt_irrefl | 
symmetry; exact Hex].
repeat(rewrite find_find2);
apply (Ins.insert_find _ _ _ H1); simpl; intro Hww;
apply Hw; symmetry; exact Hww.
rewrite <- Hw; split; [exact Hfind|].
rewrite <- inj_0; apply inj_gt.
rewrite Ins.insert_find_new; [|exact H1].
apply Ins.insert_has_element_new.
exact Hfind.
Qed.

Definition delete : map -> cursor -> map.
exact Del.delete.
Defined.

Lemma delete_delete :
forall (l : map), forall (cu : cursor),
has_element_ l cu -> delete_ l cu (delete l cu).
intros l cu; unfold has_element_; unfold delete_; unfold delete;
unfold odelete; unfold delete_pos; unfold delete_inv; unfold delete_find;
unfold key_; unfold position_; unfold element_; unfold no_element;
unfold length_; unfold find_; unfold first_; simpl.
intro Hpos; split.
rewrite <- inj_0 in Hpos; apply inj_gt_rev in Hpos;
apply (Raw_List.has_element_position) in Hpos;
unfold witness.
apply (Del.delete_find_deleted _ _ Hpos).
split; [exact Hpos|].
assert (Z_of_nat (1) = 1). auto.
rewrite <- inj_0 in Hpos; apply inj_gt_rev in Hpos;
split.
apply Zplus_minus_eq; rewrite <- H; rewrite <- inj_plus;
apply inj_eq.
apply (Del.delete_length l cu Hpos).
split; [intro cun; split | split; [intro cun; split|]].
intro HH; apply inj_eq_rev in HH;
rewrite <- inj_0; apply inj_eq.
symmetry in HH; apply (Raw_List.position_eq l cu cun Hpos) in HH.
rewrite <- HH; apply (Del.delete_position_deleted l cu Hpos).
rewrite <- inj_0; intros [HH Hdiff]; apply inj_gt_rev in HH.
split; [|rewrite (Del.delete_element l _ _ Hpos HH); [split; reflexivity|
intro Heq; contradict Hdiff; rewrite Heq; reflexivity]].
apply inj_gt; apply Del.delete_position; [exact Hpos|exact HH|intro Heq;
contradict Hdiff; rewrite Heq; reflexivity].
rewrite <- inj_0; apply inj_gt.
apply (Del.delete_position_inv l cu cun Hpos);
apply inj_gt_rev; exact H0.
case_eq (beq_nat cun cu); intro Hneq;
[apply beq_nat_true in Hneq; rewrite Hneq in H0; contradict H0;
rewrite (Del.delete_position_deleted l cu Hpos); simpl;
apply Zgt_irrefl | apply beq_nat_false in Hneq].
rewrite <- inj_0 in H0; apply inj_gt_rev in H0;
rewrite (Del.delete_element l cu cun Hpos
(Del.delete_position_inv l cu cun Hpos H0) Hneq); split; reflexivity.
intros w; split.
intros Hw; rewrite (Del.delete_find l w cu Hpos);
[reflexivity|intro Heq; contradict Hw; rewrite Heq; reflexivity].
intro Heq; rewrite <- Heq; apply Del.delete_find_deleted;
apply Raw_List.has_element_position; exact Hpos.
Qed.

Definition replace : map -> key_t -> element_t -> map.
exact (fun m k e => hreplace m (k, e)).
Defined.

Lemma replace_replace :
forall (l : map), forall (k : key_t), forall (e : element_t),
contains_ l (witness k) ->
replace_ l k e (replace l k e).
unfold contains_; unfold replace_; unfold replace; unfold oreplace;
unfold key_; unfold find_; unfold element_; unfold witness;
unfold position_; unfold length_; unfold first_; simpl;
intros l k e; 
intro Hpos; split; [exact Hpos|].
rewrite <- inj_0 in Hpos; apply inj_gt_rev in Hpos; split.
apply inj_eq; apply Raw_List.replace_length.
split.
rewrite(Raw_List.replace_element_replaced l _ _ Hpos);
simpl; reflexivity.
split.
rewrite(Raw_List.replace_element_replaced l _ _ Hpos);
simpl; reflexivity.
split.
intro cun; split.
apply inj_eq.
apply Raw_List.replace_position.
intros Hdiff; rewrite(Raw_List.replace_element l _ _ cun);
[|intro HH; contradict Hdiff; symmetry; exact HH].
split; reflexivity.
intro w; case_eq (eq_real_bool w (Elt.witness k)).
intro Heq; apply beq_real_true in Heq; rewrite Heq.
repeat(rewrite find_find2).
rewrite <- (Raw_List.replace_element_replaced l _ (k,e) Hpos).
rewrite (Raw_List.replace_element_replaced _ _ _ Hpos).
unfold Raw_List.replace; simpl.
assert (k = fst (k, e)); [simpl| rewrite H;
rewrite (replace1_find_eq l _ (Raw_List.wf l))]; reflexivity.
assert (k = fst (k, e)); [simpl; reflexivity|];
intro Hdiff; apply beq_real_false in Hdiff; rewrite H at 1;
rewrite H at 3.
rewrite H in Hdiff.
repeat(rewrite find_find2); generalize (replace_find l w (k, e) Hdiff).
intro Heq; rewrite <- Heq; simpl; reflexivity.
Qed.

Definition replace_element : map -> cursor -> element_t -> map.
exact (fun m cu e => hreplace m (key_ m cu, e)).
Defined.

Lemma replace_element_replace_element :
forall (l : map), forall (cu : cursor), forall (e : element_t),
has_element_ l cu -> replace_element_ l cu e (replace_element l cu e).
intros l cu e; unfold has_element_; unfold replace_element_;
unfold replace_element; unfold hreplace; unfold position_;
unfold length_; unfold element_; unfold key_; unfold find_;
unfold first_; simpl.
intro Hpos; split; [exact Hpos|].
rewrite <- inj_0 in Hpos; rewrite <- inj_0;
apply inj_gt_rev in Hpos.
assert(cu = Raw_List.find l (Elt.witness (fst (Raw_List.element l cu)))).
apply (Raw_List.position_eq l cu _ Hpos).
rewrite (find_position_inv l (hwf l) cu Hpos);
reflexivity.
rewrite <- H.
split.
rewrite (Raw_List.replace_element_replaced l cu _ Hpos);
simpl; reflexivity.
split.
apply inj_eq.
apply Raw_List.replace_length.
split.
intro cun; split.
apply inj_eq.
rewrite Raw_List.replace_position; reflexivity.
intros Hpcun; apply inj_gt_rev in Hpcun.
split.
case_eq(beq_nat cu cun); intro Heq;
[apply beq_nat_true in Heq|apply beq_nat_false in Heq].
rewrite <- Heq;
rewrite (Raw_List.replace_element_replaced l cu _ Hpos);
simpl; reflexivity.
rewrite (Raw_List.replace_element l cu _ cun Heq);
simpl; reflexivity.
intro Heq; rewrite (Raw_List.replace_element l cu _ cun Heq);
simpl; reflexivity.
assert (fst (Raw_List.element l cu) = fst (fst (Raw_List.element l cu), e)).
simpl; reflexivity.
intro w; case_eq (eq_real_bool w 
(Elt.witness (fst (Raw_List.element l cu)))).
intro Heq; apply beq_real_true in Heq; rewrite Heq.
rewrite H0 at 3; rewrite <- (Raw_List.replace_element_replaced l cu
(fst (Raw_List.element l cu), e) Hpos).
apply (Raw_List.position_eq l);
[rewrite (find_position_inv l (hwf l));
simpl; exact Hpos|].
repeat(rewrite find_find2);
rewrite (find_position_inv l (hwf l)); simpl;
[|exact Hpos].
symmetry; rewrite <- (Raw_List.replace_position l cu
(fst (Raw_List.element l cu), e)).
rewrite (find_position_inv (Raw_List.replace l cu
(fst (Raw_List.element l cu), e))).
apply Raw_List.replace_position.
unfold Raw_List.replace; simpl;
rewrite H at 1. rewrite H0 at 1.
apply (WFh_replace1 l _ (Raw_List.wf l) (hwf l)).
rewrite Raw_List.replace_position; apply Hpos.
intro Hdiff; apply beq_real_false in Hdiff; rewrite H at 1.
rewrite H0.
symmetry; rewrite H0 in Hdiff.
generalize (replace_find l w (fst (Raw_List.element l cu), e) Hdiff).
intro Heq; exact Heq.
Qed.

Definition include : map -> key_t -> element_t -> map.
exact (fun m k e => hinclude m (k, e)).
Defined.

Lemma include_include :
forall (l : map), forall (k : key_t),
forall (e : element_t),
include__ l k e (include l k e).
unfold include__; unfold include; unfold find_; unfold position_;
unfold hinclude; unfold first_; unfold witness; simpl.
intros l k e; case_eq(beq_nat (Raw_List.find l (Elt.witness k)) O).
intro Heq; apply beq_nat_true in Heq.
split; [intro Hko; rewrite <- inj_0 in Hko; apply inj_gt_rev in Hko;
contradict Hko; rewrite Heq; rewrite Raw_List.position_no_element;
apply gt_irrefl|].
intros _; apply insert_insert.
unfold contains_; unfold position_; unfold find_; unfold first_;
unfold witness; simpl; rewrite Heq;
rewrite Raw_List.position_no_element; apply Zgt_irrefl.
intro Hdiff; apply beq_nat_false in Hdiff.
split;[|unfold no_element; intro Hko; contradict Hdiff; apply Hko].
intro Hpos; apply replace_replace.
unfold contains_; unfold position_; unfold find_; unfold first_;
unfold witness; simpl; exact Hpos.
Qed.

Definition exclude : map -> key_t -> map.
exact (fun m k => hexclude m (find_ m (witness k))).
Defined.

Lemma exclude_exclude :
forall (l : map), forall (k : key_t),
exclude_ l k (exclude l k).
unfold exclude_; unfold exclude; unfold find_; unfold position_;
unfold hexclude; unfold first_; unfold witness; simpl.
intros l k;
case_eq(beq_nat (Raw_List.find l (Elt.witness k)) O).
intro Heq; apply beq_nat_true in Heq.
split; [intro Hko; rewrite <- inj_0 in Hko; apply inj_gt_rev in Hko;
contradict Hko; rewrite Heq; rewrite Raw_List.position_no_element;
apply gt_irrefl|].
reflexivity.
intro Hdiff; apply beq_nat_false in Hdiff.
split;[|unfold no_element; intro Hko; contradict Hdiff; apply Hko].
intro Hpos; apply delete_delete.
unfold has_element_; unfold position_; simpl; exact Hpos.
Qed.

(*** MAX ***)

Module Type CompareType.

Parameter Inline compare : element_t -> element_t -> Z.

Axiom compare_refl :
forall e : element_t, (compare e e = 0)%Z.

Axiom compare_asym :
forall e1 : element_t, forall e2 : element_t,
(0 <= compare e1 e2 <-> compare e2 e1 <= 0)%Z.

Axiom compare_trans :
forall e1 : element_t, forall e2 : element_t, forall e3 : element_t,
(compare e1 e2 <= 0)%Z -> (compare e2 e3 <= 0)%Z ->
(compare e1 e3 <= 0)%Z.

End CompareType.

Module Compare (C : CompareType).

Module Compare.

Definition compare (e1 : (key_t*element_t))
(e2 : (key_t*element_t)) : Z :=
C.compare (snd e1) (snd e2).

Lemma compare_refl :
forall e : (key_t*element_t), (compare e e = 0)%Z.
intro e; unfold compare; apply C.compare_refl.
Qed.

Lemma compare_asym :
forall e1 : (key_t*element_t), forall e2 : (key_t*element_t),
(0 <= compare e1 e2 <-> compare e2 e1 <= 0)%Z.
intros e1 e2; unfold compare; apply C.compare_asym.
Qed.

Lemma compare_trans :
forall e1 : (key_t*element_t), forall e2 : (key_t*element_t),
forall e3 : (key_t*element_t),
(compare e1 e2 <= 0)%Z -> (compare e2 e3 <= 0)%Z ->
(compare e1 e3 <= 0)%Z.
intros e1 e2 e3; unfold compare; apply C.compare_trans.
Qed.

End Compare.

Definition compare_ : element_t -> element_t -> Z.
exact C.compare.
Defined.

Module Max_List := Raw_List.Max (Compare).

Definition is_max  (v:map) (cu:cursor)
  := (has_element_ v cu) /\
     (forall (cun:cursor),
      ((has_element_ v cun) -> (compare_ (element_ v cu) (element_ v cun)) >=
       0)).

Definition max_ : map -> cursor.
exact (Max_List.max).
Defined.

Lemma is_max_max :
  (forall (v:map), (~(is_empty_ v) -> (is_max v (max_ v)))).
intros l He; apply is_empty_length in He;
unfold is_max; unfold max_; unfold has_element_; unfold contains_;
unfold element_; unfold find_; unfold first_;
unfold position_.
split.
rewrite <- inj_0; apply inj_gt; apply Raw_List.position_has_element.
apply (Max_List.max_has_element l He).
intros e Hhfind;
rewrite <- inj_0 in Hhfind; apply inj_gt_rev in Hhfind.
apply (Raw_List.has_element_position) in Hhfind.
destruct (Compare.compare_asym (Raw_List.element l (Max_List.max l))
(Raw_List.element l e)) as [_ H];
apply Zle_ge; apply H; clear H.
apply (Max_List.max_element _ l Hhfind).
Qed.

End Compare.

(*** SUM_OF ***)

Module Type WeightType.

Parameter Inline weight : element_t -> nat.

End WeightType.

Module Weight (We : WeightType).

Module W.

Definition weight (e : key_t*element_t) : nat :=
We.weight (snd e).

End W.

Definition weight_ : (element_t) -> Z.
exact (fun e => Z_of_nat (We.weight e)).
Defined.

Lemma positive_weight :
  (forall (e:element_t), (weight_ e) >= 0).
intro e; unfold weight_; apply Zle_ge; apply Zle_0_nat.
Qed.

Module Sum_List := Sum_Of(W).
Import Sum_List.

Definition sum_of_weight : map -> Z.
exact (fun l => Z_of_nat (Sum_List.sum_of_weight l)).
Defined.

Lemma sum_of_weight_delete :
  (forall (v1:map),
   (forall (v2:map),
    (forall (cu:cursor),
     ((delete_ v1 cu v2) -> (sum_of_weight v2) =
      ((sum_of_weight v1) - (weight_ (element_ v1 cu))))))).
assert (Z_of_nat (1) = 1). auto.
intros l1 l2 cu; unfold delete_; unfold sum_of_weight;
unfold weight_; unfold delete_pos; unfold delete_inv;
unfold element_; unfold length_; unfold position_; unfold key_;
intros [Hfind[Hposcu[Hlgth[Hdpos Hdinv]]]]; apply Zplus_minus_eq.
rewrite <- inj_plus; apply inj_eq.
apply Sum_List.sum_of_delete.
apply Raw_List.has_element_position.
rewrite <- inj_0 in Hposcu; apply (inj_gt_rev _ _ Hposcu).
destruct (Hdpos cu) as [Hpcu _].
case_eq (Raw_List.has_element l2 cu); [|reflexivity].
intro Hhe; apply Raw_List.position_has_element in Hhe;
apply inj_gt in Hhe; contradict Hhe; 
rewrite (Hpcu (reflexivity (Z_of_nat (Raw_List.position l1 cu)))).
rewrite inj_0; apply Zgt_irrefl.
intros cun Hp; destruct (Hdpos cun) as [_ Hpcu].
intro Hdiff; assert (Z_of_nat (Raw_List.position l1 cun) <>
Z_of_nat (Raw_List.position l1 cu)).
intro Heq; contradict Hdiff; apply (Raw_List.position_eq l1 _ _ Hp);
apply inj_eq_rev; exact Heq.
apply inj_gt in Hp; destruct (Hpcu (conj Hp H0)) as [Hpe [He Hk]].
split; [apply inj_gt_rev; exact Hpe|apply injective_projections;
[exact He|exact Hk]].
destruct (Zeq_plus_swap (Z_of_nat (Raw_List.length l2))
(Z_of_nat (Raw_List.length l1)) 1) as [_ Hint]; apply Hint in Hlgth.
rewrite <- H in Hlgth; rewrite <- inj_plus in Hlgth;
apply inj_eq_rev in Hlgth; rewrite <- Hlgth.
rewrite <- plus_n_Sm; rewrite <- plus_n_O; reflexivity.
Qed.

Lemma sum_of_weight_insert :
  (forall (v1:map),
   (forall (v2:map),
    (forall (k:key_t),
     (forall (e:element_t),
      ((insert_ v1 k e v2) -> (sum_of_weight v2) =
       ((sum_of_weight v1) + (weight_ e))))))).
unfold insert_; unfold sum_of_weight; unfold weight_;
unfold insert_pos; unfold insert_inv;
unfold insert_find; unfold find_; unfold first_;
unfold position_; unfold key_; unfold element_; unfold length_;
unfold witness.
intros m1 m2 k e [Hfind2[Hlength[Hpos [Hinv Hfind]]]].
assert (Z_of_nat (1) = 1). auto.
destruct (gt_O_eq (Raw_List.position m1 (Raw_List.find
m2 (Elt.witness k)))) as [Hko|Hfind1].
apply inj_gt in Hko; rewrite inj_0 in Hko.
destruct (Hpos (Raw_List.find m2 (Elt.witness k)))
as [Hint _]; destruct (Hint Hko) as [_ [Hk Hel]]; clear Hint.
destruct (Hfind (Elt.witness k)) as [_ Hint];
destruct (Hint (reflexivity (Elt.witness k))) as [Hfind1 _];
clear Hint.
rewrite <- inj_0 in Hfind2; apply inj_gt_rev in Hfind2;
rewrite <- (Raw_List.find_element m2 _ Hfind2) in Hfind1.
generalize Hko; intro Hpos1;
rewrite <- Hk in Hfind1; contradict Hko.
rewrite <- inj_0 in Hpos1; apply inj_gt_rev in Hpos1;
rewrite <- (find_position_inv m1 (hwf m1) _ Hpos1).
repeat(rewrite <- find_find2); rewrite Hfind1.
rewrite Raw_List.position_no_element; apply Zgt_irrefl.
rewrite <- inj_plus;
rewrite (sum_of_insert_h m1 m2 (Raw_List.find m2 (Elt.witness k)) (k,e));
simpl.
rewrite plus_comm; reflexivity.
rewrite <- inj_0 in Hfind2; apply inj_gt_rev in Hfind2;
apply (Raw_List.has_element_position); exact Hfind2.
case_eq(Raw_List.has_element m1 (Raw_List.find m2
(Elt.witness k)));
[intro Hko; apply Raw_List.position_has_element in Hko|reflexivity].
contradict Hko; rewrite <- Hfind1; apply gt_irrefl.
apply inj_eq in Hfind1; rewrite inj_0 in Hfind1;
symmetry in Hfind1;
destruct (Hpos (Raw_List.find m2 (Elt.witness k) ))
as [_ Hint]; destruct (Hint Hfind1) as [Hko|[_ [Hk Hel]]]; clear Hint.
contradict Hfind2; rewrite Hko; apply Zgt_irrefl.
apply injective_projections; [exact Hk | exact Hel].
intros cun Hhem1cun.
apply Raw_List.position_has_element in Hhem1cun;
apply inj_gt in Hhem1cun; rewrite inj_0 in Hhem1cun.
destruct (Hpos cun) as [Hint _];
destruct (Hint Hhem1cun) as [Hp [Hk Hel]];
clear Hint.
split; [apply Raw_List.has_element_position|symmetry;
apply injective_projections; [exact Hk|exact Hel]].
apply inj_gt_rev; rewrite inj_0; exact Hp.
rewrite <- H in Hlength; rewrite <- inj_plus in Hlength;
apply inj_eq_rev in Hlength; rewrite plus_comm in Hlength;
exact Hlength.
Qed.

Lemma sum_of_weight_replace_element :
  (forall (v1:map),
   (forall (v2:map),
    (forall (cu:cursor),
     (forall (e:element_t),
      ((replace_element_ v1 cu e v2) -> (sum_of_weight v2) =
       ((sum_of_weight v1) + (weight_ e) - (weight_ (element_ v1 cu)))))))).
assert (Z_of_nat (1) = 1). auto.
intros l1 l2 cu e; unfold replace_element_; unfold sum_of_weight;
unfold weight_; unfold element_; unfold length_; unfold position_;
unfold key_.
intros [Hposcu[Hel[Hlgth [Hpos _]]]].
apply Zplus_minus_eq; repeat(rewrite <- inj_plus); apply inj_eq.
apply inj_eq_rev in Hlgth; rewrite <- inj_0 in Hposcu;
apply inj_gt_rev in Hposcu; rewrite <- inj_0 in Hpos; symmetry.
pattern((We.weight (snd (Raw_List.element l1 cu)) +
                            Sum_List.sum_of_weight l2)%nat);
rewrite (Sum_List.sum_of_replace l1 l2 cu
(fst(Raw_List.element l1 cu),e)).
rewrite plus_comm; reflexivity.
apply (Raw_List.has_element_position _ _ Hposcu).
apply inj_gt in Hposcu; rewrite inj_0 in Hposcu.
destruct (Hpos cu) as [_ Heleq];
destruct (Heleq Hposcu) as [Helfst _]; clear Heleq.
apply injective_projections; [exact Helfst|exact Hel].
intros cun Hposl1;
apply inj_gt in Hposl1; rewrite inj_0 in Hposl1.
destruct (Hpos cun) as [Hposeq Heleq];
destruct (Heleq Hposl1) as [Helfst Helsnd];
apply inj_eq_rev in Hposeq; rewrite <- Hposeq.
rewrite <- inj_0 in Hposl1; apply inj_gt_rev in Hposl1.
split; [exact Hposl1|intro Hdiff; apply injective_projections].
exact Helfst.
apply (Helsnd Hdiff).
symmetry; exact Hlgth.
Qed.

Lemma sum_of_weight_replace :
  (forall (v1:map),
   (forall (v2:map),
    (forall (k:key_t),
     (forall (e:element_t),
      ((replace_ v1 k e v2) -> (sum_of_weight v2) =
       ((sum_of_weight v1) + (weight_ e)
       - (weight_ (element__ v1 (witness k))))))))).
assert (Z_of_nat (1) = 1). auto.
intros l1 l2 k e; unfold replace_; unfold sum_of_weight;
unfold weight_; unfold element__; unfold length_; unfold position_;
unfold find_; unfold element_; unfold first_; unfold key_.
intros [Hposcu[Hlgth [Helfst [Helsnd [Hpos _]]]]].
apply Zplus_minus_eq; repeat(rewrite <- inj_plus); apply inj_eq.
apply inj_eq_rev in Hlgth; rewrite <- inj_0 in Hposcu;
apply inj_gt_rev in Hposcu;
pattern((We.weight (snd (Raw_List.element l1
(Raw_List.find l1 (witness k)))) + Sum_List.sum_of_weight l2)%nat);
rewrite (Sum_List.sum_of_replace l1 l2
(Raw_List.find l1 (witness k)) (k,e)).
rewrite plus_comm; reflexivity.
apply (Raw_List.has_element_position _ _ Hposcu).
apply injective_projections; [exact Helfst|exact Helsnd].
intros cun Hposl1; destruct (Hpos cun) as [Hposeq Heleq].
apply inj_eq_rev in Hposeq; rewrite Hposeq.
split; [exact Hposl1|intro Hdiff].
apply injective_projections; apply Heleq; intro Heq;
apply Hdiff; symmetry; exact Heq.
symmetry; exact Hlgth.
Qed.

Lemma sum_of_weight_null :
  (forall (v:map), ((is_empty_ v) -> (sum_of_weight v) = 0)).
unfold sum_of_weight;
intros l Hl; apply length_is_empty in Hl; unfold length_ in Hl.
rewrite <- inj_0; rewrite <- inj_0 in Hl; apply inj_eq;
apply inj_eq_rev in Hl; apply (Sum_List.sum_of_nil l Hl).
Qed.

Lemma sum_of_weight_equal :
  (forall (v1:map),
   (forall (v2:map),
    ((equivalent_ v1 v2) -> (sum_of_weight v1) = (sum_of_weight v2)))).
unfold equivalent_; unfold sum_of_weight; unfold element__;
unfold contains_; unfold position_; unfold find_; unfold length_;
unfold element_; unfold first_; intros l1 l2 [Hcu Hlgth].
apply inj_eq;
apply (sum_of_equivalent l1 l2); simpl.
apply inj_eq_rev; exact Hlgth.
intros w Hpos; apply inj_gt in Hpos; rewrite inj_0 in Hpos;
destruct (Hcu w Hpos) as [Hpos2 Hel]; clear Hcu. 
split.
apply inj_gt_rev; rewrite inj_0; exact Hpos2.
assert(We.weight
  (snd (Raw_List.element l1 (Raw_List.find l1 w))) =
We.weight
  (snd (Raw_List.element l2 (Raw_List.find l2 w)))).
rewrite Hel; reflexivity.
exact H.
Qed.

Lemma sum_of_weight_left :
  (forall (v:map),
   (forall (cu:cursor),
    ((has_element_ v cu) -> (sum_of_weight (left_ v (next_ v cu))) =
     ((sum_of_weight (left_ v cu)) + (weight_ (element_ v cu)))))).
unfold left_; unfold next_; unfold weight_; unfold has_element_;
unfold position_; unfold sum_of_weight; unfold hleft; intros l cu Hpos.
case_eq (beq_nat cu O); [intro HH; contradict Hpos;
apply beq_nat_true in HH; rewrite HH; rewrite <- inj_0;
rewrite Raw_List.position_no_element; apply Zgt_irrefl|simpl].
intros _; case_eq (beq_nat (Raw_List.next l cu) O); intro Heq; simpl.
assert(Raw_List.left l (Raw_List.next l cu) = l).
unfold Raw_List.left; rewrite Heq; reflexivity.
rewrite <- H at 1.
rewrite <- inj_plus; apply inj_eq; apply Sum_List.sum_of_left.
apply (Raw_List.has_element_position); apply inj_gt_rev;
rewrite inj_0; exact Hpos.
rewrite <- inj_plus; apply inj_eq; apply Sum_List.sum_of_left.
apply (Raw_List.has_element_position); apply inj_gt_rev;
rewrite inj_0; exact Hpos.
Qed.

Lemma sum_of_weight_right :
  (forall (v:map),
   (forall (cu:cursor),
    ((has_element_ v cu) -> (sum_of_weight (right_ v (next_ v cu))) =
     ((sum_of_weight (right_ v cu)) - (weight_ (element_ v cu)))))).
unfold right_; unfold next_; unfold weight_; unfold has_element_;
unfold position_; unfold sum_of_weight; unfold hright; intros l cu Hpos.
case_eq (beq_nat cu O); [intro HH; contradict Hpos;
apply beq_nat_true in HH; rewrite HH; rewrite <- inj_0;
rewrite Raw_List.position_no_element; apply Zgt_irrefl|simpl].
intros _; case_eq (beq_nat (Raw_List.next l cu) O); intro Heq; simpl.
assert(Sum_List.sum_of_weight(Raw_List.right l (Raw_List.next l cu)) = O).
unfold Raw_List.right; rewrite Heq; reflexivity.
rewrite <- inj_0; rewrite <- H at 1.
apply Zplus_minus_eq; symmetry.
rewrite <- inj_plus; apply inj_eq; apply Sum_List.sum_of_right.
apply (Raw_List.has_element_position); apply inj_gt_rev;
rewrite inj_0; exact Hpos.
apply Zplus_minus_eq; symmetry.
rewrite <- inj_plus; apply inj_eq; apply Sum_List.sum_of_right.
apply (Raw_List.has_element_position); apply inj_gt_rev;
rewrite inj_0; exact Hpos.
Qed.

End Weight.

End HMap.

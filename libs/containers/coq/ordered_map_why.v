(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)

Require Import Reals.

(*Why logic*) Definition lt_real : R -> R -> Prop.
Admitted.

(*Why logic*) Definition le_real : R -> R -> Prop.
Admitted.

(*Why logic*) Definition gt_real : R -> R -> Prop.
Admitted.

(*Why logic*) Definition ge_real : R -> R -> Prop.
Admitted.

(*Why logic*) Definition eq_real : R -> R -> Prop.
Admitted.

(*Why logic*) Definition neq_real : R -> R -> Prop.
Admitted.

(*Why logic*) Definition add_real : R -> R -> R.
Admitted.

(*Why logic*) Definition sub_real : R -> R -> R.
Admitted.

(*Why logic*) Definition mul_real : R -> R -> R.
Admitted.

(*Why logic*) Definition div_real : R -> R -> R.
Admitted.

(*Why logic*) Definition neg_real : R -> R.
Admitted.

(*Why logic*) Definition real_of_int : Z -> R.
Admitted.

(*Why axiom*) Lemma real_of_int_zero : (eq (IZR 0) (0)%R).
Admitted.

(*Why axiom*) Lemma real_of_int_one : (eq (IZR 1) (1)%R).
Admitted.

(*Why axiom*) Lemma real_of_int_add :
  (forall (x:Z), (forall (y:Z), (eq (IZR (x + y)) (Rplus (IZR x) (IZR y))))).
Admitted.

(*Why axiom*) Lemma real_of_int_sub :
  (forall (x:Z), (forall (y:Z), (eq (IZR (x - y)) (Rminus (IZR x) (IZR y))))).
Admitted. 

(*Why logic*) Definition truncate_real_to_int : R -> Z.
Admitted.

(*Why axiom*) Lemma truncate_down_pos :
  (forall (x:R),
   ((Rge x (0)%R) -> (Rle (IZR (truncate_real_to_int x)) x) /\
    (Rlt x (IZR ((truncate_real_to_int x) + 1))))).
Admitted.

(*Why axiom*) Lemma truncate_up_neg :
  (forall (x:R),
   ((Rle x (0)%R) -> (Rlt (IZR ((truncate_real_to_int x) - 1)) x) /\
    (Rle x (IZR (truncate_real_to_int x))))).
Admitted.

(*Why logic*) Definition floor_real_to_int : R -> Z.
Admitted.

(*Why logic*) Definition ceil_real_to_int : R -> Z.
Admitted.

(*Why logic*) Definition lt_real_bool : R -> R -> bool.
Admitted.

(*Why logic*) Definition le_real_bool : R -> R -> bool.
Admitted.

(*Why logic*) Definition gt_real_bool : R -> R -> bool.
Admitted.

(*Why logic*) Definition ge_real_bool : R -> R -> bool.
Admitted.

(*Why logic*) Definition eq_real_bool : R -> R -> bool.
Admitted.

(*Why logic*) Definition neq_real_bool : R -> R -> bool.
Admitted.

(*Why axiom*) Lemma lt_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((lt_real_bool x y) = true <-> (Rlt x y)))).
Admitted.

(*Why axiom*) Lemma le_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((le_real_bool x y) = true <-> (Rle x y)))).
Admitted.

(*Why axiom*) Lemma gt_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((gt_real_bool x y) = true <-> (Rgt x y)))).
Admitted.

(*Why axiom*) Lemma ge_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((ge_real_bool x y) = true <-> (Rge x y)))).
Admitted.

(*Why axiom*) Lemma eq_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((eq_real_bool x y) = true <-> (eq x y)))).
Admitted.

(*Why axiom*) Lemma neq_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((neq_real_bool x y) = true <-> ~(eq x y)))).
Admitted.

(*Why logic*) Definition real_max : R -> R -> R.
Admitted.

(*Why logic*) Definition real_min : R -> R -> R.
Admitted.

(*Why axiom*) Lemma real_max_is_ge :
  (forall (x:R),
   (forall (y:R), (Rge (real_max x y) x) /\ (Rge (real_max x y) y))).
Admitted.

(*Why axiom*) Lemma real_max_is_some :
  (forall (x:R),
   (forall (y:R), (eq (real_max x y) x) \/ (eq (real_max x y) y))).
Admitted.

(*Why axiom*) Lemma real_min_is_le :
  (forall (x:R),
   (forall (y:R), (Rle (real_min x y) x) /\ (Rle (real_min x y) y))).
Admitted.

(*Why axiom*) Lemma real_min_is_some :
  (forall (x:R),
   (forall (y:R), (eq (real_min x y) x) \/ (eq (real_min x y) y))).
Admitted.

(*Why function*) Definition sqr_real  (x:R) := (Rmult x x).

(*Why logic*) Definition sqrt_real : R -> R.
Admitted.

(*Why axiom*) Lemma sqrt_pos :
  (forall (x:R), ((Rge x (0)%R) -> (Rge (sqrt x) (0)%R))).
Admitted.

(*Why axiom*) Lemma sqrt_sqr :
  (forall (x:R), ((Rge x (0)%R) -> (eq (sqr_real (sqrt x)) x))).
Admitted.

(*Why axiom*) Lemma sqr_sqrt :
  (forall (x:R), ((Rge x (0)%R) -> (eq (sqrt (Rmult x x)) x))).
Admitted.

(*Why logic*) Definition pow_real : R -> R -> R.
Admitted.

(*Why logic*) Definition abs_real : R -> R.
Admitted.

(*Why axiom*) Lemma abs_real_pos :
  (forall (x:R), ((Rge x (0)%R) -> (eq (Rabs x) x))).
Admitted.

(*Why axiom*) Lemma abs_real_neg :
  (forall (x:R), ((Rle x (0)%R) -> (eq (Rabs x) (Ropp x)))).
Admitted.

(*Why logic*) Definition exp : R -> R.
Admitted.

(*Why logic*) Definition log : R -> R.
Admitted.

(*Why logic*) Definition log10 : R -> R.
Admitted.

(*Why axiom*) Lemma log_exp : (forall (x:R), (eq (log (exp x)) x)).
Admitted.

(*Why axiom*) Lemma exp_log :
  (forall (x:R), ((Rgt x (0)%R) -> (eq (exp (log x)) x))).
Admitted.

(*Why logic*) Definition cos : R -> R.
Admitted.

(*Why logic*) Definition sin : R -> R.
Admitted.

(*Why logic*) Definition tan : R -> R.
Admitted.

(*Why logic*) Definition pi : R.
Admitted.

(*Why logic*) Definition cosh : R -> R.
Admitted.

(*Why logic*) Definition sinh : R -> R.
Admitted.

(*Why logic*) Definition tanh : R -> R.
Admitted.

(*Why logic*) Definition acos : R -> R.
Admitted.

(*Why logic*) Definition asin : R -> R.
Admitted.

(*Why logic*) Definition atan : R -> R.
Admitted.

(*Why logic*) Definition atan2 : R -> R -> R.
Admitted.

(*Why logic*) Definition hypot : R -> R -> R.
Admitted.

(*Why axiom*) Lemma prod_pos :
  (forall (x:R),
   (forall (y:R),
    (((Rgt x (0)%R) /\ (Rgt y (0)%R) -> (Rgt (Rmult x y) (0)%R))) /\
    (((Rlt x (0)%R) /\ (Rlt y (0)%R) -> (Rgt (Rmult x y) (0)%R))))).
Admitted.

(*Why axiom*) Lemma abs_minus :
  (forall (x:R), (eq (Rabs (Ropp x)) (Rabs x))).
Admitted.

(**************************************************************************)
Require "set_raw".
Require Import ZArith.
Open Scope Z_scope.

Module Type Element_Type.

Parameter Inline key_t : Set.

Parameter Inline k_nl : key_t.

Parameter Inline element_t : Set.

Parameter Inline e_nl : element_t.

Parameter Inline witness : key_t -> R.

End Element_Type.

Module OMap (Elt : Element_Type).

Module ROrder.

Definition lt_real_bool : R -> R -> bool := lt_real_bool.

Definition le_real_bool : R -> R -> bool := le_real_bool.

Definition gt_real_bool : R -> R -> bool := gt_real_bool.

Definition ge_real_bool : R -> R -> bool := ge_real_bool.

Definition eq_real_bool : R -> R -> bool := eq_real_bool.

Definition neq_real_bool : R -> R -> bool := neq_real_bool.

Lemma lt_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((lt_real_bool x y) = true <-> (Rlt x y)))).
apply lt_real_bool_axiom.
Qed.

Lemma le_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((le_real_bool x y) = true <-> (Rle x y)))).
apply le_real_bool_axiom.
Qed.

Lemma gt_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((gt_real_bool x y) = true <-> (Rgt x y)))).
apply gt_real_bool_axiom.
Qed.

Lemma ge_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((ge_real_bool x y) = true <-> (Rge x y)))).
apply ge_real_bool_axiom.
Qed.

Lemma eq_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((eq_real_bool x y) = true <-> (eq x y)))).
apply eq_real_bool_axiom.
Qed.

Lemma neq_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((neq_real_bool x y) = true <-> ~(eq x y)))).
apply neq_real_bool_axiom.
Qed.

End ROrder.

Module Element.

Definition element_t : Set := prod Elt.key_t Elt.element_t.

Definition e_nl : element_t := (Elt.k_nl, Elt.e_nl).

Definition witness (e : element_t) : R := Elt.witness (fst e).

End Element.

Module Raw_Set := (set_raw.Raw_Set (Element)) (ROrder).
Import Raw_Set.

(*Why type*) Definition cursor: Set.
exact Raw_List.cursor.
Defined.

(*Why type*) Definition key_t: Set.
exact Elt.key_t.
Defined.

(*Why type*) Definition element_t: Set.
exact Elt.element_t.
Defined.

(*Why type*) Definition map: Set.
exact oset.
Defined.

(*Why logic*) Definition no_element : cursor.
exact O.
Defined.

(*Why logic*) Definition empty_ : map.
exact oempty.
Defined.

(*Why logic*) Definition length_ : map -> Z.
exact (fun l => Z_of_nat (Raw_List.length l)).
Defined.

(*Why axiom*) Lemma length_gte_zero : (forall (co:map), 0 <= (length_ co)).
intro l; unfold length_.
apply Zle_0_nat.
Qed.

(*Why logic*) Definition witness : key_t -> R.
exact Elt.witness.
Defined.

(*Why logic*) Definition lt_ : key_t -> key_t -> bool.
exact (fun k1 k2 => lt_real_bool (witness k1) (witness k2)).
Defined.

(*Why axiom*) Lemma lt_witness :
  (forall (k1:key_t),
   (forall (k2:key_t),
    ((lt_ k1 k2) = true <-> (Rlt (witness k1) (witness k2))))).
unfold lt_; intros k1 k2.
apply lt_real_bool_axiom.
Qed.

(*Why logic*) Definition position_ : map -> cursor -> Z.
exact (fun l cu => Z_of_nat(Raw_List.position l cu)).
Defined.

(*Why axiom*) Lemma position_gte_zero :
  (forall (co:map),
   (forall (cu:cursor), 0 <= (position_ co cu) /\ (position_ co cu) <=
    (length_ co))).
unfold position_.
unfold length_.
split.
apply Zle_0_nat.
apply inj_le; simpl.
apply Raw_List.position_length.
Qed.

(*Why axiom*) Lemma position_no_element :
  (forall (co:map), (position_ co no_element) = 0).
intro l; unfold position_; unfold no_element;
rewrite <- inj_0; apply inj_eq.
apply Raw_List.position_no_element.
Qed.

(*Why axiom*) Lemma position_eq :
  (forall (co:map),
   (forall (cu1:cursor),
    (forall (cu2:cursor),
     ((position_ co cu1) > 0 ->
      ((position_ co cu1) = (position_ co cu2) -> cu1 = cu2))))).
intros l cu1 cu2; unfold position_; rewrite <- inj_0;
intros Hpos Heq.
apply inj_gt_rev in Hpos.
apply inj_eq_rev in Heq.
apply (Raw_List.position_eq l cu1 cu2 Hpos Heq).
Qed.

(*Why predicate*) Definition is_empty_  (co:map)
  := (forall (cu:cursor), (position_ co cu) = 0).

(*Why axiom*) Lemma length_is_empty :
  (forall (co:map), ((is_empty_ co) -> (length_ co) = 0)).
intro l; unfold is_empty_; unfold length_; unfold position_.
intro H; rewrite <- inj_0; apply inj_eq;
apply Raw_List.length_position.
intro cu; apply inj_eq_rev; rewrite inj_0; apply H.
Qed.

(*Why axiom*) Lemma empty_is_empty : (is_empty_ empty_).
unfold is_empty_; unfold empty_; unfold position_;
unfold Raw_List.empty; simpl; auto.
Qed.

(*Why predicate*) Definition previous__  (co:map) (cu1:cursor) (cu2:cursor)
  := (((position_ co cu1) > 1 -> (position_ co cu2) =
       ((position_ co cu1) - 1))) /\
     (((position_ co cu1) = 1 \/ cu1 = no_element -> cu2 = no_element)).

(*Why logic*) Definition previous_ : map -> cursor -> cursor.
exact Raw_List.previous.
Defined.

(*Why axiom*) Lemma previous_previous :
  (forall (co:map),
   (forall (cu:cursor), (previous__ co cu (previous_ co cu)))).
unfold previous_; unfold previous__;
unfold position_; unfold no_element.
intros l cu.
assert (Z_of_nat (1) = 1).
auto.
split.
intro HH.
rewrite <- H in HH;
apply inj_gt_rev in HH;
rewrite <- H;
rewrite <- (inj_minus1 (Raw_List.position l cu) 1
(gt_S_le 1 (Raw_List.position l cu)
(gt_trans (S (Raw_List.position l cu)) (Raw_List.position l cu) 1
(gt_Sn_n (Raw_List.position l cu)) HH)));
apply inj_eq.
apply Raw_List.position_previous_gen;
exact HH.
intros [HH | HH].
rewrite <- H in HH; apply inj_eq_rev in HH.
apply Raw_List.position_previous_first; exact HH.
rewrite HH; apply Raw_List.previous_O.
Qed.

(*Why predicate*) Definition next__  (co:map) (cu1:cursor) (cu2:cursor)
  := (((length_ co) > (position_ co cu1) /\ (position_ co cu1) > 0 \/
       (position_ co cu2) > 0 -> (position_ co cu2) =
       ((position_ co cu1) + 1))) /\
     (((length_ co) > 0 /\ (position_ co cu1) = (length_ co) \/
       cu1 = no_element -> cu2 = no_element)).

(*Why logic*) Definition next_ : map -> cursor -> cursor.
exact Raw_List.next.
Defined.

(*Why axiom*) Lemma next_next :
  (forall (co:map), (forall (cu:cursor), (next__ co cu (next_ co cu)))).
intros l cu; unfold next__; unfold next_; unfold position_;
unfold no_element; unfold length_.
assert (Z_of_nat (1) = 1).
auto.
split.
intros HH.
destruct HH as [[Hlength Hpos] | HH];
[apply inj_gt_rev in Hlength;
rewrite <- inj_0 in Hpos; apply inj_gt_rev in Hpos|
rewrite <- inj_0 in HH; apply inj_gt_rev in HH;
apply Raw_List.next_has_element_inv in HH;
destruct HH as [Hpos Hlength]];
rewrite <- H; rewrite <- inj_plus;
apply inj_eq;
apply (Raw_List.next_position_gen l cu Hlength Hpos).
intros [[_ HH] | HH]; [apply inj_eq_rev in HH |].
apply Raw_List.next_position_last; exact HH.
rewrite HH; apply Raw_List.next_position_O.
Qed.

(*Why predicate*) Definition last__  (co:map) (cu:cursor)
  := ((~(is_empty_ co) -> (position_ co cu) = (length_ co))) /\
     (((is_empty_ co) -> cu = no_element)).

(*Why logic*) Definition last_ : map -> cursor.
exact Raw_List.last.
Defined.

(*Why axiom*) Lemma last_last : (forall (co:map), (last__ co (last_ co))).
intro l; unfold last__; unfold last_; unfold is_empty_; unfold position_;
unfold length_; unfold no_element.
split; [intros; apply inj_eq | intros H; apply length_is_empty in H;
rewrite <- inj_0 in H;
apply inj_eq_rev in H].
apply Raw_List.position_last_gen.
apply Raw_List.last_nil; exact H.
Qed.

(*Why predicate*) Definition first__  (co:map) (cu:cursor)
  := ((~(is_empty_ co) -> (position_ co cu) = 1)) /\
     (((is_empty_ co) -> cu = no_element)).

(*Why logic*) Definition first_ : map -> cursor.
exact Raw_List.first.
Defined.

Lemma is_empty_length : 
forall l : map, not (is_empty_ l) -> (Raw_List.length l <> 0)%nat.
unfold is_empty_; unfold length_; unfold position_;
intros l H.
intro Hl; apply H.
intro cu; rewrite <- inj_0; apply inj_eq.
symmetry; apply le_n_O_eq.
rewrite <- Hl.
apply Raw_List.position_length.
Qed.

(*Why axiom*) Lemma first_first :
  (forall (co:map), (first__ co (first_ co))).
intro l; unfold first__; unfold first_; unfold position_;
unfold no_element; unfold length_.
assert (Z_of_nat (1) = 1).
auto.
split;
[rewrite <- H; intro HH; apply inj_eq;
apply is_empty_length in HH |
unfold is_empty_; unfold length_; unfold position_;
intros Hl; apply length_is_empty in Hl;
rewrite <- inj_0 in Hl; apply inj_eq_rev in Hl].
apply Raw_List.position_first_gen; exact HH.
apply Raw_List.first_nil; exact Hl.
Qed.

(*Why logic*) Definition key_ : map -> cursor -> key_t.
exact (fun m cu => fst (Raw_List.element m cu)).
Defined.

(*Why logic*) Definition find_ : map -> R -> cursor.
exact Raw_List.find.
Defined.

(*Why predicate*) Definition find__  (co:map) (i:R) (cu:cursor)
  := cu = no_element /\
     (forall (cun:cursor),
      ((position_ co cun) > 0 -> ~(eq (witness (key_ co cun)) i))) \/
     (position_ co cu) > 0 /\ (eq (witness (key_ co cu)) i) /\
     (forall (cun:cursor),
      ((position_ co cun) > 0 ->
       (~(cu = cun) -> ~(eq (witness (key_ co cun)) i)))).

(*Why axiom*) Lemma find_find_val :
  (forall (co:map),
   (forall (i:R), (find__ co i (find_ co i)) /\
    (((is_empty_ co) -> (find_ co i) = no_element)))).
intros m r; unfold find__; unfold find_; unfold is_empty_;
unfold position_; unfold no_element; unfold key_; unfold first_.
split.
destruct (gt_O_eq (Raw_List.position m (Raw_List.find m r
))) as [Hf | Hf];
[right | left]; split.
rewrite <- inj_0; apply inj_gt; exact Hf.
split.
apply Raw_List.find_element; exact Hf.
intros cun Hpos Hs Hw.
contradict Hs.
rewrite <- Hw.
apply (Raw_List.position_eq m); [rewrite Hw; exact Hf|].
rewrite <- inj_0 in Hpos; apply inj_gt_rev in Hpos.
apply (find_position_inv m (ordered_hashed m (owf m)) cun Hpos).
apply (Raw_List.find_position); symmetry; exact Hf.
symmetry in Hf; apply Raw_List.find_position in Hf.
intros cun Hpos Hw; rewrite <- inj_0 in Hpos;
apply inj_gt_rev in Hpos; rewrite <- Hw in Hf.
destruct (gt_O_eq (Raw_List.position m
                      (Raw_List.find m
                          (witness
                             (fst (Raw_List.element m cun)))
))) as [Hpf|Hpf].
simpl in Hpf;
rewrite Hf in Hpf; rewrite Raw_List.position_no_element in Hpf;
contradict Hpf; apply gt_irrefl.
unfold witness in Hpf;
rewrite (find_position_inv m (ordered_hashed m (owf m)) cun Hpos) in Hpf;
contradict Hpos; simpl in Hpf; rewrite <- Hpf; apply gt_irrefl.
intros Hemp; apply length_is_empty in Hemp.
unfold length_ in Hemp; rewrite <- inj_0 in Hemp;
apply inj_eq_rev in Hemp.
apply (Raw_List.find_nil m _ Hemp).
Qed.

(*Why axiom*) Lemma ordered :
  (forall (s:map),
   (forall (cu1:cursor),
    (forall (cu2:cursor),
     ((position_ s cu1) > 0 /\ (position_ s cu2) > 0 ->
      ((position_ s cu2) > (position_ s cu1) <->
       (Rgt (witness (key_ s cu2)) (witness (key_ s cu1)))))))).
unfold position_; unfold witness; unfold key_;
intros s cu1 cu2 [Hp1 Hp2]; rewrite <- inj_0 in Hp1;
rewrite <- inj_0 in Hp2; apply inj_gt_rev in Hp1;
apply inj_gt_rev in Hp2; split.
intro Hsup; apply inj_gt_rev in Hsup.
apply (po_el_order s cu1 cu2 Hp1 Hp2 Hsup).
intro Hel; apply inj_gt.
apply (el_po_order s cu1 cu2 Hp1 Hp2 Hel).
Qed.

(*Why logic*) Definition element_ : map -> cursor -> element_t.
exact (fun m cu => snd (Raw_List.element m cu)).
Defined.

(*Why function*) Definition element__  (m:map) (i:R)
  := (element_ m (find_ m i)).

(*Why predicate*) Definition left_pos  (co:map) (i:Z) (col:map)
  := (forall (cu:cursor),
      ((i <= (position_ co cu) -> (position_ col cu) = 0)) /\
      ((i > (position_ co cu) -> (position_ col cu) = (position_ co cu))) /\
      (((position_ col cu) > 0 -> (position_ co cu) = (position_ col cu)))) /\
     (forall (cu:cursor),
      ((position_ co cu) < i -> (key_ col cu) = (key_ co cu))) /\
     (forall (cu:cursor),
      ((position_ co cu) < i -> (element_ col cu) = (element_ co cu))).

(*Why predicate*) Definition left_find  (co:map) (i:Z) (col:map)
  := (forall (w:R),
      (i > (position_ co (find_ co w)) /\ (position_ co (find_ co w)) > 0 \/
       (position_ col (find_ col w)) > 0 -> (find_ co w) = (find_ col w))).

(*Why predicate*) Definition left__  (co:map) (cu:cursor) (col:map)
  := ((cu = no_element -> col = co)) /\
     (((position_ co cu) > 0 -> (length_ col) = ((position_ co cu) - 1) /\
       (left_pos co (position_ co cu) col) /\
       (left_find co (position_ co cu) col))).

(*Why logic*) Definition left_ : map -> cursor -> map.
exact oleft.
Defined.

(*Why axiom*) Lemma left_left :
  (forall (co:map), (forall (cu:cursor), (left__ co cu (left_ co cu)))).
intros m cu; unfold left__; unfold left_; unfold left_pos;
unfold left_find; unfold find_; unfold position_; unfold length_;
unfold no_element; unfold key_; unfold element_; unfold first_.
split.
intro HO; rewrite  HO; unfold oleft; simpl; reflexivity.
unfold oleft; case_eq (beq_nat cu O); [intros Heq Hko;
apply beq_nat_true in Heq; rewrite Heq in Hko;
rewrite (Raw_List.position_no_element) in Hko; rewrite <- inj_0 in Hko;
apply inj_gt_rev in Hko; contradict Hko; apply gt_irrefl|intros _].
assert (Z_of_nat (1) = 1). auto.
intro Hpos; rewrite <- inj_0 in Hpos; apply inj_gt_rev in Hpos;
split.
rewrite <- H.
rewrite <- (inj_minus1 (Raw_List.position m cu) 1
(gt_le_S 0 (Raw_List.position m cu) Hpos)); apply inj_eq.
apply (Raw_List.left_length m cu Hpos).
split.
split; [|split]; intro cun.
split; [|split].
intro HH; apply inj_le_rev in HH;
rewrite <- inj_0; apply inj_eq.
apply (Raw_List.left_position_out m cu Hpos cun HH).
intro HH; apply inj_gt_rev in HH.
apply inj_eq.
apply (Raw_List.left_position_in m cu Hpos cun HH).
intro HH; rewrite <- inj_0 in HH; apply inj_gt_rev in HH;
apply inj_eq.
apply (Raw_List.left_position_inv m cu Hpos cun HH).
intro HH; apply Zlt_gt in HH; apply inj_gt_rev in HH.
apply (Raw_List.left_element_in m cu Hpos cun) in HH.
simpl; rewrite HH; split; reflexivity.
intro HH; apply Zlt_gt in HH; apply inj_gt_rev in HH.
apply (Raw_List.left_element_in m cu Hpos cun) in HH.
simpl; rewrite HH; split; reflexivity.
intros w [[Hsup Hpf] | Hpf].
rewrite <- inj_0 in Hpf; apply inj_gt_rev in Hsup;
apply inj_gt_rev in Hpf.
apply (left_find_in m cu w Hpos Hsup).
rewrite <- inj_0 in Hpf; apply inj_gt_rev in Hpf.
apply (left_find_rev m cu w Hpos Hpf).
Qed.

(*Why predicate*) Definition right_pos  (co:map) (i:Z) (cor:map)
  := (forall (cu:cursor),
      ((i > (position_ co cu) -> (position_ cor cu) = 0)) /\
      ((i <= (position_ co cu) -> (position_ cor cu) =
        ((position_ co cu) - i + 1))) /\
      (((position_ cor cu) > 0 -> (position_ co cu) =
        ((position_ cor cu) + i - 1)))) /\
     (forall (cu:cursor),
      ((position_ cor cu) > 0 -> (key_ cor cu) = (key_ co cu))) /\
     (forall (cu:cursor),
      ((position_ cor cu) > 0 -> (element_ cor cu) = (element_ co cu))).

(*Why predicate*) Definition right_find  (co:map) (i:Z) (cor:map)
  := (forall (w:R),
      (i > 0 /\ i <= (position_ co (find_ co w)) \/
       (position_ cor (find_ cor w)) > 0 -> (find_ co w) = (find_ cor w))).

(*Why predicate*) Definition right__  (co:map) (cu:cursor) (cor:map)
  := ((cu = no_element -> cor = empty_)) /\
     (((position_ co cu) > 0 -> (length_ cor) =
       ((length_ co) - (position_ co cu) + 1) /\
       (right_pos co (position_ co cu) cor) /\
       (right_find co (position_ co cu) cor))) /\
     (forall (cun:cursor),
      ((position_ cor cun) > 0 -> (position_ co cun) > 0)).

(*Why logic*) Definition right_ : map -> cursor -> map.
exact oright.
Defined.

(*Why axiom*) Lemma right_right :
  (forall (co:map), (forall (cu:cursor), (right__ co cu (right_ co cu)))).
intros m cu; unfold right__; unfold right_pos; unfold right_find;
unfold right_; unfold find_; unfold position_; unfold length_;
unfold no_element; unfold key_; unfold element_; unfold empty_;
unfold oright; unfold first_.
assert (Z_of_nat (1) = 1). auto.
split; [intro HH; rewrite HH; unfold oright; simpl; reflexivity|].
split.
unfold hleft; case_eq (beq_nat cu O); [intros Heq Hko;
apply beq_nat_true in Heq; rewrite Heq in Hko;
rewrite (Raw_List.position_no_element) in Hko; rewrite <- inj_0 in Hko;
apply inj_gt_rev in Hko; contradict Hko; apply gt_irrefl|intros _].
intro Hpos; rewrite <- inj_0 in Hpos; apply inj_gt_rev in Hpos;
split.
rewrite <- (inj_minus1 (Raw_List.length m) (Raw_List.position m cu)
(Raw_List.position_length m cu));
rewrite <- H; rewrite <- inj_plus; apply inj_eq.
simpl; apply (Raw_List.right_length m cu Hpos).
split.
split; [|split]; intro cun.
split; [|split].
intro Hs; apply inj_gt_rev in Hs; rewrite <- inj_0;
apply inj_eq.
apply (Raw_List.right_position_out m cu Hpos cun Hs).
intro Hs; apply inj_le_rev in Hs.
rewrite <- H;
rewrite <- (inj_minus1 (Raw_List.position m cun) (Raw_List.position m cu) Hs);
rewrite <- inj_plus; apply inj_eq.
apply (Raw_List.right_position_in m cu Hpos cun Hs).
intro HH; rewrite <- inj_0 in HH; apply inj_gt_rev in HH.
rewrite <- H;
rewrite <- inj_plus.
rewrite <- (inj_minus1 _ 1 (gt_le_S _ _
(le_gt_trans _ _ _ (le_plus_l _ _) HH))).
apply inj_eq.
apply (Raw_List.right_position_inv m cu Hpos cun HH).
intro Hs; rewrite <- inj_0 in Hs;apply inj_gt_rev in Hs.
destruct (le_gt_dec (Raw_List.position m cu) (Raw_List.position m cun))
as [Hinf|Hsup].
apply (Raw_List.right_element_in m cu Hpos cun) in Hinf.
simpl; rewrite Hinf; split; reflexivity.
apply (Raw_List.right_position_out m cu Hpos cun) in Hsup.
contradict Hs; simpl; rewrite Hsup; apply gt_irrefl.
intro Hs; rewrite <- inj_0 in Hs;apply inj_gt_rev in Hs.
destruct (le_gt_dec (Raw_List.position m cu) (Raw_List.position m cun))
as [Hinf|Hsup].
apply (Raw_List.right_element_in m cu Hpos cun) in Hinf.
simpl; rewrite Hinf; split; reflexivity.
apply (Raw_List.right_position_out m cu Hpos cun) in Hsup.
contradict Hs; simpl; rewrite Hsup; apply gt_irrefl.
intros w [[_ Hinf] | Hpf].
apply inj_le_rev in Hinf.
apply (right_find_in m cu w Hpos Hinf).
rewrite <- inj_0 in Hpf; apply inj_gt_rev in Hpf.
apply (right_find_rev (to_hashed m) cu w Hpos Hpf).
case (beq_nat cu 0); simpl.
intros cun Hko; contradict Hko; apply Zgt_irrefl.
intros cun Hpos; rewrite <- inj_0 in Hpos;
apply inj_gt_rev in Hpos; rewrite <- inj_0;
apply inj_gt.
apply (Raw_List.has_element_right m cu cun Hpos).
Qed.

(*Why predicate*) Definition replace_  (co1:map) (k:key_t) (e:element_t) (co2:map)
  := (position_ co1 (find_ co1 (witness k))) > 0 /\ (length_ co1) =
     (length_ co2) /\ (key_ co2 (find_ co1 (witness k))) = k /\
     (element_ co2 (find_ co1 (witness k))) = e /\
     (forall (cun:cursor), (position_ co2 cun) = (position_ co1 cun)) /\
     (forall (cun:cursor),
      ((position_ co1 cun) > 0 /\ ~cun = (find_ co1 (witness k)) ->
       (key_ co2 cun) = (key_ co1 cun))) /\
     (forall (cun:cursor),
      ((position_ co1 cun) > 0 /\ ~cun = (find_ co1 (witness k)) ->
       (element_ co2 cun) = (element_ co1 cun))) /\
     (forall (w:R), (find_ co1 w) = (find_ co2 w)).

(*Why predicate*) Definition replace_element_  (co1:map) (cu:cursor) (e:element_t) (co2:map)
  := (position_ co1 cu) > 0 /\ (element_ co2 cu) = e /\ (length_ co1) =
     (length_ co2) /\
     (forall (cun:cursor), (position_ co1 cun) = (position_ co2 cun)) /\
     (forall (cun:cursor),
      ((position_ co1 cun) > 0 -> (key_ co2 cun) = (key_ co1 cun))) /\
     (forall (cun:cursor),
      ((position_ co1 cun) > 0 /\ ~(cu = cun) ->
       (element_ co2 cun) = (element_ co1 cun))) /\
     (forall (w:R), (find_ co1 w) = (find_ co2 w)).

(*Why logic*) Definition ceiling : map -> R -> cursor.
exact ceiling.
Defined.

(*Why predicate*) Definition is_ceiling  (s:map) (i:R) (cu:cursor)
  := (cu = no_element \/ (position_ s cu) > 0) /\
     ((cu = no_element -> (is_empty_ s) \/
       (Rgt i (witness (key_ s (last_ s)))))) /\
     (((position_ s cu) > 0 -> (Rle i (witness (key_ s cu))) /\
       (((Rgt (witness (key_ s cu)) i) -> (find_ s i) = no_element /\
         (cu = (first_ s) \/ ~cu = (first_ s) /\
         (Rgt i (witness (key_ s (last_ (left_ s cu)))))))))).

(*Why axiom*) Lemma ceiling_is_ceiling :
  (forall (s:map), (forall (i:R), (is_ceiling s i (ceiling s i)))).
intros m w; unfold is_ceiling; unfold ceiling; unfold find_;
unfold key_; unfold witness; unfold last_; unfold is_empty_;
unfold first_; unfold no_element; unfold position_; unfold left_.
split.
destruct (ceiling_position m w) as [Hc | Hp];
[left; exact Hc|right; rewrite <- inj_0; apply inj_gt; exact Hp].
split.
intros Hc; destruct (ceiling_O m w Hc) as [Hl | Hs];
[left; intro cu|right; exact Hs].
rewrite <- inj_0; apply inj_eq; symmetry;
apply le_n_O_eq; rewrite <- Hl.
apply Raw_List.position_length.
intro Hpos; rewrite <- inj_0 in Hpos; apply inj_gt_rev in Hpos.
split.
apply ceiling_base; exact Hpos.
intros Hw; split.
apply (ceiling_find m w Hw).
case_eq(beq_nat (Raw_Set.ceiling m w) (Raw_List.first m));
intro Heq; [left; apply beq_nat_true in Heq; exact Heq |
right; apply beq_nat_false in Heq; split; [exact Heq|]].
apply (ceiling_oleft m w Hpos Hw Heq).
Qed.

(*Why predicate*) Definition insert_find  (co1:map) (k:key_t) (co2:map)
  := (forall (i:R), (~(eq i (witness k)) -> (find_ co1 i) = (find_ co2 i))) /\
     (((ceiling co1 (witness k)) = no_element ->
       (find_ co2 (witness k)) = (last_ co2))) /\
     (((position_ co1 (ceiling co1 (witness k))) > 0 ->
       (position_ co2 (find_ co2 (witness k))) =
       (position_ co1 (ceiling co1 (witness k))))).

(*Why predicate*) Definition insert_pos  (co1:map) (k:key_t) (co2:map)
  := (forall (cun:cursor),
      ((position_ co1 cun) > 0 -> ~(eq (witness (key_ co1 cun)) (witness k)))) /\
     (forall (cun:cursor),
      ((position_ co1 cun) > 0 ->
       (((Rgt (witness k) (witness (key_ co1 cun))) -> (position_ co2 cun) =
         (position_ co1 cun))) /\
       (((Rgt (witness (key_ co1 cun)) (witness k)) -> (position_ co2 cun) =
         ((position_ co1 cun) + 1))))) /\
     (forall (cun:cursor),
      ((position_ co1 cun) > 0 -> (element_ co1 cun) = (element_ co2 cun))) /\
     (forall (cun:cursor),
      ((position_ co1 cun) > 0 -> (key_ co1 cun) = (key_ co2 cun))).

(*Why predicate*) Definition insert_inv  (co1:map) (k:key_t) (e:element_t) (co2:map)
  := (forall (cun:cursor),
      ((position_ co2 cun) > 0 /\ (position_ co1 cun) = 0 ->
       (key_ co2 cun) = k)) /\
     (forall (cun:cursor),
      ((position_ co2 cun) > 0 /\ (position_ co1 cun) = 0 ->
       (element_ co2 cun) = e)).

(*Why predicate*) Definition insert_  (co1:map) (k:key_t) (e:element_t) (co2:map)
  := (position_ co2 (find_ co2 (witness k))) > 0 /\ (length_ co2) =
     ((length_ co1) + 1) /\ (insert_pos co1 k co2) /\
     (insert_inv co1 k e co2) /\ (insert_find co1 k co2).

(*Why predicate*) Definition delete_find  (co1:map) (k:key_t) (co2:map)
  := (forall (w:R),
      ((~(eq (witness k) w) -> (find_ co1 w) = (find_ co2 w))) /\
      (((eq (witness k) w) -> (find_ co2 w) = no_element))).

(*Why predicate*) Definition delete_pos  (co1:map) (i:Z) (co2:map)
  := (forall (cun:cursor),
      (((position_ co1 cun) = i -> (position_ co2 cun) = 0)) /\
      (((position_ co1 cun) > i -> (position_ co2 cun) =
        ((position_ co1 cun) - 1))) /\
      ((i > (position_ co1 cun) -> (position_ co2 cun) = (position_ co1 cun)))) /\
     (forall (cun:cursor),
      ((position_ co1 cun) <> i -> (element_ co2 cun) = (element_ co1 cun))) /\
     (forall (cun:cursor),
      ((position_ co1 cun) <> i -> (key_ co2 cun) = (key_ co1 cun))).


(*Why predicate*) Definition delete_  (co1:map) (cu:cursor) (co2:map)
  := (find_ co2 (witness (key_ co1 cu))) = no_element /\ (position_ co1 cu) >
     0 /\ (length_ co2) = ((length_ co1) - 1) /\
     (delete_pos co1 (position_ co1 cu) co2) /\
     (delete_find co1 (key_ co1 cu) co2).

(*Why predicate*) Definition include__  (co1:map) (k:key_t) (e:element_t) (co2:map)
  := (((position_ co1 (find_ co1 (witness k))) > 0 -> (replace_ co1 k e co2))) /\
     (((find_ co1 (witness k)) = no_element -> (insert_ co1 k e co2))).

(*Why predicate*) Definition exclude_  (co1:map) (k:key_t) (co2:map)
  := (((position_ co1 (find_ co1 (witness k))) > 0 ->
       (delete_ co1 (find_ co1 (witness k)) co2))) /\
     (((find_ co1 (witness k)) = no_element -> co1 = co2)).

(*Why predicate*) Definition has_element_  (co:map) (cu:cursor)
  := (position_ co cu) > 0.

(*Why predicate*) Definition contains_  (co:map) (i:R)
  := (position_ co (find_ co i)) > 0.

(*Why axiom*) Lemma empty_contains :
  (forall (s:map), ((forall (i:R), ~(contains_ s i)) -> (is_empty_ s))).
unfold contains_; unfold is_empty_; intros m Hc cu.
generalize (Hc (Elt.witness(key_ m cu))).
intros Hpf; destruct(gt_O_eq (Raw_List.position m cu)) as [Hpo | Heq].
contradict Hpf; unfold position_; unfold key_; unfold find_;
unfold first_; rewrite <- inj_0; apply inj_gt.
rewrite (find_position_inv m (ordered_hashed m (owf m))); apply Hpo.
unfold position_; rewrite <- inj_0; apply inj_eq;
symmetry; exact Heq.
Qed.

(*Why predicate*) Definition equal_  (co1:map) (co2:map)
  := (forall (cu:cursor), (position_ co1 cu) = (position_ co2 cu)) /\
     (forall (cu:cursor),
      ((position_ co1 cu) > 0 -> (key_ co1 cu) = (key_ co2 cu))) /\
     (forall (cu:cursor),
      ((position_ co1 cu) > 0 -> (element_ co2 cu) = (element_ co1 cu))).

(*Why predicate*) Definition equivalent_  (co1:map) (co2:map)
  := (forall (i:R),
      ((contains_ co1 i) -> (contains_ co2 i) /\
       (element__ co1 i) = (element__ co2 i))) /\
     (length_ co1) = (length_ co2).

(*Why axiom*) Lemma equivalent_sym :
  (forall (co1:map),
   (forall (co2:map), ((equivalent_ co1 co2) -> (equivalent_ co2 co1)))).
unfold equivalent_; unfold contains_; unfold find_; unfold position_;
unfold first_; intros m1 m2 [He Hl]; split;
[|symmetry; exact Hl].
intros w Hc.
assert (Raw_List.has_element m1
(Raw_List.find m1 w) = true).
rewrite <- inj_0 in Hc; apply inj_gt_rev in Hc;
apply (Raw_List.has_element_position) in Hc.
apply (equivalent_find (to_hashed m1) (to_hashed m2)).
simpl; intros i; repeat(rewrite <- find_find2).
intros Hh1; apply (Raw_List.position_has_element) in Hh1;
apply inj_gt in Hh1; rewrite inj_0 in Hh1;
destruct (He i Hh1) as [Hh2 _].
apply (Raw_List.has_element_position); apply inj_gt_rev;
rewrite inj_0; exact Hh2.
simpl; unfold length_ in Hl; apply inj_eq_rev; exact Hl.
simpl; exact Hc.
apply (Raw_List.position_has_element) in H; apply inj_gt in H;
rewrite inj_0 in H.
destruct (He w H) as [_ Hel].
split; [exact H|symmetry; exact Hel].
Qed.

(*Why predicate*) Definition no_overlaping  (co1:map) (co2:map)
  := (forall (i:R), ~(contains_ co1 i) \/ ~(contains_ co2 i)).

(*** TESTS ***)

Definition insert : map -> key_t -> element_t -> map.
exact (fun m k e => oinsert m (k, e)).
Defined.

Lemma insert_insert :
forall (l : map), forall (k : key_t),
forall (e : element_t),
not (contains_ l (witness k)) ->
insert_ l k e (insert l k e).
intros l k e; unfold insert_; unfold contains_; unfold has_element_;
unfold insert_pos; unfold insert_find; unfold insert_inv; unfold length_;
unfold position_; unfold no_element; unfold insert; unfold oinsert;
unfold element_; unfold key_; unfold find_; unfold first_;
unfold last_; simpl.
assert (Z_of_nat (1) = 1). auto.
intro Hnfind; destruct (Raw_List.find_has_element l (witness k)
) as [Hko|Hfind];
[contradict Hnfind; rewrite <- inj_0; apply inj_gt;
apply (Raw_List.position_has_element _ _ Hko)|].
unfold witness in Hfind.
assert(Raw_List.find l ((fun e : Element.element_t => Elt.witness (fst e))
(k,e)) = 0%nat).
simpl; exact Hfind.
apply (oinsertl_is_insert l (k,e)) in H0; split;
clear Hnfind.
rewrite <- inj_0; apply inj_gt.
assert(k = fst(k,e)); [simpl; reflexivity|rewrite H1 at 3].
rewrite <- (Raw_List.insert_element_new l 
(Raw_Set.ceiling l (Elt.witness (fst (k, e)))) (k, e)
(Raw_List.New_Max.new l)) at 3; [|reflexivity].
pattern (Raw_List.insert l
(Raw_Set.ceiling l (Elt.witness (fst (k, e)))) (k, e));
rewrite <- H0.
unfold witness; rewrite (find_position_inv (oinsertl l (k, e))
(ordered_hashed _ (WFo_insert l (k, e) (owf l)))); simpl; rewrite H0;
apply Raw_List.insert_has_element_new.
split; [rewrite H0; rewrite <- H; rewrite <- inj_plus;
apply inj_eq; apply Raw_List.insert_length|].
split;[split;[intro cun|split; [intro cun|split; intro cun]]|
split;[split;intro cun|split; [intro w|]]].
intro Hpos;
rewrite <- inj_0 in Hpos; apply inj_gt_rev in Hpos.
apply (find_O_diff _ _ _ Hfind Hpos).
intro Hpos; rewrite <- inj_0 in Hpos; apply inj_gt_rev in Hpos; split.
intro Hgt;  apply inj_eq.
rewrite H0; apply (oinsertl_position_inf l _ _ Hpos (owf l)).
simpl; exact Hgt.
intro Hgt; rewrite <- H; rewrite <- inj_plus; apply inj_eq.
rewrite plus_comm; simpl; rewrite H0;
apply (oinsertl_position_sup l _ _ Hpos (owf l)).
simpl; exact Hgt.
intro Hpos; rewrite <- inj_0 in Hpos; apply inj_gt_rev in Hpos.
rewrite H0; rewrite <- (Raw_List.insert_element_old l _ _ _ Hpos);
reflexivity.
intro Hpos; rewrite <- inj_0 in Hpos; apply inj_gt_rev in Hpos.
rewrite H0; rewrite <- (Raw_List.insert_element_old l _ _ _ Hpos);
reflexivity.
rewrite H0; intros [Hipos Hpos].
rewrite <- inj_0 in Hipos; apply inj_gt_rev in Hipos;
destruct (Raw_List.insert_has_element l
(ceiling l (Elt.witness (fst (k, e)))) (k, e) cun Hipos) as [Heq|Hko].
rewrite Heq.
rewrite (Raw_List.insert_element_new); [|reflexivity].
simpl; split; reflexivity.
apply inj_gt in Hko; contradict Hko; rewrite Hpos; apply Zgt_irrefl.
rewrite H0; intros [Hipos Hpos].
rewrite <- inj_0 in Hipos; apply inj_gt_rev in Hipos;
destruct (Raw_List.insert_has_element l
(ceiling l (Elt.witness (fst (k, e)))) (k, e) cun Hipos) as [Heq|Hko].
rewrite Heq.
rewrite (Raw_List.insert_element_new); [|reflexivity].
simpl; split; reflexivity.
apply inj_gt in Hko; contradict Hko; rewrite Hpos; apply Zgt_irrefl.
rewrite H0; apply (Raw_Set.insert_find l w _ (k,e)).
rewrite H0; unfold witness; unfold ceiling; simpl; split.
intro Heq; rewrite Heq.
symmetry;
apply (Raw_List.position_eq (Raw_List.insert l 0%nat (k, e)));
rewrite Raw_List.position_last_gen; rewrite Raw_List.insert_length.
rewrite <- plus_n_Sm; rewrite <- plus_n_O; apply gt_Sn_O.
assert (Elt.witness k=Elt.witness (fst (k, e))); [simpl; reflexivity| ].
rewrite H1; rewrite H1 in Hfind;
rewrite <- (Raw_List.insert_element_new l O (k,e)
(Raw_List.find (Raw_List.insert l 0%nat (k, e)) (Elt.witness (fst (k, e))))) at 3;
rewrite (insert_find_new _ _ _ Hfind); [|reflexivity].
rewrite (find_position_inv); 
[|apply ordered_hashed; rewrite H1 in Heq; rewrite <- Heq;
generalize (WFo_insert l (k, e) (owf l)); rewrite H0; trivial|];
rewrite Raw_List.insert_position_new_O.
reflexivity.
rewrite <- plus_n_Sm; rewrite <- plus_n_O; apply gt_Sn_O.
intro Hpos; rewrite <- inj_0 in Hpos; apply inj_gt_rev in Hpos; apply inj_eq.
assert (Elt.witness k=Elt.witness (fst (k, e))); [simpl; reflexivity| ].
rewrite H1; rewrite H1 in Hfind.
rewrite <- (Raw_List.insert_element_new l (Raw_Set.ceiling l
(Elt.witness (fst (k, e)))) (k,e) (Raw_List.find (Raw_List.insert l 
(Raw_Set.ceiling l (Elt.witness (fst (k, e)))) (k, e)) (Elt.witness (fst (k, e)))))
at 5; rewrite (insert_find_new _ _ _ Hfind); [|reflexivity].
rewrite (find_position_inv);
[|apply ordered_hashed;
generalize (WFo_insert l (k, e) (owf l)); rewrite H0; trivial|];
rewrite (Raw_List.insert_position_new _ _ _ Hpos); [reflexivity|exact Hpos].
Qed.

Definition delete : map -> cursor -> map.
exact odelete.
Defined.

Lemma delete_delete :
forall (l : map), forall (cu : cursor),
has_element_ l cu -> delete_ l cu (delete l cu).
intros l cu; unfold has_element_; unfold delete_; unfold delete;
unfold odelete; unfold delete_pos; unfold delete_find;
unfold key_; unfold position_; unfold element_; unfold no_element;
unfold length_; unfold find_; unfold first_; simpl.
intro Hpos; split.
rewrite <- inj_0 in Hpos; apply inj_gt_rev in Hpos;
apply (Raw_List.has_element_position) in Hpos;
unfold witness.
apply (delete_find_deleted _ _ Hpos (ordered_hashed l (owf l))).
split; [exact Hpos|].
assert (Z_of_nat (1) = 1). auto.
rewrite <- inj_0 in Hpos; apply inj_gt_rev in Hpos;
split.
apply Zplus_minus_eq; rewrite <- H; rewrite <- inj_plus;
apply inj_eq.
apply (Raw_List.delete_length l cu Hpos).
split.
split; [|split]; intro cun.
split; [|split].
intro HH; apply inj_eq_rev in HH;
rewrite <- inj_0; apply inj_eq.
symmetry in HH; apply (Raw_List.position_eq l cu cun Hpos) in HH.
rewrite <- HH; apply (Raw_List.delete_position_deleted l cu Hpos).
intro HH; apply inj_gt_rev in HH.
apply Zplus_minus_eq; rewrite <- H; rewrite <- inj_plus; apply inj_eq.
apply(Raw_List.delete_position_sup l cu cun Hpos HH).
intro HH; apply inj_gt_rev in HH.
apply inj_eq;
apply(Raw_List.delete_position_inf l cu cun Hpos HH).
intro Hneq; rewrite (Raw_List.delete_element l cu cun Hpos); [reflexivity|].
intro Heq; contradict Hneq; apply inj_eq; rewrite Heq; reflexivity.
intro Hneq; rewrite (Raw_List.delete_element l cu cun Hpos); [reflexivity|].
intro Heq; contradict Hneq; apply inj_eq; rewrite Heq; reflexivity.
intros w; split.
intros Hw; rewrite Raw_Set.delete1_find.
reflexivity.
apply Raw_List.has_element_position; exact Hpos.
unfold witness in Hw; intro HH; contradict Hw;
symmetry; exact HH.
intro Heq; rewrite <- Heq; apply delete1_find_deleted.
apply Raw_List.has_element_position; exact Hpos.
exact (Raw_List.wf l).
apply ordered_hashed; exact (owf l).
Qed.

Definition replace : map -> key_t -> element_t -> map.
exact (fun m k e => oreplace m (k, e)).
Defined.

Lemma replace_replace :
forall (l : map), forall (k : key_t), forall (e : element_t),
contains_ l (witness k) ->
replace_ l k e (replace l k e).
unfold contains_; unfold replace_; unfold replace; unfold oreplace;
unfold key_; unfold find_; unfold element_; unfold witness;
unfold position_; unfold length_; unfold first_; simpl;
intros l k e;
intro Hpos; split; [exact Hpos|].
rewrite <- inj_0 in Hpos; apply inj_gt_rev in Hpos; split.
apply inj_eq; apply Raw_List.replace_length.
split.
rewrite(Raw_List.replace_element_replaced l _ _ Hpos);
simpl; reflexivity.
split.
rewrite(Raw_List.replace_element_replaced l _ _ Hpos);
simpl; reflexivity.
split; [intro cun|split; [intro cun|split;[intro cun|intro w]]].
apply inj_eq.
apply Raw_List.replace_position.
intros [_ Hdiff]; rewrite(Raw_List.replace_element l _ _ cun);
[|intro HH; contradict Hdiff; symmetry; exact HH].
reflexivity.
intros [_ Hdiff]; rewrite(Raw_List.replace_element l _ _ cun);
[|intro HH; contradict Hdiff; symmetry; exact HH].
reflexivity.
case_eq (eq_real_bool w (Elt.witness k)).
intro Heq; apply beq_real_true in Heq; rewrite Heq.
repeat(rewrite find_find2).
rewrite <- (Raw_List.replace_element_replaced l _ (k,e) Hpos).
rewrite (Raw_List.replace_element_replaced _ _ _ Hpos).
unfold Raw_List.replace; simpl.
assert (k = fst (k, e)); [simpl| rewrite H;
rewrite (replace1_find_eq l _ (Raw_List.wf (othis l)))]; reflexivity.
assert (k = fst (k, e)); [simpl; reflexivity|];
intro Hdiff; apply beq_real_false in Hdiff; rewrite H.
rewrite H in Hdiff.
repeat(rewrite find_find2); generalize (replace_find l w (k, e) Hdiff).
intro Heq; rewrite <- Heq; simpl; reflexivity.
Qed.

Definition replace_element : map -> cursor -> element_t -> map.
exact (fun m cu e => oreplace m (key_ m cu, e)).
Defined.

Lemma replace_element_replace_element :
forall (l : map), forall (cu : cursor), forall (e : element_t),
has_element_ l cu -> replace_element_ l cu e (replace_element l cu e).
intros l cu e; unfold has_element_; unfold replace_element_;
unfold replace_element; unfold oreplace; unfold position_;
unfold length_; unfold element_; unfold key_; unfold find_;
unfold first_; simpl.
intro Hpos; split; [exact Hpos|].
rewrite <- inj_0 in Hpos; rewrite <- inj_0;
apply inj_gt_rev in Hpos.
assert(cu = Raw_List.find l (Elt.witness (fst (Raw_List.element l cu)))).
apply (Raw_List.position_eq l cu _ Hpos).
rewrite (find_position_inv l (ordered_hashed l (owf l)) cu Hpos);
reflexivity.
rewrite <- H.
split.
rewrite (Raw_List.replace_element_replaced l cu _ Hpos);
simpl; reflexivity.
split.
apply inj_eq.
apply Raw_List.replace_length.
split; [intro cun|split; [intro cun|split;[intro cun|intro w]]].
apply inj_eq.
rewrite Raw_List.replace_position; reflexivity.
intros Hpcun; apply inj_gt_rev in Hpcun.
case_eq(beq_nat cu cun); intro Heq;
[apply beq_nat_true in Heq|apply beq_nat_false in Heq].
rewrite <- Heq;
rewrite (Raw_List.replace_element_replaced l cu _ Hpos);
simpl; reflexivity.
rewrite (Raw_List.replace_element l cu _ cun Heq);
simpl; reflexivity.
intros [_ Heq]; rewrite (Raw_List.replace_element l cu _ cun Heq);
simpl; reflexivity.
assert (fst (Raw_List.element l cu) = fst (fst (Raw_List.element l cu), e)).
simpl; reflexivity.
case_eq (eq_real_bool w 
(Elt.witness (fst (Raw_List.element l cu)))).
intro Heq; apply beq_real_true in Heq; rewrite Heq.
rewrite H0 at 3; rewrite <- (Raw_List.replace_element_replaced l cu
(fst (Raw_List.element l cu), e) Hpos).
apply (Raw_List.position_eq l);
[rewrite (find_position_inv l (ordered_hashed l (owf l)));
simpl; exact Hpos|].
rewrite (find_position_inv l (ordered_hashed l (owf l))); simpl;
[|exact Hpos].
symmetry; rewrite <- (Raw_List.replace_position l cu
(fst (Raw_List.element l cu), e)).
rewrite (find_position_inv (Raw_List.replace l cu
(fst (Raw_List.element l cu), e))).
apply Raw_List.replace_position.
apply ordered_hashed; unfold Raw_List.replace; simpl;
rewrite H at 1. rewrite H0 at 1.
apply (WFo_replace1 l _ (Raw_List.wf(othis l)) (owf l)).
rewrite Raw_List.replace_position; apply Hpos.
intro Hdiff; apply beq_real_false in Hdiff; rewrite H at 1.
rewrite H0.
symmetry; rewrite H0 in Hdiff.
generalize (replace_find l w (fst (Raw_List.element l cu), e) Hdiff).
simpl. intro Heq; exact Heq.
Qed.

Definition include : map -> key_t -> element_t -> map.
exact (fun m k e => oinclude m (k, e)).
Defined.

Lemma include_include :
forall (l : map), forall (k : key_t),
forall (e : element_t),
include__ l k e (include l k e).
unfold include__; unfold include; unfold find_; unfold position_;
unfold oinclude; unfold first_; unfold witness; simpl.
intros l k e; case_eq(beq_nat (Raw_List.find l (Elt.witness k)) O).
intro Heq; apply beq_nat_true in Heq.
split; [intro Hko; rewrite <- inj_0 in Hko; apply inj_gt_rev in Hko;
contradict Hko; rewrite Heq; rewrite Raw_List.position_no_element;
apply gt_irrefl|].
intros _; apply insert_insert.
unfold contains_; unfold position_; unfold find_; unfold first_;
unfold witness; simpl; rewrite Heq;
rewrite Raw_List.position_no_element; apply Zgt_irrefl.
intro Hdiff; apply beq_nat_false in Hdiff.
split;[|unfold no_element; intro Hko; contradict Hdiff; apply Hko].
intro Hpos; apply replace_replace.
unfold contains_; unfold position_; unfold find_; unfold first_;
unfold witness; simpl; exact Hpos.
Qed.

Definition exclude : map -> key_t -> map.
exact (fun m k => oexclude m (find_ m (witness k))).
Defined.

Lemma exclude_exclude :
forall (l : map), forall (k : key_t),
exclude_ l k (exclude l k).
unfold exclude_; unfold exclude; unfold find_; unfold position_;
unfold oexclude; unfold first_; unfold witness; simpl.
intros l k;
case_eq(beq_nat (Raw_List.find l (Elt.witness k)) O).
intro Heq; apply beq_nat_true in Heq.
split; [intro Hko; rewrite <- inj_0 in Hko; apply inj_gt_rev in Hko;
contradict Hko; rewrite Heq; rewrite Raw_List.position_no_element;
apply gt_irrefl|].
reflexivity.
intro Hdiff; apply beq_nat_false in Hdiff.
split;[|unfold no_element; intro Hko; contradict Hdiff; apply Hko].
intro Hpos; apply delete_delete.
unfold has_element_; unfold position_; simpl; exact Hpos.
Qed.

(*** MAX ***)

Module Type CompareType.

Parameter Inline compare : element_t -> element_t -> Z.

Axiom compare_refl :
forall e : element_t, (compare e e = 0)%Z.

Axiom compare_asym :
forall e1 : element_t, forall e2 : element_t,
(0 <= compare e1 e2 <-> compare e2 e1 <= 0)%Z.

Axiom compare_trans :
forall e1 : element_t, forall e2 : element_t, forall e3 : element_t,
(compare e1 e2 <= 0)%Z -> (compare e2 e3 <= 0)%Z ->
(compare e1 e3 <= 0)%Z.

End CompareType.

Module Compare (C : CompareType).

Module Compare.

Definition compare (e1 : (key_t*element_t))
(e2 : (key_t*element_t)) : Z :=
C.compare (snd e1) (snd e2).

Lemma compare_refl :
forall e : (key_t*element_t), (compare e e = 0)%Z.
intro e; unfold compare; apply C.compare_refl.
Qed.

Lemma compare_asym :
forall e1 : (key_t*element_t), forall e2 : (key_t*element_t),
(0 <= compare e1 e2 <-> compare e2 e1 <= 0)%Z.
intros e1 e2; unfold compare; apply C.compare_asym.
Qed.

Lemma compare_trans :
forall e1 : (key_t*element_t), forall e2 : (key_t*element_t),
forall e3 : (key_t*element_t),
(compare e1 e2 <= 0)%Z -> (compare e2 e3 <= 0)%Z ->
(compare e1 e3 <= 0)%Z.
intros e1 e2 e3; unfold compare; apply C.compare_trans.
Qed.

End Compare.

Definition compare_ : element_t -> element_t -> Z.
exact C.compare.
Defined.

Module Max_List := Raw_List.Max (Compare).

Definition is_max  (v:map) (cu:cursor)
  := (has_element_ v cu) /\
     (forall (cun:cursor),
      ((has_element_ v cun) -> (compare_ (element_ v cu) (element_ v cun)) >=
       0)).

Definition max_ : map -> cursor.
exact (Max_List.max).
Defined.

Lemma is_max_max :
  (forall (v:map), (~(is_empty_ v) -> (is_max v (max_ v)))).
intros l He; apply is_empty_length in He;
unfold is_max; unfold max_; unfold has_element_; unfold contains_;
unfold element_; unfold find_; unfold first_;
unfold position_.
split.
rewrite <- inj_0; apply inj_gt; apply Raw_List.position_has_element.
apply (Max_List.max_has_element l He).
intros e Hhfind;
rewrite <- inj_0 in Hhfind; apply inj_gt_rev in Hhfind.
apply (Raw_List.has_element_position) in Hhfind.
destruct (Compare.compare_asym (Raw_List.element l (Max_List.max l))
(Raw_List.element l e)) as [_ H];
apply Zle_ge; apply H; clear H.
apply (Max_List.max_element _ l Hhfind).
Qed.

End Compare.

(*** SUM_OF ***)

Module Type WeightType.

Parameter Inline weight : element_t -> nat.

End WeightType.

Module Weight (We : WeightType).

Module W.

Definition weight (e : key_t*element_t) : nat :=
We.weight (snd e).

End W.

Definition weight_ : (element_t) -> Z.
exact (fun e => Z_of_nat (We.weight e)).
Defined.

Lemma positive_weight :
  (forall (e:element_t), (weight_ e) >= 0).
intro e; unfold weight_; apply Zle_ge; apply Zle_0_nat.
Qed.

Module Sum_List := Sum_Of(W).
Import Sum_List.

Definition sum_of_weight : map -> Z.
exact (fun l => Z_of_nat (Sum_List.sum_of_weight l)).
Defined.

Lemma sum_of_weight_delete :
  (forall (v1:map),
   (forall (v2:map),
    (forall (cu:cursor),
     ((delete_ v1 cu v2) -> (sum_of_weight v2) =
      ((sum_of_weight v1) - (weight_ (element_ v1 cu))))))).
assert (Z_of_nat (1) = 1). auto.
intros l1 l2 cu; unfold delete_; unfold sum_of_weight;
unfold weight_; unfold delete_pos;
unfold element_; unfold length_; unfold position_; unfold key_;
intros [Hfind[Hposcu[Hlgth[[Hdpos [He Hk]] _]]]]; apply Zplus_minus_eq.
rewrite <- inj_plus; apply inj_eq.
apply Sum_List.sum_of_delete.
apply Raw_List.has_element_position.
rewrite <- inj_0 in Hposcu; apply (inj_gt_rev _ _ Hposcu).
destruct (Hdpos cu) as [Hpcu _].
case_eq (Raw_List.has_element l2 cu); [|reflexivity].
intro Hhe; apply Raw_List.position_has_element in Hhe;
apply inj_gt in Hhe; contradict Hhe; 
rewrite (Hpcu (reflexivity (Z_of_nat (Raw_List.position l1 cu)))).
rewrite inj_0; apply Zgt_irrefl.
intros cun Hp Hdiff.
split; [|apply injective_projections; [apply Hk|apply He]; intro Heq;
apply Hdiff; apply (Raw_List.position_eq l1 _ _ Hp); apply inj_eq_rev; exact Heq].
destruct (Hdpos cun) as [_[Hi Hs]].
destruct (Z_dec (Z_of_nat (Raw_List.position l1 cun))
(Z_of_nat (Raw_List.position l1 cu))) as [[Hpp|Hpp]|Hpp].
apply Zlt_gt in Hpp; rewrite (inj_eq_rev _ _ (Hs Hpp)); exact Hp.
rewrite <- H in Hi; rewrite <- inj_minus1 in Hi; [|apply gt_le_S; exact Hp].
rewrite (inj_eq_rev _ _ (Hi Hpp)); apply le_S_gt.
apply lt_minus_O_lt; apply gt_le_S.
apply inj_gt_rev in Hpp; apply gt_le_S in Hpp; rewrite <- inj_0 in Hposcu;
apply inj_gt_rev in Hposcu; apply gt_n_S in Hposcu.
apply (le_gt_trans _ _ _ Hpp Hposcu).
contradict Hdiff; apply (Raw_List.position_eq l1 _ _ Hp);
apply inj_eq_rev; exact Hpp.
rewrite (plus_n_O (Raw_List.length l2)); rewrite plus_n_Sm.
apply inj_eq_rev; rewrite inj_plus.
rewrite Hlgth; rewrite Zplus_comm; rewrite Zplus_minus; reflexivity.
Qed.

Lemma sum_of_weight_insert :
  (forall (v1:map),
   (forall (v2:map),
    (forall (k:key_t),
     (forall (e:element_t),
      ((insert_ v1 k e v2) -> (sum_of_weight v2) =
       ((sum_of_weight v1) + (weight_ e))))))).
unfold insert_; unfold sum_of_weight; unfold weight_;
unfold insert_pos; unfold insert_inv; unfold find_; unfold first_;
unfold position_; unfold key_; unfold element_; unfold length_;
unfold witness.
intros m1 m2 k e [Hfind[Hlength[[Hw [Hpos [He Hk]]] [[Hkk Hee] _]]]].
assert (Z_of_nat (1) = 1). auto.
rewrite <- inj_0 in Hfind; apply inj_gt_rev in Hfind;
rewrite <- inj_plus.
assert (Raw_List.position m1 (Raw_List.find m2 (Elt.witness k))=O).
destruct (gt_0_eq (Raw_List.position m1 (Raw_List.find m2 (Elt.witness k))))
as [Hko|Hex]; [|symmetry; exact Hex].
apply inj_gt in Hko; generalize (Hw _ Hko); intro C; contradict C.
rewrite (Hk _ Hko); apply (Raw_List.find_element _ _ Hfind).
rewrite (sum_of_insert_o m1 _ (Raw_List.find m2 (Elt.witness k)
) (k,e)); simpl.
rewrite plus_comm; reflexivity.
apply (Raw_List.has_element_position); exact Hfind.
case_eq(Raw_List.has_element m1 (Raw_List.find m2
(Elt.witness k)));
[intro Hko|reflexivity].
apply Raw_List.position_has_element in Hko.
contradict Hko; rewrite H0; apply gt_irrefl.
apply inj_eq in H0; apply inj_gt in Hfind; apply injective_projections; simpl;
[exact (Hkk _ (conj Hfind H0))|exact (Hee _ (conj Hfind H0))].
intros cun Hhem1cun.
apply Raw_List.position_has_element in Hhem1cun;
apply inj_gt in Hhem1cun; rewrite inj_0 in Hhem1cun.
split; [exact (Hw _ Hhem1cun)|];
split; [apply injective_projections; simpl;
symmetry; [exact (Hk _ Hhem1cun)|exact (He _ Hhem1cun)]|].
destruct (Hpos _ Hhem1cun) as [Hs Hi].
split; intro HH; apply inj_eq_rev; [rewrite (Hi HH)|rewrite (Hs HH)];
[|reflexivity].
rewrite (plus_n_O (Raw_List.position m1 cun)) at 2;
rewrite plus_n_Sm; rewrite inj_plus; reflexivity.
apply inj_eq_rev; rewrite Hlength.
rewrite (plus_n_O (Raw_List.length m1)) at 2;
rewrite plus_n_Sm; rewrite inj_plus; reflexivity.
Qed.

Lemma sum_of_weight_replace_element :
  (forall (v1:map),
   (forall (v2:map),
    (forall (cu:cursor),
     (forall (e:element_t),
      ((replace_element_ v1 cu e v2) -> (sum_of_weight v2) =
       ((sum_of_weight v1) + (weight_ e) - (weight_ (element_ v1 cu)))))))).
assert (Z_of_nat (1) = 1). auto.
intros l1 l2 cu e; unfold replace_element_; unfold sum_of_weight;
unfold weight_; unfold element_; unfold length_; unfold position_;
unfold key_.
intros [Hposcu[Hel[Hlgth [Hpos [Hk [He _]]]]]].
apply Zplus_minus_eq; repeat(rewrite <- inj_plus); apply inj_eq.
apply inj_eq_rev in Hlgth; rewrite <- inj_0 in Hposcu;
apply inj_gt_rev in Hposcu; symmetry.
pattern((We.weight (snd (Raw_List.element l1 cu)) +
                            Sum_List.sum_of_weight l2)%nat);
rewrite (Sum_List.sum_of_replace l1 l2 cu
(fst(Raw_List.element l1 cu),e)).
rewrite plus_comm; reflexivity.
apply (Raw_List.has_element_position _ _ Hposcu).
apply inj_gt in Hposcu; rewrite inj_0 in Hposcu.
apply injective_projections; [exact (Hk _ Hposcu)|exact Hel].
intros cun Hposl1;
apply inj_gt in Hposl1; rewrite inj_0 in Hposl1.
split; [apply inj_gt_rev; rewrite <- Hpos;
exact Hposl1|intro Hdiff; apply injective_projections].
apply (Hk _ Hposl1).
apply (He _ (conj Hposl1 Hdiff)).
symmetry; exact Hlgth.
Qed.

Lemma sum_of_weight_replace :
  (forall (v1:map),
   (forall (v2:map),
    (forall (k:key_t),
     (forall (e:element_t),
      ((replace_ v1 k e v2) -> (sum_of_weight v2) =
       ((sum_of_weight v1) + (weight_ e)
       - (weight_ (element__ v1 (witness k))))))))).
assert (Z_of_nat (1) = 1). auto.
intros l1 l2 k e; unfold replace_; unfold sum_of_weight;
unfold weight_; unfold element__; unfold length_; unfold position_;
unfold find_; unfold element_; unfold first_; unfold key_.
intros [Hposcu[Hlgth [Helfst [Helsnd [Hpos [Hk [He _]]]]]]].
apply Zplus_minus_eq; repeat(rewrite <- inj_plus); apply inj_eq.
apply inj_eq_rev in Hlgth; rewrite <- inj_0 in Hposcu;
apply inj_gt_rev in Hposcu;
pattern((We.weight (snd (Raw_List.element l1
(Raw_List.find l1 (witness k)))) + Sum_List.sum_of_weight l2)%nat);
rewrite (Sum_List.sum_of_replace l1 l2
(Raw_List.find l1 (witness k)) (k,e)).
rewrite plus_comm; reflexivity.
apply (Raw_List.has_element_position _ _ Hposcu).
apply injective_projections; [exact Helfst|exact Helsnd].
intros cun Hposl1; apply inj_gt in Hposl1.
split; [apply inj_gt_rev; rewrite Hpos; exact Hposl1|intro Hdiff].
apply injective_projections; [apply Hk|apply He];
split; [exact Hposl1| |exact Hposl1|]; intro Heq; contradict Hdiff;
rewrite Heq; reflexivity.
symmetry; exact Hlgth.
Qed.

Lemma sum_of_weight_null :
  (forall (v:map), ((is_empty_ v) -> (sum_of_weight v) = 0)).
unfold sum_of_weight;
intros l Hl; apply length_is_empty in Hl; unfold length_ in Hl.
rewrite <- inj_0; rewrite <- inj_0 in Hl; apply inj_eq;
apply inj_eq_rev in Hl; apply (Sum_List.sum_of_nil l Hl).
Qed.

Lemma sum_of_weight_equal :
  (forall (v1:map),
   (forall (v2:map),
    ((equivalent_ v1 v2) -> (sum_of_weight v1) = (sum_of_weight v2)))).
unfold equivalent_; unfold sum_of_weight; unfold element__;
unfold contains_; unfold position_; unfold find_; unfold length_;
unfold element_; unfold first_; intros l1 l2 [Hcu Hlgth].
apply inj_eq;
apply (sum_of_equivalent (to_hashed l1) (to_hashed l2)); simpl.
apply inj_eq_rev; exact Hlgth.
intros w Hpos; apply inj_gt in Hpos; rewrite inj_0 in Hpos;
destruct (Hcu w Hpos) as [Hpos2 Hel]; clear Hcu. 
split.
apply inj_gt_rev; rewrite inj_0; exact Hpos2.
assert(We.weight
  (snd (Raw_List.element l1 (Raw_List.find l1 w))) =
We.weight
  (snd (Raw_List.element l2 (Raw_List.find l2 w)))).
rewrite Hel; reflexivity.
exact H.
Qed.

Lemma sum_of_weight_left :
  (forall (v:map),
   (forall (cu:cursor),
    ((has_element_ v cu) -> (sum_of_weight (left_ v (next_ v cu))) =
     ((sum_of_weight (left_ v cu)) + (weight_ (element_ v cu)))))).
unfold left_; unfold next_; unfold weight_; unfold has_element_;
unfold position_; unfold sum_of_weight; unfold oleft; intros l cu Hpos.
case_eq (beq_nat cu O); [intro HH; contradict Hpos;
apply beq_nat_true in HH; rewrite HH; rewrite <- inj_0;
rewrite Raw_List.position_no_element; apply Zgt_irrefl|simpl].
intros _; case_eq (beq_nat (Raw_List.next l cu) O); intro Heq; simpl.
assert(Raw_List.left l (Raw_List.next l cu) = l).
unfold Raw_List.left; rewrite Heq; reflexivity.
rewrite <- H at 1.
rewrite <- inj_plus; apply inj_eq; apply Sum_List.sum_of_left.
apply (Raw_List.has_element_position); apply inj_gt_rev;
rewrite inj_0; exact Hpos.
rewrite <- inj_plus; apply inj_eq; apply Sum_List.sum_of_left.
apply (Raw_List.has_element_position); apply inj_gt_rev;
rewrite inj_0; exact Hpos.
Qed.

Lemma sum_of_weight_right :
  (forall (v:map),
   (forall (cu:cursor),
    ((has_element_ v cu) -> (sum_of_weight (right_ v (next_ v cu))) =
     ((sum_of_weight (right_ v cu)) - (weight_ (element_ v cu)))))).
unfold right_; unfold next_; unfold weight_; unfold has_element_;
unfold position_; unfold sum_of_weight; unfold oright; intros l cu Hpos.
case_eq (beq_nat cu O); [intro HH; contradict Hpos;
apply beq_nat_true in HH; rewrite HH; rewrite <- inj_0;
rewrite Raw_List.position_no_element; apply Zgt_irrefl|simpl].
intros _; case_eq (beq_nat (Raw_List.next l cu) O); intro Heq; simpl.
assert(Sum_List.sum_of_weight(Raw_List.right l (Raw_List.next l cu)) = O).
unfold Raw_List.right; rewrite Heq; reflexivity.
rewrite <- inj_0; rewrite <- H at 1.
apply Zplus_minus_eq; symmetry.
rewrite <- inj_plus; apply inj_eq; apply Sum_List.sum_of_right.
apply (Raw_List.has_element_position); apply inj_gt_rev;
rewrite inj_0; exact Hpos.
apply Zplus_minus_eq; symmetry.
rewrite <- inj_plus; apply inj_eq; apply Sum_List.sum_of_right.
apply (Raw_List.has_element_position); apply inj_gt_rev;
rewrite inj_0; exact Hpos.
Qed.

End Weight.

End OMap.



(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)
Require Export Reals.

(*Why logic*) Definition lt_real : R -> R -> Prop.
Admitted.

(*Why logic*) Definition le_real : R -> R -> Prop.
Admitted.

(*Why logic*) Definition gt_real : R -> R -> Prop.
Admitted.

(*Why logic*) Definition ge_real : R -> R -> Prop.
Admitted.

(*Why logic*) Definition eq_real : R -> R -> Prop.
Admitted.

(*Why logic*) Definition neq_real : R -> R -> Prop.
Admitted.

(*Why logic*) Definition add_real : R -> R -> R.
Admitted.

(*Why logic*) Definition sub_real : R -> R -> R.
Admitted.

(*Why logic*) Definition mul_real : R -> R -> R.
Admitted.

(*Why logic*) Definition div_real : R -> R -> R.
Admitted.

(*Why logic*) Definition neg_real : R -> R.
Admitted.

(*Why logic*) Definition real_of_int : Z -> R.
Admitted.

(*Why axiom*) Lemma real_of_int_zero : (eq (IZR 0) (0)%R).
Admitted.

(*Why axiom*) Lemma real_of_int_one : (eq (IZR 1) (1)%R).
Admitted.

(*Why axiom*) Lemma real_of_int_add :
  (forall (x:Z), (forall (y:Z), (eq (IZR (x + y)) (Rplus (IZR x) (IZR y))))).
Admitted.

(*Why axiom*) Lemma real_of_int_sub :
  (forall (x:Z), (forall (y:Z), (eq (IZR (x - y)) (Rminus (IZR x) (IZR y))))).
Admitted.

(*Why logic*) Definition truncate_real_to_int : R -> Z.
Admitted.

(*Why axiom*) Lemma truncate_down_pos :
  (forall (x:R),
   ((Rge x (0)%R) -> (Rle (IZR (truncate_real_to_int x)) x) /\
    (Rlt x (IZR ((truncate_real_to_int x) + 1))))).
Admitted.

(*Why axiom*) Lemma truncate_up_neg :
  (forall (x:R),
   ((Rle x (0)%R) -> (Rlt (IZR ((truncate_real_to_int x) - 1)) x) /\
    (Rle x (IZR (truncate_real_to_int x))))).
Admitted.

(*Why logic*) Definition floor_real_to_int : R -> Z.
Admitted.

(*Why logic*) Definition ceil_real_to_int : R -> Z.
Admitted.

(*Why logic*) Definition lt_real_bool : R -> R -> bool.
Admitted.

(*Why logic*) Definition le_real_bool : R -> R -> bool.
Admitted.

(*Why logic*) Definition gt_real_bool : R -> R -> bool.
Admitted.

(*Why logic*) Definition ge_real_bool : R -> R -> bool.
Admitted.

(*Why logic*) Definition eq_real_bool : R -> R -> bool.
Admitted.

(*Why logic*) Definition neq_real_bool : R -> R -> bool.
Admitted.

(*Why axiom*) Lemma lt_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((lt_real_bool x y) = true <-> (Rlt x y)))).
Admitted.

(*Why axiom*) Lemma le_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((le_real_bool x y) = true <-> (Rle x y)))).
Admitted.

(*Why axiom*) Lemma gt_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((gt_real_bool x y) = true <-> (Rgt x y)))).
Admitted.

(*Why axiom*) Lemma ge_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((ge_real_bool x y) = true <-> (Rge x y)))).
Admitted.

(*Why axiom*) Lemma eq_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((eq_real_bool x y) = true <-> (eq x y)))).
Admitted.

(*Why axiom*) Lemma neq_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((neq_real_bool x y) = true <-> ~(eq x y)))).
Admitted.

(*Why logic*) Definition real_max : R -> R -> R.
Admitted.

(*Why logic*) Definition real_min : R -> R -> R.
Admitted.

(*Why axiom*) Lemma real_max_is_ge :
  (forall (x:R),
   (forall (y:R), (Rge (real_max x y) x) /\ (Rge (real_max x y) y))).
Admitted.

(*Why axiom*) Lemma real_max_is_some :
  (forall (x:R),
   (forall (y:R), (eq (real_max x y) x) \/ (eq (real_max x y) y))).
Admitted.

(*Why axiom*) Lemma real_min_is_le :
  (forall (x:R),
   (forall (y:R), (Rle (real_min x y) x) /\ (Rle (real_min x y) y))).
Admitted.

(*Why axiom*) Lemma real_min_is_some :
  (forall (x:R),
   (forall (y:R), (eq (real_min x y) x) \/ (eq (real_min x y) y))).
Admitted.

(*Why function*) Definition sqr_real  (x:R) := (Rmult x x).

(*Why logic*) Definition sqrt_real : R -> R.
Admitted.

(*Why axiom*) Lemma sqrt_pos :
  (forall (x:R), ((Rge x (0)%R) -> (Rge (sqrt x) (0)%R))).
Admitted.

(*Why axiom*) Lemma sqrt_sqr :
  (forall (x:R), ((Rge x (0)%R) -> (eq (sqr_real (sqrt x)) x))).
Admitted.

(*Why axiom*) Lemma sqr_sqrt :
  (forall (x:R), ((Rge x (0)%R) -> (eq (sqrt (Rmult x x)) x))).
Admitted.

(*Why logic*) Definition pow_real : R -> R -> R.
Admitted.

(*Why logic*) Definition abs_real : R -> R.
Admitted.

(*Why axiom*) Lemma abs_real_pos :
  (forall (x:R), ((Rge x (0)%R) -> (eq (Rabs x) x))).
Admitted.

(*Why axiom*) Lemma abs_real_neg :
  (forall (x:R), ((Rle x (0)%R) -> (eq (Rabs x) (Ropp x)))).
Admitted.

(*Why logic*) Definition exp : R -> R.
Admitted.

(*Why logic*) Definition log : R -> R.
Admitted.

(*Why logic*) Definition log10 : R -> R.
Admitted.

(*Why axiom*) Lemma log_exp : (forall (x:R), (eq (log (exp x)) x)).
Admitted.

(*Why axiom*) Lemma exp_log :
  (forall (x:R), ((Rgt x (0)%R) -> (eq (exp (log x)) x))).
Admitted.

(*Why logic*) Definition cos : R -> R.
Admitted.

(*Why logic*) Definition sin : R -> R.
Admitted.

(*Why logic*) Definition tan : R -> R.
Admitted.

(*Why logic*) Definition pi : R.
Admitted.

(*Why logic*) Definition cosh : R -> R.
Admitted.

(*Why logic*) Definition sinh : R -> R.
Admitted.

(*Why logic*) Definition tanh : R -> R.
Admitted.

(*Why logic*) Definition acos : R -> R.
Admitted.

(*Why logic*) Definition asin : R -> R.
Admitted.

(*Why logic*) Definition atan : R -> R.
Admitted.

(*Why logic*) Definition atan2 : R -> R -> R.
Admitted.

(*Why logic*) Definition hypot : R -> R -> R.
Admitted.

(*Why axiom*) Lemma prod_pos :
  (forall (x:R),
   (forall (y:R),
    (((Rgt x (0)%R) /\ (Rgt y (0)%R) -> (Rgt (Rmult x y) (0)%R))) /\
    (((Rlt x (0)%R) /\ (Rlt y (0)%R) -> (Rgt (Rmult x y) (0)%R))))).
Admitted.

(*Why axiom*) Lemma abs_minus :
  (forall (x:R), (eq (Rabs (Ropp x)) (Rabs x))).
Admitted.

(**************************************************************************)
Require "set_raw".
Require Import ZArith.
Open Scope Z_scope.

Module Type Element_Type.

Parameter Inline element_t : Set.

Parameter Inline e_nl : element_t.

Parameter Inline witness : element_t -> R.

End Element_Type.

Module OSet (Elt : Element_Type).

Module ROrder.

Definition lt_real_bool : R -> R -> bool := lt_real_bool.

Definition le_real_bool : R -> R -> bool := le_real_bool.

Definition gt_real_bool : R -> R -> bool := gt_real_bool.

Definition ge_real_bool : R -> R -> bool := ge_real_bool.

Definition eq_real_bool : R -> R -> bool := eq_real_bool.

Definition neq_real_bool : R -> R -> bool := neq_real_bool.

Lemma lt_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((lt_real_bool x y) = true <-> (Rlt x y)))).
apply lt_real_bool_axiom.
Qed.

Lemma le_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((le_real_bool x y) = true <-> (Rle x y)))).
apply le_real_bool_axiom.
Qed.

Lemma gt_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((gt_real_bool x y) = true <-> (Rgt x y)))).
apply gt_real_bool_axiom.
Qed.

Lemma ge_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((ge_real_bool x y) = true <-> (Rge x y)))).
apply ge_real_bool_axiom.
Qed.

Lemma eq_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((eq_real_bool x y) = true <-> (eq x y)))).
apply eq_real_bool_axiom.
Qed.

Lemma neq_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((neq_real_bool x y) = true <-> ~(eq x y)))).
apply neq_real_bool_axiom.
Qed.

End ROrder.

Module Raw_Set := (set_raw.Raw_Set (Elt)) (ROrder).
Import Raw_Set.

(*Why type*) Definition cursor: Set.
exact Raw_List.cursor.
Defined.

(*Why type*) Definition set: Set.
exact oset.
Defined.

(*Why type*) Definition element_t: Set.
exact Elt.element_t.
Defined.

(*Why logic*) Definition no_element : cursor.
exact O.
Defined.

(*Why logic*) Definition empty_ : set.
exact oempty.
Defined.

(*Why logic*) Definition length_ : set -> Z.
exact (fun l => Z_of_nat (Raw_List.length l)).
Defined.

(*Why axiom*) Lemma length_gte_zero : (forall (co:set), 0 <= (length_ co)).
intro l; unfold length_.
apply Zle_0_nat.
Qed.

(*Why logic*) Definition witness : element_t -> R.
exact Elt.witness.
Defined.

(*Why logic*) Definition position_ : set -> cursor -> Z.
exact (fun l cu => Z_of_nat(Raw_List.position l cu)).
Defined.

(*Why axiom*) Lemma position_gte_zero :
  (forall (co:set),
   (forall (cu:cursor), 0 <= (position_ co cu) /\ (position_ co cu) <=
    (length_ co))).
unfold position_.
unfold length_.
split.
apply Zle_0_nat.
apply inj_le; simpl.
apply Raw_List.position_length.
Qed.

(*Why axiom*) Lemma position_no_element :
  (forall (co:set), (position_ co no_element) = 0).
intro l; unfold position_; unfold no_element;
rewrite <- inj_0; apply inj_eq.
apply Raw_List.position_no_element.
Qed.

(*Why axiom*) Lemma position_eq :
  (forall (co:set),
   (forall (cu1:cursor),
    (forall (cu2:cursor),
     ((position_ co cu1) > 0 ->
      ((position_ co cu1) = (position_ co cu2) -> cu1 = cu2))))).
intros l cu1 cu2; unfold position_; rewrite <- inj_0;
intros Hpos Heq.
apply inj_gt_rev in Hpos.
apply inj_eq_rev in Heq.
apply (Raw_List.position_eq l cu1 cu2 Hpos Heq).
Qed.

(*Why logic*) Definition element_ : set -> cursor -> element_t.
exact Raw_List.element.
Defined.

(*Why predicate*) Definition is_empty_  (co:set)
  := (forall (cu:cursor), (position_ co cu) = 0).

(*Why axiom*) Lemma length_is_empty :
  (forall (co:set), ((is_empty_ co) -> (length_ co) = 0)).
intro l; unfold is_empty_; unfold length_; unfold position_.
intro H; rewrite <- inj_0; apply inj_eq;
apply Raw_List.length_position.
intro cu; apply inj_eq_rev; rewrite inj_0; apply H.
Qed.

(*Why axiom*) Lemma empty_is_empty : (is_empty_ empty_).
unfold is_empty_; unfold empty_; unfold position_;
unfold Raw_List.empty; simpl; auto.
Qed.

(*Why predicate*) Definition previous__  (co:set) (cu1:cursor) (cu2:cursor)
  := (((position_ co cu1) > 1 -> (position_ co cu2) =
       ((position_ co cu1) - 1))) /\
     (((position_ co cu1) = 1 \/ cu1 = no_element -> cu2 = no_element)).

(*Why logic*) Definition previous_ : set -> cursor -> cursor.
exact Raw_List.previous.
Defined.

(*Why axiom*) Lemma previous_previous :
  (forall (co:set),
   (forall (cu:cursor), (previous__ co cu (previous_ co cu)))).
unfold previous_; unfold previous__;
unfold position_; unfold no_element.
intros l cu.
assert (Z_of_nat (1) = 1).
auto.
split.
intro HH.
rewrite <- H in HH;
apply inj_gt_rev in HH;
rewrite <- H;
rewrite <- (inj_minus1 (Raw_List.position l cu) 1
(gt_S_le 1 (Raw_List.position l cu)
(gt_trans (S (Raw_List.position l cu)) (Raw_List.position l cu) 1
(gt_Sn_n (Raw_List.position l cu)) HH)));
apply inj_eq.
apply Raw_List.position_previous_gen;
exact HH.
intros [HH | HH].
rewrite <- H in HH; apply inj_eq_rev in HH.
apply Raw_List.position_previous_first; exact HH.
rewrite HH; apply Raw_List.previous_O.
Qed.

(*Why predicate*) Definition next__  (co:set) (cu1:cursor) (cu2:cursor)
  := (((length_ co) > (position_ co cu1) /\ (position_ co cu1) > 0 \/
       (position_ co cu2) > 0 -> (position_ co cu2) =
       ((position_ co cu1) + 1))) /\
     (((length_ co) > 0 /\
      (position_ co cu1) = (length_ co) \/ cu1 = no_element ->
       cu2 = no_element)).

(*Why logic*) Definition next_ : set -> cursor -> cursor.
exact Raw_List.next.
Defined.

(*Why axiom*) Lemma next_next :
  (forall (co:set), (forall (cu:cursor), (next__ co cu (next_ co cu)))).
intros l cu; unfold next__; unfold next_; unfold position_;
unfold no_element; unfold length_.
assert (Z_of_nat (1) = 1).
auto.
split.
intros HH.
destruct HH as [[Hlength Hpos] | HH];
[apply inj_gt_rev in Hlength;
rewrite <- inj_0 in Hpos; apply inj_gt_rev in Hpos|
rewrite <- inj_0 in HH; apply inj_gt_rev in HH;
apply Raw_List.next_has_element_inv in HH;
destruct HH as [Hpos Hlength]];
rewrite <- H; rewrite <- inj_plus;
apply inj_eq;
apply (Raw_List.next_position_gen l cu Hlength Hpos).
intros [[_ HH] | HH]; [apply inj_eq_rev in HH |].
apply Raw_List.next_position_last; exact HH.
rewrite HH; apply Raw_List.next_position_O.
Qed.

(*Why predicate*) Definition last__  (co:set) (cu:cursor)
  := ((~(is_empty_ co) -> (position_ co cu) = (length_ co))) /\
     (((is_empty_ co) -> cu = no_element)).

(*Why logic*) Definition last_ : set -> cursor.
exact Raw_List.last.
Defined.

Lemma is_empty_length :
forall l : set, not (is_empty_ l) -> (Raw_List.length l <> 0)%nat.
unfold is_empty_; unfold length_; unfold position_;
intros l H.
intro Hl; apply H.
intro cu; rewrite <- inj_0; apply inj_eq.
symmetry; apply le_n_O_eq.
rewrite <- Hl.
apply Raw_List.position_length.
Qed.

(*Why axiom*) Lemma last_last : (forall (co:set), (last__ co (last_ co))).
intro l; unfold last__; unfold last_; unfold position_;
unfold length_; unfold no_element.
split; [intros _ |intros H;
apply length_is_empty in H; unfold length_ in H].
apply inj_eq; apply Raw_List.position_last_gen.
rewrite <- inj_0 in H; apply inj_eq_rev in H;
apply Raw_List.last_nil; exact H.
Qed.

(*Why predicate*) Definition first__  (co:set) (cu:cursor)
  := ((~(is_empty_ co) -> (position_ co cu) = 1)) /\
     (((is_empty_ co) -> cu = no_element)).

(*Why logic*) Definition first_ : set -> cursor.
exact Raw_List.first.
Defined.

(*Why axiom*) Lemma first_first :
  (forall (co:set), (first__ co (first_ co))).
intro l; unfold first__; unfold first_; unfold position_;
unfold no_element; unfold length_.
assert (Z_of_nat (1) = 1).
auto.
split;
[rewrite <- H; intro HH; apply inj_eq;
apply is_empty_length in HH |
unfold is_empty_; unfold length_; unfold position_;
intros Hl; apply length_is_empty in Hl;
rewrite <- inj_0 in Hl; apply inj_eq_rev in Hl].
apply Raw_List.position_first_gen; exact HH.
apply Raw_List.first_nil; exact Hl.
Qed.

(*Why logic*) Definition find_ : set -> R -> cursor.
exact Raw_List.find.
Defined.

(*Why predicate*) Definition find__  (co:set) (i:R) (cu:cursor)
  := cu = no_element /\
     (forall (cun:cursor),
      ((position_ co cun) > 0 -> ~(eq (witness (element_ co cun)) i))) \/
     (position_ co cu) > 0 /\ (eq (witness (element_ co cu)) i) /\
     (forall (cun:cursor),
      ((position_ co cun) > 0 ->
       (cu <> cun ->
        ~(eq (witness (element_ co cun)) i)))).

(*Why axiom*) Lemma find_find_val :
  (forall (co:set),
   (forall (i:R), (find__ co i (find_ co i)) /\
    (((is_empty_ co) -> (find_ co i) = no_element)))).
intros m r; unfold find__; unfold find_; unfold is_empty_;
unfold position_; unfold no_element; unfold element_; unfold first_.
split.
destruct (gt_O_eq (Raw_List.position m (Raw_List.find m r
))) as [Hf | Hf];
[right | left]; split.
rewrite <- inj_0; apply inj_gt; exact Hf.
split.
apply Raw_List.find_element; exact Hf.
intros cun Hpos Hs Hw.
contradict Hs.
rewrite <- Hw.
apply (Raw_List.position_eq m); [rewrite Hw; exact Hf|].
rewrite <- inj_0 in Hpos; apply inj_gt_rev in Hpos.
apply (find_position_inv m (ordered_hashed m (owf m)) cun Hpos).
apply (Raw_List.find_position); symmetry; exact Hf.
symmetry in Hf; apply Raw_List.find_position in Hf.
intros cun Hpos Hw; rewrite <- inj_0 in Hpos;
apply inj_gt_rev in Hpos; rewrite <- Hw in Hf.
destruct (gt_O_eq (Raw_List.position m
                      (Raw_List.find m
                          (witness
                             (Raw_List.element m cun))
                    ))) as [Hpf|Hpf].
simpl in Hpf;
rewrite Hf in Hpf; rewrite Raw_List.position_no_element in Hpf;
contradict Hpf; apply gt_irrefl.
unfold witness in Hpf;
rewrite (find_position_inv m (ordered_hashed m (owf m)) cun Hpos) in Hpf;
contradict Hpos; simpl in Hpf; rewrite <- Hpf; apply gt_irrefl.
intros Hemp; apply length_is_empty in Hemp.
unfold length_ in Hemp; rewrite <- inj_0 in Hemp;
apply inj_eq_rev in Hemp.
apply (Raw_List.find_nil m _ Hemp).
Qed.

(*Why axiom*) Lemma ordered :
  (forall (s:set),
   (forall (cu1:cursor),
    (forall (cu2:cursor),
     ((position_ s cu1) > 0 /\ (position_ s cu2) > 0 ->
      ((position_ s cu2) > (position_ s cu1) <->
       (Rgt (witness (element_ s cu2)) (witness (element_ s cu1)))))))).
unfold position_; unfold witness; unfold element_;
intros s cu1 cu2 [Hp1 Hp2]; rewrite <- inj_0 in Hp1;
rewrite <- inj_0 in Hp2; apply inj_gt_rev in Hp1;
apply inj_gt_rev in Hp2; split.
intro Hsup; apply inj_gt_rev in Hsup.
apply (po_el_order s cu1 cu2 Hp1 Hp2 Hsup).
intro Hel; apply inj_gt.
apply (el_po_order s cu1 cu2 Hp1 Hp2 Hel).
Qed.

(*Why predicate*) Definition left_pos  (co:set) (i:Z) (col:set)
  := (forall (cu:cursor),
      (((position_ co cu) >= i -> (position_ col cu) = 0)) /\
      (((position_ co cu) < i -> (position_ col cu) = (position_ co cu) /\
        (element_ col cu) = (element_ co cu))) /\
      (((position_ col cu) > 0 -> (position_ co cu) = (position_ col cu)))).

(*Why predicate*) Definition left_find  (co:set) (i:Z) (col:set)
  := (forall (w:R),
      (i > (position_ co (find_ co w)) /\ (position_ co (find_ co w)) > 0 \/
       (position_ col (find_ col w)) > 0 -> (find_ co w) = (find_ col w))).

(*Why predicate*) Definition left__  (co:set) (cu:cursor) (col:set)
  := ((cu = no_element -> col = co)) /\
     (((position_ co cu) > 0 -> (length_ col) = ((position_ co cu) - 1) /\
       (left_pos co (position_ co cu) col) /\
       (left_find co (position_ co cu) col))).

(*Why logic*) Definition left_ : set -> cursor -> set.
exact oleft.
Defined.

(*Why axiom*) Lemma left_left :
  (forall (co:set), (forall (cu:cursor), (left__ co cu (left_ co cu)))).
intros m cu; unfold left__; unfold left_; unfold left_pos;
unfold left_find; unfold find_; unfold position_; unfold length_;
unfold no_element; unfold element_; unfold first_.
split.
intro HO; rewrite  HO; unfold oleft; simpl; reflexivity.
unfold oleft; case_eq (beq_nat cu O); [intros Heq Hko;
apply beq_nat_true in Heq; rewrite Heq in Hko;
rewrite (Raw_List.position_no_element) in Hko; rewrite <- inj_0 in Hko;
apply inj_gt_rev in Hko; contradict Hko; apply gt_irrefl|intros _].
assert (Z_of_nat (1) = 1). auto.
intro Hpos; rewrite <- inj_0 in Hpos; apply inj_gt_rev in Hpos;
split.
rewrite <- H.
rewrite <- (inj_minus1 (Raw_List.position m cu) 1
(gt_le_S 0 (Raw_List.position m cu) Hpos)); apply inj_eq.
apply (Raw_List.left_length m cu Hpos).
split.
intro cun; split.
intro HH; apply Zge_le in HH; apply inj_le_rev in HH;
rewrite <- inj_0; apply inj_eq.
apply (Raw_List.left_position_out m cu Hpos cun HH).
split.
intro HH; apply Zlt_gt in HH; apply inj_gt_rev in HH; split.
apply inj_eq.
apply (Raw_List.left_position_in m cu Hpos cun HH).
apply (Raw_List.left_element_in m cu Hpos cun) in HH.
simpl; rewrite HH; split; reflexivity.
intro HH; rewrite <- inj_0 in HH; apply inj_gt_rev in HH;
apply inj_eq.
apply (Raw_List.left_position_inv m cu Hpos cun HH).
intros w [[Hsup Hpf] | Hpf].
rewrite <- inj_0 in Hpf; apply inj_gt_rev in Hsup;
apply inj_gt_rev in Hpf.
apply (left_find_in m cu w Hpos Hsup).
rewrite <- inj_0 in Hpf; apply inj_gt_rev in Hpf.
apply (left_find_rev m cu w Hpos Hpf).
Qed.

(*Why predicate*) Definition right_pos  (co:set) (i:Z) (cor:set)
  := (forall (cu:cursor),
      ((i > (position_ co cu) -> (position_ cor cu) = 0)) /\
      ((i <= (position_ co cu) -> (position_ cor cu) =
        ((position_ co cu) - i + 1) /\ (element_ cor cu) = (element_ co cu))) /\
      (((position_ cor cu) > 0 -> (position_ co cu) =
        ((position_ cor cu) + i - 1)))).

(*Why predicate*) Definition right_find  (co:set) (i:Z) (cor:set)
  := (forall (w:R),
      (i <= (position_ co (find_ co w)) /\ i > 0 \/
       (position_ cor (find_ cor w)) > 0 -> (find_ co w) = (find_ cor w))).

(*Why predicate*) Definition right__  (co:set) (cu:cursor) (cor:set)
  := ((cu = no_element -> cor = empty_)) /\
     (((position_ co cu) > 0 -> (length_ cor) =
       ((length_ co) - (position_ co cu) + 1) /\
       (right_pos co (position_ co cu) cor) /\
       (right_find co (position_ co cu) cor))) /\
     (forall (cun:cursor),
      ((position_ cor cun) > 0 -> (position_ co cun) > 0)).

(*Why logic*) Definition right_ : set -> cursor -> set.
exact oright.
Defined.

(*Why axiom*) Lemma right_right :
  (forall (co:set), (forall (cu:cursor), (right__ co cu (right_ co cu)))).
intros m cu; unfold right__; unfold right_pos; unfold right_find;
unfold right_; unfold find_; unfold position_; unfold length_;
unfold no_element; unfold element_; unfold empty_;
unfold oright; unfold first_.
assert (Z_of_nat (1) = 1). auto.
split; [intro HH; rewrite HH; unfold oright; simpl; reflexivity|].
split.
unfold oright; case_eq (beq_nat cu O); [intros Heq Hko;
apply beq_nat_true in Heq; rewrite Heq in Hko;
rewrite (Raw_List.position_no_element) in Hko; rewrite <- inj_0 in Hko;
apply inj_gt_rev in Hko; contradict Hko; apply gt_irrefl|intros _].
intro Hpos; rewrite <- inj_0 in Hpos; apply inj_gt_rev in Hpos;
split.
rewrite <- (inj_minus1 (Raw_List.length m) (Raw_List.position m cu)
(Raw_List.position_length m cu));
rewrite <- H; rewrite <- inj_plus; apply inj_eq.
simpl; apply (Raw_List.right_length m cu Hpos).
split.
intro cun; split.
intro Hs; apply inj_gt_rev in Hs; rewrite <- inj_0;
apply inj_eq.
apply (Raw_List.right_position_out m cu Hpos cun Hs).
split.
intro Hs; apply inj_le_rev in Hs; split.
rewrite <- H;
rewrite <- (inj_minus1 (Raw_List.position m cun) (Raw_List.position m cu) Hs);
rewrite <- inj_plus; apply inj_eq.
apply (Raw_List.right_position_in m cu Hpos cun Hs).
apply (Raw_List.right_element_in m cu Hpos cun) in Hs.
simpl; rewrite Hs; split; reflexivity.
intro HH; rewrite <- inj_0 in HH; apply inj_gt_rev in HH.
rewrite <- H;
rewrite <- inj_plus.
rewrite <- (inj_minus1 _ 1 (gt_le_S _ _
(le_gt_trans _ _ _ (le_plus_l _ _) HH))).
apply inj_eq.
apply (Raw_List.right_position_inv m cu Hpos cun HH).
intros w [[Hinf _] | Hpf].
apply inj_le_rev in Hinf.
apply (right_find_in m cu w Hpos Hinf).
rewrite <- inj_0 in Hpf; apply inj_gt_rev in Hpf.
apply (right_find_rev (to_hashed m) cu w Hpos Hpf).
case (beq_nat cu 0); simpl.
intros cun Hko; contradict Hko; apply Zgt_irrefl.
intros cun Hpos; rewrite <- inj_0 in Hpos;
apply inj_gt_rev in Hpos; rewrite <- inj_0;
apply inj_gt.
apply (Raw_List.has_element_right m cu cun Hpos).
Qed.

(*Why predicate*) Definition replace_  (co1:set) (e:element_t) (co2:set)
  := (position_ co1 (find_ co1 (witness e))) > 0 /\ (length_ co1) =
     (length_ co2) /\ (element_ co2 (find_ co1 (witness e))) = e /\
     (forall (cun:cursor), (position_ co2 cun) = (position_ co1 cun) /\
      ((~cun = (find_ co1 (witness e)) ->
        (element_ co2 cun) = (element_ co1 cun)))) /\
     (forall (w:R), (find_ co1 w) = (find_ co2 w)).

(*Why predicate*) Definition replace_pos  (co1:set) (co2:set)
  := (forall (cu:cursor), (position_ co1 cu) = 0 /\ (position_ co2 cu) = 0 \/
      (position_ co1 cu) > 0 /\ (position_ co2 cu) > 0).

(*Why predicate*) Definition replace_element_  (co1:set) (cu:cursor) (e:element_t) (co2:set)
  := (position_ co1 cu) > 0 /\ (length_ co1) = (length_ co2) /\
     (element_ co2 cu) = e /\ (replace_pos co1 co2) /\
     (forall (cun:cursor),
      ((position_ co1 cun) > 0 ->
       (~(cu = cun) -> (element_ co2 cun) = (element_ co1 cun)))) /\
     (forall (w:R),
      ((~(eq (witness e) w) /\ ~(find_ co1 w) = cu ->
        (find_ co1 w) = (find_ co2 w))) /\
      (((eq (witness e) w) -> (find_ co2 w) = cu))).

(*Why logic*) Definition ceiling : set -> R -> cursor.
exact ceiling.
Defined.

(*Why predicate*) Definition is_ceiling  (s:set) (i:R) (cu:cursor)
  := (cu = no_element \/ (position_ s cu) > 0) /\
     ((cu = no_element -> (is_empty_ s) \/
       (Rgt i (witness (element_ s (last_ s)))))) /\
     (((position_ s cu) > 0 -> (Rle i (witness (element_ s cu))) /\
       (((Rgt (witness (element_ s cu)) i) -> (find_ s i) = no_element /\
         (cu = (first_ s) \/ ~cu = (first_ s) /\
         (Rgt i (witness (element_ s (last_ (left_ s cu)))))))))).

(*Why axiom*) Lemma ceiling_is_ceiling :
  (forall (s:set), (forall (i:R), (is_ceiling s i (ceiling s i)))).
intros m w; unfold is_ceiling; unfold ceiling; unfold find_;
unfold element_; unfold witness; unfold last_; unfold is_empty_;
unfold first_; unfold no_element; unfold position_; unfold left_.
split.
destruct (ceiling_position m w) as [Hc | Hp];
[left; exact Hc|right; rewrite <- inj_0; apply inj_gt; exact Hp].
split.
intros Hc; destruct (ceiling_O m w Hc) as [Hl | Hs];
[left; intro cu|right; exact Hs].
rewrite <- inj_0; apply inj_eq; symmetry;
apply le_n_O_eq; rewrite <- Hl.
apply Raw_List.position_length.
intro Hpos; rewrite <- inj_0 in Hpos; apply inj_gt_rev in Hpos.
split.
apply ceiling_base; exact Hpos.
intros Hw; split.
apply (ceiling_find m w Hw).
case_eq(beq_nat (Raw_Set.ceiling m w) (Raw_List.first m));
intro Heq; [left; apply beq_nat_true in Heq; exact Heq |
right; apply beq_nat_false in Heq; split; [exact Heq|]].
apply (ceiling_oleft m w Hpos Hw Heq).
Qed.

(*Why predicate*) Definition insert_find  (co1:set) (e:element_t) (co2:set)
  := (forall (i:R), (~(eq i (witness e)) -> (find_ co1 i) = (find_ co2 i))).

(*Why predicate*) Definition insert_pos  (co1:set) (e:element_t) (co2:set)
  := (forall (cun:cursor),
      ((position_ co1 cun) > 0 -> (element_ co1 cun) = (element_ co2 cun) /\
       ~(eq (witness (element_ co1 cun)) (witness e)) /\
       (((Rgt (witness e) (witness (element_ co1 cun))) ->
         (position_ co2 cun) = (position_ co1 cun))) /\
       (((Rgt (witness (element_ co1 cun)) (witness e)) ->
         (position_ co2 cun) = ((position_ co1 cun) + 1))))).

(*Why predicate*) Definition insert_inv  (co1:set) (e:element_t) (co2:set)
  := (forall (cun:cursor),
      (0 < (position_ co2 cun) ->
       (((eq (witness (element_ co2 cun)) (witness e)) ->
         (position_ co1 cun) = 0 /\ (element_ co2 cun) = e)) /\
       ((~(eq (witness (element_ co2 cun)) (witness e)) ->
         (element_ co1 cun) = (element_ co2 cun) /\ (position_ co1 cun) > 0)))).

(*Why predicate*) Definition insert_  (co1:set) (e:element_t) (co2:set)
  := (position_ co2 (find_ co2 (witness e))) > 0 /\ (length_ co2) =
     ((length_ co1) + 1) /\ (insert_pos co1 e co2) /\
     (insert_inv co1 e co2) /\ (insert_find co1 e co2).

(*Why axiom*) Lemma insert_find_nl :
  (forall (co1:set),
   (forall (e:element_t),
    (forall (co2:set),
     ((insert_ co1 e co2) ->
      (((ceiling co1 (witness e)) = no_element ->
        (find_ co2 (witness e)) = (last_ co2))) /\
      (((position_ co1 (ceiling co1 (witness e))) > 0 ->
        (position_ co2 (find_ co2 (witness e))) =
        (position_ co1 (ceiling co1 (witness e))))))))).
assert(Z_of_nat (1) = 1). auto.
intros m e im [Hfind [Hlength [Hipos [Hiinv Hifind]]]].
unfold insert_pos in Hipos; unfold insert_inv in Hiinv;
unfold insert_find in Hifind.
destruct (Hiinv _ (Zgt_lt _ _ Hfind)) as [He _].
unfold find_ in Hfind; unfold first_ in Hfind;
unfold position_ in Hfind; rewrite <- inj_0 in Hfind;
apply inj_gt_rev in Hfind.
unfold length_ in Hlength; rewrite <- H in Hlength;
rewrite <- inj_plus in Hlength; apply inj_eq_rev in Hlength.
unfold find_ in He; unfold element_ in He; unfold witness in He;
unfold first_ in He.
rewrite (Raw_List.find_element im (Elt.witness e) Hfind) in He.
destruct (He (reflexivity _)) as [Hpos _]; clear He.
split.
intros Hc; apply (Raw_List.position_eq im _ _ Hfind).
unfold position_; rewrite Raw_List.position_last_gen.
destruct (gt_O_eq (Raw_List.length m)) as [Hli | Hli].
unfold no_element in Hc; apply ceiling_O in Hc.
destruct Hc as [Hko|Hsup].
contradict Hli; rewrite Hko; apply gt_irrefl.
destruct (le_lt_eq_dec _ _ (Raw_List.position_length im
(Raw_List.find im (witness e)))) as [Hko | Heq];
[contradict Hko; rewrite Hlength|exact Heq].
rewrite <- plus_n_Sm; rewrite <- plus_n_O.
apply le_not_gt; apply gt_S_le; apply gt_n_S.
generalize Hli; intro Hposp;
rewrite <- (Raw_List.position_last_gen);
rewrite <- (Raw_List.position_last_gen) in Hposp.
unfold position_ in Hipos;
apply inj_gt in Hposp; rewrite inj_0 in Hposp;
destruct (Hipos _ Hposp) as [He[_[Hint _]]];
rewrite <- inj_0 in Hposp; apply inj_gt_rev in Hposp.
apply inj_gt_rev;
unfold element_ in Hint; rewrite <- (Hint Hsup);
apply inj_gt.
apply inj_gt in Hposp; rewrite <- (Hint Hsup) in Hposp;
apply inj_gt_rev in Hposp.
apply (w_po_order_l im _ _ Hposp Hfind).
unfold element_ in He; rewrite <- He; exact Hsup.
rewrite <- Hli in Hlength; simpl in Hlength;
destruct (le_lt_eq_dec _ _ (Raw_List.position_length im
(Raw_List.find im (witness e)))) as [Hko | Heq];
[contradict Hko; rewrite Hlength|exact Heq].
apply le_not_gt; apply gt_S_le; apply gt_n_S.
exact Hfind.
intro Hc; destruct (Hipos _ Hc) as [He[Hw[_ Hint]]].
unfold position_ in Hc; rewrite <- inj_0 in Hc; apply inj_gt_rev in Hc;
destruct (Rle_lt_or_eq_dec _ _ (ceiling_base _ _ Hc)) as [Hlt | Heq];
[|contradict Hw; unfold element_; symmetry; apply Heq].
apply Rlt_gt in Hlt.
unfold position_; apply inj_eq.
unfold element_ in Hint; generalize (Hint Hlt); intro Heqpos.
unfold position_ in Heqpos;
rewrite <- H in Heqpos; rewrite <- inj_plus in Heqpos;
apply inj_eq_rev in Heqpos;
rewrite <- plus_n_Sm in Heqpos; rewrite <- plus_n_O in Heqpos.
generalize (gt_Sn_O (Raw_List.position m (ceiling m (witness e))));
intro Hci; rewrite <- Heqpos in Hci.
unfold element_ in He; unfold ceiling in He; rewrite He in Hlt.
apply (w_po_order_r im _ _ Hci Hfind) in Hlt.
rewrite Heqpos in Hlt; apply gt_S_le in Hlt.
destruct (le_lt_eq_dec _ _ Hlt) as [Hinf|Heq];
[|exact Heq].
apply (lt_not_le) in Hinf; apply not_le in Hinf.
generalize (gt_le_trans _ _ _ Hinf (gt_le_S _ _ Hfind)); intro Hprev;
generalize Hprev; intro Hppos.
apply Raw_List.position_previous_gen in Hprev.
apply gt_pred in Hppos; rewrite <- (pred_of_minus) in Hprev;
rewrite <- Hprev in Hppos.
apply gt_le_S in Hinf; apply le_pred in Hinf;
rewrite <- pred_Sn in Hinf; rewrite <- Hprev in Hinf.
generalize (ceiling_previous m _ Hppos); intro Hpw.
generalize (Hipos (Raw_List.previous m (ceiling m (witness e))));
intros Hpint.
unfold position_ in Hpint; apply inj_gt in Hppos;
rewrite inj_0 in Hppos; generalize (Hpint Hppos); clear Hpint;
rewrite <- inj_0 in Hppos; apply inj_gt_rev in Hppos.
intros [Hpe[Hppw[Hpint _]]].
generalize (Hpint Hpw); clear Hint Hpint.
intros Hpeqpos; apply inj_eq_rev in Hpeqpos.
rewrite <- Hpeqpos in Hinf; rewrite <- Hpeqpos in Hppos.
unfold element_ in Hpe; unfold ceiling in Hpe; rewrite Hpe in Hpw.
apply (w_po_order_l im _ (witness e) Hppos Hfind) in Hpw.
contradict Hinf; apply gt_not_le.
exact Hpw.
Qed.

(*Why predicate*) Definition delete_find  (co1:set) (e:element_t) (co2:set)
  := (forall (w:R),
      ((~(eq (witness e) w) -> (find_ co1 w) = (find_ co2 w))) /\
      (((eq (witness e) w) -> (find_ co2 w) = no_element))).

(*Why predicate*) Definition delete_pos  (co1:set) (i:Z) (co2:set)
  := (forall (cun:cursor),
      (((position_ co1 cun) = i -> (position_ co2 cun) = 0)) /\
      (((position_ co1 cun) > i -> (position_ co2 cun) =
        ((position_ co1 cun) - 1) /\ (element_ co2 cun) = (element_ co1 cun))) /\
      ((i > (position_ co1 cun) -> (position_ co2 cun) =
        (position_ co1 cun) /\ (element_ co2 cun) = (element_ co1 cun)))).

(*Why predicate*) Definition delete_inv  (co1:set) (i:Z) (co2:set)
  := (forall (cun:cursor),
      ((i <= (position_ co2 cun) -> (position_ co1 cun) =
        ((position_ co2 cun) + 1) /\ (element_ co1 cun) = (element_ co2 cun))) /\
      ((i > (position_ co2 cun) /\ (position_ co2 cun) > 0 ->
        (position_ co1 cun) = (position_ co2 cun) /\
        (element_ co2 cun) = (element_ co1 cun)))).

(*Why predicate*) Definition delete_  (co1:set) (cu:cursor) (co2:set)
  := (find_ co2 (witness (element_ co1 cu))) = no_element /\
     (position_ co1 cu) > 0 /\ (length_ co2) = ((length_ co1) - 1) /\
     (delete_pos co1 (position_ co1 cu) co2) /\
     (delete_inv co1 (position_ co1 cu) co2) /\
     (delete_find co1 (element_ co1 cu) co2).

(*Why predicate*) Definition include__  (co1:set) (e:element_t) (co2:set)
  := (((position_ co1 (find_ co1 (witness e))) > 0 -> (replace_ co1 e co2))) /\
     (((find_ co1 (witness e)) = no_element -> (insert_ co1 e co2))).

(*Why predicate*) Definition exclude_  (co1:set) (e:element_t) (co2:set)
  := (((position_ co1 (find_ co1 (witness e))) > 0 ->
       (delete_ co1 (find_ co1 (witness e)) co2))) /\
     (((find_ co1 (witness e)) = no_element -> co1 = co2)).

(*Why predicate*) Definition has_element_  (co:set) (cu:cursor)
  := (position_ co cu) > 0.

(*Why predicate*) Definition contains_  (co:set) (i:R)
  := (position_ co (find_ co i)) > 0.

(*Why axiom*) Lemma empty_contains :
  (forall (s:set), ((forall (i:R), ~(contains_ s i)) -> (is_empty_ s))).
unfold contains_; unfold is_empty_; intros m Hc cu.
generalize (Hc (Elt.witness(element_ m cu))).
intros Hpf; destruct(gt_O_eq (Raw_List.position m cu)) as [Hpo | Heq].
contradict Hpf; unfold position_; unfold element_; unfold find_;
unfold first_; rewrite <- inj_0; apply inj_gt.
rewrite (find_position_inv m (ordered_hashed m (owf m))); apply Hpo.
unfold position_; rewrite <- inj_0; apply inj_eq;
symmetry; exact Heq.
Qed.

(*Why predicate*) Definition equal_  (co1:set) (co2:set)
  := (forall (cu:cursor), (position_ co1 cu) = (position_ co2 cu) /\
      (((position_ co1 cu) > 0 -> (element_ co1 cu) = (element_ co2 cu)))).

(*Why predicate*) Definition equivalent_  (co1:set) (co2:set)
  := (forall (i:R), ((contains_ co1 i) -> (contains_ co2 i))) /\
     (length_ co1) = (length_ co2).

(*Why axiom*) Lemma equivalent_sym :
  (forall (co1:set),
   (forall (co2:set), ((equivalent_ co1 co2) -> (equivalent_ co2 co1)))).
unfold equivalent_; unfold contains_; unfold find_; unfold position_;
unfold first_; intros m1 m2 [He Hl]; split;
[|symmetry; exact Hl].
intros w Hc.
assert (Raw_List.has_element m1
(Raw_List.find m1 w) = true).
rewrite <- inj_0 in Hc; apply inj_gt_rev in Hc;
apply (Raw_List.has_element_position) in Hc.
apply (equivalent_find (to_hashed m1) (to_hashed m2)).
simpl; intros i; repeat(rewrite <- find_find2).
intros Hh1; apply (Raw_List.position_has_element) in Hh1.
apply inj_gt in Hh1; rewrite inj_0 in Hh1.
generalize (He i Hh1); intro Hh2.
apply (Raw_List.has_element_position); apply inj_gt_rev;
rewrite inj_0; exact Hh2.
simpl; unfold length_ in Hl; apply inj_eq_rev; exact Hl.
simpl; exact Hc.
apply (Raw_List.position_has_element) in H; apply inj_gt in H;
rewrite inj_0 in H.
destruct (He w H) as [_ Hel].
exact H.
Qed.

(*Why logic*) Definition inter_ : set -> set -> set.
exact ointer.
Defined.

(*Why predicate*) Definition is_inter  (s1:set) (s2:set) (i:set)
  := (forall (j:R),
      (((contains_ s1 j) /\ (contains_ s2 j) -> (contains_ i j))) /\
      ((~(contains_ s1 j) \/ ~(contains_ s2 j) -> ~(contains_ i j)))).

(*Why axiom*) Lemma inter_is_inter :
  (forall (s1:set),
   (forall (s2:set), (is_inter s1 s2 (inter_ s1 s2)) /\
    (length_ (inter_ s1 s2)) = (length_ (inter_ s2 s1)))).
intros s1 s2; unfold is_inter; unfold inter_; unfold hinter;
unfold length_; unfold contains_; unfold position_;
unfold find_; unfold first_; simpl; split.
intro w; repeat(rewrite find_find2); rewrite <- inj_0; split.
intros [H1 H2]; apply inj_gt_rev in H1; apply inj_gt_rev in H2;
apply Raw_List.has_element_position in H1;
apply Raw_List.has_element_position in H2;
apply inj_gt; apply Raw_List.position_has_element;
apply (inter_contains _ _ _ H1 H2).
intros HH Hp; apply Classical_Prop.or_not_and in HH; contradict HH.
apply inj_gt_rev in Hp; apply Raw_List.has_element_position in Hp;
destruct (inter_contains_inv _ _ _ Hp) as [Hp1 Hp2].
split; apply inj_gt; apply Raw_List.position_has_element;
[exact Hp1|exact Hp2].
apply inj_eq; apply (inter_length s1 s2
(ordered_hashed s1 (owf s1)) (ordered_hashed s2 (owf s2))).
Qed.

(*Why logic*) Definition union_ : set -> set -> set.
exact ounion.
Defined.

(*Why predicate*) Definition is_union  (s1:set) (s2:set) (u:set)
  := (forall (i:R),
      (((contains_ s1 i) \/ (contains_ s2 i) -> (contains_ u i))) /\
      ((~(contains_ s1 i) /\ ~(contains_ s2 i) -> ~(contains_ u i))) /\
      (length_ u) = ((length_ s1) + (length_ s2) - (length_ (inter_ s1 s2)))).

(*Why axiom*) Lemma union_is_union :
  (forall (s1:set), (forall (s2:set), (is_union s1 s2 (union_ s1 s2)))).
intros s1 s2; unfold is_union; unfold union_; unfold inter_;
unfold length_; unfold contains_; unfold position_;
unfold find_; unfold first_.
intro w; repeat(rewrite find_find2); rewrite <- inj_0; split.
intros [H | H]; apply inj_gt_rev in H;
apply Raw_List.has_element_position in H;
apply inj_gt; apply Raw_List.position_has_element;
apply (ounion_contains s1 s2 w); [left|right]; exact H.
split.
intros HH Hp; apply Classical_Prop.and_not_or in HH; contradict HH.
apply inj_gt_rev in Hp; apply Raw_List.has_element_position in Hp;
destruct (ounion_contains_inv _ _ _ Hp) as [H | H];
[left|right]; apply inj_gt; apply Raw_List.position_has_element;
exact H.
apply Zplus_minus_eq; repeat(rewrite <- inj_plus);
apply inj_eq; symmetry; rewrite plus_comm; apply (ounion_length s1 s2).
Qed.

(*Why logic*) Definition diff_ : set -> set -> set.
exact odiff.
Defined.

(*Why predicate*) Definition is_diff  (s1:set) (s2:set) (d:set)
  := (forall (i:R),
      (((contains_ s1 i) /\ ~(contains_ s2 i) -> (contains_ d i))) /\
      ((~(contains_ s1 i) \/ (contains_ s2 i) -> ~(contains_ d i))) /\
      (length_ d) = ((length_ s1) - (length_ (inter_ s1 s2)))).

(*Why axiom*) Lemma diff_is_diff :
  (forall (s1:set), (forall (s2:set), (is_diff s1 s2 (diff_ s1 s2)))).
intros s1 s2; unfold is_diff; unfold inter_; unfold diff_;
unfold hdiff; unfold hinter;
unfold length_; unfold contains_; unfold position_;
unfold find_; unfold first_; simpl.
intro w; repeat(rewrite find_find2); rewrite <- inj_0; split.
intros [H1 Hn2]; apply inj_gt_rev in H1;
apply Raw_List.has_element_position in H1;
case_eq (Raw_List.has_element s2 (Raw_List.find s2 w)); intro H2;
[contradict Hn2; apply inj_gt;
apply (Raw_List.position_has_element _ _ H2)|];
apply inj_gt; apply Raw_List.position_has_element;
apply (diff_contains _ _ _ H1 H2).
split.
intros HH Hp; apply inj_gt_rev in Hp;
apply Raw_List.has_element_position in Hp;
destruct (diff_contains_inv _ _ _ (ordered_hashed s1 (owf s1)) Hp)
as [Hp1 Hp2].
destruct HH as [H | H]; [contradict H|contradict Hp2].
apply inj_gt; apply (Raw_List.position_has_element _ _ Hp1).
apply inj_gt_rev in H; rewrite (Raw_List.has_element_position _ _ H);
apply Bool.diff_true_false.
apply Zplus_minus_eq; rewrite <- inj_plus;
apply inj_eq; symmetry; rewrite plus_comm;
apply (diff_length s1 s2 (ordered_hashed s1 (owf s1))
(ordered_hashed s2 (owf s2))).
Qed.

(*Why predicate*) Definition is_subset_  (s1:set) (s2:set)
  := (forall (i:R), ((contains_ s1 i) -> (contains_ s2 i))).

(*** TESTS ***)

Definition insert : set -> element_t -> set.
exact oinsert.
Defined.

Lemma insert_insert :
forall (l : set), forall (e : element_t),
not (contains_ l (witness e)) ->
insert_ l e (insert l e).
intros l e; unfold insert_; unfold contains_; unfold has_element_;
unfold insert_pos; unfold insert_find; unfold insert_inv; unfold length_;
unfold position_; unfold no_element; unfold insert; unfold oinsert;
unfold element_; unfold find_; unfold first_; simpl.
assert (Z_of_nat (1) = 1). auto.
intro Hnfind; destruct (Raw_List.find_has_element l (witness e)
) as [Hko|Hfind];
[contradict Hnfind; rewrite <- inj_0; apply inj_gt;
apply (Raw_List.position_has_element _ _ Hko)|].
unfold witness in Hfind.
generalize Hfind; intro Hins;
apply (oinsertl_is_insert l e) in Hins; split;
clear Hnfind.
rewrite <- inj_0; apply inj_gt.
rewrite <- (Raw_List.insert_element_new l 
(Raw_Set.ceiling l (Elt.witness e)) e
(Raw_List.New_Max.new l)) at 3; [|reflexivity].
unfold witness; rewrite <- Hins.
rewrite (find_position_inv (oinsertl l e)
(ordered_hashed _ (WFo_insert l e (owf l)))); simpl; rewrite Hins;
apply Raw_List.insert_has_element_new.
split; [rewrite Hins; rewrite <- H; rewrite <- inj_plus;
apply inj_eq; apply Raw_List.insert_length|].
split;[intros cu Hpos|split;[intros cu Hipos|intros w Hw]].
rewrite <- inj_0 in Hpos; apply inj_gt_rev in Hpos; split; [|split].
rewrite Hins; rewrite (Raw_List.insert_element_old l _ _ _ Hpos);
reflexivity.
unfold witness; apply (find_O_diff l _ _ Hfind Hpos).
split; intro Hgt; [|rewrite <- H; rewrite <- inj_plus]; apply inj_eq.
rewrite Hins; apply (oinsertl_position_inf l _ _ Hpos (owf l)).
simpl; exact Hgt.
rewrite plus_comm; simpl; rewrite Hins;
apply (oinsertl_position_sup l _ _ Hpos (owf l)).
simpl; exact Hgt.
apply Zlt_gt in Hipos; split;
rewrite <- inj_0 in Hipos; apply inj_gt_rev in Hipos;
rewrite Hins in Hipos; destruct (Raw_List.insert_has_element l
(ceiling l (Elt.witness e)) e cu Hipos) as [Heq|Hpos].
intros _; rewrite Heq.
split.
rewrite <- inj_0; apply inj_eq;
apply (Raw_List.insert_position_rev_new l
(Raw_Set.ceiling l (Elt.witness e)) e); reflexivity.
rewrite Hins; rewrite (Raw_List.insert_element_new); [|reflexivity].
simpl; split; reflexivity.
generalize (find_position_inv l (ordered_hashed l (owf l)) _ Hpos);
simpl; intro Hff.
rewrite (Raw_List.insert_element_old _ 
(Raw_Set.ceiling l (Elt.witness e)) e _ Hpos) in Hff.
unfold witness; intro He; contradict Hff; 
pattern (Raw_List.insert l
(Raw_Set.ceiling l (Elt.witness e)) e).
rewrite <- Hins; rewrite He; rewrite Hfind.
intro Heq; contradict Hpos; rewrite <- Heq;
rewrite (Raw_List.position_no_element); apply gt_irrefl.
intro Hko; contradict Hko; rewrite Heq; rewrite Hins;
rewrite (Raw_List.insert_element_new); [simpl|]; reflexivity.
intros _; rewrite Hins;
rewrite (Raw_List.insert_element_old _ _ _ _ Hpos).
simpl; split; [reflexivity|rewrite <- inj_0; apply inj_gt; exact Hpos].
rewrite Hins; repeat(rewrite find_find2);
apply Raw_Set.insert_find; simpl; exact Hw.
Qed.

Definition delete : set -> cursor -> set.
exact odelete.
Defined.

Lemma delete_delete :
forall (l : set), forall (cu : cursor),
has_element_ l cu -> delete_ l cu (delete l cu).
intros l cu; unfold has_element_; unfold delete_; unfold delete;
unfold odelete; unfold delete_pos; unfold delete_inv; unfold delete_find;
unfold position_; unfold element_; unfold no_element;
unfold length_; unfold find_; unfold first_; simpl.
intro Hpos; split.
rewrite <- inj_0 in Hpos; apply inj_gt_rev in Hpos;
apply (Raw_List.has_element_position) in Hpos;
unfold witness.
apply (delete_find_deleted _ _ Hpos (ordered_hashed l (owf l))).
split; [exact Hpos|].
assert (Z_of_nat (1) = 1). auto.
rewrite <- inj_0 in Hpos; apply inj_gt_rev in Hpos;
split.
apply Zplus_minus_eq; rewrite <- H; rewrite <- inj_plus;
apply inj_eq.
apply (Raw_List.delete_length l cu Hpos).
split; [intro cun; split | split; [intro cun; split|]].
intro HH; apply inj_eq_rev in HH;
rewrite <- inj_0; apply inj_eq.
symmetry in HH; apply (Raw_List.position_eq l cu cun Hpos) in HH.
rewrite <- HH; apply (Raw_List.delete_position_deleted l cu Hpos).
split; intro HH; apply inj_gt_rev in HH; split.
apply Zplus_minus_eq; rewrite <- H; rewrite <- inj_plus; apply inj_eq.
apply(Raw_List.delete_position_sup l cu cun Hpos HH).
case_eq (beq_nat cun cu); intro Hneq;
[apply beq_nat_true in Hneq; rewrite Hneq in HH; contradict HH;
apply gt_irrefl | apply beq_nat_false in Hneq].
rewrite (Raw_List.delete_element l cu cun Hpos Hneq);
split; reflexivity.
apply inj_eq;
apply(Raw_List.delete_position_inf l cu cun Hpos HH).
case_eq (beq_nat cun cu); intro Hneq;
[apply beq_nat_true in Hneq; rewrite Hneq in HH; contradict HH;
apply gt_irrefl | apply beq_nat_false in Hneq].
rewrite (Raw_List.delete_element l cu cun Hpos Hneq);
split; reflexivity.
intro HH; apply inj_le_rev in HH; split.
case_eq (leb (Raw_List.position l cun) (Raw_List.position l cu));
intro Hs; [apply leb_complete in Hs| apply leb_complete_conv in Hs].
destruct (le_lt_or_eq _ _ Hs) as [Ht|Ht].
apply lt_not_le in Ht; apply not_le in Ht.
rewrite (Raw_List.delete_position_inf _ _ _ Hpos Ht) in HH.
apply (le_antisym _ _ Hs) in HH; rewrite HH in Ht;
contradict Ht; apply gt_irrefl.
symmetry in Ht;
apply (Raw_List.position_eq l cu cun Hpos) in Ht;
rewrite <- Ht.
rewrite <- Ht in HH; rewrite (Raw_List.delete_position_deleted _ _ Hpos) in HH.
apply le_n_O_eq in HH; contradict Hpos; rewrite HH;
apply gt_irrefl.
apply lt_not_le in Hs; apply not_le in Hs.
rewrite <- H; rewrite <- inj_plus; rewrite plus_comm;
apply inj_eq;
apply (Raw_List.delete_position_sup _ _ _ Hpos Hs).
case_eq(beq_nat cun cu); intro Heq;
[apply beq_nat_true in Heq; rewrite Heq in HH;
rewrite (Raw_List.delete_position_deleted _ _ Hpos) in HH;
apply le_n_O_eq in HH; contradict Hpos; rewrite HH;
apply gt_irrefl|].
apply beq_nat_false in Heq;
rewrite (Raw_List.delete_element l cu cun Hpos Heq);
split; reflexivity.
intros [HH Hpcun]; rewrite <- inj_0 in Hpcun;
apply inj_gt_rev in Hpcun; apply inj_gt_rev in HH.
case_eq (leb (Raw_List.position l cu) (Raw_List.position l cun));
intro Hs; [apply leb_complete in Hs| apply leb_complete_conv in Hs].
destruct (le_lt_or_eq _ _ Hs) as [Ht|Ht].
apply lt_not_le in Ht; apply not_le in Ht.
generalize Ht; intro Htt;
apply (Raw_List.delete_position_sup _ _ _ Hpos) in Ht.
rewrite Ht in Htt.
apply gt_S_le in Htt.
contradict HH; apply le_not_gt; exact Htt.
apply (Raw_List.position_eq l cu cun Hpos) in Ht;
rewrite <- Ht in Hpcun.
contradict Hpcun;
rewrite (Raw_List.delete_position_deleted _ _ Hpos); apply gt_irrefl.
split.
apply inj_eq.
apply lt_not_le in Hs; apply not_le in Hs.
symmetry; apply (Raw_List.delete_position_inf _ _ _ Hpos Hs).
case_eq(beq_nat cun cu); intro Heq.
apply beq_nat_true in Heq; rewrite Heq in Hpcun;
rewrite (Raw_List.delete_position_deleted _ _ Hpos) in Hpcun;
apply le_n_O_eq in Hpcun; contradict Hpcun; apply O_S.
apply beq_nat_false in Heq;
rewrite (Raw_List.delete_element l cu cun Hpos Heq);
split; reflexivity.
intros w; split.
intros Hw; rewrite Raw_Set.delete1_find.
reflexivity.
apply Raw_List.has_element_position; exact Hpos.
unfold witness in Hw; intro HH; contradict Hw;
symmetry; exact HH.
intro Heq; rewrite <- Heq; apply delete1_find_deleted.
apply Raw_List.has_element_position; exact Hpos.
exact (Raw_List.wf l).
exact (ordered_hashed l (owf l)).
Qed.

Definition replace : set -> element_t -> set.
exact oreplace.
Defined.

Lemma replace_replace :
forall (l : set), forall (e : element_t),
contains_ l (witness e) ->
replace_ l e (replace l e).
unfold contains_; unfold replace_; unfold replace; unfold oreplace;
unfold find_; unfold element_; unfold witness;
unfold position_; unfold length_; unfold first_; simpl;
intros l e.
intro Hpos; split; [exact Hpos|].
rewrite <- inj_0 in Hpos; apply inj_gt_rev in Hpos; split.
apply inj_eq; apply Raw_List.replace_length.
split.
rewrite(Raw_List.replace_element_replaced l _ _ Hpos);
simpl; reflexivity.
split.
intro cun; split.
apply inj_eq.
apply Raw_List.replace_position.
intros Hdiff; rewrite(Raw_List.replace_element l _ _ cun);
[|intro HH; contradict Hdiff; symmetry; exact HH].
split; reflexivity.
intro w; case_eq (eq_real_bool w (Elt.witness e)).
intro Heq; apply beq_real_true in Heq; rewrite Heq.
repeat(rewrite find_find2).
rewrite <- (Raw_List.replace_element_replaced l _ e Hpos).
rewrite (Raw_List.replace_element_replaced _ _ _ Hpos).
unfold Raw_List.replace; simpl.
rewrite (replace1_find_eq l _ (Raw_List.wf l)); reflexivity.
intro Hdiff; apply beq_real_false in Hdiff;
repeat(rewrite find_find2); generalize (replace_find l w e Hdiff).
intro Heq; rewrite <- Heq; simpl; reflexivity.
Qed.

Definition replace_element : set -> cursor -> element_t -> set.
exact oreplace_elt.
Defined.

Lemma replace_element_replace_element :
forall (l : set), forall (cu : cursor), forall (e : element_t),
has_element_ l cu ->
(not (contains_ l (witness e)) \/ witness e=witness(element_ l cu)) ->
replace_element_ l cu e (replace_element l cu e).
intros s cu e; unfold has_element_; unfold contains_;
unfold replace_element_; unfold replace_element;
unfold replace_pos; unfold position_; unfold find_; unfold first_;
unfold element_; unfold length_; simpl.
intro Hpos; split; [exact Hpos|].
split; [apply inj_eq; apply oreplace_eltl_length|].
rewrite <- inj_0 in Hpos; apply inj_gt_rev in Hpos;
split; [apply oreplace_eltl_element_replaced;
[|apply (Raw_List.has_element_position _ _ Hpos)]|].
destruct H as [H|H]; [left|right].
destruct (Raw_List.find_has_element s (Elt.witness e)) as [Hko|Hex].
apply Raw_List.position_has_element in Hko; contradict H;
rewrite <- inj_0; apply inj_gt; exact Hko.
exact Hex.
unfold witness in H; rewrite H.
symmetry; apply (Raw_List.position_eq _ _ _ Hpos); symmetry.
apply (find_position_inv s (ordered_hashed s (owf s))); exact Hpos.
split; [intro cun|].
destruct (gt_O_eq(Raw_List.position s cun)); [right|left];
rewrite <- inj_0;
[split; apply inj_gt; [exact H0|]|split; apply inj_eq;
[symmetry; exact H0|]].
apply Raw_List.has_element_position in H0;
rewrite (oreplace_eltl_has_element s cu cun e) in H0;
apply (Raw_List.position_has_element _ cun H0).
destruct (gt_O_eq(Raw_List.position (oreplace_eltl s cu e) cun));
[|symmetry; exact H1].
apply Raw_List.has_element_position in H1;
rewrite <- (oreplace_eltl_has_element s cu cun e) in H1;
apply Raw_List.position_has_element in H1; contradict H1;
rewrite <- H0; apply gt_irrefl.
split; [intros cun Hposcun Hdiff|intro w].
rewrite <- inj_0 in Hposcun; apply inj_gt_rev in Hposcun;
apply Raw_List.has_element_position in Hposcun; symmetry;
apply (oreplace_eltl_element s cu cun e Hdiff Hposcun).
split.
intros [Hdiff Hfind];
apply (oreplace_eltl_find s cu e w (owf s) Hdiff Hfind).
intros Heq; rewrite <- Heq;
apply (oreplace_eltl_find_replaced s cu e (owf s)).
apply (Raw_List.has_element_position s cu Hpos).
destruct H as [H|H]; [left|right].
destruct (Raw_List.find_has_element s (Elt.witness e)) as [Hko|Hex].
apply Raw_List.position_has_element in Hko; contradict H;
rewrite <- inj_0; apply inj_gt; exact Hko.
exact Hex.
unfold witness in H; rewrite H.
symmetry; apply (Raw_List.position_eq _ _ _ Hpos); symmetry.
apply (find_position_inv s (ordered_hashed s (owf s))); exact Hpos.
Qed.

Definition include : set -> element_t -> set.
exact oinclude.
Defined.

Lemma include_include :
forall (l : set), forall (e : element_t),
include__ l e (include l e).
unfold include__; unfold include; unfold find_; unfold position_;
unfold oinclude; unfold first_; unfold witness; simpl.
intros l e; case_eq(beq_nat (Raw_List.find l (Elt.witness e)) O).
intro Heq; apply beq_nat_true in Heq.
split; [intro Hko; rewrite <- inj_0 in Hko; apply inj_gt_rev in Hko;
contradict Hko; rewrite Heq; rewrite Raw_List.position_no_element;
apply gt_irrefl|].
intros _; apply insert_insert.
unfold contains_; unfold position_; unfold find_; unfold first_;
unfold witness; simpl; rewrite Heq;
rewrite Raw_List.position_no_element; apply Zgt_irrefl.
intro Hdiff; apply beq_nat_false in Hdiff.
split;[|unfold no_element; intro Hko; contradict Hdiff; apply Hko].
intro Hpos; apply replace_replace.
unfold contains_; unfold position_; unfold find_; unfold first_;
unfold witness; simpl; exact Hpos.
Qed.

Definition exclude : set -> element_t -> set.
exact (fun s e => (oexclude s (Raw_List.find s (witness e)))).
Defined.

Lemma exclude_exclude :
forall (l : set), forall (e : element_t),
exclude_ l e (exclude l e).
unfold exclude_; unfold exclude; unfold find_; unfold position_;
unfold oexclude; unfold first_; unfold witness; simpl.
intros l e;
case_eq(beq_nat (Raw_List.find l (Elt.witness e)) O).
intro Heq; apply beq_nat_true in Heq.
split; [intro Hko; rewrite <- inj_0 in Hko; apply inj_gt_rev in Hko;
contradict Hko; rewrite Heq; rewrite Raw_List.position_no_element;
apply gt_irrefl|].
reflexivity.
intro Hdiff; apply beq_nat_false in Hdiff.
split;[|unfold no_element; intro Hko; contradict Hdiff; apply Hko].
intro Hpos; apply delete_delete.
unfold has_element_; unfold position_; simpl; exact Hpos.
Qed.

(*** MAX ***)

Module Type CompareType.

Parameter Inline compare : element_t -> element_t -> Z.

Axiom compare_refl :
forall e : element_t, (compare e e = 0)%Z.

Axiom compare_asym :
forall e1 : element_t, forall e2 : element_t,
(0 <= compare e1 e2 <-> compare e2 e1 <= 0)%Z.

Axiom compare_trans :
forall e1 : element_t, forall e2 : element_t, forall e3 : element_t,
(compare e1 e2 <= 0)%Z -> (compare e2 e3 <= 0)%Z ->
(compare e1 e3 <= 0)%Z.

End CompareType.

Module Compare (C : CompareType).

Definition compare_ : element_t -> element_t -> Z.
exact C.compare.
Defined.

Module Max_List := Raw_List.Max (C).

Definition is_max  (v:set) (cu:cursor)
  := (has_element_ v cu) /\
     (forall (cun:cursor),
      ((has_element_ v cun) -> (compare_ (element_ v cu) (element_ v cun)) >=
       0)).

Definition max_ : set -> cursor.
exact (Max_List.max).
Defined.

Lemma is_max_max :
  (forall (v:set), (~(is_empty_ v) -> (is_max v (max_ v)))).
intros l He; apply is_empty_length in He;
unfold is_max; unfold max_; unfold has_element_; unfold contains_;
unfold element_; unfold find_; unfold first_;
unfold position_.
split.
rewrite <- inj_0; apply inj_gt; apply Raw_List.position_has_element.
apply (Max_List.max_has_element l He).
intros e Hhfind;
rewrite <- inj_0 in Hhfind; apply inj_gt_rev in Hhfind.
apply (Raw_List.has_element_position) in Hhfind.
destruct (C.compare_asym (Raw_List.element l (Max_List.max l))
(Raw_List.element l e)) as [_ H];
apply Zle_ge; apply H; clear H.
apply (Max_List.max_element _ l Hhfind).
Qed.

End Compare.

(*** SUM_OF ***)

Module Type WeightType.

Parameter Inline weight : element_t -> nat.

End WeightType.

Module Weight (W : WeightType).

Definition weight_ : (element_t) -> Z.
exact (fun e => Z_of_nat (W.weight e)).
Defined.

Lemma positive_weight :
  (forall (e:element_t), (weight_ e) >= 0).
intro e; unfold weight_; apply Zle_ge; apply Zle_0_nat.
Qed.

Module Sum_List := Sum_Of(W).
Import Sum_List.

Definition sum_of_weight : set -> Z.
exact (fun l => Z_of_nat (Sum_List.sum_of_weight l)).
Defined.

Lemma sum_of_weight_delete :
  (forall (v1:set),
   (forall (v2:set),
    (forall (cu:cursor),
     ((delete_ v1 cu v2) -> (sum_of_weight v2) =
      ((sum_of_weight v1) - (weight_ (element_ v1 cu))))))).
assert (Z_of_nat (1) = 1). auto.
intros l1 l2 cu; unfold delete_; unfold sum_of_weight;
unfold weight_; unfold delete_pos; unfold delete_inv;
unfold element_; unfold length_; unfold position_;
intros [Hfind[Hposcu[Hlgth[Hdpos Hdinv]]]]; apply Zplus_minus_eq.
rewrite <- inj_plus; apply inj_eq.
apply Sum_List.sum_of_delete.
apply Raw_List.has_element_position.
rewrite <- inj_0 in Hposcu; apply (inj_gt_rev _ _ Hposcu).
destruct (Hdpos cu) as [Hpcu _].
case_eq (Raw_List.has_element l2 cu); [|reflexivity].
intro Hhe; apply Raw_List.position_has_element in Hhe;
apply inj_gt in Hhe; contradict Hhe; 
rewrite (Hpcu (reflexivity (Z_of_nat (Raw_List.position l1 cu)))).
rewrite inj_0; apply Zgt_irrefl.
intros cun Hp; destruct (Hdpos cun) as [_ [Hpcu _]].
apply inj_gt in Hp; destruct (Hpcu Hp) as [Hpe Hel].
split; [apply inj_eq_rev|exact Hel].
rewrite inj_S; rewrite Hpe.
unfold Zsucc; rewrite Zplus_comm.
symmetry; apply Zplus_minus.
intros cun Hhecun Hp; destruct (Hdpos cun) as [_ [_ Hpcu]].
apply inj_lt in Hp; apply Zlt_gt in Hp.
destruct (Hpcu Hp) as [Hpe Hel].
split; [apply inj_eq_rev; symmetry; exact Hpe|exact Hel].
destruct (Zeq_plus_swap (Z_of_nat (Raw_List.length l2))
(Z_of_nat (Raw_List.length l1)) 1) as [_ Hint]; apply Hint in Hlgth.
rewrite <- H in Hlgth; rewrite <- inj_plus in Hlgth;
apply inj_eq_rev in Hlgth; rewrite <- Hlgth.
rewrite <- plus_n_Sm; rewrite <- plus_n_O; reflexivity.
Qed.

Lemma sum_of_weight_insert :
  (forall (v1:set),
   (forall (v2:set),
     (forall (e:element_t),
      ((insert_ v1 e v2) -> (sum_of_weight v2) =
       ((sum_of_weight v1) + (weight_ e)))))).
unfold insert_; unfold sum_of_weight; unfold weight_;
unfold insert_pos; unfold insert_inv; unfold insert_find;
unfold position_; unfold element_; unfold length_;
unfold find_; unfold first_; unfold no_element; unfold witness.
intros m1 m2 e [Hfind[Hlength[Hpos [Hinv _]]]].
assert (Z_of_nat (1) = 1). auto.
destruct (Hinv (Raw_List.find m2 (Elt.witness e)
) (Zgt_lt _ _ Hfind)) as [HH _].
rewrite <- inj_0 in Hfind; apply inj_gt_rev in Hfind;
rewrite (Raw_List.find_element _ _ Hfind) in HH.
destruct (HH (reflexivity (Elt.witness e))) as [Hpos1cu Hel];
clear HH.
rewrite <- inj_plus;
rewrite (sum_of_insert_o _ _ (Raw_List.find m2 (Elt.witness e)
) e); simpl.
rewrite plus_comm; reflexivity.
apply (Raw_List.has_element_position); exact Hfind.
case_eq(Raw_List.has_element m1 (Raw_List.find m2
(Elt.witness e)));
[intro Hko|reflexivity].
apply Raw_List.position_has_element in Hko.
rewrite <- inj_0 in Hpos1cu; apply inj_eq_rev in Hpos1cu;
contradict Hko; rewrite Hpos1cu; apply gt_irrefl.
exact Hel.
intros cun Hhem1cun.
apply Raw_List.position_has_element in Hhem1cun;
apply inj_gt in Hhem1cun; rewrite inj_0 in Hhem1cun.
destruct (Hpos cun Hhem1cun) as [Hecun[Hdiff[Hi Hs]]].
split; [exact Hdiff|split; [symmetry; exact Hecun|]].
split; intro Hwit; symmetry; apply inj_eq_rev; [|exact (Hi Hwit)].
rewrite (Hs Hwit); rewrite <- H; rewrite <- inj_plus;
rewrite plus_comm; simpl; reflexivity.
apply inj_eq_rev; rewrite Hlength; rewrite <- H;
rewrite <- inj_plus; rewrite plus_comm; simpl; reflexivity.
Qed.

Lemma sum_of_weight_replace_element :
  (forall (v1:set),
   (forall (v2:set),
    (forall (cu:cursor),
     (forall (e:element_t),
      ((replace_element_ v1 cu e v2) -> (sum_of_weight v2) =
       ((sum_of_weight v1) + (weight_ e) - (weight_ (element_ v1 cu)))))))).
assert (Z_of_nat (1) = 1). auto.
intros l1 l2 cu e; unfold replace_element_; unfold replace_pos;
unfold sum_of_weight; unfold find_; unfold first_;
unfold weight_; unfold element_; unfold length_; unfold position_.
intros [Hposcu[Hlgth [Hel [Hpos [Helt _]]]]].
apply Zplus_minus_eq; repeat(rewrite <- inj_plus); apply inj_eq.
apply inj_eq_rev in Hlgth; rewrite <- inj_0 in Hposcu;
apply inj_gt_rev in Hposcu;
rewrite (Sum_List.sum_of_replace l1 l2 cu e).
rewrite plus_comm; reflexivity.
apply (Raw_List.has_element_position _ _ Hposcu).
exact Hel.
intros cun Hposl1; destruct (Hpos cun) as [[Hko _] | [_ Hposeq]].
contradict Hposl1; rewrite <- inj_0 in Hko; apply inj_eq_rev in Hko;
rewrite Hko; apply gt_irrefl.
rewrite <- inj_0 in Hposeq; apply inj_gt_rev in Hposeq.
split; [exact Hposeq|intro Hdiff].
apply inj_gt in Hposl1; rewrite inj_0 in Hposl1;
apply Helt; [exact Hposl1|exact Hdiff].
symmetry; exact Hlgth.
Qed.

Lemma sum_of_weight_replace :
  (forall (v1:set),
   (forall (v2:set),
     (forall (e:element_t),
      ((replace_ v1 e v2) -> (sum_of_weight v2) =
       ((sum_of_weight v1) + (weight_ e)
       - (weight_ (element_ v1 (find_ v1 (witness e))))))))).
assert (Z_of_nat (1) = 1). auto.
intros l1 l2 e; unfold replace_; unfold sum_of_weight;
unfold weight_; unfold length_; unfold position_;
unfold find_; unfold element_; unfold first_.
intros [Hposcu[Hlgth [Hel [Hpos _]]]].
apply Zplus_minus_eq; repeat(rewrite <- inj_plus); apply inj_eq.
apply inj_eq_rev in Hlgth; rewrite <- inj_0 in Hposcu;
apply inj_gt_rev in Hposcu;
rewrite (Sum_List.sum_of_replace l1 l2
(Raw_List.find l1 (witness e)) e).
rewrite plus_comm; reflexivity.
apply (Raw_List.has_element_position _ _ Hposcu).
exact Hel.
intros cun Hposl1; destruct (Hpos cun) as [Hposeq Heleq].
apply inj_eq_rev in Hposeq; rewrite Hposeq.
split; [exact Hposl1|intro Hdiff].
apply Heleq; intro Heq;
apply Hdiff; symmetry; exact Heq.
symmetry; exact Hlgth.
Qed.

Lemma sum_of_weight_null :
  (forall (v:set), ((is_empty_ v) -> (sum_of_weight v) = 0)).
unfold sum_of_weight;
intros l Hl; apply length_is_empty in Hl; unfold length_ in Hl.
rewrite <- inj_0; rewrite <- inj_0 in Hl; apply inj_eq;
apply inj_eq_rev in Hl; apply (Sum_List.sum_of_nil l Hl).
Qed.

Lemma sum_of_weight_equal :
  (forall (v1:set),
   (forall (v2:set),
    ((equal_ v1 v2) -> (sum_of_weight v1) = (sum_of_weight v2)))).
unfold equal_; unfold sum_of_weight; unfold position_;
unfold element_; intros l1 l2 Heq.
apply inj_eq;
apply (Sum_List.sum_of_equal l1 l2).
intros cu; destruct (Heq cu) as [Hp He];
split; [apply inj_eq_rev in Hp; exact Hp|intro Hpl1].
apply He; rewrite <- inj_0; apply inj_gt;
exact Hpl1.
Qed.

Lemma sum_of_weight_left :
  (forall (v:set),
   (forall (cu:cursor),
    ((has_element_ v cu) -> (sum_of_weight (left_ v (next_ v cu))) =
     ((sum_of_weight (left_ v cu)) + (weight_ (element_ v cu)))))).
unfold left_; unfold next_; unfold weight_; unfold has_element_;
unfold position_; unfold sum_of_weight; unfold oleft; intros l cu Hpos.
case_eq (beq_nat cu O); [intro HH; contradict Hpos;
apply beq_nat_true in HH; rewrite HH; rewrite <- inj_0;
rewrite Raw_List.position_no_element; apply Zgt_irrefl|simpl].
intros _; case_eq (beq_nat (Raw_List.next l cu) O); intro Heq; simpl.
assert(Raw_List.left l (Raw_List.next l cu) = l).
unfold Raw_List.left; rewrite Heq; reflexivity.
rewrite <- H at 1.
rewrite <- inj_plus; apply inj_eq; apply Sum_List.sum_of_left.
apply (Raw_List.has_element_position); apply inj_gt_rev;
rewrite inj_0; exact Hpos.
rewrite <- inj_plus; apply inj_eq; apply Sum_List.sum_of_left.
apply (Raw_List.has_element_position); apply inj_gt_rev;
rewrite inj_0; exact Hpos.
Qed.

Lemma sum_of_weight_right :
  (forall (v:set),
   (forall (cu:cursor),
    ((has_element_ v cu) -> (sum_of_weight (right_ v (next_ v cu))) =
     ((sum_of_weight (right_ v cu)) - (weight_ (element_ v cu)))))).
unfold right_; unfold next_; unfold weight_; unfold has_element_;
unfold position_; unfold sum_of_weight; unfold oright; intros l cu Hpos.
case_eq (beq_nat cu O); [intro HH; contradict Hpos;
apply beq_nat_true in HH; rewrite HH; rewrite <- inj_0;
rewrite Raw_List.position_no_element; apply Zgt_irrefl|simpl].
intros _; case_eq (beq_nat (Raw_List.next l cu) O); intro Heq; simpl.
assert(Sum_List.sum_of_weight(Raw_List.right l (Raw_List.next l cu)) = O).
unfold Raw_List.right; rewrite Heq; reflexivity.
rewrite <- inj_0; rewrite <- H at 1.
apply Zplus_minus_eq; symmetry.
rewrite <- inj_plus; apply inj_eq; apply Sum_List.sum_of_right.
apply (Raw_List.has_element_position); apply inj_gt_rev;
rewrite inj_0; exact Hpos.
apply Zplus_minus_eq; symmetry.
rewrite <- inj_plus; apply inj_eq; apply Sum_List.sum_of_right.
apply (Raw_List.has_element_position); apply inj_gt_rev;
rewrite inj_0; exact Hpos.
Qed.

End Weight.

End OSet.


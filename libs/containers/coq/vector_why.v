(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)
Require Import ZArith.
Open Scope Z_scope.
Require "vector_raw".

Module Type Element_Type.

Parameter Inline element_t : Set.

Parameter Inline e_nl : element_t.

Parameter Inline beq_elt : element_t -> element_t -> bool.

Axiom beq_elt_refl : forall e : element_t, beq_elt e e = true.

Axiom beq_elt_true : forall e1 : element_t, forall e2 : element_t,
beq_elt e1 e2 = true -> e1 = e2.

Axiom beq_elt_false : forall e1 : element_t, forall e2 : element_t,
beq_elt e1 e2 = false -> e1 <> e2.

End Element_Type.

Module Vector (Elt : Element_Type).

Module Raw_Vector := vector_raw.Raw_Vector(Elt).

Import Raw_Vector.

(*Why type*) Definition cursor: Set.
exact ListR.cursor.
Defined.

(*Why type*) Definition vector: Set.
exact ListR.list.
Defined.

(*Why type*) Definition element_t: Set.
exact Elt.element_t.
Defined.

(*Why logic*) Definition no_element : cursor.
exact O.
Defined.

(*Why logic*) Definition empty_ : vector.
exact ListR.empty.
Defined.

(*Why logic*) Definition length_ : vector -> Z.
exact (fun v => (Z_of_nat (ListR.length v))).
Defined.

(*Why axiom*) Lemma length_gte_zero :
  (forall (co:vector), (length_ co) >= 0).
intro v; unfold length_; apply Zle_ge; apply Zle_0_nat.
Qed.

(*Why logic*) Definition to_index_ : vector -> cursor -> Z.
exact to_index.
Defined.

(*Why axiom*) Lemma to_index_gte_zero :
  (forall (cu:cursor),
   (forall (v:vector), (length_ v) >= (to_index_ v cu) /\ (to_index_ v cu) >=
    0)).
unfold length_; unfold to_index_; intros cu v; apply to_index_int.
Qed.

(*Why axiom*) Lemma to_index_eq :
  (forall (cu1:cursor),
   (forall (cu2:cursor),
    (forall (v:vector),
     ((to_index_ v cu1) = (to_index_ v cu2) /\ (to_index_ v cu2) > 0 ->
      cu1 = cu2)))).
intros cu1 cu2 v; unfold to_index_; apply to_index_eq.
Qed.

(*Why axiom*) Lemma to_index_no_element :
  (forall (v:vector), (to_index_ v no_element) = 0).
intros v; unfold to_index_; unfold no_element; apply to_index_nl.
Qed.

(*Why logic*) Definition to_cursor_ : vector -> Z -> cursor.
exact to_cursor.
Defined.

(*Why predicate*) Definition to_cursor__  (co:vector) (i:Z) (cu:cursor)
  := (to_index_ co cu) = i /\ (length_ co) >= i /\ i > 0 \/
     cu = no_element /\ (i <= 0 \/ i > (length_ co)).

(*Why axiom*) Lemma to_cursor_to_cursor :
  (forall (co:vector), (forall (i:Z), (to_cursor__ co i (to_cursor_ co i)))).
unfold to_cursor_; unfold to_cursor__; unfold to_index_; unfold length_.
apply Raw_Vector.to_cursor_index.
Qed.

(*Why predicate*) Definition is_empty_  (co:vector) := (length_ co) = 0.

(*Why axiom*) Lemma empty_is_empty : (is_empty_ empty_).
unfold is_empty_; unfold empty_; unfold length_; reflexivity.
Qed.

(*Why predicate*) Definition has_element_  (v:vector) (cu:cursor)
  := 0 < (to_index_ v cu).

(*Why function*) Definition previous_  (v:vector) (cu:cursor)
  := (to_cursor_ v ((to_index_ v cu) - 1)).

(*Why function*) Definition next_  (v:vector) (cu:cursor)
  := (to_cursor_ v ((to_index_ v cu) + 1)).

(*Why function*) Definition last_  (co:vector)
  := (to_cursor_ co (length_ co)).

(*Why function*) Definition first_  (co:vector) := (to_cursor_ co 1).

(*Why logic*) Definition element_ : vector -> Z -> element_t.
exact Raw_Vector.element.
Defined.

(*Why function*) Definition element_curs_  (v:vector) (cu:cursor)
  := (element_ v (to_index_ v cu)).

(*Why logic*) Definition find_ : vector -> element_t -> Z -> Z.
exact (fun v e i => Z_of_nat(Raw_Vector.find v e i)).
Defined.

(*Why predicate*) Definition find__  (co:vector) (e:element_t) (i:Z) (j:Z)
  := ((length_ co) >= i /\ i > 0) /\ (j = 0 /\
     (forall (k:Z), ((length_ co) >= k /\ k >= i -> ~(element_ co k) = e)) \/
     ((length_ co) >= j /\ j >= i) /\ (element_ co j) = e /\
     (forall (k:Z), (j > k /\ k >= i -> ~(element_ co k) = e))).

(*Why axiom*) Lemma find_find_val :
  (forall (co:vector),
   (forall (e:element_t),
    (forall (i:Z),
     (((length_ co) >= i /\ i > 0 -> (find__ co e i (find_ co e i)))) /\
     (((length_ co) = 0 -> (find_ co e i) = 0))))).
unfold find__; unfold length_; unfold find_; unfold element_;
intros v e i.
split.
split; [exact H|].
destruct (Raw_Vector.find_case v e i H) as [HO | [Hi Hs]]; [left|right].
split; [rewrite <- inj_0; apply inj_eq; exact HO|].
intros k Hin; apply (Raw_Vector.find_is_first_O _ _ _ _ H Hin HO).
split.
split; [apply Zle_ge; apply inj_le; exact Hi|
rewrite <- (Zabs_eq i) at 2; [rewrite <- inj_Zabs_nat;
apply Zle_ge; apply inj_le; exact Hs|]].
destruct H as [_ Hpos]; apply Zlt_le_weak;
apply Zgt_lt; exact Hpos.
split; [apply (Raw_Vector.find_element v e i H Hi Hs)|].
intros k Hk; apply (Raw_Vector.find_is_first _ _ _ _ H Hk Hi).
destruct v as [l Hwf]; unfold ListR.length; simpl;
rewrite <- inj_0; intros Hl; apply inj_eq_rev in Hl.
unfold find; simpl.
case ((Zgt_bool i 0 && Zge_bool (Z_of_nat (List.length l)) i)%bool).
generalize Hl; case l; simpl. 
case_eq (beq_nat (Zabs_nat i) 0); reflexivity.
intros et ll Hko; symmetry in Hko; contradict Hko; apply O_S.
rewrite <- beq_nat_refl; generalize Hl; case l; simpl.
reflexivity.
intros et ll Hko; symmetry in Hko; contradict Hko; apply O_S.
Qed.

(*Why predicate*) Definition equal_  (co1:vector) (co2:vector)
  := (length_ co1) = (length_ co2) /\
     (forall (i:Z),
      ((length_ co1) >= i /\ i > 0 -> (element_ co1 i) = (element_ co2 i))).

(*Why predicate*) Definition replace_element_  (co1:vector) (i:Z) (e:element_t) (co2:vector)
  := ((length_ co1) >= i /\ i > 0) /\ (length_ co1) = (length_ co2) /\
     (element_ co2 i) = e /\
     (forall (j:Z),
      ((length_ co1) >= j /\ j > 0 ->
       (i <> j -> (element_ co2 j) = (element_ co1 j)))) /\
     (forall (cu:cursor), (to_index_ co1 cu) = (to_index_ co2 cu)).

(*Why predicate*) Definition left__  (co:vector) (i:Z) (col:vector)
  := (((length_ co) + 1) >= i /\ i > 0 -> (length_ col) = (i - 1) /\
      (forall (j:Z), (0 < j /\ j < i -> (element_ col j) = (element_ co j))) /\
      (forall (cu:cursor),
       (0 < (to_index_ co cu) /\ (to_index_ co cu) < i \/ 0 <
        (to_index_ col cu) -> (to_index_ col cu) = (to_index_ co cu)))).

(*Why logic*) Definition left_ : vector -> Z -> vector.
exact Raw_Vector.left.
Defined.

(*Why axiom*) Lemma left_left :
  (forall (co:vector), (forall (i:Z), (left__ co i (left_ co i)))).
unfold left__; unfold left_; unfold length_; unfold element_;
unfold to_index_; unfold has_element_; unfold to_cursor_.
assert (Z_of_nat 1 = 1); [auto|rewrite <- H];
intros v i; rewrite <- inj_plus; intro Hin; split.
apply Zplus_minus_eq; rewrite <- inj_plus; symmetry;
rewrite plus_comm; apply (Raw_Vector.left1_length v i Hin).
split; [intro j; apply (Raw_Vector.left1_element v i j Hin)|].
intro cu; apply (Raw_Vector.left1_to_index v i cu Hin).
Qed.

(*Why predicate*) Definition right__  (co:vector) (i:Z) (cor:vector)
  := (((length_ co) + 1) >= i /\ i > 0 -> (length_ cor) =
      ((length_ co) - i + 1) /\
      (forall (j:Z),
       (0 < j /\ j <= (length_ cor) ->
        (element_ cor j) = (element_ co (j + i - 1))))).

(*Why logic*) Definition right_ : vector -> Z -> vector.
exact Raw_Vector.right.
Defined.

(*Why axiom*) Lemma right_right :
  (forall (co:vector), (forall (i:Z), (right__ co i (right_ co i)))).
unfold right__; unfold right_; unfold length_; unfold element_;
unfold to_index_; unfold has_element_; unfold to_cursor_.
assert (Z_of_nat 1 = 1); [auto|rewrite <- H];
intros v i; rewrite <- inj_plus; intro Hin; split.
apply (Zplus_reg_l i); rewrite (Zplus_assoc i _ (Z_of_nat 1));
rewrite Zplus_minus; rewrite <- inj_plus.
apply (Raw_Vector.right_length v i Hin).
intro j; apply (Raw_Vector.right_element v i j Hin).
Qed.

(*Why predicate*) Definition insert_elmt  (co1:vector) (i:Z) (e:element_t) (co2:vector)
  := (element_ co2 i) = e /\
     (forall (j:Z),
      ((0 < j /\ j < i -> (element_ co1 j) = (element_ co2 j))) /\
      ((i < j /\ j <= ((length_ co1) + 1) ->
        (element_ co1 (j - 1)) = (element_ co2 j)))).

(*Why predicate*) Definition insert_curs  (co1:vector) (i:Z) (co2:vector)
  := (forall (cu:cursor),
      (0 < (to_index_ co1 cu) /\ (to_index_ co1 cu) < i \/ 0 <
       (to_index_ co2 cu) /\ (to_index_ co2 cu) < i -> (to_index_ co1 cu) =
       (to_index_ co2 cu))).

(*Why predicate*) Definition insert_  (co1:vector) (i:Z) (e:element_t) (co2:vector)
  := (((length_ co1) + 1) >= i /\ i > 0) /\ (length_ co2) =
     ((length_ co1) + 1) /\ (insert_elmt co1 i e co2) /\
     (insert_curs co1 i co2).

(*Why predicate*) Definition delete_elmt  (co1:vector) (i:Z) (co2:vector)
  := (forall (j:Z),
      (((length_ co1) > j /\ j >= i ->
        (element_ co1 (j + 1)) = (element_ co2 j))) /\
      ((0 < j /\ j < i -> (element_ co2 j) = (element_ co1 j)))).

(*Why predicate*) Definition delete_curs  (co1:vector) (i:Z) (co2:vector)
  := (forall (cu:cursor),
      (0 < (to_index_ co1 cu) /\ (to_index_ co1 cu) < i \/ 0 <
       (to_index_ co2 cu) /\ (to_index_ co2 cu) < i -> (to_index_ co1 cu) =
       (to_index_ co2 cu))).

(*Why predicate*) Definition delete_  (co1:vector) (i:Z) (co2:vector)
  := ((length_ co1) >= i /\ i > 0) /\ (length_ co2) = ((length_ co1) - 1) /\
     (delete_elmt co1 i co2) /\ (delete_curs co1 i co2).

(*Why predicate*) Definition contains_  (co:vector) (e:element_t)
  := (length_ co) >= (find_ co e 1) /\ (find_ co e 1) > 0.

(*** TESTS ***)

Definition insert : vector -> Z -> element_t -> vector.
exact Raw_Vector.insert.
Defined.

Lemma insert_insert :
forall (l : vector), forall (i : Z),
forall (e : element_t),
((length_ l) + 1) >= i /\ i > 0 ->
insert_ l i e (insert l i e).
intros v i e; unfold insert_; unfold insert;
unfold insert_elmt; unfold insert_curs; unfold element_;
unfold has_element_; unfold last_; unfold length_; unfold to_cursor_.
assert (1 = Z_of_nat 1); [auto|rewrite H; rewrite <- inj_plus;
rewrite <- plus_n_Sm; rewrite <- plus_n_O].
intro Hin; split; [exact Hin|].
split; [apply inj_eq; apply Raw_Vector.insert_length|].
split; [split; [apply (Raw_Vector.insert_element_new _ _ _ Hin)|]|].
intros j; split; intro Hi.
apply (Raw_Vector.insert_element_inf _ _ _ _ Hin Hi).
apply (Raw_Vector.insert_element_sup _ _ _ _ Hin Hi).
intro cu; unfold to_index_.
apply (Raw_Vector.insert_to_index _ _ _ _ Hin).
Qed.

Definition delete : vector -> Z -> vector.
exact Raw_Vector.delete.
Defined.

Lemma delete_delete :
forall (l : vector), forall (cu : Z),
length_ l >= cu /\ cu > 0 -> delete_ l cu (delete l cu).
intros v i; unfold delete_; unfold delete; unfold delete_elmt;
unfold delete_curs; unfold element_; unfold length_;
unfold has_element_; unfold to_index_.
assert (1 = Z_of_nat 1); [auto|rewrite H].
intro Hpos; split; [exact Hpos|].
split; [apply Zplus_minus_eq; rewrite <- inj_plus; simpl plus;
apply inj_eq; apply (Raw_Vector.delete_length _ _ Hpos)|].
split; [intro j; split; intro HH|intro cu].
apply (Raw_Vector.delete_element_sup v i j Hpos HH).
apply (Raw_Vector.delete_element_inf v i j Hpos HH).
apply (Raw_Vector.delete_to_index _ _ _ Hpos).
Qed.

Definition replace_element : vector -> Z -> element_t -> vector.
exact Raw_Vector.replace.
Defined.

Lemma replace_element_replace_element :
forall (l : vector), forall (i : Z), forall (e : element_t),
0 < i <= length_ l -> replace_element_ l i e (replace_element l i e).
intros v i e; unfold replace_element_;
unfold length_;  unfold has_element_;
unfold element_.
intros [Hlt Hle]; assert(Z_of_nat (ListR.length v) >= i /\ i > 0);
[split; [apply Zle_ge; exact Hle|apply Zlt_gt; exact Hlt]|
clear Hlt Hle; split; [exact H|]].
split; [apply inj_eq; apply (Raw_Vector.replace_length v e i H)|].
split; [apply (Raw_Vector.replace_element_replaced v e i H)|
split; [intros j Hj Hij|intro cu]].
apply (Raw_Vector.replace_element_diff v e i j H Hj Hij).
apply Raw_Vector.replace_to_index.
Qed.

(*** MAX ***)

Module Type CompareType.

Parameter Inline compare : element_t -> element_t -> Z.

Axiom compare_refl :
forall e : element_t, (compare e e = 0)%Z.

Axiom compare_asym :
forall e1 : element_t, forall e2 : element_t,
(0 <= compare e1 e2 <-> compare e2 e1 <= 0)%Z.

Axiom compare_trans :
forall e1 : element_t, forall e2 : element_t, forall e3 : element_t,
(compare e1 e2 <= 0)%Z -> (compare e2 e3 <= 0)%Z ->
(compare e1 e3 <= 0)%Z.

End CompareType.

Module Compare (Compare : CompareType).

Definition compare_ : element_t -> element_t -> Z.
exact Compare.compare.
Defined.

Module Max_Vector := Raw_Vector.Max (Compare).

Definition is_max  (v : vector) (j : Z)
  :=  0<j<=length_ v /\
	  (forall i : Z,
		 0<i<=length_ v ->
		(compare_ (element_ v j) (element_ v i)) >= 0).

Definition max_ : vector -> Z.
exact (Max_Vector.max).
Defined.

Lemma is_max_max :
  (forall (v:vector), (~(is_empty_ v) -> (is_max v (max_ v)))).
unfold is_empty_; unfold is_max; unfold max_; unfold element_;
unfold length_; unfold compare_.
intros v He; split; [apply Max_Vector.max_has_element; intro Heq;
apply He; rewrite Heq; reflexivity| intros i Hin].
apply (Max_Vector.max_element _ _ Hin).
Qed.

End Compare.

(*** SUM_OF ***)

Module Type WeightType.

Parameter Inline weight : element_t -> nat.

End WeightType.

Module Weight (W : WeightType).

Definition weight_ : element_t -> Z.
exact (fun e => Z_of_nat (W.weight e)).
Defined.

Lemma positive_weight :
  (forall (e:element_t), (weight_ e) >= 0).
intro e; unfold weight_; apply Zle_ge; apply Zle_0_nat.
Qed.

Module Sum_Vector := Raw_Vector.Sum_Of(W).

Definition sum_of_weight : vector -> Z.
exact (fun l => Z_of_nat (Sum_Vector.sum_of_weight l)).
Defined.

Lemma sum_of_weight_delete :
  (forall (v1:vector),
   (forall (v2:vector),
    (forall (i : Z),
     ((delete_ v1 i v2) -> (sum_of_weight v2) =
      ((sum_of_weight v1) - (weight_ (element_ v1 i))))))).
intros v1 v2 i; unfold delete_; unfold delete_elmt; unfold delete_curs;
unfold sum_of_weight; unfold weight_; unfold element_; unfold length_;
unfold to_index_; unfold has_element_.
intros [Hin[Hlgth[Helt _]]].
apply Zplus_minus_eq; rewrite <- inj_plus; apply inj_eq.
apply (Zplus_eq_compat _ _ _ _ (reflexivity 1)) in Hlgth;
rewrite Zplus_minus in Hlgth.
assert (1 = Z_of_nat 1); [auto|rewrite H in Hlgth; clear H];
rewrite <- inj_plus in Hlgth; apply inj_eq_rev in Hlgth; simpl in Hlgth.
apply (Sum_Vector.sum_of_delete v1 v2 i Hin Helt Hlgth).
Qed.

Lemma sum_of_weight_insert :
  (forall (v1:vector),
   (forall (v2:vector),
    (forall (i : Z),
     (forall (e:element_t),
      ((insert_ v1 i e v2) -> (sum_of_weight v2) =
       ((sum_of_weight v1) + (weight_ e))))))).
intros v1 v2 i e; unfold insert_; unfold insert_elmt; unfold insert_curs;
unfold sum_of_weight; unfold weight_; unfold element_; unfold length_;
unfold to_index_; unfold has_element_.
assert (1 = Z_of_nat 1); [auto|rewrite H; clear H];
intros [Hin[Hlgth[[Heq Helt] _]]].
rewrite <- Hlgth in Hin; rewrite <- inj_plus in Hlgth;
apply inj_eq_rev in Hlgth; rewrite <- plus_n_Sm in Hlgth;
rewrite <- plus_n_O in Hlgth.
rewrite <- Heq; rewrite <- inj_plus; rewrite plus_comm;
apply inj_eq; symmetry in Hlgth.
apply (Sum_Vector.sum_of_delete v2 v1 i Hin); [|exact Hlgth].
intros j; split; [intros [Hlj Hji]|].
destruct (Helt (j + Z_of_nat 1)) as [_ Helt2];
generalize Helt2; clear Helt Helt2; 
rewrite (Zplus_comm _ (Z_of_nat 1)) at 3;
rewrite (Zplus_comm (Z_of_nat (ListR.length v1))).
rewrite Zminus_plus; rewrite <- inj_plus; simpl plus.
intro Helt; symmetry; apply Helt; rewrite Hlgth; simpl Z_of_nat.
apply Zgt_le_succ in Hlj; apply Zge_le in Hji; apply Zle_gt_succ in Hji;
apply Zgt_lt in Hji; apply (conj Hji Hlj).
destruct (Helt j) as [Helt1 _]; apply Helt1; simpl Z_of_nat.
Qed.

Lemma sum_of_weight_replace_element :
  (forall (v1:vector),
   (forall (v2:vector),
    (forall (i : Z),
     (forall (e:element_t),
      ((replace_element_ v1 i e v2) -> (sum_of_weight v2) =
       ((sum_of_weight v1) + (weight_ e) - (weight_ (element_ v1 i)))))))).
intros v1 v2 i e; unfold replace_element_;
unfold sum_of_weight; unfold weight_; unfold element_; unfold length_;
unfold to_index_; unfold has_element_.
intros [Hin[Hlgth[Heq [Helt _]]]].
apply Zplus_minus_eq; repeat(rewrite <- inj_plus); apply inj_eq.
apply inj_eq_rev in Hlgth; symmetry in Hlgth.
apply (Sum_Vector.sum_of_replace v1 v2 i e Hlgth Hin Heq Helt).
Qed.

Lemma sum_of_weight_null :
  (forall (v:vector), ((is_empty_ v) -> (sum_of_weight v) = 0)).
unfold is_empty_; unfold sum_of_weight; unfold length_.
rewrite <- inj_0; intros v Hl; apply inj_eq_rev in Hl; apply inj_eq.
apply (Sum_Vector.sum_of_empty v Hl).
Qed.

Lemma sum_of_weight_equal :
  (forall (v1:vector),
   (forall (v2:vector),
    ((equal_ v1 v2) -> (sum_of_weight v1) = (sum_of_weight v2)))).
unfold equal_; unfold sum_of_weight; unfold length_;
unfold element_; intros l1 l2 [Hl Heq].
apply inj_eq_rev in Hl; apply inj_eq;
apply (Sum_Vector.sum_of_equal l1 l2 Hl Heq).
Qed.

Lemma sum_of_weight_left :
  (forall (v:vector),
   (forall (i:Z),
    (length_(v) + 1 >= i /\ i > 1 ->
    (sum_of_weight (left_ v i)) =
     ((sum_of_weight (left_ v (i-1))) + (weight_ (element_ v (i-1))))))).
unfold left_; unfold element_; unfold weight_; unfold length_;
unfold sum_of_weight; intros v i Hpos.
rewrite <- inj_plus; apply inj_eq.
apply (Sum_Vector.sum_of_left v i Hpos).
Qed.

Lemma sum_of_weight_right :
  (forall (v:vector),
   (forall (i:Z),
    (length_(v) + 1 >= i /\ i > 1 ->
    (sum_of_weight (right_ v i)) =
     ((sum_of_weight (right_ v (i-1))) - (weight_ (element_ v (i-1))))))).
unfold right_; unfold element_; unfold weight_; unfold length_;
unfold sum_of_weight; intros v i Hpos.
apply Zplus_minus_eq;
rewrite <- inj_plus; apply inj_eq.
apply (Sum_Vector.sum_of_right v i Hpos).
Qed.

End Weight.

End Vector.


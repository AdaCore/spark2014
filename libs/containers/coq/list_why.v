(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)
(* Require Why. *)
Require Import ZArith.
Open Scope Z_scope.
Require "list_raw".

Module Type Element_Type.

Parameter Inline element_t : Set.

Parameter Inline e_nl : element_t.

Parameter Inline beq_elt : element_t -> element_t -> bool.

Axiom beq_elt_refl : forall e : element_t, beq_elt e e = true.

Axiom beq_elt_true : forall e1 : element_t, forall e2 : element_t,
beq_elt e1 e2 = true -> e1 = e2.

Axiom beq_elt_false : forall e1 : element_t, forall e2 : element_t,
beq_elt e1 e2 = false -> e1 <> e2.

End Element_Type.

Module List (Elt : Element_Type).

Module E.

Definition element_t : Set.
exact Elt.element_t.
Defined.

Definition witness_t : Set := element_t.

Definition witness (e : element_t) : witness_t := e.

Definition e_nl : element_t.
exact Elt.e_nl.
Defined.

Definition eq_witness : element_t -> element_t -> Prop.
exact (fun e1 e2 => e1 = e2).
Defined.

Definition beq_witness : element_t -> element_t -> bool.
exact Elt.beq_elt.
Defined.

Lemma beq_witness_refl : forall e : element_t, beq_witness e e = true.
apply Elt.beq_elt_refl.
Qed.

Lemma beq_witness_true : forall e1 : element_t, forall e2 : element_t,
beq_witness e1 e2 = true -> eq_witness e1 e2.
apply Elt.beq_elt_true.
Qed.

Lemma beq_witness_false : forall e1 : element_t, forall e2 : element_t,
beq_witness e1 e2 = false -> not (eq_witness e1 e2).
apply Elt.beq_elt_false.
Qed.

End E.

Module Raw_List := list_raw.Raw_List(E).

(*Why type*) Definition cursor: Set.
exact Raw_List.cursor.  
Defined.

(*Why type*) Definition list: Set.
exact Raw_List.list.
Defined.

(*Why type*) Definition element_t: Set.
exact E.element_t.  
Defined.

(*Why logic*) Definition no_element : cursor.
exact O.
Defined.

(*Why logic*) Definition empty_ : list.
exact Raw_List.empty.
Defined.

(*Why logic*) Definition length_ : list -> Z.
exact (fun l => Z_of_nat(Raw_List.length l)).
Defined.

(*Why axiom*) Lemma length_gte_zero : (forall (co:list), (length_ co) >= 0).
intro l; unfold length_; apply Zle_ge; apply Zle_0_nat.
Qed.

(*Why logic*) Definition position_ : list -> cursor -> Z.
exact (fun l cu => Z_of_nat(Raw_List.position l cu)).
Defined.

(*Why axiom*) Lemma position_gte_zero :
  (forall (co:list),
   (forall (cu:cursor), (length_ co) >= (position_ co cu) /\
    (position_ co cu) >= 0)).
unfold position_.
unfold length_.
split; apply Zle_ge.
apply inj_le; simpl.
apply Raw_List.position_length.
apply Zle_0_nat.
Qed.

(*Why axiom*) Lemma position_no_element :
  (forall (co:list), (position_ co no_element) = 0).
intro l; unfold position_; unfold no_element;
rewrite <- inj_0; apply inj_eq.
apply Raw_List.position_no_element.
Qed.

(*Why axiom*) Lemma position_eq :
  (forall (co:list),
   (forall (cu1:cursor),
    (forall (cu2:cursor),
     ((position_ co cu1) > 0 ->
      ((position_ co cu1) = (position_ co cu2) -> cu1 = cu2))))).
intros l cu1 cu2; unfold position_; rewrite <- inj_0;
intros Hpos Heq.
apply inj_gt_rev in Hpos.
apply inj_eq_rev in Heq.
apply (Raw_List.position_eq l cu1 cu2 Hpos Heq).
Qed.

(*Why predicate*) Definition is_empty_  (co:list)
  := (forall (cu:cursor), (position_ co cu) = 0) /\ (length_ co) = 0.

(*Why axiom*) Lemma empty_is_empty : (is_empty_ empty_).
unfold is_empty_; unfold empty_; unfold position_; unfold length_;
unfold Raw_List.length; unfold Raw_List.empty; simpl; auto.
Qed.


(*Why logic*) Definition previous_ : list -> cursor -> cursor.
exact Raw_List.previous.
Defined.

(*Why axiom*) Lemma previous_previous :
  (forall (co:list),
   (forall (cu:cursor),
    ((position_ co cu) > 1 -> (position_ co (previous_ co cu)) =
     ((position_ co cu) - 1)))) /\
  (forall (co:list),
   (forall (cu:cursor),
    ((position_ co cu) = 1 \/ cu = no_element ->
     (previous_ co cu) = no_element))).
unfold previous_;
unfold position_; unfold no_element.
split;
intros l cu;
assert (Z_of_nat (1) = 1); [auto| |auto|].
intro HH;
rewrite <- H in HH;
apply inj_gt_rev in HH;
rewrite <- H;
rewrite <- (inj_minus1 (Raw_List.position l cu) 1
(gt_S_le 1 (Raw_List.position l cu)
(gt_trans (S (Raw_List.position l cu)) (Raw_List.position l cu) 1
(gt_Sn_n (Raw_List.position l cu)) HH)));
apply inj_eq.
apply Raw_List.position_previous_gen;
exact HH.
intros [HH | HH].
rewrite <- H in HH; apply inj_eq_rev in HH.
apply Raw_List.position_previous_first; exact HH.
rewrite HH; apply Raw_List.previous_O.
Qed.

(*Why predicate*) Definition next__  (co:list) (cu1:cursor) (cu2:cursor)
  := (((length_ co) > (position_ co cu1) /\ (position_ co cu1) > 0 ->
       (position_ co cu2) = ((position_ co cu1) + 1))) /\
     (((length_ co) > 0 /\ (position_ co cu1) = (length_ co) \/
       cu1 = no_element -> cu2 = no_element)).

(*Why logic*) Definition next_ : list -> cursor -> cursor.
exact Raw_List.next.
Defined.

(*Why axiom*) Lemma next_next :
  (forall (co:list), (forall (cu:cursor), (next__ co cu (next_ co cu)))).
intros l cu; unfold next__; unfold next_; unfold position_;
unfold no_element; unfold length_.
assert (Z_of_nat (1) = 1).
auto.
split.
intros [Hlength Hpos];
rewrite <- H; rewrite <- inj_plus;
apply inj_eq;
rewrite <- inj_0 in Hpos; apply inj_gt_rev in Hpos.
apply inj_gt_rev in Hlength;
apply Raw_List.next_position_gen; [exact Hlength | exact Hpos].
intros [[_ HH] | HH]; [apply inj_eq_rev in HH |].
apply Raw_List.next_position_last; exact HH.
rewrite HH; apply Raw_List.next_position_O.
Qed.

(*Why predicate*) Definition last__  (co:list) (cu:cursor)
  := ((~(is_empty_ co) -> (position_ co cu) = (length_ co))) /\
     (((is_empty_ co) -> cu = no_element)).

(*Why logic*) Definition last_ : list -> cursor.
exact Raw_List.last.
Defined.

(*Why axiom*) Lemma last_last : (forall (co:list), (last__ co (last_ co))).
intro l; unfold last__; unfold last_; unfold is_empty_; unfold position_;
unfold length_; unfold no_element.
split; [intros; apply inj_eq | intros [_ H]; rewrite <- inj_0 in H;
apply inj_eq_rev in H].
apply Raw_List.position_last_gen.
apply Raw_List.last_nil; exact H.
Qed.

(*Why predicate*) Definition first__  (co:list) (cu:cursor)
  := ((~(is_empty_ co) -> (position_ co cu) = 1)) /\
     (((is_empty_ co) -> cu = no_element)).

(*Why logic*) Definition first_ : list -> cursor.
exact Raw_List.first.
Defined.

Lemma is_empty_length : 
forall l : list, not (is_empty_ l) -> (Raw_List.length l <> 0)%nat.
unfold is_empty_; unfold length_; unfold position_;
intros l H.
intro Hl; apply H.
split; [|rewrite <- inj_0; apply inj_eq; exact Hl].
intro cu; rewrite <- inj_0; apply inj_eq.
symmetry; apply le_n_O_eq.
rewrite <- Hl.
apply Raw_List.position_length.
Qed.

(*Why axiom*) Lemma first_first :
  (forall (co:list), (first__ co (first_ co))).
intro l; unfold first__; unfold first_; unfold position_;
unfold no_element; unfold length_.
assert (Z_of_nat (1) = 1).
auto.
split;
[rewrite <- H; intro HH; apply inj_eq;
apply is_empty_length in HH |
unfold is_empty_; unfold length_; unfold position_;
intros [_ Hl]; rewrite <- inj_0 in Hl; apply inj_eq_rev in Hl].
apply Raw_List.position_first_gen; exact HH.
apply Raw_List.first_nil; exact Hl.
Qed.

(*Why logic*) Definition element_ : list -> cursor -> element_t.
exact Raw_List.element.
Defined.

(*Why predicate*) Definition left_pos  (co:list) (i:Z) (col:list)
  := (forall (cu:cursor), (i <= (position_ co cu) -> (position_ col cu) = 0)) /\
     (forall (cu:cursor),
      (i > (position_ co cu) -> (position_ col cu) = (position_ co cu))) /\
     (forall (cu:cursor),
      (i > (position_ co cu) -> (element_ col cu) = (element_ co cu))) /\
     (forall (cu:cursor),
      ((position_ col cu) > 0 -> (position_ co cu) = (position_ col cu))).

(*Why predicate*) Definition left__  (co:list) (cu:cursor) (col:list)
  := ((cu = no_element -> col = co)) /\
     (((position_ co cu) > 0 -> (length_ col) = ((position_ co cu) - 1) /\
       (left_pos co (position_ co cu) col))).

(*Why logic*) Definition left_ : list -> cursor -> list.
exact Raw_List.left.
Defined.

(*Why axiom*) Lemma left_left :
  (forall (co:list), (forall (cu:cursor), (left__ co cu (left_ co cu)))).
intros l cu; unfold left__; unfold left_; unfold left_pos;
unfold position_; unfold element_; unfold no_element;
unfold length_.
split; [intro H; rewrite H; apply Raw_List.left_nil|].
intro H; rewrite <- inj_0 in H; apply inj_gt_rev in H.
assert (Z_of_nat (1) = 1). auto.
rewrite <- H0.
split.
rewrite <- (inj_minus1 (Raw_List.position l cu) 1
(gt_le_S 0 (Raw_List.position l cu) H)); apply inj_eq.
apply (Raw_List.left_length l cu H).
split.
intro cun; intro HH; apply inj_le_rev in HH;
rewrite <- inj_0; apply inj_eq.
apply (Raw_List.left_position_out l cu H cun HH).
split.
intros cun HH; apply inj_gt_rev in HH.
apply inj_eq.
apply (Raw_List.left_position_in l cu H cun HH).
split; intros cun HH; [|rewrite <- inj_0 in HH]; apply inj_gt_rev in HH.
apply (Raw_List.left_element_in l cu H cun HH).
apply inj_eq; apply (Raw_List.left_position_inv l cu H cun HH).
Qed.

(*Why predicate*) Definition right_pos  (co:list) (i:Z) (cor:list)
  := (forall (cu:cursor), (i > (position_ co cu) -> (position_ cor cu) = 0)) /\
     (forall (cu:cursor),
      ((i <= (position_ co cu) -> (position_ cor cu) =
        ((position_ co cu) - i + 1))) /\
      (((position_ cor cu) > 0 -> (position_ co cu) =
        ((position_ cor cu) + i - 1)))) /\
     (forall (cu:cursor),
      (i <= (position_ co cu) -> (element_ cor cu) = (element_ co cu))).

(*Why predicate*) Definition right__  (co:list) (cu:cursor) (cor:list)
  := ((cu = no_element -> cor = empty_)) /\
     (((position_ co cu) > 0 -> (length_ cor) =
       ((length_ co) - (position_ co cu) + 1) /\
       (right_pos co (position_ co cu) cor))) /\
     (forall (cun:cursor),
      ((position_ cor cun) > 0 -> (position_ co cun) > 0)).

(*Why logic*) Definition right_ : list -> cursor -> list.
exact Raw_List.right.
Defined.

(*Why axiom*) Lemma right_right :
  (forall (co:list), (forall (cu:cursor), (right__ co cu (right_ co cu)))).
intros l cu; unfold right__; unfold right_; unfold right_pos;
unfold empty_; unfold position_; unfold length_;
unfold element_; unfold no_element; simpl.
assert (Z_of_nat (1) = 1). auto.
split; [intro HH; rewrite HH; apply Raw_List.right_nil|]; split.
intro Hpos; rewrite <- inj_0 in Hpos; apply inj_gt_rev in Hpos;
split.
rewrite <- (inj_minus1 (Raw_List.length l) (Raw_List.position l cu)
(Raw_List.position_length l cu));
rewrite <- H; rewrite <- inj_plus; apply inj_eq.
apply (Raw_List.right_length l cu Hpos).
split; [|split]; intro cun.
intro Hs; apply inj_gt_rev in Hs; rewrite <- inj_0;
apply inj_eq.
apply (Raw_List.right_position_out l cu Hpos cun Hs).
split.
intro Hs; apply inj_le_rev in Hs.
rewrite <- H;
rewrite <- (inj_minus1 (Raw_List.position l cun) (Raw_List.position l cu) Hs);
rewrite <- inj_plus; apply inj_eq.
apply (Raw_List.right_position_in l cu Hpos cun Hs).
intro HH; rewrite <- inj_0 in HH; apply inj_gt_rev in HH.
rewrite <- H;
rewrite <- inj_plus.
rewrite <- (inj_minus1 _ 1 (gt_le_S _ _
(le_gt_trans _ _ _ (le_plus_l _ _) HH))).
apply inj_eq.
apply (Raw_List.right_position_inv l cu Hpos cun HH).
intro Hs; apply inj_le_rev in Hs.
apply (Raw_List.right_element_in l cu Hpos cun Hs).
intros cun Hpos; rewrite <- inj_0 in Hpos;
apply inj_gt_rev in Hpos; rewrite <- inj_0;
apply inj_gt.
apply (Raw_List.has_element_right l cu cun Hpos).
Qed.

(*Why logic*) Definition find_first : list -> element_t -> cursor.
exact (fun l => Raw_List.find (Raw_List.this l)).
Defined.

(*Why predicate*) Definition find__  (co:list) (e:element_t) (cu:cursor)
  := cu = no_element /\
     (forall (cun:cursor),
      ((position_ co cun) > 0 -> ~((element_ co cun) = e))) \/
     (position_ co cu) > 0 /\ (element_ co cu) = e /\
     (forall (cun:cursor),
      ((position_ co cu) > (position_ co cun) /\ (position_ co cun) > 0 ->
       ~(element_ co cun) = e)).

(*Why axiom*) Lemma find_find_val :
  (forall (co:list), (forall (e:element_t), (find__ co e (find_first co e)))).
intros l e; unfold find__; unfold is_empty_; unfold
position_; unfold length_; unfold find_first; unfold no_element;
unfold element_; rewrite <- inj_0.
destruct (Raw_List.find_has_element (Raw_List.this l) e) as [Hf|Hf]; [right|left].
apply Raw_List.position_has_element in Hf;
split; [apply inj_gt; exact Hf|].
split; [apply (Raw_List.find_element l e Hf)|].
intros cun [Hs1 Hs2].
apply inj_gt_rev in Hs1; apply inj_gt_rev in Hs2.
apply (Raw_List.find_is_first_gen l e cun Hs1 Hs2).
symmetry in Hf; split.
symmetry; exact Hf.
intros cun H; apply inj_gt_rev in H.
apply (Raw_List.find_is_first_O l e cun).
rewrite <- Hf; apply Raw_List.position_no_element.
exact H.
Qed.

(*Why function*) Definition find_  (l:list) (e:element_t) (cu:cursor)
  := (find_first (right_ l cu) e).

(*Why predicate*) Definition equal_  (co1:list) (co2:list)
  := (forall (cu:cursor), (position_ co1 cu) = (position_ co2 cu)) /\
     (forall (cu:cursor),
      ((position_ co1 cu) > 0 -> (element_ co1 cu) = (element_ co2 cu))).

(*Why predicate*) Definition replace_element_  (co1:list) (cu:cursor) (e:element_t) (co2:list)
  := (position_ co1 cu) > 0 /\ (length_ co1) = (length_ co2) /\
     (element_ co2 cu) = e /\
     (forall (cun:cursor), (position_ co2 cun) = (position_ co1 cun)) /\
     (forall (cun:cursor),
      (~(cu = cun) /\ (position_ co1 cun) > 0 ->
       (element_ co2 cun) = (element_ co1 cun))).

(*Why predicate*) Definition insert_pos  (co1:list) (i:Z) (co2:list)
  := (forall (cun:cursor),
      ((i > (position_ co1 cun) /\ (position_ co1 cun) > 0 ->
        (position_ co2 cun) = (position_ co1 cun))) /\
      ((i <= (position_ co1 cun) -> (position_ co2 cun) =
        ((position_ co1 cun) + 1)))) /\
     (forall (cun:cursor),
      ((position_ co1 cun) > 0 -> (element_ co1 cun) = (element_ co2 cun))).

(*Why predicate*) Definition insert_inv  (co1:list) (i:Z) (e:element_t) (co2:list)
  := (forall (cun:cursor),
      ((position_ co2 cun) = i -> (element_ co2 cun) = e)) /\
     (forall (cun:cursor),
      ((i > (position_ co2 cun) /\ (position_ co2 cun) > 0 ->
        (element_ co1 cun) = (element_ co2 cun))) /\
      (((position_ co2 cun) > i -> (element_ co1 cun) = (element_ co2 cun)))) /\
     (forall (cun:cursor),
      (((position_ co2 cun) = i -> (position_ co1 cun) = 0)) /\
      ((i > (position_ co2 cun) /\ (position_ co2 cun) > 0 ->
        (position_ co1 cun) = (position_ co2 cun))) /\
      (((position_ co2 cun) > i -> (position_ co1 cun) =
        ((position_ co2 cun) - 1)))).

(*Why predicate*) Definition insert_  (co1:list) (cu:cursor) (e:element_t) (co2:list)
  := (cu = no_element \/ (position_ co1 cu) > 0) /\ (length_ co2) =
     ((length_ co1) + 1) /\ (cu = no_element /\
     (insert_pos co1 ((length_ co1) + 1) co2) /\
     (insert_inv co1 ((length_ co1) + 1) e co2) \/ (position_ co1 cu) > 0 /\
     (insert_pos co1 (position_ co1 cu) co2) /\
     (insert_inv co1 (position_ co1 cu) e co2)).

(*Why predicate*) Definition delete_pos  (co1:list) (i:Z) (co2:list)
  := (forall (cun:cursor),
      (((position_ co1 cun) = i -> (position_ co2 cun) = 0)) /\
      (((position_ co1 cun) > i -> (position_ co2 cun) =
        ((position_ co1 cun) - 1))) /\
      ((i > (position_ co1 cun) -> (position_ co2 cun) = (position_ co1 cun)))) /\
     (forall (cun:cursor),
      (((position_ co1 cun) > i -> (element_ co2 cun) = (element_ co1 cun))) /\
      ((i > (position_ co1 cun) -> (element_ co2 cun) = (element_ co1 cun)))).

(*Why predicate*) Definition delete_inv  (co1:list) (i:Z) (co2:list)
  := (forall (cun:cursor),
      ((i <= (position_ co2 cun) -> (element_ co1 cun) = (element_ co2 cun))) /\
      ((i > (position_ co2 cun) /\ (position_ co2 cun) > 0 ->
        (element_ co2 cun) = (element_ co1 cun)))) /\
     (forall (cun:cursor),
      ((i > (position_ co2 cun) /\ (position_ co2 cun) > 0 ->
        (position_ co1 cun) = (position_ co2 cun))) /\
      ((i <= (position_ co2 cun) -> (position_ co1 cun) =
        ((position_ co2 cun) + 1)))).

(*Why predicate*) Definition delete_  (co1:list) (cu:cursor) (co2:list)
  := (position_ co1 cu) > 0 /\ (length_ co2) = ((length_ co1) - 1) /\
     (delete_pos co1 (position_ co1 cu) co2) /\
     (delete_inv co1 (position_ co1 cu) co2).

(*Why predicate*) Definition has_element_  (co:list) (cu:cursor)
  := (position_ co cu) > 0.

(*Why predicate*) Definition contains_  (co:list) (e:element_t)
  := (position_ co (find_first co e)) > 0.

(*** TESTS ***)

Definition insert : list -> cursor -> element_t -> list.
exact Raw_List.insert.
Defined.

Lemma insert_insert :
forall (l : list), forall (cu : cursor),
forall (e : element_t),
cu = no_element \/ has_element_ l cu ->
insert_ l cu e (insert l cu e).
intros l cu e; unfold insert_; unfold has_element_;
unfold insert_pos; unfold insert_inv; unfold length_;
unfold position_; unfold no_element; unfold insert;
unfold element_.
assert (Z_of_nat (1) = 1). auto.
intro Hp; split; [exact Hp | split].
rewrite <- H; rewrite <- inj_plus; apply inj_eq.
apply Raw_List.insert_length.
destruct Hp as [Heq|Hpos];
[left; rewrite Heq|right]; split;
[reflexivity| |exact Hpos
|rewrite <- inj_0 in Hpos; apply inj_gt_rev in Hpos];
split; split.
intro cun; split.
intros [H1 H2].
rewrite <- inj_0 in H2; apply inj_gt_rev in H2;
rewrite <- H in H1; rewrite <- inj_plus in H1; apply inj_gt_rev in H1;
apply inj_eq.
apply (Raw_List.insert_position_O l e cun H2).
intro HH; rewrite <- H in HH; rewrite <- inj_plus in HH;
apply inj_le_rev in HH; contradict HH.
apply gt_not_le; rewrite <- plus_n_Sm;
rewrite <- plus_n_O; apply le_S_gt; apply le_n_S.
apply (Raw_List.position_length l cun).
intros cun HH; rewrite <- inj_0 in HH; apply inj_gt_rev in HH.
apply (Raw_List.insert_element_old l O e cun HH).
intros cun HH; rewrite <- H in HH; rewrite <- inj_plus in HH;
apply inj_eq_rev in HH;
rewrite <- (Raw_List.insert_position_new_O l e) in HH.
apply (Raw_List.insert_element_new l O e cun HH).
split.
intro cun; split.
intros [Hl Hpos]; rewrite <- inj_0 in Hpos;
apply inj_gt_rev in Hpos; rewrite <- H in Hl;
rewrite <- inj_plus in Hl; apply inj_gt_rev in Hl;
apply (Raw_List.insert_has_element) in Hpos;
destruct Hpos as [Hko|Hpos].
rewrite Hko in Hl; rewrite (Raw_List.insert_position_new_O l e) in Hl;
contradict Hl; apply gt_irrefl.
apply (Raw_List.insert_element_old l O e cun Hpos).
intro Hko; rewrite <- H in Hko; rewrite <- inj_plus in Hko;
apply inj_gt_rev in Hko; contradict Hko.
apply le_not_gt; rewrite <- (Raw_List.insert_length l O e).
apply Raw_List.position_length.
rewrite <- H; intros cun; split; [|split].
intro Hp; rewrite <- inj_plus in Hp; apply inj_eq_rev in Hp;
rewrite <- inj_0; apply inj_eq.
rewrite <- (Raw_List.insert_position_new_O l e) in Hp.
apply (Raw_List.insert_position_rev_new _ _ _ _ Hp).
intros [Hinf Hp]; apply inj_eq; rewrite <- inj_plus in Hinf;
apply inj_gt_rev in Hinf;
rewrite <- inj_0 in Hp; apply inj_gt_rev in Hp.
apply Raw_List.insert_has_element in Hp.
destruct Hp as [Hko | Hpos];
[|symmetry; apply (Raw_List.insert_position_O l e cun Hpos)].
rewrite Hko in Hinf; rewrite (Raw_List.insert_position_new_O l e) in Hinf.
contradict Hinf; apply le_not_gt; apply le_refl.
intro Hko; rewrite <- inj_plus in Hko;
apply inj_gt_rev in Hko; contradict Hko; apply le_not_gt.
rewrite <- (Raw_List.insert_length l O e).
apply Raw_List.position_length.
intro cun; split.
intros [Hinf Hp]; apply inj_eq;
apply inj_gt_rev in Hinf;
rewrite <- inj_0 in Hp; apply inj_gt_rev in Hp.
apply (Raw_List.insert_position_inf l cu cun e Hpos Hp Hinf).
intro Hsup; apply inj_le_rev in Hsup; rewrite <- H;
rewrite <- inj_plus; apply inj_eq.
apply (Raw_List.insert_position_sup l cu cun e Hpos Hsup).
intros cun Hp; rewrite <- inj_0 in Hp; apply inj_gt_rev in Hp.
apply (Raw_List.insert_element_old l cu e cun Hp).
intros cun HH; apply inj_eq_rev in HH;
rewrite <- (Raw_List.insert_position_new l cu e Hpos) in HH.
apply (Raw_List.insert_element_new l cu e cun HH).
split; intro cun; split.
intros [H1 H2];
rewrite <- inj_0 in H2; apply inj_gt_rev in H2.
apply (Raw_List.insert_has_element) in H2.
destruct H2 as [Hko|Hp].
rewrite Hko in H1;
rewrite (Raw_List.insert_position_new _ _ _ Hpos) in H1.
apply inj_gt_rev in H1; contradict H1; apply gt_irrefl.
apply (Raw_List.insert_element_old l cu e cun Hp).
intro Hq; apply inj_gt_rev in Hq; generalize (gt_trans _ _ _ Hq Hpos).
intro HH; apply (Raw_List.insert_has_element) in HH.
destruct HH as [Hko | Hppos];
[|apply (Raw_List.insert_element_old l cu e cun Hppos)].
contradict Hq; rewrite Hko; apply le_not_gt;
rewrite (Raw_List.insert_position_new _ _ _ Hpos); apply le_refl.
intro HH; apply inj_eq_rev in HH;
rewrite <- (Raw_List.insert_position_new _ _ e Hpos) in HH.
rewrite <- inj_0; apply inj_eq;
apply (Raw_List.insert_position_rev_new _ _ _ _ HH).
split.
intros [Hinf Hp]; apply inj_eq;
apply inj_gt_rev in Hinf;
rewrite <- inj_0 in Hp; apply inj_gt_rev in Hp.
apply (Raw_List.insert_has_element) in Hp.
destruct Hp as [Hko | Hppos].
contradict Hinf; rewrite Hko; apply le_not_gt;
rewrite (Raw_List.insert_position_new _ _ _ Hpos); apply le_refl.
case_eq (leb (Raw_List.position l cu) (Raw_List.position l cun));
intro Hq; [apply leb_complete in Hq|apply leb_complete_conv in Hq].
generalize Hq; intro Hko.
apply (Raw_List.insert_position_sup l cu cun e Hpos) in Hq.
rewrite Hq in Hinf.
rewrite <- plus_n_Sm in Hinf; rewrite <- plus_n_O in Hinf.
elim (gt_irrefl _ (gt_le_trans _ _ _ Hinf
(le_trans _ _ _ Hko (le_n_Sn _)))).
symmetry;
apply (Raw_List.insert_position_inf l cu cun e Hpos Hppos Hq).
intros H1; apply inj_gt_rev in H1;
case_eq (leb (Raw_List.position l cu) (Raw_List.position l cun));
intro Hq; [apply leb_complete in Hq|apply leb_complete_conv in Hq].
rewrite (Raw_List.insert_position_sup l cu cun e Hpos Hq).
rewrite inj_plus; rewrite H;
rewrite Zplus_comm; symmetry;
apply Zminus_plus.
generalize Hq; intro H2;
destruct (Raw_List.insert_has_element l cu e cun
(gt_trans _ _ _ H1 Hpos)) as [Hko|Hp].
rewrite Hko in H1; rewrite (Raw_List.insert_position_new _ _ _ Hpos) in H1.
contradict H1; apply gt_irrefl.
apply lt_not_le in Hq; apply not_le in Hq.
apply (Raw_List.insert_position_inf l cu cun e Hpos Hp) in H2.
rewrite H2 in H1;
elim (gt_irrefl _ (gt_trans _ _ _ Hq H1)).
Qed.

Definition delete : list -> cursor -> list.
exact Raw_List.delete.
Defined.

Lemma delete_delete :
forall (l : list), forall (cu : cursor),
has_element_ l cu -> delete_ l cu (delete l cu).
intros l cu; unfold has_element_; unfold delete_;
unfold delete; unfold delete_pos; unfold delete_inv;
unfold position_; unfold element_; unfold length_.
intro Hpos; split; [exact Hpos|].
assert (Z_of_nat (1) = 1). auto.
rewrite <- inj_0 in Hpos; apply inj_gt_rev in Hpos;
split.
apply Zplus_minus_eq; rewrite <- H; rewrite <- inj_plus;
apply inj_eq.
apply (Raw_List.delete_length l cu Hpos).
split; split; intro cun; split.
intro HH; apply inj_eq_rev in HH;
rewrite <- inj_0; apply inj_eq.
symmetry in HH; apply (Raw_List.position_eq l cu cun Hpos) in HH.
rewrite <- HH; apply (Raw_List.delete_position_deleted l cu Hpos).
split; intro HH; apply inj_gt_rev in HH.
apply Zplus_minus_eq; rewrite <- H; rewrite <- inj_plus; apply inj_eq.
apply(Raw_List.delete_position_sup l cu cun Hpos HH).
case_eq (beq_nat cun cu); intro Hneq;
[apply beq_nat_true in Hneq; rewrite Hneq in HH; contradict HH;
apply gt_irrefl | apply beq_nat_false in Hneq].
apply inj_eq;
apply(Raw_List.delete_position_inf l cu cun Hpos HH).
intro HH; apply inj_gt_rev in HH.
case_eq (beq_nat cun cu); intro Hneq;
[apply beq_nat_true in Hneq; rewrite Hneq in HH; contradict HH;
apply gt_irrefl | apply beq_nat_false in Hneq].
apply (Raw_List.delete_element l cu cun Hpos Hneq).
intro HH; apply inj_gt_rev in HH.
case_eq (beq_nat cun cu); intro Hneq;
[apply beq_nat_true in Hneq; rewrite Hneq in HH; contradict HH;
apply gt_irrefl | apply beq_nat_false in Hneq].
apply (Raw_List.delete_element l cu cun Hpos Hneq).
intro HH; apply inj_le_rev in HH.
case_eq (leb (Raw_List.position l cun) (Raw_List.position l cu));
intro Hs; [apply leb_complete in Hs| apply leb_complete_conv in Hs].
destruct (le_lt_or_eq _ _ Hs) as [Ht|Ht].
apply lt_not_le in Ht; apply not_le in Ht.
rewrite (Raw_List.delete_position_inf _ _ _ Hpos Ht) in HH.
apply (le_antisym _ _ Hs) in HH; rewrite HH in Ht;
contradict Ht; apply gt_irrefl.
symmetry in Ht;
apply (Raw_List.position_eq l cu cun Hpos) in Ht;
rewrite <- Ht.
rewrite <- Ht in HH; rewrite (Raw_List.delete_position_deleted _ _ Hpos) in HH.
apply le_n_O_eq in HH; contradict Hpos; rewrite HH;
apply gt_irrefl.
apply lt_not_le in Hs; apply not_le in Hs.
case_eq(beq_nat cun cu); intro Heq;
[apply beq_nat_true in Heq; rewrite Heq in HH;
rewrite (Raw_List.delete_position_deleted _ _ Hpos) in HH;
apply le_n_O_eq in HH; contradict Hpos; rewrite HH;
apply gt_irrefl|].
apply beq_nat_false in Heq; symmetry;
apply (Raw_List.delete_element l cu cun Hpos Heq).
intros [HH Hpcun]; rewrite <- inj_0 in Hpcun;
apply inj_gt_rev in Hpcun; apply inj_gt_rev in HH.
case_eq(beq_nat cun cu); intro Heq.
apply beq_nat_true in Heq; rewrite Heq in Hpcun;
rewrite (Raw_List.delete_position_deleted _ _ Hpos) in Hpcun;
apply le_n_O_eq in Hpcun; contradict Hpcun; apply O_S.
apply beq_nat_false in Heq;
apply (Raw_List.delete_element l cu cun Hpos Heq).
intros [HH Hpcun]; rewrite <- inj_0 in Hpcun;
apply inj_gt_rev in Hpcun; apply inj_gt_rev in HH.
case_eq (leb (Raw_List.position l cu) (Raw_List.position l cun));
intro Hs; [apply leb_complete in Hs| apply leb_complete_conv in Hs].
destruct (le_lt_or_eq _ _ Hs) as [Ht|Ht].
apply lt_not_le in Ht; apply not_le in Ht.
generalize Ht; intro Htt;
apply (Raw_List.delete_position_sup _ _ _ Hpos) in Ht.
rewrite Ht in Htt.
apply gt_S_le in Htt.
contradict HH; apply le_not_gt; exact Htt.
apply (Raw_List.position_eq l cu cun Hpos) in Ht;
rewrite <- Ht in Hpcun.
contradict Hpcun;
rewrite (Raw_List.delete_position_deleted _ _ Hpos); apply gt_irrefl.
apply inj_eq.
apply lt_not_le in Hs; apply not_le in Hs.
symmetry; apply (Raw_List.delete_position_inf _ _ _ Hpos Hs).
intro HH; apply inj_le_rev in HH.
case_eq (leb (Raw_List.position l cun) (Raw_List.position l cu));
intro Hs; [apply leb_complete in Hs| apply leb_complete_conv in Hs].
destruct (le_lt_or_eq _ _ Hs) as [Ht|Ht].
apply lt_not_le in Ht; apply not_le in Ht.
rewrite (Raw_List.delete_position_inf _ _ _ Hpos Ht) in HH.
apply (le_antisym _ _ Hs) in HH; rewrite HH in Ht;
contradict Ht; apply gt_irrefl.
symmetry in Ht;
apply (Raw_List.position_eq l cu cun Hpos) in Ht;
rewrite <- Ht.
rewrite <- Ht in HH; rewrite (Raw_List.delete_position_deleted _ _ Hpos) in HH.
apply le_n_O_eq in HH; contradict Hpos; rewrite HH;
apply gt_irrefl.
apply lt_not_le in Hs; apply not_le in Hs.
case_eq(beq_nat cun cu); intro Heq;
[apply beq_nat_true in Heq; rewrite Heq in HH;
rewrite (Raw_List.delete_position_deleted _ _ Hpos) in HH;
apply le_n_O_eq in HH; contradict Hpos; rewrite HH;
apply gt_irrefl|].
rewrite <- H; rewrite <- inj_plus; rewrite plus_comm;
apply inj_eq;
apply (Raw_List.delete_position_sup _ _ _ Hpos Hs).
Qed.

Definition replace_element : list -> cursor -> element_t -> list.
exact Raw_List.replace.
Defined.

Lemma replace_element_replace_element :
forall (l : list), forall (cu : cursor), forall (e : element_t),
has_element_ l cu -> replace_element_ l cu e (replace_element l cu e).
intros l cu e; unfold has_element_; unfold replace_element_;
unfold replace_element; unfold position_; unfold length_;
unfold element_.
intro Hpos; split; [exact Hpos|].
rewrite <- inj_0 in Hpos; rewrite <- inj_0;
apply inj_gt_rev in Hpos; split.
apply inj_eq.
apply Raw_List.replace_length.
split.
apply(Raw_List.replace_element_replaced l cu e Hpos).
split; intro cun.
apply inj_eq.
apply Raw_List.replace_position.
intros [Hdiff Hpcun]; apply inj_gt_rev in Hpcun.
apply(Raw_List.replace_element l cu e cun Hdiff).
Qed.

(*** MAX ***)

Module Type CompareType.

Parameter Inline compare : element_t -> element_t -> Z.

Axiom compare_refl :
forall e : element_t, (compare e e = 0)%Z.

Axiom compare_asym :
forall e1 : element_t, forall e2 : element_t,
(0 <= compare e1 e2 <-> compare e2 e1 <= 0)%Z.

Axiom compare_trans :
forall e1 : element_t, forall e2 : element_t, forall e3 : element_t,
(compare e1 e2 <= 0)%Z -> (compare e2 e3 <= 0)%Z ->
(compare e1 e3 <= 0)%Z.

End CompareType.

Module Compare (Compare : CompareType).

Definition compare_ : element_t -> element_t -> Z.
exact Compare.compare.
Defined.

Module Max_List := Raw_List.Max (Compare).

Definition is_max  (v:list) (cu:cursor)
  := (has_element_ v cu) /\
     (forall (e:element_t),
      ((contains_ v e) -> (compare_ (element_ v cu) e) >= 0)).

Definition max_ (l : list) :=
Max_List.max (Raw_List.this l).

Lemma is_max_max :
  (forall (v:list), (~(is_empty_ v) -> (is_max v (max_ v)))).
intros l He; apply is_empty_length in He;
unfold is_max; unfold max_; unfold has_element_; unfold contains_;
unfold element_; unfold find_; unfold first_;
unfold position_.
split.
rewrite <- inj_0; apply inj_gt; apply Raw_List.position_has_element.
simpl; apply (Max_List.max_has_element _ He).
intros e Hhfind;
rewrite <- inj_0 in Hhfind; apply inj_gt_rev in Hhfind.
rewrite <- (Raw_List.find_element l e Hhfind).
apply (Raw_List.has_element_position) in Hhfind.
destruct (Compare.compare_asym (Raw_List.element l (Max_List.max (Raw_List.this l)))
(Raw_List.element l (Raw_List.find (Raw_List.this l) e))) as [_ H];
apply Zle_ge; apply H; clear H.
apply (Max_List.max_element _ l Hhfind).
Qed.

End Compare.

(*** SUM_OF ***)

Module Type WeightType.

Parameter Inline weight : element_t -> nat.

End WeightType.

Module Weight (W : WeightType).

Definition weight_ : element_t -> Z.
exact (fun e => Z_of_nat (W.weight e)).
Defined.

Lemma positive_weight :
  (forall (e:element_t), (weight_ e) >= 0).
intro e; unfold weight_; apply Zle_ge; apply Zle_0_nat.
Qed.

Module Sum_List := Raw_List.Sum_Of(W).

Definition sum_of_weight : list -> Z.
exact (fun l => Z_of_nat (Sum_List.sum_of_weight (Raw_List.this l))).
Defined.

Lemma sum_of_weight_delete :
  (forall (v1:list),
   (forall (v2:list),
    (forall (cu:cursor),
     ((delete_ v1 cu v2) -> (sum_of_weight v2) =
      ((sum_of_weight v1) - (weight_ (element_ v1 cu))))))).
assert (Z_of_nat (1) = 1). auto.
intros l1 l2 cu; unfold delete_; unfold sum_of_weight;
unfold weight_; unfold delete_pos; unfold delete_inv;
unfold element_; unfold length_; unfold position_;
intros [Hposcu[Hlgth[[Hdpos Hdelm Hdinv]]]]; apply Zplus_minus_eq.
rewrite <- inj_plus; apply inj_eq.
apply Sum_List.sum_of_delete.
apply Raw_List.has_element_position.
rewrite <- inj_0 in Hposcu; apply (inj_gt_rev _ _ Hposcu).
destruct (Hdpos cu) as [Hpcu _].
case_eq (Raw_List.has_element (Raw_List.this l2) cu); [|reflexivity].
intro Hhe; apply Raw_List.position_has_element in Hhe;
apply inj_gt in Hhe; contradict Hhe; 
rewrite (Hpcu (reflexivity (Z_of_nat (Raw_List.position l1 cu)))).
rewrite inj_0; apply Zgt_irrefl.
intros cun Hp; destruct (Hdpos cun) as [_ [Hpcui Hpcus]].
destruct (Z_dec (Z_of_nat (Raw_List.position l1 cun))
(Z_of_nat (Raw_List.position l1 cu))) as [[Hs|Hi]|Hko];
[intros _; apply Zlt_gt in Hs|intros _|intro Hdiff; contradict Hdiff;
apply (Raw_List.position_eq l1 _ _ Hp); apply inj_eq_rev; exact Hko].
generalize (Hpcus Hs); intro Heqpos; destruct (Hdelm cun) as [_ He];
generalize (He Hs); intro Heqe; split;
[apply inj_eq_rev in Heqpos; rewrite Heqpos; exact Hp|exact Heqe].
generalize (Hpcui Hi); intro Heqpos; destruct (Hdelm cun) as [He _];
generalize (He Hi); intro Heqe; split;
apply inj_gt_rev in Hi; rewrite (S_pred _ _ Hi) in Heqpos;
rewrite (S_pred _ _ Hi) in Hi.
rewrite <- inj_0 in Hposcu; apply inj_gt_rev in Hposcu;
apply gt_S_le in Hi; apply (le_gt_trans _ _ _ Hi) in Hposcu.
rewrite (plus_n_O (pred (Raw_List.position l1 cun))) in Heqpos;
rewrite plus_n_Sm in Heqpos; rewrite inj_plus in Heqpos;
rewrite Zplus_comm in Heqpos; rewrite Zminus_plus in Heqpos.
apply inj_eq_rev in Heqpos; rewrite Heqpos; exact Hposcu.
exact Heqe.
destruct (Zeq_plus_swap (Z_of_nat (Raw_List.length l2))
(Z_of_nat (Raw_List.length l1)) 1) as [_ Hint]; apply Hint in Hlgth.
rewrite <- H in Hlgth; rewrite <- inj_plus in Hlgth;
apply inj_eq_rev in Hlgth; rewrite <- Hlgth.
rewrite <- plus_n_Sm; rewrite <- plus_n_O; reflexivity.
Qed.

Lemma sum_of_weight_insert :
  (forall (v1:list),
   (forall (v2:list),
    (forall (cu:cursor),
     (forall (e:element_t),
      ((insert_ v1 cu e v2) -> (sum_of_weight v2) =
       ((sum_of_weight v1) + (weight_ e))))))).
assert (Z_of_nat (1) = 1). auto.
intros l1 l2 cu e; unfold insert_; unfold sum_of_weight;
unfold weight_; unfold insert_pos; unfold insert_inv;
unfold element_; unfold length_; unfold position_.
intros [[Hnel | Hposcu]];
[rewrite Hnel; rewrite (Raw_List.position_no_element);
intros [Hlgth [[_ [[Hposp Hpose] [Hinve [_ Hinvp]]]] | [Hko _]]];
[| contradict Hko; rewrite inj_0; apply Zgt_irrefl]|
intros [Hlgth [[Hko _] | [_ [[Hposp Hpose] [Hinve [_ Hinvp]]]]]];
[contradict Hposcu; rewrite Hko; rewrite (Raw_List.position_no_element);
 rewrite inj_0; apply Zgt_irrefl|]].
generalize (Hinve (Raw_List.last l2)); intro HHe.
destruct (Hinvp (Raw_List.last l2)) as [HHp _].
rewrite <- Raw_List.position_last_gen in Hlgth.
generalize (HHe Hlgth); intro Hellast; clear HHe.
generalize (HHp Hlgth); intro Hposlast; clear HHp.
rewrite <- inj_plus;
rewrite (Sum_List.sum_of_insert l1 l2 (S(Raw_List.length l1))
(Raw_List.last l2) e ).
rewrite plus_comm; reflexivity.
apply (Raw_List.has_element_position).
rewrite <- H in Hlgth; rewrite <- inj_plus in Hlgth;
rewrite <- plus_n_Sm in Hlgth; rewrite <- plus_n_O in Hlgth;
apply inj_eq_rev in Hlgth.
rewrite Hlgth; apply gt_Sn_O.
case_eq(Raw_List.has_element (Raw_List.this l1) (Raw_List.last l2));
[intro Hko|reflexivity].
apply Raw_List.position_has_element in Hko.
rewrite <- inj_0 in Hposlast; apply inj_eq_rev in Hposlast;
contradict Hko; rewrite Hposlast; apply gt_irrefl.
exact Hellast.
rewrite (plus_n_O (Raw_List.length l1));
rewrite plus_n_Sm; intros cun Hppos.
apply inj_le in Hppos; rewrite inj_plus in Hppos; rewrite H in Hppos.
destruct(Hposp cun) as [_ Hposi]; generalize (Hpose cun); intro Heli;
generalize (Hposi Hppos); clear Hposi; intro Hp.
rewrite <- H in Hppos; rewrite <- inj_plus in Hppos;
apply inj_le_rev in Hppos; rewrite <- plus_n_Sm in Hppos;
rewrite <- plus_n_O in Hppos.
rewrite <- H in Hp; rewrite <- inj_plus in Hp;
apply inj_eq_rev in Hp; rewrite <- plus_n_Sm in Hp;
rewrite <- plus_n_O in Hp.
split; [exact Hp | symmetry; apply Heli].
rewrite <- inj_0; apply inj_gt;
apply (le_gt_trans _ _ _ Hppos (gt_Sn_O _)).
rewrite (plus_n_O (Raw_List.length l1));
rewrite plus_n_Sm; intros cun Hhe Hppos.
apply inj_gt in Hppos; rewrite inj_plus in Hppos; rewrite H in Hppos.
destruct(Hposp cun) as [Hposi _]; generalize (Hpose cun); intro Heli;
assert (Z_of_nat (Raw_List.length l1) + 1 > 
Z_of_nat (Raw_List.position l1 cun) /\
Z_of_nat (Raw_List.position l1 cun) > 0);
[split;[exact Hppos|]|].
rewrite <- inj_0; apply inj_gt;
apply (Raw_List.position_has_element _ _ Hhe).
generalize (Hposi H0); clear Hposi; intro Hp.
apply inj_eq_rev in Hp.
split; [symmetry; exact Hp | symmetry; apply Heli].
destruct H0 as [_ HH]; exact HH.
rewrite <- H in Hlgth; rewrite <- inj_plus in Hlgth;
rewrite <- plus_n_Sm in Hlgth; rewrite <- plus_n_O in Hlgth;
apply inj_eq_rev in Hlgth; rewrite <- Raw_List.position_last_gen;
exact Hlgth.
destruct (Hposp cu) as [_ Hppos];
generalize (Hppos (Zle_refl _)); clear Hppos; intro Hp.
rewrite <- H in Hp; rewrite <- inj_plus in Hp;
apply inj_eq_rev in Hp; rewrite <- plus_n_Sm in Hp;
rewrite <- plus_n_O in Hp.
rewrite <- inj_0 in Hposcu; apply inj_gt_rev in Hposcu.
generalize Hposcu; intro Hposscu;
apply gt_n_S in Hposscu; rewrite <- Hp in Hposscu;
generalize (Raw_List.position_previous_gen l2 cu Hposscu);
rewrite Hp; rewrite <- pred_of_minus;
rewrite <- pred_Sn; intro Hpos_prev.
destruct (Hinvp (Raw_List.previous l2 cu)) as [Hint _].
generalize (Hint (inj_eq _ _ Hpos_prev)); intro Hpprevl1.
generalize (Hinve (Raw_List.previous l2 cu) (inj_eq _ _ Hpos_prev));
intro Hel; clear Hint.
rewrite <- inj_plus;
rewrite (Sum_List.sum_of_insert l1 l2 (Raw_List.position l1 cu)
(Raw_List.previous l2 cu) e ).
rewrite plus_comm; reflexivity.
apply (Raw_List.has_element_position).
rewrite Hpos_prev; exact Hposcu.
case_eq(Raw_List.has_element (Raw_List.this l1)
(Raw_List.previous l2 cu));
[intro Hko|reflexivity].
apply Raw_List.position_has_element in Hko.
rewrite <- inj_0 in Hpprevl1; apply inj_eq_rev in Hpprevl1;
contradict Hko; rewrite Hpprevl1; apply gt_irrefl.
exact Hel.
intros cun Hppos; apply inj_le in Hppos.
destruct (Hposp cun) as [_ Hposi];
generalize (Hpose cun); intro Heli.
generalize (Hposi Hppos); clear Hposi; intro Hpcun.
rewrite <- H in Hpcun; rewrite <- inj_plus in Hpcun;
apply inj_eq_rev in Hpcun; rewrite <- plus_n_Sm in Hpcun;
rewrite <- plus_n_O in Hpcun.
split; [exact Hpcun | symmetry; apply Heli].
apply inj_le_rev in Hppos;rewrite <- inj_0; apply inj_gt;
apply (le_gt_trans _ _ _ Hppos Hposcu).
intros cun Hhe Hppos; apply inj_gt in Hppos.
destruct (Hposp cun) as [Hposi _];
generalize (Hpose cun); intro Heli.
assert (Z_of_nat (Raw_List.position l1 cu) > 
Z_of_nat (Raw_List.position l1 cun) /\
Z_of_nat (Raw_List.position l1 cun) > 0);
[split;[exact Hppos|]|].
rewrite <- inj_0; apply inj_gt;
apply (Raw_List.position_has_element _ _ Hhe).
generalize (Hposi H0); clear Hposi; intro Hpcun.
apply inj_eq_rev in Hpcun.
split; [symmetry; exact Hpcun | symmetry; apply Heli].
destruct H0 as [_ HH]; exact HH.
rewrite <- H in Hlgth; rewrite <- inj_plus in Hlgth;
rewrite <- plus_n_Sm in Hlgth; rewrite <- plus_n_O in Hlgth;
apply inj_eq_rev in Hlgth; exact Hlgth.
Qed.

Lemma sum_of_weight_replace_element :
  (forall (v1:list),
   (forall (v2:list),
    (forall (cu:cursor),
     (forall (e:element_t),
      ((replace_element_ v1 cu e v2) -> (sum_of_weight v2) =
       ((sum_of_weight v1) + (weight_ e) - (weight_ (element_ v1 cu)))))))).
assert (Z_of_nat (1) = 1). auto.
intros l1 l2 cu e; unfold replace_element_; unfold sum_of_weight;
unfold weight_; unfold element_; unfold length_; unfold position_.
intros [Hposcu[Hlgth [Hel [Hposp Hpose]]]].
apply Zplus_minus_eq; repeat(rewrite <- inj_plus); apply inj_eq.
apply inj_eq_rev in Hlgth; rewrite <- inj_0 in Hposcu;
apply inj_gt_rev in Hposcu; rewrite <- inj_0 in Hpose;
rewrite (Sum_List.sum_of_replace l1 l2 cu e).
rewrite plus_comm; reflexivity.
apply (Raw_List.has_element_position _ _ Hposcu).
exact Hel.
intros cun Hposl1;
generalize (Hposp cun)(Hpose cun); intros Hposeq Heleq.
apply inj_eq_rev in Hposeq; rewrite Hposeq.
split; [exact Hposl1|intro Hdiff; apply Heleq].
split; [exact Hdiff|apply inj_gt; exact Hposl1].
symmetry; exact Hlgth.
Qed.

Lemma sum_of_weight_null :
  (forall (v:list), ((is_empty_ v) -> (sum_of_weight v) = 0)).
unfold is_empty_; unfold sum_of_weight; unfold length_.
intros l [_ Hl].
rewrite <- inj_0; rewrite <- inj_0 in Hl; apply inj_eq;
apply inj_eq_rev in Hl; apply (Sum_List.sum_of_nil l Hl).
Qed.

Lemma sum_of_weight_equal :
  (forall (v1:list),
   (forall (v2:list),
    ((equal_ v1 v2) -> (sum_of_weight v1) = (sum_of_weight v2)))).
unfold equal_; unfold sum_of_weight; unfold position_;
unfold element_; intros l1 l2 [Heqp Heqe].
apply inj_eq;
apply (Sum_List.sum_of_equal l1 l2).
intros cu; generalize (Heqp cu)(Heqe cu); intros Hp He;
split; [apply inj_eq_rev in Hp; exact Hp|intro Hpl1].
apply He; rewrite <- inj_0; apply inj_gt;
exact Hpl1.
Qed.

Lemma sum_of_weight_left :
  (forall (v:list),
   (forall (cu:cursor),
    ((has_element_ v cu) -> (sum_of_weight (left_ v (next_ v cu))) =
     ((sum_of_weight (left_ v cu)) + (weight_ (element_ v cu)))))).
unfold left_; unfold next_; unfold weight_; unfold has_element_;
unfold position_; unfold sum_of_weight; intros l cu Hpos.
rewrite <- inj_plus; apply inj_eq; apply Sum_List.sum_of_left.
apply (Raw_List.has_element_position); apply inj_gt_rev;
rewrite inj_0; exact Hpos.
Qed.

Lemma sum_of_weight_right :
  (forall (v:list),
   (forall (cu:cursor),
    ((has_element_ v cu) -> (sum_of_weight (right_ v (next_ v cu))) =
     ((sum_of_weight (right_ v cu)) - (weight_ (element_ v cu)))))).
unfold right_; unfold next_; unfold weight_; unfold has_element_;
unfold position_; unfold sum_of_weight; intros l cu Hpos.
apply Zplus_minus_eq; symmetry.
rewrite <- inj_plus; apply inj_eq; apply Sum_List.sum_of_right.
apply (Raw_List.has_element_position); apply inj_gt_rev;
rewrite inj_0; exact Hpos.
Qed.

End Weight.

End List.


(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)
(* Require Why. *)
Require Import ZArith.
Open Scope Z_scope.
Require "list_raw".

Module Type Element_Type.

Parameter Inline element_t : Set.

Parameter Inline e_nl : element_t.

Parameter Inline beq_elt : element_t -> element_t -> bool.

Axiom beq_elt_refl : forall e : element_t, beq_elt e e = true.

Axiom beq_elt_true : forall e1 : element_t, forall e2 : element_t,
beq_elt e1 e2 = true -> e1 = e2.

Axiom beq_elt_false : forall e1 : element_t, forall e2 : element_t,
beq_elt e1 e2 = false -> e1 <> e2.

End Element_Type.

Module List (Elt : Element_Type).

Module E.

Definition element_t : Set.
exact Elt.element_t.
Defined.

Definition witness_t : Set := element_t.

Definition witness (e : element_t) : witness_t := e.

Definition e_nl : element_t.
exact Elt.e_nl.
Defined.

Definition eq_witness : element_t -> element_t -> Prop.
exact (fun e1 e2 => e1 = e2).
Defined.

Definition beq_witness : element_t -> element_t -> bool.
exact Elt.beq_elt.
Defined.

Lemma beq_witness_refl : forall e : element_t, beq_witness e e = true.
apply Elt.beq_elt_refl.
Qed.

Lemma beq_witness_true : forall e1 : element_t, forall e2 : element_t,
beq_witness e1 e2 = true -> eq_witness e1 e2.
apply Elt.beq_elt_true.
Qed.

Lemma beq_witness_false : forall e1 : element_t, forall e2 : element_t,
beq_witness e1 e2 = false -> not (eq_witness e1 e2).
apply Elt.beq_elt_false.
Qed.

End E.

Module Raw_List := list_raw.Raw_List(E).

(*Why type*) Definition cursor: Set.
exact Raw_List.cursor.  
Defined.

(*Why type*) Definition element_t: Set.
exact E.element_t.  
Defined.

(*Why type*) Definition list: Set.
exact Raw_List.list.
Defined.

(*Why logic*) Definition no_element : cursor.
exact O.
Defined.

(*Why logic*) Definition empty_ : list.
exact Raw_List.empty.
Defined.

(*Why logic*) Definition length_ : list -> Z.
exact (fun l => Z_of_nat(Raw_List.length l)).
Defined.

(*Why axiom*) Lemma length_gte_zero : (forall (co:list), 0 <= (length_ co)).
intro l; unfold length_; apply Zle_0_nat.
Qed.

(*Why logic*) Definition position_ : list -> cursor -> Z.
exact (fun l cu => Z_of_nat(Raw_List.position l cu)).
Defined.

(*Why axiom*) Lemma position_gte_zero :
  (forall (co:list),
   (forall (cu:cursor), 0 <= (position_ co cu) /\ (position_ co cu) <=
    (length_ co))).
unfold position_.
unfold length_.
split.
apply Zle_0_nat.
apply inj_le; simpl.
apply Raw_List.position_length.
Qed.

(*Why axiom*) Lemma position_no_element :
  (forall (co:list), (position_ co no_element) = 0).
intro l; unfold position_; unfold no_element;
rewrite <- inj_0; apply inj_eq.
apply Raw_List.position_no_element.
Qed.

(*Why axiom*) Lemma position_eq :
  (forall (co:list),
   (forall (cu1:cursor),
    (forall (cu2:cursor),
     ((position_ co cu1) > 0 ->
      ((position_ co cu1) = (position_ co cu2) -> cu1 = cu2))))).
intros l cu1 cu2; unfold position_; rewrite <- inj_0;
intros Hpos Heq.
apply inj_gt_rev in Hpos.
apply inj_eq_rev in Heq.
apply (Raw_List.position_eq l cu1 cu2 Hpos Heq).
Qed.

(*Why predicate*) Definition is_empty_  (co:list)
  := (forall (cu:cursor), (position_ co cu) = 0) /\ (length_ co) = 0.

(*Why axiom*) Lemma empty_is_empty : (is_empty_ empty_).
unfold is_empty_; unfold empty_; unfold position_; unfold length_;
unfold Raw_List.length; unfold Raw_List.empty; simpl; auto.
Qed.

(*Why predicate*) Definition previous__  (co:list) (cu1:cursor) (cu2:cursor)
  := (((position_ co cu1) > 1 -> (position_ co cu2) =
       ((position_ co cu1) - 1))) /\
     (((position_ co cu1) = 1 \/ cu1 = no_element -> cu2 = no_element)).

(*Why logic*) Definition previous_ : list -> cursor -> cursor.
exact Raw_List.previous.
Defined.

(*Why axiom*) Lemma previous_previous :
  (forall (co:list),
   (forall (cu:cursor), (previous__ co cu (previous_ co cu)))).
unfold previous_; unfold previous__;
unfold position_; unfold no_element.
intros l cu.
assert (Z_of_nat (1) = 1).
auto.
split.
intro HH.
rewrite <- H in HH;
apply inj_gt_rev in HH;
rewrite <- H;
rewrite <- (inj_minus1 (Raw_List.position l cu) 1
(gt_S_le 1 (Raw_List.position l cu)
(gt_trans (S (Raw_List.position l cu)) (Raw_List.position l cu) 1
(gt_Sn_n (Raw_List.position l cu)) HH)));
apply inj_eq.
apply Raw_List.position_previous_gen;
exact HH.
intros [HH | HH].
rewrite <- H in HH; apply inj_eq_rev in HH.
apply Raw_List.position_previous_first; exact HH.
rewrite HH; apply Raw_List.previous_O.
Qed.

(*Why predicate*) Definition next__  (co:list) (cu1:cursor) (cu2:cursor)
  := (((length_ co) > (position_ co cu1) /\ (position_ co cu1) > 0 ->
       (position_ co cu2) = ((position_ co cu1) + 1))) /\
     (((length_ co) > 0 /\
       (position_ co cu1) = (length_ co) \/ cu1 = no_element ->
       cu2 = no_element)).

(*Why logic*) Definition next_ : list -> cursor -> cursor.
exact Raw_List.next.
Defined.

(*Why axiom*) Lemma next_next :
  (forall (co:list), (forall (cu:cursor), (next__ co cu (next_ co cu)))).
intros l cu; unfold next__; unfold next_; unfold position_;
unfold no_element; unfold length_.
assert (Z_of_nat (1) = 1).
auto.
split;
[intros [Hlength Hpos];
rewrite <- H; rewrite <- inj_plus;
apply inj_eq; apply inj_gt_rev in Hlength;
rewrite <- inj_0 in Hpos; apply inj_gt_rev in Hpos|
intros [[_ HH] | HH]; [apply inj_eq_rev in HH |]].
apply Raw_List.next_position_gen; [exact Hlength | exact Hpos].
apply Raw_List.next_position_last; exact HH.
rewrite HH; apply Raw_List.next_position_O.
Qed.

(*Why predicate*) Definition last__  (co:list) (cu:cursor)
  := ((~(is_empty_ co) -> (position_ co cu) = (length_ co))) /\
     (((is_empty_ co) -> cu = no_element)).

(*Why logic*) Definition last_ : list -> cursor.
exact Raw_List.last.
Defined.

(*Why axiom*) Lemma last_last : (forall (co:list), (last__ co (last_ co))).
intro l; unfold last__; unfold last_; unfold is_empty_; unfold position_;
unfold length_; unfold no_element.
split; [intros; apply inj_eq | intros [_ H]; rewrite <- inj_0 in H;
apply inj_eq_rev in H].
apply Raw_List.position_last_gen.
apply Raw_List.last_nil; exact H.
Qed.

(*Why predicate*) Definition first__  (co:list) (cu:cursor)
  := ((~(is_empty_ co) -> (position_ co cu) = 1)) /\
     (((is_empty_ co) -> cu = no_element)).

(*Why logic*) Definition first_ : list -> cursor.
exact Raw_List.first.
Defined.

Lemma is_empty_length : 
forall l : list, not (is_empty_ l) -> (Raw_List.length l <> 0)%nat.
unfold is_empty_; unfold length_; unfold position_;
intros l H.
intro Hl; apply H.
split; [|rewrite <- inj_0; apply inj_eq; exact Hl].
intro cu; rewrite <- inj_0; apply inj_eq.
symmetry; apply le_n_O_eq.
rewrite <- Hl.
apply Raw_List.position_length.
Qed.

(*Why axiom*) Lemma first_first :
  (forall (co:list), (first__ co (first_ co))).
intro l; unfold first__; unfold first_; unfold position_;
unfold no_element; unfold length_.
assert (Z_of_nat (1) = 1).
auto.
split;
[rewrite <- H; intro HH; apply inj_eq;
apply is_empty_length in HH |
unfold is_empty_; unfold length_; unfold position_;
intros [_ Hl]; rewrite <- inj_0 in Hl; apply inj_eq_rev in Hl].
apply Raw_List.position_first_gen; exact HH.
apply Raw_List.first_nil; exact Hl.
Qed.

(*Why logic*) Definition element_ : list -> cursor -> element_t.
exact Raw_List.element.
Defined.

(*Why predicate*) Definition left_pos  (co:list) (i:Z) (col:list)
  := (forall (cu:cursor),
      ((i <= (position_ co cu) -> (position_ col cu) = 0)) /\
      ((i > (position_ co cu) -> (position_ col cu) = (position_ co cu) /\
        (element_ col cu) = (element_ co cu))) /\
      (((position_ col cu) > 0 -> (position_ co cu) = (position_ col cu)))).

(*Why predicate*) Definition left__  (co:list) (cu:cursor) (col:list)
  := ((cu = no_element -> col = co)) /\
     (((position_ co cu) > 0 -> (length_ col) = ((position_ co cu) - 1) /\
       (left_pos co (position_ co cu) col))).

(*Why logic*) Definition left_ : list -> cursor -> list.
exact Raw_List.left.
Defined.

(*Why axiom*) Lemma left_left :
  (forall (co:list), (forall (cu:cursor), (left__ co cu (left_ co cu)))).
intros l cu; unfold left__; unfold left_; unfold left_pos;
unfold position_; unfold element_; unfold no_element;
unfold length_.
split; [intro H; rewrite H; apply Raw_List.left_nil|].
intro H; rewrite <- inj_0 in H; apply inj_gt_rev in H.
assert (Z_of_nat (1) = 1). auto.
rewrite <- H0.
split.
rewrite <- (inj_minus1 (Raw_List.position l cu) 1
(gt_le_S 0 (Raw_List.position l cu) H)); apply inj_eq.
apply (Raw_List.left_length l cu H).
intro cun; split.
intro HH; apply inj_le_rev in HH;
rewrite <- inj_0; apply inj_eq.
apply (Raw_List.left_position_out l cu H cun HH).
split.
intro HH; apply inj_gt_rev in HH; split.
apply inj_eq.
apply (Raw_List.left_position_in l cu H cun HH).
apply (Raw_List.left_element_in l cu H cun HH).
intro HH; rewrite <- inj_0 in HH; apply inj_gt_rev in HH;
apply inj_eq.
apply (Raw_List.left_position_inv l cu H cun HH).
Qed.

(*Why predicate*) Definition right_pos  (co:list) (i:Z) (cor:list)
  := (forall (cu:cursor),
      ((i > (position_ co cu) -> (position_ cor cu) = 0)) /\
      ((i <= (position_ co cu) -> (position_ cor cu) =
        ((position_ co cu) - i + 1) /\ (element_ cor cu) = (element_ co cu))) /\
      (((position_ cor cu) > 0 -> (position_ co cu) =
        ((position_ cor cu) + i - 1)))).

(*Why predicate*) Definition right__  (co:list) (cu:cursor) (cor:list)
  := ((cu = no_element -> cor = empty_)) /\
     (((position_ co cu) > 0 -> (length_ cor) =
       ((length_ co) - (position_ co cu) + 1) /\
       (right_pos co (position_ co cu) cor))) /\
     (forall (cun:cursor),
      ((position_ cor cun) > 0 -> (position_ co cun) > 0)).

(*Why logic*) Definition right_ : list -> cursor -> list.
exact Raw_List.right.
Defined.

(*Why axiom*) Lemma right_right :
  (forall (co:list), (forall (cu:cursor), (right__ co cu (right_ co cu)))).
intros l cu; unfold right__; unfold right_; unfold right_pos;
unfold empty_; unfold position_; unfold length_;
unfold element_; unfold no_element; simpl.
assert (Z_of_nat (1) = 1). auto.
split; [intro HH; rewrite HH; apply Raw_List.right_nil|]; split.
intro Hpos; rewrite <- inj_0 in Hpos; apply inj_gt_rev in Hpos;
split.
rewrite <- (inj_minus1 (Raw_List.length l) (Raw_List.position l cu)
(Raw_List.position_length l cu));
rewrite <- H; rewrite <- inj_plus; apply inj_eq.
apply (Raw_List.right_length l cu Hpos).
intro cun; split.
intro Hs; apply inj_gt_rev in Hs; rewrite <- inj_0;
apply inj_eq.
apply (Raw_List.right_position_out l cu Hpos cun Hs).
split.
intro Hs; apply inj_le_rev in Hs; split.
SearchAbout minus.
rewrite <- H;
rewrite <- (inj_minus1 (Raw_List.position l cun) (Raw_List.position l cu) Hs);
rewrite <- inj_plus; apply inj_eq.
apply (Raw_List.right_position_in l cu Hpos cun Hs).
apply (Raw_List.right_element_in l cu Hpos cun Hs).
intro HH; rewrite <- inj_0 in HH; apply inj_gt_rev in HH.
rewrite <- H;
rewrite <- inj_plus.
SearchAbout plus.
rewrite <- (inj_minus1 _ 1 (gt_le_S _ _
(le_gt_trans _ _ _ (le_plus_l _ _) HH))).
apply inj_eq.
apply (Raw_List.right_position_inv l cu Hpos cun HH).
intros cun Hpos; rewrite <- inj_0 in Hpos;
apply inj_gt_rev in Hpos; rewrite <- inj_0;
apply inj_gt.
apply (Raw_List.has_element_right l cu cun Hpos).
Qed.

(*Why logic*) Definition find_first : list -> element_t -> cursor.
exact Raw_List.find.
Defined.

(*Why predicate*) Definition find__  (co:list) (e:element_t) (cu:cursor)
  := cu = no_element /\
     (forall (cun:cursor),
      ((position_ co cun) > 0 -> ~((element_ co cun) = e))) \/
     (position_ co cu) > 0 /\ (element_ co cu) = e /\
     (forall (cun:cursor),
      ((position_ co cu) > (position_ co cun) /\ (position_ co cun) > 0 ->
       ~(element_ co cun) = e)).

(*Why axiom*) Lemma find_find_val :
  (forall (co:list), (forall (e:element_t), (find__ co e (find_first co e)))).
intros l e; unfold find__; unfold is_empty_; unfold
position_; unfold length_; unfold find_first; unfold no_element;
unfold element_; rewrite <- inj_0.
destruct (Raw_List.find_has_element l e) as [Hf|Hf]; [right|left].
apply Raw_List.position_has_element in Hf;
split; [apply inj_gt; exact Hf|].
split; [apply (Raw_List.find_element l e Hf)|].
intros cun [Hs1 Hs2].
apply inj_gt_rev in Hs1; apply inj_gt_rev in Hs2.
apply (Raw_List.find_is_first_gen l e cun Hs1 Hs2).
symmetry in Hf; split.
symmetry; exact Hf.
intros cun H; apply inj_gt_rev in H.
apply (Raw_List.find_is_first_O l e cun).
rewrite <- Hf; apply Raw_List.position_no_element.
exact H.
Qed.

(*Why function*) Definition find_  (l:list) (e:element_t) (cu:cursor)
  := (find_first (right_ l cu) e).

(*Why predicate*) Definition equal_  (co1:list) (co2:list)
  := (forall (cu:cursor), (position_ co1 cu) = (position_ co2 cu) /\
      (((position_ co1 cu) > 0 -> (element_ co1 cu) = (element_ co2 cu)))).

(*Why predicate*) Definition replace_element_  (co1:list) (cu:cursor) (e:element_t) (co2:list)
  := (position_ co1 cu) > 0 /\ (length_ co1) = (length_ co2) /\
     (element_ co2 cu) = e /\
     (forall (cun:cursor), (position_ co2 cun) = (position_ co1 cun) /\
      ((~(cu = cun) /\ (position_ co1 cun) > 0 ->
        (element_ co2 cun) = (element_ co1 cun)))).

(*Why predicate*) Definition insert_pos  (co1:list) (i:Z) (co2:list)
  := (forall (cun:cursor),
      ((i > (position_ co1 cun) /\ (position_ co1 cun) > 0 ->
        (position_ co2 cun) = (position_ co1 cun))) /\
      ((i <= (position_ co1 cun) -> (position_ co2 cun) =
        ((position_ co1 cun) + 1))) /\
      (((position_ co1 cun) > 0 -> (element_ co1 cun) = (element_ co2 cun)))).

(*Why predicate*) Definition insert_inv  (co1:list) (i:Z) (e:element_t) (co2:list)
  := (forall (cun:cursor),
      (((position_ co2 cun) = i -> (position_ co1 cun) = 0 /\
        (element_ co2 cun) = e)) /\
      ((i > (position_ co2 cun) /\ (position_ co2 cun) > 0 ->
        (position_ co1 cun) = (position_ co2 cun) /\
        (element_ co1 cun) = (element_ co2 cun))) /\
      (((position_ co2 cun) > i -> (position_ co1 cun) =
        ((position_ co2 cun) - 1) /\ (element_ co1 cun) = (element_ co2 cun)))).

(*Why predicate*) Definition insert_  (co1:list) (cu:cursor) (e:element_t) (co2:list)
  := (cu = no_element \/ (position_ co1 cu) > 0) /\ (length_ co2) =
     ((length_ co1) + 1) /\ (cu = no_element /\
     (insert_pos co1 ((length_ co1) + 1) co2) /\
     (insert_inv co1 ((length_ co1) + 1) e co2) \/ (position_ co1 cu) > 0 /\
     (insert_pos co1 (position_ co1 cu) co2) /\
     (insert_inv co1 (position_ co1 cu) e co2)).

(*Why predicate*) Definition delete_pos  (co1:list) (i:Z) (co2:list)
  := (forall (cun:cursor),
      (((position_ co1 cun) = i -> (position_ co2 cun) = 0)) /\
      (((position_ co1 cun) > i -> (position_ co2 cun) =
        ((position_ co1 cun) - 1) /\ (element_ co2 cun) = (element_ co1 cun))) /\
      ((i > (position_ co1 cun) -> (position_ co2 cun) =
        (position_ co1 cun) /\ (element_ co2 cun) = (element_ co1 cun)))).

(*Why predicate*) Definition delete_inv  (co1:list) (i:Z) (co2:list)
  := (forall (cun:cursor),
      ((i <= (position_ co2 cun) -> (position_ co1 cun) =
        ((position_ co2 cun) + 1) /\ (element_ co1 cun) = (element_ co2 cun))) /\
      ((i > (position_ co2 cun) /\ (position_ co2 cun) > 0 ->
        (position_ co1 cun) = (position_ co2 cun) /\
        (element_ co2 cun) = (element_ co1 cun)))).

(*Why predicate*) Definition delete_  (co1:list) (cu:cursor) (co2:list)
  := (position_ co1 cu) > 0 /\ (length_ co2) = ((length_ co1) - 1) /\
     (delete_pos co1 (position_ co1 cu) co2) /\
     (delete_inv co1 (position_ co1 cu) co2).

(*Why predicate*) Definition has_element_  (co:list) (cu:cursor)
  := (position_ co cu) > 0.

(*Why predicate*) Definition contains_  (co:list) (e:element_t)
  := (position_ co (find_first co e)) > 0.


(*Why axiom*) Lemma contains_inserted :
  (forall (l1:list),
   (forall (l2:list),
    (forall (cu:cursor),
     (forall (e:element_t), ((insert_ l1 cu e l2) -> (contains_ l2 e)))))).
unfold insert_; unfold contains_.
assert (Z_of_nat (1) = 1). auto.
intros l1 l2 cu e;
case_eq(beq_nat (Raw_List.length l2) O).
intros Hko [_[Hlgth]]; apply beq_nat_true in Hko.
unfold length_ in Hlgth; rewrite <- H in Hlgth;
rewrite <- inj_plus in Hlgth; apply inj_eq_rev in Hlgth.
contradict Hlgth; rewrite Hko; rewrite <- plus_n_Sm;
rewrite <- plus_n_O; apply O_S.
intros Hl; apply beq_nat_false in Hl;
apply Raw_List.position_first_gen in Hl.
generalize (gt_Sn_O O); intro Hpfst; rewrite <- Hl in Hpfst.
intros [[Hno | Hp][Hlgth]].
rewrite Hno; intros [Hpos|Hko];
[|destruct Hko as [Hko _]; contradict Hko;
rewrite position_no_element; apply Zgt_irrefl].
destruct Hpos as [_ [Hpos Hinv]].
unfold insert_inv in Hinv.
generalize (Raw_List.position_last_gen l2).
unfold position_ in Hinv; unfold length_ in Hinv.
intros Hlst; apply inj_eq in Hlst;
destruct (Hinv (Raw_List.last l2)) as [Hinvl _]; clear Hinv.
unfold length_ in Hlgth; rewrite Hlgth in Hlst;
generalize (Hinvl Hlst); clear Hinvl; intros [_ He].
rewrite <- He; unfold position_; unfold find_first; unfold element_;
unfold element_ in He; rewrite <- inj_0; apply inj_gt.
apply (Raw_List.find_element_rev l2).
rewrite <- H in Hlgth; rewrite <- inj_plus in Hlgth;
apply inj_eq_rev in Hlgth;
rewrite (Raw_List.position_last_gen); rewrite Hlgth.
apply le_plus_r.
intros [[Hko _]|[_[Hpos Hinv]]].
contradict Hp; rewrite Hko; rewrite position_no_element;
apply Zgt_irrefl.
unfold insert_pos in Hpos.
destruct (Hpos cu) as [_[Hpcu _]];
generalize (Hpcu (Zle_refl (position_ l1 cu))); clear Hpcu;
intro Hpcu; generalize Hp; intro Hp2.
unfold position_ in Hp; rewrite <- inj_0 in Hp;
apply inj_gt_rev in Hp; unfold position_ in Hpcu;
rewrite <- H in Hpcu; rewrite <- inj_plus in Hpcu;
apply inj_eq_rev in Hpcu; apply gt_n_S in Hp.
rewrite <- plus_n_Sm in Hpcu; rewrite <- plus_n_O in Hpcu;
rewrite <- Hpcu in Hp.
generalize (reflexivity (pred(Raw_List.position l2 cu)));
intro Hprev; rewrite Hpcu in Hprev at 2; rewrite <- pred_Sn in Hprev.
rewrite pred_of_minus in Hprev.
rewrite <- (Raw_List.position_previous_gen _ _ Hp) in Hprev.
unfold insert_inv in Hinv.
destruct (Hinv (Raw_List.previous l2 cu)) as [Hint _].
unfold position_ in Hint; apply inj_eq in Hprev;
destruct (Hint Hprev) as [_ Hel]; clear Hint.
rewrite <- Hel; unfold position_; unfold find_first;
unfold element_; rewrite <- inj_0; apply inj_gt;
apply (Raw_List.find_element_rev l2).
unfold position_ in Hp2; rewrite <- inj_0 in Hp2;
apply inj_gt_rev in Hp2.
apply inj_eq_rev in Hprev;
rewrite Hprev; apply gt_le_S; apply Hp2.
Qed.

(*** TESTS ***)

Definition insert : list -> cursor -> element_t -> list.
exact Raw_List.insert.
Defined.

Lemma insert_insert :
forall (l : list), forall (cu : cursor),
forall (e : element_t),
cu = no_element \/ has_element_ l cu ->
insert_ l cu e (insert l cu e).
intros l cu e; unfold insert_; unfold has_element_;
unfold insert_pos; unfold insert_inv; unfold length_;
unfold position_; unfold no_element; unfold insert;
unfold element_.
assert (Z_of_nat (1) = 1). auto.
intro Hp; split; [exact Hp | split].
rewrite <- H; rewrite <- inj_plus; apply inj_eq.
apply Raw_List.insert_length.
destruct Hp as [Heq|Hpos];
[left; rewrite Heq|right]; split;
[reflexivity| |exact Hpos
|rewrite <- inj_0 in Hpos; apply inj_gt_rev in Hpos];
split; intro cun; split.
intros [H1 H2].
rewrite <- inj_0 in H2; apply inj_gt_rev in H2;
rewrite <- H in H1; rewrite <- inj_plus in H1; apply inj_gt_rev in H1;
apply inj_eq.
apply (Raw_List.insert_position_O l e cun H2).
split.
intro HH; rewrite <- H in HH; rewrite <- inj_plus in HH;
apply inj_le_rev in HH; contradict HH.
SearchAbout le.
apply gt_not_le; rewrite <- plus_n_Sm;
rewrite <- plus_n_O; apply le_S_gt; apply le_n_S.
apply (Raw_List.position_length l cun).
intro HH; rewrite <- inj_0 in HH; apply inj_gt_rev in HH.
apply (Raw_List.insert_element_old l O e cun HH).
intro HH; rewrite <- H in HH; rewrite <- inj_plus in HH;
apply inj_eq_rev in HH;
rewrite <- (Raw_List.insert_position_new_O l e) in HH; split.
rewrite <- inj_0; apply inj_eq.
apply (Raw_List.insert_position_rev_new l O e cun HH).
apply (Raw_List.insert_element_new l O e cun HH).
split.
intros [Hl Hpos]; rewrite <- inj_0 in Hpos;
apply inj_gt_rev in Hpos; rewrite <- H in Hl;
rewrite <- inj_plus in Hl; apply inj_gt_rev in Hl;
apply (Raw_List.insert_has_element) in Hpos;
destruct Hpos as [Hko|Hpos];
[rewrite Hko in Hl; rewrite (Raw_List.insert_position_new_O l e) in Hl;
contradict Hl; apply gt_irrefl|split].
apply inj_eq; symmetry.
apply (Raw_List.insert_position_O l e cun Hpos).
apply (Raw_List.insert_element_old l O e cun Hpos).
intro Hko; rewrite <- H in Hko; rewrite <- inj_plus in Hko;
apply inj_gt_rev in Hko; contradict Hko.
apply le_not_gt; rewrite <- (Raw_List.insert_length l O e).
apply Raw_List.position_length.
intros [Hinf Hp]; apply inj_eq; apply inj_gt_rev in Hinf;
rewrite <- inj_0 in Hp; apply inj_gt_rev in Hp.
apply (Raw_List.insert_position_inf l cu cun e Hpos Hp Hinf).
split.
intro Hsup; apply inj_le_rev in Hsup; rewrite <- H;
rewrite <- inj_plus; apply inj_eq.
apply (Raw_List.insert_position_sup l cu cun e Hpos Hsup).
intro Hp; rewrite <- inj_0 in Hp; apply inj_gt_rev in Hp.
apply (Raw_List.insert_element_old l cu e cun Hp).
intro HH; apply inj_eq_rev in HH;
rewrite <- (Raw_List.insert_position_new l cu e Hpos) in HH; split.
rewrite <- inj_0; apply inj_eq.
apply (Raw_List.insert_position_rev_new l cu e cun HH).
apply (Raw_List.insert_element_new l cu e cun HH).
split.
intros [H1 H2];
rewrite <- inj_0 in H2; apply inj_gt_rev in H2.
apply (Raw_List.insert_has_element) in H2.
destruct H2 as [Hko|Hp].
rewrite Hko in H1;
rewrite (Raw_List.insert_position_new _ _ _ Hpos) in H1.
apply inj_gt_rev in H1; contradict H1; apply gt_irrefl.
split.
case_eq (leb (Raw_List.position l cu) (Raw_List.position l cun));
intro Hq; [apply leb_complete in Hq|apply leb_complete_conv in Hq].
generalize Hq; intro Hko.
apply (Raw_List.insert_position_sup l cu cun e Hpos) in Hq.
rewrite Hq in H1.
apply inj_gt_rev in H1; rewrite <- plus_n_Sm in H1;
rewrite <- plus_n_O in H1.
elim (gt_irrefl _ (gt_le_trans _ _ _ H1
(le_trans _ _ _ Hko (le_n_Sn _)))).
symmetry; apply inj_eq;
apply (Raw_List.insert_position_inf l cu cun e Hpos Hp Hq).
apply (Raw_List.insert_element_old l cu e cun Hp).
intros H1; apply inj_gt_rev in H1;
case_eq (leb (Raw_List.position l cu) (Raw_List.position l cun));
intro Hq; [apply leb_complete in Hq|apply leb_complete_conv in Hq].
rewrite (Raw_List.insert_position_sup l cu cun e Hpos Hq).
split.
rewrite inj_plus; rewrite H;
rewrite Zplus_comm; symmetry;
apply Zminus_plus.
apply (Raw_List.insert_element_old l cu e cun
(le_gt_trans _ _ _ Hq Hpos)).
generalize Hq; intro H2;
destruct (Raw_List.insert_has_element l cu e cun
(gt_trans _ _ _ H1 Hpos)) as [Hko|Hp].
rewrite Hko in H1; rewrite (Raw_List.insert_position_new _ _ _ Hpos) in H1.
contradict H1; apply gt_irrefl.
apply lt_not_le in Hq; apply not_le in Hq.
apply (Raw_List.insert_position_inf l cu cun e Hpos Hp) in H2.
rewrite H2 in H1;
elim (gt_irrefl _ (gt_trans _ _ _ Hq H1)).
Qed.

Definition delete : list -> cursor -> list.
exact Raw_List.delete.
Defined.

Lemma delete_delete :
forall (l : list), forall (cu : cursor),
has_element_ l cu -> delete_ l cu (delete l cu).
intros l cu; unfold has_element_; unfold delete_;
unfold delete; unfold delete_pos; unfold delete_inv;
unfold position_; unfold element_; unfold length_.
intro Hpos; split; [exact Hpos|].
assert (Z_of_nat (1) = 1). auto.
rewrite <- inj_0 in Hpos; apply inj_gt_rev in Hpos;
split.
apply Zplus_minus_eq; rewrite <- H; rewrite <- inj_plus;
apply inj_eq.
apply (Raw_List.delete_length l cu Hpos).
split; intro cun; split.
intro HH; apply inj_eq_rev in HH;
rewrite <- inj_0; apply inj_eq.
symmetry in HH; apply (Raw_List.position_eq l cu cun Hpos) in HH.
rewrite <- HH; apply (Raw_List.delete_position_deleted l cu Hpos).
split; intro HH; apply inj_gt_rev in HH; split.
apply Zplus_minus_eq; rewrite <- H; rewrite <- inj_plus; apply inj_eq.
apply(Raw_List.delete_position_sup l cu cun Hpos HH).
case_eq (beq_nat cun cu); intro Hneq;
[apply beq_nat_true in Hneq; rewrite Hneq in HH; contradict HH;
apply gt_irrefl | apply beq_nat_false in Hneq].
apply (Raw_List.delete_element l cu cun Hpos Hneq).
apply inj_eq;
apply(Raw_List.delete_position_inf l cu cun Hpos HH).
case_eq (beq_nat cun cu); intro Hneq;
[apply beq_nat_true in Hneq; rewrite Hneq in HH; contradict HH;
apply gt_irrefl | apply beq_nat_false in Hneq].
apply (Raw_List.delete_element l cu cun Hpos Hneq).
intro HH; apply inj_le_rev in HH; split.
case_eq (leb (Raw_List.position l cun) (Raw_List.position l cu));
intro Hs; [apply leb_complete in Hs| apply leb_complete_conv in Hs].
destruct (le_lt_or_eq _ _ Hs) as [Ht|Ht].
apply lt_not_le in Ht; apply not_le in Ht.
rewrite (Raw_List.delete_position_inf _ _ _ Hpos Ht) in HH.
apply (le_antisym _ _ Hs) in HH; rewrite HH in Ht;
contradict Ht; apply gt_irrefl.
symmetry in Ht;
apply (Raw_List.position_eq l cu cun Hpos) in Ht;
rewrite <- Ht.
rewrite <- Ht in HH; rewrite (Raw_List.delete_position_deleted _ _ Hpos) in HH.
apply le_n_O_eq in HH; contradict Hpos; rewrite HH;
apply gt_irrefl.
apply lt_not_le in Hs; apply not_le in Hs.
rewrite <- H; rewrite <- inj_plus; rewrite plus_comm;
apply inj_eq;
apply (Raw_List.delete_position_sup _ _ _ Hpos Hs).
case_eq(beq_nat cun cu); intro Heq;
[apply beq_nat_true in Heq; rewrite Heq in HH;
rewrite (Raw_List.delete_position_deleted _ _ Hpos) in HH;
apply le_n_O_eq in HH; contradict Hpos; rewrite HH;
apply gt_irrefl|].
apply beq_nat_false in Heq; symmetry;
apply (Raw_List.delete_element l cu cun Hpos Heq).
intros [HH Hpcun]; rewrite <- inj_0 in Hpcun;
apply inj_gt_rev in Hpcun; apply inj_gt_rev in HH.
case_eq (leb (Raw_List.position l cu) (Raw_List.position l cun));
intro Hs; [apply leb_complete in Hs| apply leb_complete_conv in Hs].
destruct (le_lt_or_eq _ _ Hs) as [Ht|Ht].
apply lt_not_le in Ht; apply not_le in Ht.
generalize Ht; intro Htt;
apply (Raw_List.delete_position_sup _ _ _ Hpos) in Ht.
rewrite Ht in Htt.
apply gt_S_le in Htt.
contradict HH; apply le_not_gt; exact Htt.
apply (Raw_List.position_eq l cu cun Hpos) in Ht;
rewrite <- Ht in Hpcun.
contradict Hpcun;
rewrite (Raw_List.delete_position_deleted _ _ Hpos); apply gt_irrefl.
split.
apply inj_eq.
apply lt_not_le in Hs; apply not_le in Hs.
symmetry; apply (Raw_List.delete_position_inf _ _ _ Hpos Hs).
case_eq(beq_nat cun cu); intro Heq.
apply beq_nat_true in Heq; rewrite Heq in Hpcun;
rewrite (Raw_List.delete_position_deleted _ _ Hpos) in Hpcun;
apply le_n_O_eq in Hpcun; contradict Hpcun; apply O_S.
apply beq_nat_false in Heq;
apply (Raw_List.delete_element l cu cun Hpos Heq).
Qed.

Definition replace_element : list -> cursor -> element_t -> list.
exact Raw_List.replace.
Defined.

Lemma replace_element_replace_element :
forall (l : list), forall (cu : cursor), forall (e : element_t),
has_element_ l cu -> replace_element_ l cu e (replace_element l cu e).
intros l cu e; unfold has_element_; unfold replace_element_;
unfold replace_element; unfold position_; unfold length_;
unfold element_.
intro Hpos; split; [exact Hpos|].
rewrite <- inj_0 in Hpos; rewrite <- inj_0;
apply inj_gt_rev in Hpos; split.
apply inj_eq.
apply Raw_List.replace_length.
split.
apply(Raw_List.replace_element_replaced l cu e Hpos).
intro cun; split.
apply inj_eq.
apply Raw_List.replace_position.
intros [Hdiff Hpcun]; apply inj_gt_rev in Hpcun.
apply(Raw_List.replace_element l cu e cun Hdiff).
Qed.

(*** MAX ***)

Module Type CompareType.

Parameter Inline compare : element_t -> element_t -> Z.

Axiom compare_refl :
forall e : element_t, (compare e e = 0)%Z.

Axiom compare_asym :
forall e1 : element_t, forall e2 : element_t,
(0 <= compare e1 e2 <-> compare e2 e1 <= 0)%Z.

Axiom compare_trans :
forall e1 : element_t, forall e2 : element_t, forall e3 : element_t,
(compare e1 e2 <= 0)%Z -> (compare e2 e3 <= 0)%Z ->
(compare e1 e3 <= 0)%Z.

End CompareType.

Module Compare (Compare : CompareType).

Definition compare_ : element_t -> element_t -> Z.
exact Compare.compare.
Defined.

Module Max_List := Raw_List.Max (Compare).

Definition is_max  (v:list) (cu:cursor)
  := (has_element_ v cu) /\
     (forall (e:element_t),
      ((contains_ v e) -> (compare_ (element_ v cu) e) >= 0)).

Definition max_ : list -> cursor.
exact (Max_List.max).
Defined.

Lemma is_max_max :
  (forall (v:list), (~(is_empty_ v) -> (is_max v (max_ v)))).
intros l He; apply is_empty_length in He;
unfold is_max; unfold max_; unfold has_element_; unfold contains_;
unfold element_; unfold find_; unfold first_;
unfold position_.
split.
rewrite <- inj_0; apply inj_gt; apply Raw_List.position_has_element.
apply (Max_List.max_has_element l He).
intros e Hhfind;
rewrite <- inj_0 in Hhfind; apply inj_gt_rev in Hhfind.
rewrite <- (Raw_List.find_element l e Hhfind).
apply (Raw_List.has_element_position) in Hhfind.
destruct (Compare.compare_asym (Raw_List.element l (Max_List.max l))
(Raw_List.element l (Raw_List.find l e))) as [_ H];
apply Zle_ge; apply H; clear H.
apply (Max_List.max_element _ l Hhfind).
Qed.

End Compare.

(*** SUM_OF ***)

Module Type WeightType.

Parameter Inline weight : element_t -> nat.

End WeightType.

Module Weight (W : WeightType).

Definition weight_ : element_t -> Z.
exact (fun e => Z_of_nat (W.weight e)).
Defined.

Lemma positive_weight :
  (forall (e:element_t), (weight_ e) >= 0).
intro e; unfold weight_; apply Zle_ge; apply Zle_0_nat.
Qed.

Module Sum_List := Raw_List.Sum_Of(W).

Definition sum_of_weight : list -> Z.
exact (fun l => Z_of_nat (Sum_List.sum_of_weight l)).
Defined.

Lemma sum_of_weight_delete :
  (forall (v1:list),
   (forall (v2:list),
    (forall (cu:cursor),
     ((delete_ v1 cu v2) -> (sum_of_weight v2) =
      ((sum_of_weight v1) - (weight_ (element_ v1 cu))))))).
assert (Z_of_nat (1) = 1). auto.
intros l1 l2 cu; unfold delete_; unfold sum_of_weight;
unfold weight_; unfold delete_pos; unfold delete_inv;
unfold element_; unfold length_; unfold position_;
intros [Hposcu[Hlgth[Hdpos Hdinv]]]; apply Zplus_minus_eq.
rewrite <- inj_plus; apply inj_eq.
apply Sum_List.sum_of_delete.
apply Raw_List.has_element_position.
rewrite <- inj_0 in Hposcu; apply (inj_gt_rev _ _ Hposcu).
destruct (Hdpos cu) as [Hpcu _].
case_eq (Raw_List.has_element l2 cu); [|reflexivity].
intro Hhe; apply Raw_List.position_has_element in Hhe;
apply inj_gt in Hhe; contradict Hhe; 
rewrite (Hpcu (reflexivity (Z_of_nat (Raw_List.position l1 cu)))).
rewrite inj_0; apply Zgt_irrefl.
intros cun Hp; destruct (Hdpos cun) as [_ [Hpcui Hpcus]].
destruct (Z_dec (Z_of_nat (Raw_List.position l1 cun))
(Z_of_nat (Raw_List.position l1 cu))) as [[Hs|Hi]|Hko];
[intros _; apply Zlt_gt in Hs|intros _|intro Hdiff; contradict Hdiff;
apply (Raw_List.position_eq l1 _ _ Hp); apply inj_eq_rev; exact Hko].
destruct (Hpcus Hs) as [Heqpos He]; split;
[apply inj_eq_rev in Heqpos; rewrite Heqpos; exact Hp|exact He].
destruct (Hpcui Hi) as [Heqpos He];
apply inj_gt_rev in Hi; rewrite (S_pred _ _ Hi) in Heqpos;
rewrite (S_pred _ _ Hi) in Hi.
rewrite <- inj_0 in Hposcu; apply inj_gt_rev in Hposcu;
apply gt_S_le in Hi; apply (le_gt_trans _ _ _ Hi) in Hposcu.
rewrite (plus_n_O (pred (Raw_List.position l1 cun))) in Heqpos;
rewrite plus_n_Sm in Heqpos; rewrite inj_plus in Heqpos;
rewrite Zplus_comm in Heqpos; rewrite Zminus_plus in Heqpos.
split; [apply inj_eq_rev in Heqpos; rewrite Heqpos; exact Hposcu|exact He].
destruct (Zeq_plus_swap (Z_of_nat (Raw_List.length l2))
(Z_of_nat (Raw_List.length l1)) 1) as [_ Hint]; apply Hint in Hlgth.
rewrite <- H in Hlgth; rewrite <- inj_plus in Hlgth;
apply inj_eq_rev in Hlgth; rewrite <- Hlgth.
rewrite <- plus_n_Sm; rewrite <- plus_n_O; reflexivity.
Qed.

Lemma sum_of_weight_insert :
  (forall (v1:list),
   (forall (v2:list),
    (forall (cu:cursor),
     (forall (e:element_t),
      ((insert_ v1 cu e v2) -> (sum_of_weight v2) =
       ((sum_of_weight v1) + (weight_ e))))))).
assert (Z_of_nat (1) = 1). auto.
intros l1 l2 cu e; unfold insert_; unfold sum_of_weight;
unfold weight_; unfold insert_pos; unfold insert_inv;
unfold element_; unfold length_; unfold position_.
intros [[Hnel | Hposcu]];
[rewrite Hnel; rewrite (Raw_List.position_no_element);
intros [Hlgth [[_ [Hpos Hinv]] | [Hko _]]];
[| contradict Hko; rewrite inj_0; apply Zgt_irrefl]|
intros [Hlgth [[Hko _] | [_ [Hpos Hinv]]]];
[contradict Hposcu; rewrite Hko; rewrite (Raw_List.position_no_element);
 rewrite inj_0; apply Zgt_irrefl|]].
destruct (Hinv (Raw_List.last l2)) as [HH _].
rewrite <- Raw_List.position_last_gen in Hlgth.
destruct (HH Hlgth) as [Hposlast Hellast]; clear HH.
rewrite <- inj_plus;
rewrite (Sum_List.sum_of_insert l1 l2 (S(Raw_List.length l1))
(Raw_List.last l2) e ).
rewrite plus_comm; reflexivity.
apply (Raw_List.has_element_position).
rewrite <- H in Hlgth; rewrite <- inj_plus in Hlgth;
rewrite <- plus_n_Sm in Hlgth; rewrite <- plus_n_O in Hlgth;
apply inj_eq_rev in Hlgth.
rewrite Hlgth; apply gt_Sn_O.
case_eq(Raw_List.has_element l1 (Raw_List.last l2));
[intro Hko|reflexivity].
apply Raw_List.position_has_element in Hko.
rewrite <- inj_0 in Hposlast; apply inj_eq_rev in Hposlast;
contradict Hko; rewrite Hposlast; apply gt_irrefl.
exact Hellast.
rewrite (plus_n_O (Raw_List.length l1));
rewrite plus_n_Sm; intros cun Hppos.
apply inj_le in Hppos; rewrite inj_plus in Hppos; rewrite H in Hppos.
destruct(Hpos cun) as [_ [Hposi Heli]];
generalize (Hposi Hppos); clear Hposi; intro Hp.
rewrite <- H in Hppos; rewrite <- inj_plus in Hppos;
apply inj_le_rev in Hppos; rewrite <- plus_n_Sm in Hppos;
rewrite <- plus_n_O in Hppos.
rewrite <- H in Hp; rewrite <- inj_plus in Hp;
apply inj_eq_rev in Hp; rewrite <- plus_n_Sm in Hp;
rewrite <- plus_n_O in Hp.
split; [exact Hp | symmetry; apply Heli].
rewrite <- inj_0; apply inj_gt;
apply (le_gt_trans _ _ _ Hppos (gt_Sn_O _)).
rewrite (plus_n_O (Raw_List.length l1));
rewrite plus_n_Sm; intros cun Hhe Hppos.
apply inj_gt in Hppos; rewrite inj_plus in Hppos; rewrite H in Hppos.
destruct(Hpos cun) as [Hposi [_ Heli]];
assert (Z_of_nat (Raw_List.length l1) + 1 > 
Z_of_nat (Raw_List.position l1 cun) /\
Z_of_nat (Raw_List.position l1 cun) > 0);
[split;[exact Hppos|]|].
rewrite <- inj_0; apply inj_gt;
apply (Raw_List.position_has_element _ _ Hhe).
generalize (Hposi H0); clear Hposi; intro Hp.
apply inj_eq_rev in Hp.
split; [symmetry; exact Hp | symmetry; apply Heli].
destruct H0 as [_ HH]; exact HH.
rewrite <- H in Hlgth; rewrite <- inj_plus in Hlgth;
rewrite <- plus_n_Sm in Hlgth; rewrite <- plus_n_O in Hlgth;
apply inj_eq_rev in Hlgth; rewrite <- Raw_List.position_last_gen;
exact Hlgth.
destruct (Hpos cu) as [_ [Hppos _]];
generalize (Hppos (Zle_refl _)); clear Hppos; intro Hp.
rewrite <- H in Hp; rewrite <- inj_plus in Hp;
apply inj_eq_rev in Hp; rewrite <- plus_n_Sm in Hp;
rewrite <- plus_n_O in Hp.
rewrite <- inj_0 in Hposcu; apply inj_gt_rev in Hposcu.
generalize Hposcu; intro Hposscu;
apply gt_n_S in Hposscu; rewrite <- Hp in Hposscu;
generalize (Raw_List.position_previous_gen l2 cu Hposscu);
rewrite Hp; rewrite <- pred_of_minus;
rewrite <- pred_Sn; intro Hpos_prev.
destruct (Hinv (Raw_List.previous l2 cu)) as [Hint _];
destruct (Hint (inj_eq _ _ Hpos_prev)) as [Hpprevl1 Hel]; clear Hint.
rewrite <- inj_plus;
rewrite (Sum_List.sum_of_insert l1 l2 (Raw_List.position l1 cu)
(Raw_List.previous l2 cu) e ).
rewrite plus_comm; reflexivity.
apply (Raw_List.has_element_position).
rewrite Hpos_prev; exact Hposcu.
case_eq(Raw_List.has_element l1 (Raw_List.previous l2 cu));
[intro Hko|reflexivity].
apply Raw_List.position_has_element in Hko.
rewrite <- inj_0 in Hpprevl1; apply inj_eq_rev in Hpprevl1;
contradict Hko; rewrite Hpprevl1; apply gt_irrefl.
exact Hel.
intros cun Hppos; apply inj_le in Hppos.
destruct(Hpos cun) as [_ [Hposi Heli]];
generalize (Hposi Hppos); clear Hposi; intro Hpcun.
rewrite <- H in Hpcun; rewrite <- inj_plus in Hpcun;
apply inj_eq_rev in Hpcun; rewrite <- plus_n_Sm in Hpcun;
rewrite <- plus_n_O in Hpcun.
split; [exact Hpcun | symmetry; apply Heli].
apply inj_le_rev in Hppos;rewrite <- inj_0; apply inj_gt;
apply (le_gt_trans _ _ _ Hppos Hposcu).
intros cun Hhe Hppos; apply inj_gt in Hppos.
destruct(Hpos cun) as [Hposi [_ Heli]];
assert (Z_of_nat (Raw_List.position l1 cu) > 
Z_of_nat (Raw_List.position l1 cun) /\
Z_of_nat (Raw_List.position l1 cun) > 0);
[split;[exact Hppos|]|].
rewrite <- inj_0; apply inj_gt;
apply (Raw_List.position_has_element _ _ Hhe).
generalize (Hposi H0); clear Hposi; intro Hpcun.
apply inj_eq_rev in Hpcun.
split; [symmetry; exact Hpcun | symmetry; apply Heli].
destruct H0 as [_ HH]; exact HH.
rewrite <- H in Hlgth; rewrite <- inj_plus in Hlgth;
rewrite <- plus_n_Sm in Hlgth; rewrite <- plus_n_O in Hlgth;
apply inj_eq_rev in Hlgth; exact Hlgth.
Qed.

Lemma sum_of_weight_replace_element :
  (forall (v1:list),
   (forall (v2:list),
    (forall (cu:cursor),
     (forall (e:element_t),
      ((replace_element_ v1 cu e v2) -> (sum_of_weight v2) =
       ((sum_of_weight v1) + (weight_ e) - (weight_ (element_ v1 cu)))))))).
assert (Z_of_nat (1) = 1). auto.
intros l1 l2 cu e; unfold replace_element_; unfold sum_of_weight;
unfold weight_; unfold element_; unfold length_; unfold position_.
intros [Hposcu[Hlgth [Hel Hpos]]].
apply Zplus_minus_eq; repeat(rewrite <- inj_plus); apply inj_eq.
apply inj_eq_rev in Hlgth; rewrite <- inj_0 in Hposcu;
apply inj_gt_rev in Hposcu; rewrite <- inj_0 in Hpos;
rewrite (Sum_List.sum_of_replace l1 l2 cu e).
rewrite plus_comm; reflexivity.
apply (Raw_List.has_element_position _ _ Hposcu).
exact Hel.
intros cun Hposl1; destruct (Hpos cun) as [Hposeq Heleq].
apply inj_eq_rev in Hposeq; rewrite Hposeq.
split; [exact Hposl1|intro Hdiff; apply Heleq].
split; [exact Hdiff|apply inj_gt; exact Hposl1].
symmetry; exact Hlgth.
Qed.

Lemma sum_of_weight_null :
  (forall (v:list), ((is_empty_ v) -> (sum_of_weight v) = 0)).
unfold is_empty_; unfold sum_of_weight; unfold length_.
intros l [_ Hl].
rewrite <- inj_0; rewrite <- inj_0 in Hl; apply inj_eq;
apply inj_eq_rev in Hl; apply (Sum_List.sum_of_nil l Hl).
Qed.

Lemma sum_of_weight_equal :
  (forall (v1:list),
   (forall (v2:list),
    ((equal_ v1 v2) -> (sum_of_weight v1) = (sum_of_weight v2)))).
unfold equal_; unfold sum_of_weight; unfold position_;
unfold element_; intros l1 l2 Heq.
apply inj_eq;
apply (Sum_List.sum_of_equal l1 l2).
intros cu; destruct (Heq cu) as [Hp He];
split; [apply inj_eq_rev in Hp; exact Hp|intro Hpl1].
apply He; rewrite <- inj_0; apply inj_gt;
exact Hpl1.
Qed.

Lemma sum_of_weight_left :
  (forall (v:list),
   (forall (cu:cursor),
    ((has_element_ v cu) -> (sum_of_weight (left_ v (next_ v cu))) =
     ((sum_of_weight (left_ v cu)) + (weight_ (element_ v cu)))))).
unfold left_; unfold next_; unfold weight_; unfold has_element_;
unfold position_; unfold sum_of_weight; intros l cu Hpos.
rewrite <- inj_plus; apply inj_eq; apply Sum_List.sum_of_left.
apply (Raw_List.has_element_position); apply inj_gt_rev;
rewrite inj_0; exact Hpos.
Qed.

Lemma sum_of_weight_right :
  (forall (v:list),
   (forall (cu:cursor),
    ((has_element_ v cu) -> (sum_of_weight (right_ v (next_ v cu))) =
     ((sum_of_weight (right_ v cu)) - (weight_ (element_ v cu)))))).
unfold right_; unfold next_; unfold weight_; unfold has_element_;
unfold position_; unfold sum_of_weight; intros l cu Hpos.
apply Zplus_minus_eq; symmetry.
rewrite <- inj_plus; apply inj_eq; apply Sum_List.sum_of_right.
apply (Raw_List.has_element_position); apply inj_gt_rev;
rewrite inj_0; exact Hpos.
Qed.

End Weight.

End List.


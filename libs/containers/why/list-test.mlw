module Main

  use import int.Int
  use import module ref.Ref
  use import module list.Main


(*** REDONDANT AXIOMS (for Alt-Ergo) *)


lemma left_length :
      forall s:list, cu:cursor, e:element_t [length_ (left_ s (next_ s cu))].
      	     has_element_ s cu ->
	     (length_ (left_ s cu)) + 1 = length_ (left_ s (next_ s cu))

lemma right_equal :
     forall s:list. forall cu:cursor. forall s2:list [equal_ (right_ s (next_ s cu)) (right_ s2 (next_ s cu))].
     	  has_element_ s cu -> equal_ (right_ s cu) (right_ s2 cu) ->
	  equal_ (right_ s (next_ s cu)) (right_ s2 (next_ s cu))

lemma right_equal_next :
     forall s:list. forall cu:cursor. forall s2:list [equal_ (right_ s cu) (right_ s2 cu), next_ s cu].
     	  has_element_ s cu -> equal_ (right_ s cu) (right_ s2 cu) ->
	  next_ s cu = next_ s2 cu

lemma right_insert :
     forall l1:list. forall l2:list. forall cu1:cursor.
     forall e:element_t [insert_ l1 cu1 e l2, equal_ (right_ l1 cu1) (right_ l2 cu1)].
     	    insert_ l1 cu1 e l2 -> equal_ (right_ l1 cu1) (right_ l2 cu1)

lemma next_insert :
     forall l1:list. forall l2:list. forall cu1:cursor.
     forall e:element_t [insert_ l1 cu1 e l2, next_ l2 cu1].
      	    has_element_ l1 cu1 ->
     	    insert_ l1 cu1 e l2 -> next_ l1 cu1 = next_ l2 cu1

lemma insert_has_element :
     forall l1:list, l2:list, cu1:cursor, cu2:cursor,
     e:element_t [insert_ l1 cu1 e l2, has_element_ l2 cu2].
     	    insert_ l1 cu1 e l2 -> has_element_ l1 cu2 -> has_element_ l2 cu2

lemma right_delete :
     forall l1:list, l2:list, cu1:cursor
     [delete_ l1 cu1 l2, equal_ (right_ l1 (next_ l1 cu1)) (right_ l2 (next_ l1 cu1))].
      	    has_element_ l1 cu1 ->
     	    delete_ l1 cu1 l2 -> equal_ (right_ l1 (next_ l1 cu1)) (right_ l2 (next_ l1 cu1))

lemma left_contains :
      forall s:list, cu:cursor, e:element_t [contains_ (left_ s (next_ s cu)) e].
      	     has_element_ s cu ->
	     contains_ (left_ s (next_ s cu)) e -> contains_ (left_ s cu) e \/ e = element_ s cu

lemma contains_insert :
     forall l1:list, l2:list, cu:cursor. forall e:element_t.
     forall el:element_t [insert_ l1 cu e l2, contains_ l1 el].
     	    insert_ l1 cu e l2 -> contains_ l2 el -> e = el \/ contains_ l1 el

goal interm1 :
     forall l1:list, l2:list, cu:cursor. forall e:element_t.
	insert_ l1 cu e l2 -> position_ l1 cu > 0 ->
	position_ l2 (previous_ l2 cu) = position_ l1 cu

goal interm2 :
     forall l1:list, l2:list, cu:cursor. forall e:element_t.
	insert_ l1 cu e l2 -> position_ l2 (last_ l2) = length_ l2

goal interm3 :
     forall l1:list, l2:list, cu:cursor. forall e:element_t.
	insert_ l1 cu e l2 -> (position_ l1 cu > 0 ->
	position_ l2 (previous_ l2 cu) = position_ l1 cu) ->
        (position_ l2 (last_ l2) = length_ l2) -> contains_ l2 e

axiom contains_insert_inv :
     forall l1:list, l2:list, cu:cursor. forall e:element_t [insert_ l1 cu e l2, contains_ l2 e].
	insert_ l1 cu e l2 -> contains_ l2 e

lemma contains_delete :
     forall l1:list, l2:list, cu:cursor.
     forall el:element_t [delete_ l1 cu l2, contains_ l1 el].
     	    delete_ l1 cu l2 -> contains_ l2 el -> contains_ l1 el

lemma equal_refl :
      forall l1:list. forall l2:list [equal_ l1 l2 | equal_ l2 l1].
      	     equal_ l1 l2 -> equal_ l2 l1

lemma equal_trans :
      forall l1:list. forall l2:list. forall l3:list [equal_ l2 l3, equal_ l1 l3 | equal_ l1 l2, equal_ l1 l3].
      	     equal_ l1 l2 -> equal_ l2 l3 -> equal_ l1 l3

goal interm4 :
     forall l1:list. forall l2:list. forall cu1:cursor.
     forall e:element_t.
     	    replace_element_ l1 cu1 e l2 -> position_ l1 (next_ l1 cu1) = position_ l1 (next_ l2 cu1)

goal interm5 :
     forall l1:list. forall l2:list. forall cu1:cursor.
     forall e:element_t.
	replace_element_ l1 cu1 e l2 -> position_ l1 (next_ l1 cu1) = position_ l1 (next_ l2 cu1) ->
	 next_ l1 cu1 = next_ l2 cu1

axiom next_replace :
     forall l1:list. forall l2:list. forall cu1:cursor.
     forall e:element_t [replace_element_ l1 cu1 e l2, next_ l2 cu1].
     	    replace_element_ l1 cu1 e l2 -> next_ l1 cu1 = next_ l2 cu1

lemma right_replace :
     forall l1:list. forall l2:list. forall cu1:cursor. forall e : element_t
     [replace_element_ l1 cu1 e l2, right_ l2 (next_ l2 cu1)].
     	    replace_element_ l1 cu1 e l2 -> equal_ (right_ l2 (next_ l2 cu1)) (right_ l1 (next_ l2 cu1))

lemma has_element_left :
     forall l:list. forall cu:cursor. forall cun:cursor
     [has_element_ (left_ l (next_ l cu)) cun].
      	    has_element_ l cu -> has_element_ (left_ l (next_ l cu)) cun -> has_element_ (left_ l cu) cun \/ cu = cun

(*** UNIT-TESTS ***)

predicate p element_t

predicate p_forall_cont (co:list) =
	  forall cu:cursor.
	  	 has_element_ co cu -> p (element_ co cu)

let test_replace_element1 (co:ref list) (cu:cursor) (cun:cursor) (e:element_t) =
    { has_element_ !co cu /\ has_element_ !co cun /\ not cu = cun }
    replace_element co cu e
    { element_ !co cu = e /\ element_ !co cun = element_ (old !co) cun /\ has_element_ !co cun
    /\ position_ !co cun = position_ (old !co) cun }

let test_replace_element2 (co:ref list) (cu:cursor) (e:element_t) =
    { has_element_ !co cu /\ p e /\ p_forall_cont !co }
    replace_element co cu e
    { p_forall_cont !co /\ element_ !co cu = e /\ has_element_ !co cu }

let test_insert1 (co:ref list) (cu:cursor) (e:element_t) (cu2:cursor) =
    { has_element_ !co cu /\ p e /\ p_forall_cont !co /\ has_element_ !co cu2 }
    insert co cu e
    { p_forall_cont !co /\ position_ !co cu = 1 + (position_ (old !co) cu) /\ 
    element_ !co (previous_ !co cu) = e /\ 
    element_ !co cu2 = element_ (old !co) cu2 /\ has_element_ !co cu2
    /\ length_ !co = (length_ (old !co)) + 1 }

let test_insert2 (co:ref list) (e:element_t) (cu2:cursor) =
    { p e /\ p_forall_cont !co /\ has_element_ !co cu2 }
    insert co no_element e
    { p_forall_cont !co  /\ contains_ !co e /\ element_ !co (last_ !co) = e /\
    element_ !co cu2 = element_ (old !co) cu2 /\
    p (element_ (old !co) cu2) /\
    p (element_ !co cu2) /\ length_ !co = (length_ (old !co)) + 1 /\ has_element_ !co cu2 }

let test_delete (co:ref list) (cu:cursor) (cun:cursor) =
    { has_element_ !co cu /\ p_forall_cont !co /\ has_element_ !co (next_ !co cu) /\ 
    has_element_ !co (previous_ !co cu) /\ has_element_ !co cun /\ not cun = cu }
    delete co cu
    { p_forall_cont !co /\ not (has_element_ !co cu) /\ 
     position_ !co (next_ (old !co) cu) = (position_ (old !co) (next_ (old !co) cu)) - 1 /\
     position_ !co (previous_ (old !co) cu) = position_ (old !co) (previous_ (old !co) cu) /\
     has_element_ !co cun /\ element_ !co cun = element_ (old !co) cun
     /\ length_ !co = (length_ (old !co)) - 1 }

let test_insert_delete1 (co:ref list) (cu:cursor) (cun:cursor) (e:element_t) =
    { has_element_ !co cu /\ p_forall_cont !co /\ has_element_ !co cun }
    insert co cu e;
    delete co (previous !co cu)
    { p_forall_cont !co /\ element_ !co cun = element_ (old !co) cun }

let test_insert_delete2 (co:ref list) (cun:cursor) (e:element_t) =
    {p_forall_cont !co /\ has_element_ !co cun }
    insert co no_element e;
    delete co (last !co)
    { p_forall_cont !co /\ element_ !co cun = element_ (old !co) cun }

let test_left1 (co:list) (cu:cursor) =
    { position_ co cu > 1 }
    ()
    { is_empty_ (left_ co (first_ co)) /\
      co = left_ co no_element /\
      previous_ co cu = last_ (left_ co cu) }

let test_left2 (co1:list) (co2:list) (cu:cursor) =
    { has_element_ co1 cu /\ has_element_ co2 cu /\ length_ (left_ co1 cu) = length_ (left_ co2 cu) }
    ()
    { position_ co1 cu = position_ co2 cu }

let test_left3 (co1:list) (co2:list) (cu:cursor) =
    { has_element_ co1 cu /\ has_element_ co2 cu /\ position_ co1 cu = position_ co2 cu }
    ()
    { length_ (left_ co1 cu) = length_ (left_ co2 cu) }

let test_right1 (co:list) (cu:cursor) (l:list) =
    { has_element_ co cu /\ right_ co cu = l }
    ()
    { is_empty_ (right_ co no_element) /\
      first_ (right_ co cu) = cu /\
      equal_ co (right_ co (first_ co)) /\
      next_ co cu = next_ l cu }

let test_right2 (co1:list) (co2:list) (cu:cursor) =
    { has_element_ co2 cu /\ right_ co1 cu = right_ co2 cu }
    ()
    { has_element_ co1 cu }

let test_find (co:list) (cu:cursor) (e:element_t) =
    { has_element_ co cu /\ element_ co cu = e }
    ()
    { contains_ co e }

let test_false (co:ref list) (cu:cursor) =
    { not (is_empty_ !co) }
    ()
    { false }

(*** TESTS ***) 

(* inserting an element only if it is not there yet garantees the presence of the element *)
let conditional_insert (l : ref list) (e : element_t) =
        { }
	if not (contains !l e) then
		append l e
	{ contains_ !l e }

(* removing an element from a list decreases its length by one *)
let test1 (li : ref list) (c : cursor) =
  { has_element_ !li c }
  let n = next !li c in
  if has_element !li n then
    delete li n
  else
    delete li c
  { length_ !li = (length_ (old !li)) - 1}

(* take a list of 4 elements, prepend element e, remove all initial 4 elements
   /\ take the last element of the list, it is e *)
let test2 (li : ref list) (e : element_t) =
  { length_ !li = 4 }
  prepend li e;
  let c = ref (last !li) in
  delete li !c;
  c := first !li;
  c := next !li (first !li);
  delete li !c;
  c := last !li;
  delete li !c;
  c := last !li;
  delete li !c;
  element !li (last !li)
  { result = e }

(* adding elements to a list does not invalidate an existing cursor *)
let test3 (li : ref list) (c d f g h : cursor) (e : element_t) =
  { position_ !li c = 4 /\ has_element_ !li f /\ position_ !li h <> 0 }
  insert li c e;
  append li e;
  if has_element !li d then
    insert li d e;
  insert li f e;
  if length !li > 5 then
    if g = (next !li c) then
      insert li g e
    else
      insert li h e
  { has_element_ !li c }

(* iterate through the list /\ increment a counter, which should equal 
   the length of the list on exit *)
let test4 (li : list) =
  { }
  let n = ref 0 in
  let c = ref (first li) in
  while has_element li !c do
    invariant {
	(has_element_ li !c \/ !c = no_element) /\ 
      	!n = length_ (left_ li !c)
    }
    n := !n + 1;
    c := next li !c
  done;
  !n
  { result = length_ li }

(* iterate through the list by adding element e at every position. This doubles
   the size of the list *)
let test5 (li : ref list) (e : element_t) =
  { not (is_empty_ !li) }
  let c = ref (first !li) in
  'Init:
  while has_element !li !c do
    invariant {
	(((has_element_ (at !li 'Init) !c /\ has_element_ !li !c) \/ !c = no_element) /\
	length_ (left_ !li !c) = 2 * (length_ (left_ (at !li 'Init) !c)) /\
      	equal_ (right_ !li !c) (right_ (at !li 'Init) !c))
    }
    insert li !c e;
    c := next !li !c
  done
  { length_ !li = 2 * (length_ (old !li)) }

(* Removes some elements from li /\ stores them in removed *)
function fun_test element_t : bool

let interm6 (li:ref list) (removed:ref list) (c:ref cursor) =
    { has_element_ !li !c }
    let c_int = next !li !c in
    append removed (element !li !c);
    delete li !c;
    c := c_int
    { ((has_element_ (old !li) !c /\ has_element_ !li !c) \/ !c = no_element) /\
	(length_ (left_ !li !c)) + (length_ !removed) = 
		(length_ (left_ (old !li) !c)) + (length_ (old !removed)) /\
      	equal_ (right_ !li !c) (right_ (old !li) !c) /\ !c = next_ (old !li) (old !c) }

let test6 (li:ref list) (removed:ref list) =
  { not (is_empty_ !li) /\ is_empty_ !removed }
  let c = ref (first !li) in
  'Init:
  while has_element !li !c do
    invariant {
	(((has_element_ (at !li 'Init) !c /\ has_element_ !li !c) \/ !c = no_element) /\
	(length_ (left_ !li !c)) + (length_ !removed) = length_ (left_ (at !li 'Init) !c) /\
      	equal_ (right_ !li !c) (right_ (at !li 'Init) !c))
    }
    if fun_test(element !li !c) then
    interm6 li removed c
  done
   { (length_ !li) + (length_ !removed) = length_ (old !li) }

exception Return

(* the usual implementation of contains indeed computes the awaited result *)
let my_contain (s:list) (e:element_t) =
    { }
    let c = ref (first s) in
    let res = ref False in
    try
      while has_element s !c do
    	  invariant {
	    ((has_element_ s !c \/ !c = no_element) /\
	    (not contains_ (left_ s !c) e)) }
	    if e = element s !c then
	       raise Return
	    else c:=next s !c
      done
    with Return -> res := True end;
    ! res
    { result = True <-> contains_ s e }

(* the usual implementation of find indeed computes the awaited result *)
let my_find (s : list) (e : element_t) (f : cursor) =
  { has_element_ s f }
  let c = ref f in
  try
    while has_element s !c do
      invariant {
        (has_element_ (right_ s f) !c \/ !c = no_element) /\
        find_ (left_ (right_ s  f) !c) e f = no_element
      }
      if e = element s !c then
        raise Return
      else c := next s !c
    done
  with Return -> () end;
  !c
  { result = find_ s e f }

function f element_t : element_t

(* after map l s, every element in s has been transformed through f *)
let map_f (s : ref list) =
  { }
  'Init :
  let c = ref (first !s) in
  while !c <> no_element do
    invariant {
     (has_element_ !s !c /\ has_element_ (at !s 'Init) !c \/ !c = no_element) /\
     (forall cu : cursor. has_element_ (left_ !s !c) cu ->
                                       element_ !s cu = f (element_ (at !s 'Init) cu)) /\
     equal_ (right_ (at !s 'Init) !c) (right_ !s !c)
    }
    replace_element s !c (f(element !s !c));
    c := next !s !c   
  done
  { forall cu : cursor. has_element_ !s cu -> element_ !s cu = f (element_ (old !s) cu) }

(*** MAX TESTS ***)

function compare_ element_t element_t : int

predicate is_max (v:list) (cu:cursor) =
	  has_element_ v cu /\
	  (forall e:element_t.
		 contains_ v e -> compare_ (element_ v cu) e >= 0)

function max_ list : cursor

axiom is_max_max :
      forall v:list.
      	     (not (is_empty_ v) -> is_max v (max_ v))

val max :
	  v:list ->
	  { not (is_empty_ v) }
	  cursor
	  { result = max_ v }


(* Heap : all the elements of result are bigger than those still in v_min *)
let test_max (v_min:ref list) (n:int) =
    { length_ !v_min >= n }
    'Init:
    let i = ref 1 in
    let v_max = ref empty_ in
    if !i <= n then
    while !i <= n do
    	  invariant {
	    (length_ !v_min = (length_ (at !v_min 'Init)) - !i + 1 /\
	    forall cu1:cursor. forall cu2:cursor. has_element_ !v_max cu1 ->
	    has_element_ !v_min cu2 ->
	    compare_ (element_ !v_max cu1) (element_ !v_min cu2) >= 0)}
    	  append v_max (element !v_min (max !v_min));
	  delete v_min (max !v_min);
	  i := !i+1
    done;
    !v_max
    { forall cu1:cursor. forall cu2:cursor. has_element_ result cu1 ->
	    has_element_ !v_min cu2 ->
	    compare_ (element_ result cu1) (element_ !v_min cu2) >= 0}

(* More user friendly version *)
let test_max2 (v_min:ref list) (n:int) =
    { length_ !v_min >= n }
    'Init:
    let i = ref 1 in
    let v_max = ref empty_ in
    if !i <= n then
    while !i <= n do
    	  invariant {
	    (length_ !v_min = (length_ (at !v_min 'Init)) - !i + 1 /\
	    forall e1:element_t. forall e2:element_t. contains_ !v_max e1 ->
	    contains_ !v_min e2 -> compare_ e1 e2 >= 0)}
    	  append v_max (element !v_min (max !v_min));
	  delete v_min (max !v_min);
	  i := !i+1
    done;
    !v_max
    { forall e1:element_t. forall e2:element_t. contains_ result e1 ->
	    contains_ !v_min e2 ->
	    compare_ e1 e2 >= 0}

(*** SUM_OF TESTS ***)

function weight_ element_t : int
predicate checkk_ element_t

val weight :
	  e:element_t ->
	  {}
	  int
	  {result  =weight_ e}

axiom positive_weight :
      forall e:element_t.
      	     weight_ e >= 0

val checkk :
	  e:element_t ->
	  {}
	  bool
	  {result = True <-> checkk_ e}

(* Sum_of_weight /\ some axioms *)
function sum_of_weight list : int

axiom sum_of_weight_delete :
      forall v1:list. forall v2:list. forall cu:cursor [sum_of_weight v2, delete_ v1 cu v2].
      	     delete_ v1 cu v2 -> sum_of_weight v2 = (sum_of_weight v1) - (weight_ (element_ v1 cu))

axiom sum_of_weight_insert :
      forall v1:list. forall v2:list. forall cu:cursor. forall e:element_t[sum_of_weight v2, insert_ v1 cu e v2].
      	     insert_ v1 cu e v2 -> sum_of_weight v2 = (sum_of_weight v1) + (weight_ e)

axiom sum_of_weight_null :
      forall v:list[sum_of_weight v].
      	     is_empty_ v -> sum_of_weight v = 0

axiom sum_of_weight_equal :
      forall v1:list. forall v2:list[sum_of_weight v1].
      	     equal_ v1 v2 -> sum_of_weight v1 = sum_of_weight v2

axiom sum_of_weight_left :
      forall v:list. forall cu:cursor[sum_of_weight (left_ v (next_ v cu))].
      	     has_element_ v cu ->
	     sum_of_weight (left_ v (next_ v cu)) = 
		(sum_of_weight (left_ v cu)) + (weight_ (element_ v cu))

(* deletes some elements from v /\ then inserts an equivalent element *)
let test_sum_of (v:ref list) (w:ref int) (e:element_t) =
    { }
    'Init:
    w := 0;
    let c = ref (first !v) in
    while has_element !v !c do
    	  invariant {
	    sum_of_weight !v = (sum_of_weight (at !v 'Init)) - !w
    	  }
    	  if (checkk (element !v !c)) then
	     (w := !w + (weight(element !v !c));
	     delete v !c)
	  else c := next !v !c
    done;
    assert { weight_ e = !w };(* IMPOSSIBLE TO PROVE *)
    append v e
    { sum_of_weight !v = sum_of_weight (old !v) }

(* deletes elements from v until their total weight exceeds wmin *)
let test_sum_of2 (v:ref list) (w:ref int) (wmin : int) =
    { wmin <= sum_of_weight !v }
    'Init:
    w:=0;
    if !w < wmin then
    while !w < wmin do
    	  invariant {
	    sum_of_weight !v = (sum_of_weight (at !v 'Init)) - !w
    	  }
    	 w := !w + (weight (element !v (first !v)));
	 delete v (first !v)
    done
    { sum_of_weight !v = sum_of_weight (old !v) - !w /\ !w >= wmin }

(* computes sum_of_weight(v) *)
let test_sum_of3 (v:list) =
    { }
    let w = ref 0 in
    let c = ref (first v) in
    if has_element v !c then
    while has_element v !c do
    	  invariant {
	    !w = sum_of_weight (left_ v !c) /\
	    (has_element_ v !c \/ !c = no_element)
    	  }
    	 w := !w + (weight (element v !c));
	 c := next v !c
    done;
    !w
    { sum_of_weight v = result }

end

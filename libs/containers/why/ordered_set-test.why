include "ordered_set.why"

(* Everything works with alt-ergo (-redondance or not it depends) in 60s,
   except:
	- two goals, right_equal_next and insert_has_element, which take less than 20min
   	- one VC of test_new_position which takes less than 90s (no option) *)

(*** GOALS ***)

goal contains_insert :
     forall l1:set. forall l2:set. forall e:element_t.
     forall i:real [insert_(l1,e,l2),contains_(l1,i)|insert_(l1,e,l2),contains_(l2,i)].
     	    insert_(l1,e,l2) -> contains_(l2,i) -> i=witness(e) or contains_(l1,i)

goal contains_delete :
     forall l1:set. forall l2:set. forall cu:cursor.
     forall i:real [delete_(l1,cu,l2),contains_(l1,i)|delete_(l1,cu,l2),contains_(l2,i)].
     	    delete_(l1,cu,l2) -> contains_(l2,i) -> contains_(l1,i) and i<>witness(element_(l1,cu))

goal insert_has_element :
      forall s:set. forall e:element_t. forall si:set. forall cu:cursor [insert_(s,e,si),has_element_(si,cu)].
      	     insert_(s,e,si) -> has_element_(si,cu) -> has_element_(s,cu) or cu=find_(si,witness(e))

goal delete_has_element :
      forall s:set. forall c:cursor. forall si:set. forall cu:cursor [delete_(s,c,si),has_element_(si,cu)].
      	     delete_(s,c,si) -> has_element_(si,cu) -> has_element_(s,cu) and not cu=c

goal left_contains :
      forall s:set. forall cu:cursor. forall i:real [contains_(left_(s,next_(s,cu)),i)].
      	     has_element_(s,cu) ->
	     (contains_(left_(s,next_(s,cu)),i) <-> contains_(left_(s,cu),i) or i=witness(element_(s,cu)))

goal contains_left :
     forall ss:set. forall c:cursor [contains_(left_(ss,c),witness(element_(ss,c)))].
     	    has_element_(ss,c) -> not contains_(left_(ss,c),witness(element_(ss,c)))

goal contains_element :
     forall s:set. forall cu:cursor [contains_(s,witness(element_(s,cu)))].
     	    has_element_(s,cu) -> contains_(s,witness(element_(s,cu)))

goal is_empty_inter :
     forall s1:set. forall s2:set [is_empty_(inter_(s1,s2))].
     	    is_empty_(inter_(s1,s2)) <-> (forall i:real. not(contains_(s1,i) and contains_(s2,i)))

goal position_next :
      forall s:set. forall cu:cursor [position_(s,next_(s,cu))].
      	     has_element_(s,next_(s,cu)) -> position_(s,next_(s,cu))=position_(s,cu)+1

goal delete_next :
      forall s:set. forall c:cursor. forall si:set. forall cu:cursor [delete_(s,c,si),has_element_(si,next_(s,c))].
      	     delete_(s,c,si) -> has_element_(si,next_(s,c)) or next_(s,c)=no_element

goal length_left :
      forall s:set. forall c:cursor [length_(left_(s,c))].
      	     has_element_(s,c)->length_(left_(s,c))=position_(s,c)-1

goal right_delete :
     forall s1:set. forall s2:set.
     forall c:cursor [delete_(s1,c,s2), equal_(right_(s1,next_(s1,c)),right_(s2,next_(s1,c)))].
     	    delete_(s1,c,s2) -> has_element_(s1,c) -> equal_(right_(s1,next_(s1,c)),right_(s2,next_(s1,c)))

goal equal_refl :
     forall s1:set. forall s2:set [equal_(s2,s1)].
     	    equal_(s1,s2) -> equal_(s2,s1)

goal right_equal :
     forall s:set. forall cu:cursor. forall s2:set [equal_(right_(s,next_(s,cu)),right_(s2,next_(s,cu)))].
     	  has_element_(s,cu) -> equal_(right_(s,cu),right_(s2,cu)) ->
	  equal_(right_(s,next_(s,cu)),right_(s2,next_(s,cu)))

goal equal_trans :
      forall l1:set. forall l2:set. forall l3:set [equal_(l2,l3),equal_(l1,l3) | equal_(l1,l2),equal_(l1,l3)].
      	     equal_(l1,l2) -> equal_(l2,l3) -> equal_(l1,l3)

goal has_element_next_right :
    forall s:set. forall c:cursor [has_element_(s,next_(s,c)), right_(s,c) | has_element_(right_(s,c),next_(s,c))].
    	   has_element_(s,c) -> has_element_(s,next_(s,c)) -> has_element_(right_(s,c),next_(s,c))

goal has_element_right :
    forall s:set. forall c:cursor. forall cu:cursor [has_element_(s,cu), right_(s,c) | has_element_(right_(s,c),cu)].
    	   has_element_(right_(s,c),cu) -> has_element_(s,cu)

goal equal_has_element :
     forall s1:set. forall s2:set. forall c:cursor [equal_(s1,s2), has_element_(s2,c)].
     	    has_element_(s1,c) -> equal_(s1,s2) -> has_element_(s2,c)

goal left_length :
      forall s:set. forall s1:set. forall cu:cursor. forall e:element_t [length_(left_(s,next_(s1,cu)))].
      	     has_element_(s,cu) ->
	     length_(left_(s,cu))+1=length_(left_(s,next_(s,cu)))

goal right_equal_next :
     forall s:set. forall cu:cursor.
     forall s2:set [equal_(right_(s,cu),right_(s2,cu)),next_(s,cu)].
     	  has_element_(s,cu) -> equal_(right_(s,cu),right_(s2,cu)) ->
	  next_(s,cu)=next_(s2,cu)

goal length_union :
      forall s1:set. forall s2:set [length_(union_(s1,s2))].
      	     is_empty_(inter_(s1,s2)) -> length_(union_(s1,s2))=length_(s1)+length_(s2)

goal length_diff :
      forall s1:set. forall s2:set [length_(diff_(s1,s2))].
      	     length_(diff_(s1,s2))=length_(s1)-length_(inter_(s1,s2))

goal position_right :
    forall s:set. forall c:cursor. forall cu:cursor [position_(right_(s,c),cu) | element_(right_(s,c),cu)].
    	   has_element_(s,c) ->
    	   position_(right_(s,c),cu)>0 -> position_(s,cu)>=position_(s,c) and element_(s,cu)=element_(right_(s,c),cu)

goal next_last :
      forall s:set. forall c:cursor [has_element_(s,c),next_(s,c),position_(s,c),length_(s)].
      	     has_element_(s,c) -> next_(s,c)=no_element -> position_(s,c)=length_(s)

goal right_order :
      forall co:set. forall cu:cursor. forall i:real [has_element_(co,cu),witness(element_(co,cu)),contains_(co,i),
      position_(co,find_(co,i)),position_(co,cu),right_(co,cu)].
      has_element_(co,cu) ->
      witness(element_(co,cu))<i ->  contains_(co,i) ->
      position_(co,find_(co,i))>=position_(co,cu)

goal delete_last :
      forall s1:set. forall s2:set [delete_(s1,last_(s1),s2)].
      delete_(s1,last_(s1),s2) -> not is_empty_(s2) -> witness(element_(s2,last_(s2)))<witness(element_(s1,last_(s1)))

goal insert_first :
      forall s1:set. forall s2:set. forall e:element_t [insert_(s1,e,s2),witness(element_(s1,first_(s1)))].
      insert_(s1,e,s2) -> not is_empty_(s1) ->
      witness(e)<witness(element_(s1,first_(s1))) ->
      e=element_(s2,first_(s2))

goal delete_first :
      forall s1:set. forall s2:set [delete_(s1,first_(s1),s2)].
      delete_(s1,first_(s1),s2) -> not is_empty_(s2) -> witness(element_(s2,first_(s2)))>witness(element_(s1,first_(s1)))

goal insert_last :
      forall s1:set. forall s2:set. forall e:element_t [insert_(s1,e,s2),witness(element_(s1,last_(s1)))].
      insert_(s1,e,s2) -> not is_empty_(s1) ->
      witness(e)>witness(element_(s1,last_(s1))) ->
      e=element_(s2,last_(s2))


(* REDONDANT AXIOMS (for Alt-Ergo) *)
(* AXIOMS FROM HASHED_SET *)

axiom contains_insert :
     forall l1:set. forall l2:set. forall e:element_t.
     forall i:real [insert_(l1,e,l2),contains_(l1,i)|insert_(l1,e,l2),contains_(l2,i)].
     	    insert_(l1,e,l2) -> contains_(l2,i) -> i=witness(e) or contains_(l1,i)

axiom contains_delete :
     forall l1:set. forall l2:set. forall cu:cursor.
     forall i:real [delete_(l1,cu,l2),contains_(l1,i)|delete_(l1,cu,l2),contains_(l2,i)].
     	    delete_(l1,cu,l2) -> contains_(l2,i) -> contains_(l1,i) and i<>witness(element_(l1,cu))

axiom insert_has_element :
      forall s:set. forall e:element_t. forall si:set. forall cu:cursor [insert_(s,e,si),has_element_(si,cu)].
      	     insert_(s,e,si) -> has_element_(si,cu) -> has_element_(s,cu) or cu=find_(si,witness(e))

axiom delete_has_element :
      forall s:set. forall c:cursor. forall si:set. forall cu:cursor [delete_(s,c,si),has_element_(si,cu)].
      	     delete_(s,c,si) -> has_element_(si,cu) -> has_element_(s,cu) and not cu=c

axiom left_contains :
      forall s:set. forall cu:cursor. forall i:real [contains_(left_(s,next_(s,cu)),i)].
      	     has_element_(s,cu) ->
	     (contains_(left_(s,next_(s,cu)),i) <-> contains_(left_(s,cu),i) or i=witness(element_(s,cu)))

axiom contains_left :
     forall ss:set. forall c:cursor [contains_(left_(ss,c),witness(element_(ss,c)))].
     	    has_element_(ss,c) -> not contains_(left_(ss,c),witness(element_(ss,c)))

axiom contains_element :
     forall s:set. forall cu:cursor [contains_(s,witness(element_(s,cu)))].
     	    has_element_(s,cu) -> contains_(s,witness(element_(s,cu)))

axiom is_empty_inter :
     forall s1:set. forall s2:set [is_empty_(inter_(s1,s2))].
     	    is_empty_(inter_(s1,s2)) <-> (forall i:real. not(contains_(s1,i) and contains_(s2,i)))

axiom position_next :
      forall s:set. forall cu:cursor [position_(s,next_(s,cu))].
      	     has_element_(s,next_(s,cu)) -> position_(s,next_(s,cu))=position_(s,cu)+1

axiom delete_next :
      forall s:set. forall c:cursor. forall si:set. forall cu:cursor [delete_(s,c,si),has_element_(si,next_(s,c))].
      	     delete_(s,c,si) -> has_element_(si,next_(s,c)) or next_(s,c)=no_element

axiom length_left :
      forall s:set. forall c:cursor [length_(left_(s,c))].
      	     has_element_(s,c)->length_(left_(s,c))=position_(s,c)-1

axiom right_delete :
     forall s1:set. forall s2:set.
     forall c:cursor [delete_(s1,c,s2), equal_(right_(s1,next_(s1,c)),right_(s2,next_(s1,c)))].
     	    delete_(s1,c,s2) -> has_element_(s1,c) -> equal_(right_(s1,next_(s1,c)),right_(s2,next_(s1,c)))

axiom equal_refl :
     forall s1:set. forall s2:set [equal_(s2,s1)].
     	    equal_(s1,s2) -> equal_(s2,s1)

axiom right_equal :
     forall s:set. forall cu:cursor. forall s2:set [equal_(right_(s,next_(s,cu)),right_(s2,next_(s,cu)))].
     	  has_element_(s,cu) -> equal_(right_(s,cu),right_(s2,cu)) ->
	  equal_(right_(s,next_(s,cu)),right_(s2,next_(s,cu)))

axiom equal_trans :
      forall l1:set. forall l2:set. forall l3:set [equal_(l2,l3),equal_(l1,l3) | equal_(l1,l2),equal_(l1,l3)].
      	     equal_(l1,l2) -> equal_(l2,l3) -> equal_(l1,l3)

axiom has_element_next_right :
    forall s:set. forall c:cursor [has_element_(s,next_(s,c)), right_(s,c) | has_element_(right_(s,c),next_(s,c))].
    	   has_element_(s,c) -> has_element_(s,next_(s,c)) -> has_element_(right_(s,c),next_(s,c))

axiom has_element_right :
    forall s:set. forall c:cursor. forall cu:cursor [has_element_(s,cu), right_(s,c) | has_element_(right_(s,c),cu)].
    	   has_element_(right_(s,c),cu) -> has_element_(s,cu)

axiom equal_has_element :
     forall s1:set. forall s2:set. forall c:cursor [equal_(s1,s2), has_element_(s2,c)].
     	    has_element_(s1,c) -> equal_(s1,s2) -> has_element_(s2,c)

axiom left_length :
      forall s:set. forall s1:set. forall cu:cursor. forall e:element_t [length_(left_(s,next_(s1,cu)))].
      	     has_element_(s,cu) ->
	     length_(left_(s,cu))+1=length_(left_(s,next_(s,cu)))

axiom right_equal_next :
     forall s:set. forall cu:cursor.
     forall s2:set [equal_(right_(s,cu),right_(s2,cu)),next_(s,cu)].
     	  has_element_(s,cu) -> equal_(right_(s,cu),right_(s2,cu)) ->
	  next_(s,cu)=next_(s2,cu)

axiom length_union :
      forall s1:set. forall s2:set [length_(union_(s1,s2))].
      	     is_empty_(inter_(s1,s2)) -> length_(union_(s1,s2))=length_(s1)+length_(s2)

axiom length_diff :
      forall s1:set. forall s2:set [length_(diff_(s1,s2))].
      	     length_(diff_(s1,s2))=length_(s1)-length_(inter_(s1,s2))

axiom position_right :
    forall s:set. forall c:cursor. forall cu:cursor [position_(right_(s,c),cu) | element_(right_(s,c),cu)].
    	   has_element_(s,c) ->
    	   position_(right_(s,c),cu)>0 -> position_(s,cu)>=position_(s,c) and element_(s,cu)=element_(right_(s,c),cu)

(* SPECIFIC AXIOMS (ORDER) *)

axiom next_last :
      forall s:set. forall c:cursor [has_element_(s,c),next_(s,c),position_(s,c),length_(s)].
      	     has_element_(s,c) -> next_(s,c)=no_element -> position_(s,c)=length_(s)

axiom right_order :
      forall co:set. forall cu:cursor. forall i:real [has_element_(co,cu),witness(element_(co,cu)),contains_(co,i),
      position_(co,find_(co,i)),position_(co,cu),right_(co,cu)].
      has_element_(co,cu) ->
      witness(element_(co,cu))<i ->  contains_(co,i) ->
      position_(co,find_(co,i))>=position_(co,cu)

axiom delete_last :
      forall s1:set. forall s2:set [delete_(s1,last_(s1),s2)].
      delete_(s1,last_(s1),s2) -> not is_empty_(s2) -> witness(element_(s2,last_(s2)))<witness(element_(s1,last_(s1)))

axiom insert_first :
      forall s1:set. forall s2:set. forall e:element_t [insert_(s1,e,s2),witness(element_(s1,first_(s1)))].
      insert_(s1,e,s2) -> not is_empty_(s1) ->
      witness(e)<witness(element_(s1,first_(s1))) ->
      e=element_(s2,first_(s2))

axiom delete_first :
      forall s1:set. forall s2:set [delete_(s1,first_(s1),s2)].
      delete_(s1,first_(s1),s2) -> not is_empty_(s2) -> witness(element_(s2,first_(s2)))>witness(element_(s1,first_(s1)))

axiom insert_last :
      forall s1:set. forall s2:set. forall e:element_t [insert_(s1,e,s2),witness(element_(s1,last_(s1)))].
      insert_(s1,e,s2) -> not is_empty_(s1) ->
      witness(e)>witness(element_(s1,last_(s1))) ->
      e=element_(s2,last_(s2))

(*** UNIT-TESTS ***)

let test_replace_element1 (co:set ref) (cu:cursor) (cun:cursor) (e:element_t) (el:element_t)=
    { has_element_(co,cu) and has_element_(co,cun) and not cu=cun and
    (not contains_(co,witness(e)) or find_(co,witness(e))=cu) and
    not find_(co,witness(el))=cu and contains_(co,witness(el)) }
    replace_element co cu e
    { element_(co,cu)=e and element_(co,cun)=element_(co@,cun) and has_element_(co,cun) 
    and position_(co,cun)>0 and contains_(co,witness(e)) and contains_(co,witness(el))
    and find_(co,witness(el))=find_(co@,witness(el))  and false }

logic p : element_t -> prop

predicate p_forall_cont (co:set) =
	  forall cu:cursor.
	  	 has_element_(co,cu) -> p(element_(co,cu))

let test_replace_element2 (co:set ref) (cu:cursor) (e:element_t) (el:element_t) =
    { has_element_(co,cu) and p(e) and p_forall_cont(co) and
    (not contains_(co,witness(e)) or find_(co,witness(e))=cu) and
     not contains_(co,witness(el)) and witness(e)<>witness(el) }
    replace_element co cu e
    { p_forall_cont(co) and element_(co,cu)=e and
    contains_(co,witness(e)) and not contains_(co,witness(el)) and false }

let test_replace_element3 (co:set ref) (cu:cursor) (e:element_t) (el:element_t) =
    { has_element_(co,cu) and find_(co,witness(e))=cu and contains_(co,witness(el)) }
    replace_element co cu e
    { contains_(co,witness(element_(co@,cu))) and contains_(co,witness(el)) and false }

let test_insert1 (co:set ref) (e:element_t) (cu2:cursor) (el:element_t) =
    { p(e) and p_forall_cont(co) and has_element_(co,cu2) and not contains_(co,witness(e)) and
    contains_(co,witness(el)) }
    insert co e
    { p_forall_cont(co) and
    contains_(co,witness(e)) and
    element_(co,cu2)=element_(co@,cu2) and
    length_(co)=length_(co@)+1 and
    find_(co,witness(el))=find_(co@,witness(el)) and
    (witness(element_(co,cu2))<witness(e) -> position_(co,cu2)=position_(co@,cu2)) and
    (ceiling(co@,witness(e))=no_element -> position_(co,find_(co,witness(e)))=length_(co)) and
    (has_element_(co@,ceiling(co@,witness(e))) ->
    		position_(co,find_(co,witness(e)))=position_(co@,ceiling(co@,witness(e)))) and
    false }

let test_include1 (co:set ref) (e:element_t) (cu2:cursor) (el:element_t) =
    { p(e) and p_forall_cont(co) and has_element_(co,cu2) and not contains_(co,witness(e)) and
    contains_(co,witness(el)) }
    include_ co e
    { p_forall_cont(co) and
    contains_(co,witness(e)) and
    element_(co,cu2)=element_(co@,cu2) and
    length_(co)=length_(co@)+1 and
    find_(co,witness(el))=find_(co@,witness(el)) and
    false }

let test_include2 (co:set ref) (e:element_t) (cu2:cursor) (el:element_t) =
    { p(e) and p_forall_cont(co) and has_element_(co,cu2) and contains_(co,witness(e)) and
    witness(e)<>witness(el) and not find_(co,witness(e))=cu2 }
    include_ co e
    { p_forall_cont(co) and 
    element_(co,find_(co@,witness(e)))=e and
    element_(co,cu2)=element_(co@,cu2) and
    length_(co)=length_(co@) and
    find_(co,witness(el))=find_(co@,witness(el)) and
    false }

let test_delete (co:set ref) (cu:cursor) (cu2:cursor) =
    { has_element_(co,cu) and p_forall_cont(co) and has_element_(co,cu2) and
      witness(element_(co,cu2))<witness(element_(co,cu)) }
    delete co cu
    { p_forall_cont(co) and not has_element_(co,cu) and
     position_(co,cu2)=position_(co@,cu2) and
     length_(co)=length_(co@)-1 and false }

let test_insert_delete1 (co:set ref) (cun:cursor) (e:element_t) (el:element_t) =
    { p_forall_cont(co) and has_element_(co,cun) and not contains_(co,witness(e)) }
    init:
    insert co e;
    interm:
    delete co (find !co e);
    void
    { p_forall_cont(co) and element_(co,cun)=element_(co@,cun) and
    find_(co,witness(el))=find_(co@,witness(el)) and false }

let test_exclude (co:set ref) (cu:cursor)(cun:cursor) (e:element_t) =
    { has_element_(co,cu) and element_(co,cu)=e and has_element_(co,cun) and not cu=cun }
    exclude co e
    { element_(co,cun)=element_(co@,cun) and false }

let test_left1 (co:set) (cu:cursor) (el:element_t) =
    { p_forall_cont(left_(co,no_element))
     and (has_element_(co,cu) or cu=no_element) and
     (has_element_(co,cu)->witness(el)<witness(element_(co,cu))) and  contains_(co,witness(el))}
    void
    { p_forall_cont(left_(co,cu)) and
      is_empty_(left_(co,first_(co))) and
      contains_(left_(co,cu),witness(el)) and 
      equal_(co,left_(co,no_element))
      and false }

let test_left2 (co:set) (cu:cursor) (cun:cursor) =
    { not has_element_(co,cu) and (has_element_(co,cu) or cu=no_element)}
    void
    { not has_element_(left_(co,cun),cu)
      and false }

let test_right1 (co:set) (cu:cursor) (e:element_t) (el:element_t) =
    { p_forall_cont(co)
      and has_element_(co,cu) and
      witness(element_(co,cu))<witness(el) and  contains_(co,witness(el)) and 
      position_(co,find_(co,witness(e)))>=position_(co,cu) }
    void
    { p_forall_cont(right_(co,cu)) and
      is_empty_(right_(co,no_element)) and
      find_(right_(co,cu),witness(el))=find_(co,witness(el)) and
      contains_(right_(co,cu),witness(el)) and 
      equal_(co,right_(co,first_(co))) and
      contains_(right_(co,cu),witness(e))
      and false }

let test_right2 (co:set) (cu:cursor) (cun:cursor) =
    { not has_element_(co,cu) }
    void
    { not has_element_(right_(co,cun),cu)
      and false }

let test_right_delete (s:set ref) (cu1:cursor) (cu2:cursor) (cu:cursor) =
     { 0<position_(s,cu1)<position_(s,cu2) }
     init:
     delete s cu1
     { position_(right_(s@,cu2),cu)=position_(right_(s,cu2),cu) and
		 (position_(right_(s@,cu2),cu)>0 -> element_(right_(s@,cu2),cu)=element_(right_(s,cu2),cu)) and false }

let test_union1 (s1:set) (s2:set) (e:element_t) =
    { contains_(union_(s1,s2),witness(e)) and not contains_(s2,witness(e)) }
    void
    { contains_(s1,witness(e)) and false }

let test_union2 (s1:set) (s2:set) (s3:set) =
    { is_empty_(inter_(s1,s2)) and is_empty_(inter_(s2,s3)) and is_empty_(inter_(s1,s3))}
    union s1 s2
    { is_empty_(inter_(result,s3)) and equivalent_(union_(result,s3),union_(s1,union_(s2,s3))) and false }

let test_inter (s1:set) (s2:set) (e:element_t) =
    { not contains_(inter_(s1,s2),witness(e)) and contains_(s2,witness(e)) }
    void
    { not contains_(s1,witness(e)) and false }

let test_diff1 (s1:set) (s2:set) (e:element_t) =
    { not contains_(diff_(s1,s2),witness(e)) and contains_(s1,witness(e)) }
    void
    { contains_(inter_(s1,s2),witness(e)) and false }

let test_diff2 (s1:set) (s2:set) (e:element_t) =
    { contains_(union_(diff_(s1,s2),diff_(s2,s1)),witness(e)) }
    void
    { not contains_(inter_(s1,s2),witness(e)) and contains_(union_(s1,s2),witness(e)) and false }

let test_diff3 (s1:set) (s2:set) (e:element_t) =
    { not contains_(union_(diff_(s1,s2),diff_(s2,s1)),witness(e)) }
    void
    { (contains_(inter_(s1,s2),witness(e)) or (not contains_(union_(s1,s2),witness(e)))) and
      is_empty_(inter_(diff_(s1,s2),diff_(s2,s1))) and
      length_(union_(diff_(s1,s2),diff_(s2,s1)))=length_(union_(s1,s2))-length_(inter_(s1,s2)) and false }

let test_is_subset (s1:set ref) (s2:set) (e:element_t) =
    { contains_(s2,witness(e)) and is_subset_(s1,s2) }
    include_ s1 e
    { is_subset_(s1,s2) and false }

let test_false (co:set ref) (cu:cursor) (col:set) (e:element_t) =
    { position_(co,cu)>0 }
    void
    { false }

(*** TESTS ***)

(* Copys the n first element s of ss into s. *)
let test11 (s:set ref) (ss:set) (n:int) (c:cursor ref) =
    { is_empty_(s) and length_(ss)>n and n>0 }
    let i = ref 1 in
    c := first ss;
    init:
    while !i <= n do
    	  { invariant
	    ((forall e:element_t. contains_(s,witness(e)) -> 0<position_(ss,find_(ss,witness(e)))<i) and
	    length_(s)=i-1 and position_(ss,c)=i and i<=n+1)
	  }
    iloop:
    insert s (element ss !c);
    c := next ss !c;
    i := !i+1;
    void
    done
    { equivalent_(s,left_(ss,c)) and length_(s)=n and false }

(* A more user friendly version. *)
let test12 (s:set ref) (ss:set) (n:int) (c:cursor ref) =
    { is_empty_(s) and length_(ss)>=n+1 and n>0 }
    let i = ref 0 in
    c := first ss;
    init:
    while !i < n do
    	  { invariant
	    (has_element_(ss,c) and
	    equivalent_(s,left_(ss,c)) and
	    length_(s)=i and i<=n)
	  }
    iloop:
    insert s (element ss !c);
    c := next ss !c;
    i := !i+1
    done
    { equivalent_(s,left_(ss,c)) and length_(s)=n and false }

(* Copys every element in ss into s. *)
let test2 (s:set ref) (ss:set) =
    { is_empty_(s) and length_(ss)>0 }
    let c = ref first(ss) in
    init:
    while has_element ss !c do
    	  { invariant
	    ((has_element_(ss,c) or c=no_element) and
	    (forall e:element_t. contains_(s,witness(e)) -> 0<position_(ss,find_(ss,witness(e)))<=length_(s)) and
	    (has_element_(ss,c) -> length_(s)=position_(ss,c)-1) and
	    (c=no_element -> length_(s)=length_(ss)))
	  }
    iloop:
    insert s (element ss !c);
    c := next ss !c;
    void
    done
    { equivalent_(s,ss) and false }

(* A more user friendly version. *)
let test22 (s:set ref) (ss:set) =
    { is_empty_(s) and length_(ss)>0 }
    let c = ref first(ss) in
    init:
    while has_element ss !c do
    	  { invariant
	    ((has_element_(ss,c) or c=no_element) and
	    equivalent_(s,left_(ss,c)))
	  }
    insert s (element ss !c);
    c := next ss !c
    done
    { equivalent_(s,ss) and false }

(* Applys f to every element in s1. *)
logic f : element_t -> element_t

let test3 (s1:set) (s2:set) =
    { forall e:element_t. contains_(s1,witness(e)) -> contains_(s2,witness(f(e))) }
    let s3 = ref empty_ in
    let c = ref first s1 in
    if has_element s1 !c then
    while has_element s1 !c do
    	  { invariant
    	    is_subset_(s3,s2)
    	  }
    include_ s3 (f(element s1 !c));
    c := next s1 !c
    done;
    !s3
    { is_subset_(result,s2) and false }

let test4 (s:set) (e:element_t) (c:cursor ref) =
    c:= first s;
    let b=ref false in
    while has_element s !c && not !b do
    	  { invariant
	    ((has_element_(s,c) or c=no_element) and
	    (b=true and has_element_(s,c) and witness(e)=witness(element_(s,c))
	    or b=false and not contains_(left_(s,c),witness(e)))) }
	    if equivalent_elements e (element s !c) then
	       b:=true
	    else c:=next s !c
    done;
    !b
    { (result=true <-> contains_(s,witness(e))) and c=find_(s,witness(e)) and false }

(* Removes some elements from s and stores them in removed *)
logic fun_test : element_t -> bool

let interm6 (s:set ref) (removed:set ref) (c:cursor ref) =
    { has_element_(s,c) and is_empty_(inter_(s,removed)) }
    let c_int = next !s !c in
    insert removed (element !s !c);
    delete s !c;
    c := c_int
    { ((has_element_(s@,c) and has_element_(s,c)) or c=no_element) and
        is_empty_(inter_(s,removed)) and
	length_(left_(s,c))+length_(removed)=length_(left_(s@,c))+length_(removed@) and
      	equal_(right_(s,c),right_(s@,c)) and c=next_(s@,c@) }

let test6 (s:set ref) (removed:set ref) =
  { not is_empty_(s) and is_empty_(removed) }
  let c = ref first !s in
  init:
  while has_element !s !c do
    { invariant
	(((has_element_(s@init,c) and has_element_(s,c)) or c=no_element) and
	length_(left_(s,c))+length_(removed)=length_(left_(s@init,c)) and
	is_empty_(inter_(s,removed)) and
      	equal_(right_(s,c),right_(s@init,c)))
    }
    (*if fun_test(element !s !c) then*)
    interm6 s removed c
  done
   { length_(s)+length_(removed)=length_(s@) and false }

(*** MAX TESTS ***)

logic compare_ : element_t, element_t -> int

predicate is_max (v:set,cu:cursor) =
	  has_element_(v,cu) and
	  (forall cun:cursor.
		 has_element_(v,cun) -> compare_(element_(v,cu),element_(v,cun))>=0)

logic max_ : set -> cursor

axiom is_max_max :
      forall v:set.
      	     (not is_empty_(v) -> is_max(v,max_(v)))

(* A REDONDANT AXIOM (for Alt-Ergo) *)

parameter max :
	  v:set ->
	  { not is_empty_(v) }
	  cursor
	  { result=max_(v) }

(* Heap : all the elements of result are bigger than those still in v_min *)
let test_max (v_min:set ref) (n:int) =
    { length_(v_min)>=n }
    init:
    let i=ref 1 in
    let v_max=ref empty_ in
    if !i<=n then
    while !i<=n do
    	  { invariant
	    (length_(v_min)=length_(v_min@init)-i+1 and
	    is_empty_(inter_(v_min,v_max)) and
	    forall cu1:cursor. forall cu2:cursor. has_element_(v_max,cu1) ->
	    has_element_(v_min,cu2) ->
	    compare_(element_(v_max, cu1),element_(v_min,cu2))>=0)}
	  iloop:
    	  insert v_max (element !v_min (max !v_min));
	  delete v_min (max !v_min);
	  i := !i+1
    done;
    !v_max
    { (forall cu1:cursor. forall cu2:cursor. has_element_(result,cu1) ->
	    has_element_(v_min,cu2) ->
	    compare_(element_(result, cu1),element_(v_min,cu2))>=0) and false}

(*** ORDER ***)

let test_order (v:set ref) (e:element_t) =
    { is_empty_(v) or witness(element_(v,last_(v)))<=witness(e) }
    include_ v e;
    void
    { element_(v,last_(v))=e }

(* Heap : all the elements of result are bigger than those still in v_min *)
let test_max_order (v_min:set ref) (n:int) =
    { length_(v_min)>=n }
    init:
    let i=ref 1 in
    let v_max=ref empty_ in
    if !i<=n then
    while !i<=n do
    	  { invariant
	    (length_(v_min)=length_(v_min@init)-i+1 and
	    (not is_empty_(v_min) -> not is_empty_(v_max) ->
	    witness(element_(v_min,last_(v_min)))<witness(element_(v_max,first_(v_max))))) }
	  iii:
    	  insert v_max (element !v_min (last !v_min));
	  interm:
	  delete v_min (last !v_min);
	  i := !i+1
    done;
    !v_max
    { (not is_empty_(v_min) -> not is_empty_(result) ->
    witness(element_(v_min,last_(v_min)))<witness(element_(result,first_(result)))) and false }

(* all the elements of result are smaller than those still in v_max *)
let test_min_order (v_max:set ref) (n:int) =
    { length_(v_max)>=n }
    init:
    let i=ref 1 in
    let v_min=ref empty_ in
    if !i<=n then
    while !i<=n do
    	  { invariant
	    (length_(v_max)=length_(v_max@init)-i+1 and
	    (not is_empty_(v_min) -> not is_empty_(v_max) ->
	    witness(element_(v_min,last_(v_min)))<witness(element_(v_max,first_(v_max))))) }
	  iii:
    	  insert v_min (element !v_max (first !v_max));
	  interm:
	  delete v_max (first !v_max);
	  i := !i+1
    done;
    !v_min
    { (not is_empty_(v_max) -> not is_empty_(result) ->
    witness(element_(result,last_(result)))<witness(element_(v_max,first_(v_max)))) and false }

(* Finds the position in s were e will be inserted.
   Then includes e in s and returns the cursor which should points toward it .
   NB : Gwy adds 3 false cases to the 3 cases comming from the if statements *)
let test_new_position (s:set ref) (e:element_t) (b:bool) =
    let c=ref first !s in
    while ((has_element !s !c) && (lt (element !s !c) e)) do
    	  { invariant
	    (has_element_(s,c) or c=no_element) and
	    (c=first_(s) or witness(element_(s,last_(left_(s,c))))<witness(e))
	  }
    	  c:= next !s !c
    done;
    eloop:
    assert{c=ceiling(s,witness(e))};
    include_ s e;
    if has_element !s !c then
    if lt e (element !s !c) then
       previous !s !c
    else !c
    else last !s
    { result=find_(s,witness(e)) and false }

(*** SUM_OF TESTS ***)

logic weight_ : element_t -> int
logic checkk_ : element_t -> prop

parameter weight :
	  e:element_t ->
	  {}
	  int
	  {result=weight_(e)}

axiom positive_weight :
      forall e:element_t.
      	     weight_(e)>=0

parameter checkk :
	  e:element_t ->
	  {}
	  bool
	  {result=true <-> checkk_(e)}

(* Sum_of_weight and some axioms *)
logic sum_of_weight : set -> int

axiom sum_of_weight_delete :
      forall v1:set. forall v2:set. forall cu:cursor.
      	     delete_(v1,cu,v2) -> sum_of_weight(v2)=sum_of_weight(v1)-weight_(element_(v1,cu))

axiom sum_of_weight_insert :
      forall v1:set. forall v2:set. forall e:element_t.
      	     insert_(v1,e,v2) -> sum_of_weight(v2)=sum_of_weight(v1)+weight_(e)

axiom sum_of_weight_null :
      forall v:set.
      	     is_empty_(v) -> sum_of_weight(v)=0

axiom sum_of_weight_equal :
      forall v1:set. forall v2:set.
      	     equal_(v1,v2) -> sum_of_weight(v1)=sum_of_weight(v2)

axiom sum_of_weight_left :
      forall v:set. forall cu:cursor.
      	     has_element_(v,cu) ->
	     sum_of_weight(left_(v,next_(v,cu)))=sum_of_weight(left_(v,cu))+weight_(element_(v,cu))

(* deletes some elements from v and then inserts an equivalent element *)
let test_sum_of (v:set ref) (w:int ref) (e:element_t) =
    { not contains_(v,witness(e)) }
    init:
    w:=0;
    let c= ref (first !v) in
    while has_element !v !c do
    	  { invariant
	    (sum_of_weight(v)=sum_of_weight(v@init)-w) and
	    not contains_(v,witness(e))
    	  }
    	  if (checkk (element !v !c)) then
	     (w := !w+(weight(element !v !c));
	     delete v !c)
	  else c:=next !v !c
    done;
    assert { weight_(e)=w }; (* IMPOSSIBLE TO PROVE *)
    insert v e
    { sum_of_weight(v)=sum_of_weight(v@) }

(* deletes elements from v until their total weight exceeds wmin *)
let test_sum_of2 (v:set ref) (w:int ref) (wmin : int) =
    { wmin <= sum_of_weight(v) }
    init:
    w:=0;
    if !w<wmin then
    while !w<wmin do
    	  { invariant
	    (sum_of_weight(v)=sum_of_weight(v@init)-w)
    	  }
    	 w := !w+(weight (element !v (first !v)));
	 delete v (first !v)
    done
    { sum_of_weight(v)=sum_of_weight(v@)-w and w>=wmin }

(* computes sum_of_weight(v) *)
let test_sum_of3 (v:set) =
    init:
    let w = ref 0 in
    let c = ref (first v) in
    if has_element v !c then
    while has_element v !c do
    	  { invariant
	    (w=sum_of_weight(left_(v,c)) and
	    (has_element_(v,c) or c=no_element))
    	  }
    	 w := !w+(weight(element v !c));
	 c := next v !c
    done;
    !w
    { sum_of_weight(v)=result }
module Main
  use import real.Real
  use import int.Int
  use import module ref.Ref
  
  (*** TO BE INSTANTIATED ***)

  type element_t

  function equal_elements element_t element_t : bool

  axiom equal_refl :
  forall e : element_t [equal_elements e e].
	equal_elements e e = True

  axiom equal_sym :
  forall e1 : element_t, e2 : element_t [equal_elements e1 e2].
	equal_elements e1 e2 = equal_elements e2 e1

  axiom equal_trans :
  forall e1 : element_t, e2 : element_t, e3 : element_t [equal_elements e1 e2, equal_elements e1 e3 | equal_elements e1 e2, equal_elements e2 e3].
	equal_elements e1 e2 = True -> equal_elements e2 e3 = True -> equal_elements e1 e3 = True

  function lt element_t element_t : bool

  (**************************)

  type cursor
  
  type set
  
  function no_element  : cursor
  
  function empty_  : set
  
  function length set : int
  
  axiom Length_gte_zero:
    (forall co:set [(length co : int)]. (Int.(<=) 0 (length co : int)))
  
  function witness element_t : real

  axiom lt_witness :
    (forall k1 : element_t, k2 : element_t [lt k1 k2].
	Real.(<) (witness k1) (witness k2) -> lt k1 k2 = True) /\
    (forall k1 : element_t, k2 : element_t [lt k1 k2].
	lt k1 k2 = True -> Real.(<) (witness k1) (witness k2))
  
  function position_ set cursor : int
  
  axiom Position_gte_zero:
    (forall co:set.
      (forall cu:cursor.
        ((Int.(<=) 0 (position_ co cu : int)) /\
         (Int.(<=) (position_ co cu : int) (length co : int)))))
  
  axiom Position_no_element:
    (forall co:set. ((position_ co (no_element  : cursor) : int) = 0))
  
  axiom Position_eq:
    (forall co:set.
      (forall cu1:cursor.
        (forall cu2:cursor.
          ((Int.(>) (position_ co cu1 : int) 0) ->
           (((position_ co cu1 : int) = (position_ co cu2 : int)) ->
            (cu1 = cu2))))))
  
  function element_ set cursor : element_t
  
  predicate is_empty_ (co : set) =
    (forall cu:cursor. ((position_ co cu : int) = 0))
  
  axiom Length_is_empty:
    (forall co:set. ((is_empty_ co) -> ((length co : int) = 0)))
  
  axiom Empty_is_empty: (is_empty_ (empty_  : set))
  
  predicate previous__ (co : set) (cu1 : cursor) (cu2 : cursor) =
    (((Int.(>) (position_ co cu1 : int) 1) ->
      ((position_ co cu2 : int) = (Int.(-) (position_ co cu1 : int) 1 : int))) /\
     ((((position_ co cu1 : int) = 1) \/ (cu1 = (no_element  : cursor))) ->
      (cu2 = (no_element  : cursor))))
  
  function previous_ set cursor : cursor
  
  axiom Previous_previous:
    (forall co:set.
      (forall cu:cursor [(previous_ co cu : cursor)].
        (previous__ co cu (previous_ co cu : cursor))))
  
  predicate next__ (co : set) (cu1 : cursor) (cu2 : cursor) =
    (((((Int.(>) (length co : int) (position_ co cu1 : int)) /\
        (Int.(>) (position_ co cu1 : int) 0)) \/
       (Int.(>) (position_ co cu2 : int) 0)) ->
      ((position_ co cu2 : int) = (Int.(+) (position_ co cu1 : int) 1 : int))) /\
     ((((Int.(>) (length co : int) 0) /\
        ((position_ co cu1 : int) = (length co : int))) \/
       (cu1 = (no_element  : cursor))) ->
      (cu2 = (no_element  : cursor))))
  
  function next_ set cursor : cursor
  
  axiom Next_next:
    (forall co:set.
      (forall cu:cursor [(next_ co cu : cursor)].
        (next__ co cu (next_ co cu : cursor))))
  
  predicate last_ (co : set) (cu : cursor) =
    (((not (is_empty_ co)) -> ((position_ co cu : int) = (length co : int))) /\
     ((is_empty_ co) -> (cu = (no_element  : cursor))))
  
  function last set : cursor
  
  axiom Last_last:
    (forall co:set [(last co : cursor)]. (last_ co (last co : cursor)))
  
  predicate first_ (co : set) (cu : cursor) =
    (((not (is_empty_ co)) -> ((position_ co cu : int) = 1)) /\
     ((is_empty_ co) -> (cu = (no_element  : cursor))))
  
  function first set : cursor
  
  axiom First_first:
    (forall co:set [(first co : cursor)]. (first_ co (first co : cursor)))
  
  function find_ set real : cursor
  
  predicate find__ (co : set) (i : real) (cu : cursor) =
    (cu = (no_element  : cursor) /\
      (forall cun:cursor.
        Int.(>) (position_ co cun : int) 0 ->
         (witness (element_ co cun : element_t) : real) <> i)) \/
     (Int.(>) (position_ co cu : int) 0 /\
      (witness (element_ co cu : element_t) : real) = i)(* /\
       (forall cun:cursor.
         ((Int.(>) (position_ co cun : int) 0) ->
          ((cu <> cun) ->
           ((witness (element_ co cun : element_t) : real) <> i)))))))*)
  
  axiom Find_find_val:
    (forall co:set.
      (forall i:real.
        ((find__ co i (find_ co i : cursor)) /\
         ((is_empty_ co) -> ((find_ co i : cursor) = (no_element  : cursor))))))
  
  axiom Ordered:
    (forall s:set.
      (forall cu1:cursor.
        (forall cu2:cursor.
          (((Int.(>) (position_ s cu1 : int) 0) /\
            (Int.(>) (position_ s cu2 : int) 0)) ->
           ((Int.(>) (position_ s cu2 : int) (position_ s cu1 : int)) <->
            (Real.(>) (witness (element_ s cu2 : element_t) : real) (witness (element_ s cu1 : element_t) : real)))))))
  
  predicate left_pos (co : set) (i : int) (col : set) =
    (forall cu:cursor.
       Int.(>=) (position_ co cu : int) i ->
         position_ col cu = 0) /\
    (forall cu:cursor.
        Int.(<) (position_ co cu : int) i ->
          position_ col cu = position_ co cu) /\
    (forall cu:cursor.
         Int.(>) (position_ col cu : int) 0 ->
          (position_ co cu : int) = (position_ col cu : int)) /\
     (forall cu:cursor.
       Int.(>) (position_ col cu : int) 0 ->
        (element_ col cu : element_t) = (element_ co cu : element_t))
  
  predicate left_find (co : set) (cu : cursor) (col : set) =
	(forall w:real [element_ co cu, find_ col w | element_ co cu, find_ co w].
		Real.(>) (witness (element_ co cu)) w -> find_ col w = find_ co w /\
		position_ col (find_ col w) = position_ co (find_ co w)) /\
	(forall w:real [element_ co cu, find_ col w].
		Real.(<=) (witness (element_ co cu)) w -> find_ col w = no_element) /\
	(forall w:real [find_ col w | find_ co w]. 
	 	position_ col (find_ col w) > 0 \/ position_ co cu > position_ co (find_ co w)
		-> find_ col w = find_ co w)
  
  predicate left__ (co : set) (cu : cursor) (col : set) =
    (((cu = (no_element  : cursor)) -> (col = co)) /\
     ((Int.(>) (position_ co cu : int) 0) ->
      (((length col : int) = (Int.(-) (position_ co cu : int) 1 : int)) /\
       ((left_pos co (position_ co cu) col) /\
        (left_find co cu col)))))
  
  function left_ set cursor : set
  
  axiom Left_left:
    (forall co:set.
      (forall cu:cursor [(left_ co cu : set)].
        (left__ co cu (left_ co cu : set))))
  
  predicate right_pos (co : set) (i : int) (cor : set) =
    ((forall cu:cursor.
       (((Int.(>) i (position_ co cu : int)) ->
         ((position_ cor cu : int) = 0)) /\
        (((Int.(<=) i (position_ co cu : int)) ->
          ((position_ cor cu : int) = (Int.(+) (Int.(-) (position_ co cu : int) i : int) 1 : int))) /\
         ((Int.(>) (position_ cor cu : int) 0) ->
          ((position_ co cu : int) = (Int.(-) (Int.(+) (position_ cor cu : int) i : int) 1 : int)))))) /\
     (forall cu:cursor.
       ((Int.(<=) i (position_ co cu : int)) ->
        ((element_ cor cu : element_t) = (element_ co cu : element_t)))))
  
  predicate right_find (co : set) (i : int) (cor : set) =
    (forall w:real.
      ((((Int.(<=) i (position_ co (find_ co w : cursor) : int)) /\
         (Int.(>) i 0)) \/
        (Int.(>) (position_ cor (find_ cor w : cursor) : int) 0)) ->
       ((find_ co w : cursor) = (find_ cor w : cursor))))
  
  predicate right__ (co : set) (cu : cursor) (cor : set) =
    (((cu = (no_element  : cursor)) -> (cor = (empty_  : set))) /\
     (((Int.(>) (position_ co cu : int) 0) ->
       (((length cor : int) = (Int.(+) (Int.(-) (length co : int) (position_ co cu : int) : int) 1 : int)) /\
        ((right_pos co (position_ co cu : int) cor) /\
         (right_find co (position_ co cu : int) cor)))) /\
      (forall cun:cursor.
        ((Int.(>) (position_ cor cun : int) 0) ->
         (Int.(>) (position_ co cun : int) 0)))))
  
  function right_ set cursor : set
  
  axiom Right_right:
    (forall co:set.
      (forall cu:cursor [(right_ co cu : set)].
        (right__ co cu (right_ co cu : set))))
  
  predicate replace_ (co1 : set) (e : element_t) (co2 : set) =
    ((Int.(>) (position_ co1 (find_ co1 (witness e : real) : cursor) : int) 0) /\
     (((length co1 : int) = (length co2 : int)) /\
      (((element_ co2 (find_ co1 (witness e : real) : cursor) : element_t) = e) /\
       ((forall cun:cursor.
          ((position_ co2 cun : int) = (position_ co1 cun : int))) /\
        ((forall cun:cursor.
           (((Int.(>) (position_ co1 cun : int) 0) /\
             (not (cun = (find_ co1 (witness e : real) : cursor)))) ->
            ((element_ co2 cun : element_t) = (element_ co1 cun : element_t)))) /\
         (forall w:real. ((find_ co1 w : cursor) = (find_ co2 w : cursor))))))))
  
  predicate replace_pos (co1 : set) (co2 : set) =
    (forall cu:cursor.
      ((((position_ co1 cu : int) = 0) /\ ((position_ co2 cu : int) = 0)) \/
       ((Int.(>) (position_ co1 cu : int) 0) /\
        (Int.(>) (position_ co2 cu : int) 0))))
  
  predicate replace_element_ (co1 : set) (cu : cursor) (e : element_t) (co2 : set) =
    ((Int.(>) (position_ co1 cu : int) 0) /\
     (((length co1 : int) = (length co2 : int)) /\
      (((element_ co2 cu : element_t) = e) /\
       ((replace_pos co1 co2) /\
        ((forall cun:cursor.
           ((Int.(>) (position_ co1 cun : int) 0) ->
            ((cu <> cun) ->
             ((element_ co2 cun : element_t) = (element_ co1 cun : element_t))))) /\
         ((forall w:real.
            (((witness e : real) = w) -> ((find_ co2 w : cursor) = cu))) /\
          (forall w:real.
            ((((witness e : real) <> w) /\
              (not ((find_ co1 w : cursor) = cu))) ->
             ((find_ co1 w : cursor) = (find_ co2 w : cursor))))))))))
  
  function ceiling set real : cursor
  
  predicate is_ceiling (s : set) (i : real) (cu : cursor) =
     (cu = no_element  /\
       (is_empty_ s \/
        Real.(>) i (witness (element_ s (last s : cursor) : element_t)))) \/
      (Int.(>) (position_ s cu : int) 0 /\
       Real.(<=) i (witness (element_ s cu : element_t) : real) /\
	(forall cun : cursor. 0 < position_ s cun < position_ s cu
	 -> Real.(>) i (witness (element_ s cun))))
  
  axiom Ceiling_is_ceiling:
    (forall s:set.
      forall i:real [(ceiling s i : cursor)].
        is_ceiling s i (ceiling s i : cursor))
  
  predicate insert_find (co1 : set) (e : element_t) (co2 : set) =
    ((forall i:real.
       ((i <> (witness e : real)) ->
        ((find_ co1 i : cursor) = (find_ co2 i : cursor)))) /\
     ((((ceiling co1 (witness e : real) : cursor) = (no_element  : cursor)) ->
       ((find_ co2 (witness e : real) : cursor) = (last co2 : cursor))) /\
      ((Int.(>) (position_ co1 (ceiling co1 (witness e : real) : cursor) : int) 0) ->
       ((position_ co2 (find_ co2 (witness e : real) : cursor) : int) = (position_ co1 (ceiling co1 (witness e : real) : cursor) : int)))))
  
  predicate insert_pos (co1 : set) (e : element_t) (co2 : set) =
    ((forall cun:cursor.
       ((Int.(>) (position_ co1 cun : int) 0) ->
        (((Real.(>) (witness e : real) (witness (element_ co1 cun : element_t) : real)) ->
          ((position_ co2 cun : int) = (position_ co1 cun : int))) /\
         ((Real.(>) (witness (element_ co1 cun : element_t) : real) (witness e : real)) ->
          ((position_ co2 cun : int) = (Int.(+) (position_ co1 cun : int) 1 : int)))))) /\
     ((forall cun:cursor.
        ((Int.(>) (position_ co1 cun : int) 0) ->
         ((element_ co1 cun : element_t) = (element_ co2 cun : element_t)))) /\
      (forall cun:cursor.
        ((Int.(>) (position_ co1 cun : int) 0) ->
         ((witness (element_ co1 cun : element_t) : real) <> (witness e : real))))))
  
  predicate insert_inv (co1 : set) (e : element_t) (co2 : set) =
    ((forall cun:cursor.
       (((Int.(<) 0 (position_ co2 cun : int)) /\
         ((witness (element_ co2 cun : element_t) : real) = (witness e : real))) ->
        ((position_ co1 cun : int) = 0))) /\
     (forall cun:cursor.
       (((Int.(<) 0 (position_ co2 cun : int)) /\
         ((position_ co1 cun : int) = 0)) ->
        ((element_ co2 cun : element_t) = e))))
  
  predicate insert_ (co1 : set) (e : element_t) (co2 : set) =
    ((Int.(>) (position_ co2 (find_ co2 (witness e : real) : cursor) : int) 0) /\
     (((length co2 : int) = (Int.(+) (length co1 : int) 1 : int)) /\
      ((insert_pos co1 e co2) /\
       ((insert_inv co1 e co2) /\ (insert_find co1 e co2)))))
  
  predicate delete_find (co1 : set) (e : element_t) (co2 : set) =
    (forall w:real.
      ((((witness e : real) <> w) ->
        ((find_ co1 w : cursor) = (find_ co2 w : cursor))) /\
       (((witness e : real) = w) ->
        ((find_ co2 w : cursor) = (no_element  : cursor)))))
  
  predicate delete_pos (co1 : set) (i : int) (co2 : set) =
    ((forall cun:cursor.
       ((((position_ co1 cun : int) = i) -> ((position_ co2 cun : int) = 0)) /\
        (((Int.(>) (position_ co1 cun : int) i) ->
          ((position_ co2 cun : int) = (Int.(-) (position_ co1 cun : int) 1 : int))) /\
         ((Int.(>) i (position_ co1 cun : int)) ->
          ((position_ co2 cun : int) = (position_ co1 cun : int)))))) /\
     (forall cun:cursor.
       (((position_ co1 cun : int) <> i) ->
        ((element_ co2 cun : element_t) = (element_ co1 cun : element_t)))))
  
  predicate delete_inv (co1 : set) (i : int) (co2 : set) =
    (forall cun:cursor.
      ((Int.(>) (position_ co2 cun : int) 0) ->
       (Int.(>) (position_ co1 cun : int) 0)))
  
  predicate delete_ (co1 : set) (cu : cursor) (co2 : set) =
    (((find_ co2 (witness (element_ co1 cu : element_t) : real) : cursor) = (no_element  : cursor)) /\
     ((Int.(>) (position_ co1 cu : int) 0) /\
      (((length co2 : int) = (Int.(-) (length co1 : int) 1 : int)) /\
       ((delete_pos co1 (position_ co1 cu : int) co2) /\
        ((delete_inv co1 (position_ co1 cu : int) co2) /\
         (delete_find co1 (element_ co1 cu : element_t) co2))))))
  
  predicate include__ (co1 : set) (e : element_t) (co2 : set) =
    (((Int.(>) (position_ co1 (find_ co1 (witness e : real) : cursor) : int) 0) ->
      (replace_ co1 e co2)) /\
     (((find_ co1 (witness e : real) : cursor) = (no_element  : cursor)) ->
      (insert_ co1 e co2)))
  
  predicate exclude_ (co1 : set) (e : element_t) (co2 : set) =
    (((Int.(>) (position_ co1 (find_ co1 (witness e : real) : cursor) : int) 0) ->
      (delete_ co1 (find_ co1 (witness e : real) : cursor) co2)) /\
     (((find_ co1 (witness e : real) : cursor) = (no_element  : cursor)) ->
      (co1 = co2)))
  
  predicate has_element (co : set) (cu : cursor) =
    (Int.(>) (position_ co cu : int) 0)
  
  predicate contains (co : set) (i : real) =
    (Int.(>) (position_ co (find_ co i : cursor) : int) 0)
  
  axiom Empty_contains:
    (forall s:set [(is_empty_ s)].
      ((forall i:real. (not (contains s i))) -> (is_empty_ s)))
  
  predicate equal_ (co1 : set) (co2 : set) =
    length co1 = length co2 /\
    forall cu1:cursor. 
    (position_ co1 cu1 : int) > 0 -> exists cu2:cursor.
       (position_ co1 cu1 : int) = (position_ co2 cu1 : int) /\
        (equal_elements (element_ co1 cu1 : element_t) (element_ co2 cu2 : element_t) = True)
  
  predicate strict_equal (co1 : set) (co2 : set) =
    ((forall cu:cursor.
       ((position_ co1 cu : int) = (position_ co2 cu : int))) /\
     (forall cu:cursor.
       ((Int.(>) (position_ co1 cu : int) 0) ->
        ((element_ co1 cu : element_t) = (element_ co2 cu : element_t)))))
  
  predicate equivalent_sets (co1 : set) (co2 : set) =
    ((forall i:real. ((contains co1 i) -> (contains co2 i))) /\
     ((length co1 : int) = (length co2 : int)))
  
  axiom Equivalent_sym:
    (forall co1:set.
      (forall co2:set [(equivalent_sets co2 co1)| (equivalent_sets co1 co2)].
        ((equivalent_sets co1 co2) -> (equivalent_sets co2 co1))))
  
  function inter set set : set
  
  predicate is_inter (s1 : set) (s2 : set) (i : set) =
    (forall j:real [(contains s1 j), (contains s2 j)| (contains i j)].
      ((((contains s1 j) /\ (contains s2 j)) -> (contains i j)) /\
       (((not (contains s1 j)) \/ (not (contains s2 j))) ->
        (not (contains i j)))))
  
  axiom Inter_is_inter:
    (forall s1:set.
      (forall s2:set [(inter s1 s2 : set)].
        ((is_inter s1 s2 (inter s1 s2 : set)) /\
         ((length (inter s1 s2 : set) : int) = (length (inter s2 s1 : set) : int)))))
  
  function union set set : set
  
  predicate is_union (s1 : set) (s2 : set) (u : set) =
    ((forall i:real [(contains s1 i), (contains s2 i)| (contains u i)].
       ((((contains s1 i) \/ (contains s2 i)) -> (contains u i)) /\
        (((not (contains s1 i)) /\ (not (contains s2 i))) ->
         (not (contains u i))))) /\
     ((length u : int) = (Int.(-) (Int.(+) (length s1 : int) (length s2 : int) : int) (length (inter s1 s2 : set) : int) : int)))
  
  axiom Union_is_union:
    (forall s1:set.
      (forall s2:set [(union s1 s2 : set)].
        (is_union s1 s2 (union s1 s2 : set))))
  
  function diff set set : set
  
  predicate is_diff (s1 : set) (s2 : set) (d : set) =
    ((forall i:real [(contains s1 i), (contains s2 i)| (contains d i)].
       ((((contains s1 i) /\ (not (contains s2 i))) -> (contains d i)) /\
        (((not (contains s1 i)) \/ (contains s2 i)) ->
         (not (contains d i))))) /\
     ((length d : int) = (Int.(-) (length s1 : int) (length (inter s1 s2 : set) : int) : int)))
  
  axiom Diff_is_diff:
    (forall s1:set.
      (forall s2:set [(diff s1 s2 : set)].
        (is_diff s1 s2 (diff s1 s2 : set))))
  
  predicate is_subset_ (s1 : set) (s2 : set) =
    (forall i:real. ((contains s1 i) -> (contains s2 i)))

  predicate equivalent_elements (e1 : element_t) (e2 : element_t) =
    witness e1 = witness e2

(*** PARAMETERS ***)

val element :
	  co:set-> cu:cursor ->
	  { has_element co cu }
	  element_t
	  { result = element_ co cu }

val find :
	  co:set-> e:element_t ->
	  { }
	  cursor
	  { result = find_ co (witness e) }

val replace_element :
	  co:ref set -> cu:cursor -> e:element_t ->
	  { position_ !co cu > 0 /\ (not (contains !co (witness e)) \/ witness e = witness (element_ !co cu)) }
	  unit reads co writes co
	  { replace_element_ (old !co) cu e !co }

val insert :
	  co:ref set -> e:element_t ->
	  { not (contains !co (witness e)) }
	  unit reads co writes co
	  { insert_(old !co) e !co }

val replace :
	  co:ref set -> e:element_t ->
	  { contains !co (witness e) }
	  unit reads co writes co
	  { replace_ (old !co) e !co }

val include_ :
	  co:ref set -> e:element_t ->
	  {  }
	  unit reads co writes co
	  { include__ (old !co) e !co }

val delete :
	  co:ref set -> cu:cursor ->
	  { has_element !co cu }
	  unit reads co writes co
	  { delete_ (old !co) cu !co }

val exclude :
	  co:ref set -> e:element_t ->
	  {  }
	  unit reads co writes co
	  { exclude_ (old !co) e !co }

val previous :
	  co:set -> cu:cursor ->
	  { cu = no_element \/ has_element co cu }
	  cursor
	  { result = previous_ co cu } 

val next :
	  co:set -> cu:cursor ->
	  { cu = no_element \/ has_element co cu }
	  cursor 
	  { result = next_ co cu }
  
end


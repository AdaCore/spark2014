include "hashed_set.why"

(* Everything works with alt-ergo in 10s
   except :
   	  - one goal, right_egal which takes less than 10min *)

(*** GOALS ***)

goal contains_insert_g :
     forall l1:set. forall l2:set. forall e:element_t.
     forall i:real [insert_(l1,e,l2),contains_(l1,i)|insert_(l1,e,l2),contains_(l2,i)].
     	    insert_(l1,e,l2) -> contains_(l2,i) -> i=witness(e) or contains_(l1,i)

goal contains_delete_g :
     forall l1:set. forall l2:set. forall cu:cursor.
     forall i:real [delete_(l1,cu,l2),contains_(l1,i)|delete_(l1,cu,l2),contains_(l2,i)].
     	    delete_(l1,cu,l2) -> contains_(l2,i) -> contains_(l1,i) and i<>witness(element_(l1,cu))

goal insert_has_element_g :
      forall s:set. forall e:element_t. forall si:set. forall cu:cursor [insert_(s,e,si),has_element_(si,cu)].
      	     insert_(s,e,si) -> has_element_(si,cu) -> has_element_(s,cu) or cu=find_(si,witness(e))

goal delete_has_element_g :
      forall s:set. forall c:cursor. forall si:set. forall cu:cursor [delete_(s,c,si),has_element_(si,cu)].
      	     delete_(s,c,si) -> has_element_(si,cu) -> has_element_(s,cu) and not cu=c

goal left_contains_g :
      forall s:set. forall cu:cursor. forall i:real [contains_(left_(s,next_(s,cu)),i)].
      	     has_element_(s,cu) ->
	     (contains_(left_(s,next_(s,cu)),i) <-> contains_(left_(s,cu),i) or i=witness(element_(s,cu)))

goal contains_left_g :
     forall ss:set. forall c:cursor [contains_(left_(ss,c),witness(element_(ss,c)))].
     	    has_element_(ss,c) -> not contains_(left_(ss,c),witness(element_(ss,c)))

goal contains_element_g :
     forall s:set. forall cu:cursor [contains_(s,witness(element_(s,cu)))].
     	    has_element_(s,cu) -> contains_(s,witness(element_(s,cu)))

goal is_empty_inter_g :
     forall s1:set. forall s2:set [is_empty_(inter_(s1,s2))].
     	    is_empty_(inter_(s1,s2)) <-> (forall i:real. not(contains_(s1,i) and contains_(s2,i)))

goal position_next_g :
      forall s:set. forall cu:cursor [position_(s,next_(s,cu))].
      	     has_element_(s,next_(s,cu)) -> position_(s,next_(s,cu))=position_(s,cu)+1

goal delete_next_g :
      forall s:set. forall c:cursor. forall si:set. forall cu:cursor [delete_(s,c,si),has_element_(si,next_(s,c))].
      	     delete_(s,c,si) -> has_element_(si,next_(s,c)) or next_(s,c)=no_element

goal length_left_g :
      forall s:set. forall c:cursor [length_(left_(s,c))].
      	     has_element_(s,c)->length_(left_(s,c))=position_(s,c)-1

goal equal_refl_g :
     forall s1:set. forall s2:set [equal_(s2,s1)].
     	    equal_(s1,s2) -> equal_(s2,s1)

goal right_equal_g :
     forall s:set. forall cu:cursor. forall s2:set [equal_(right_(s,next_(s,cu)),right_(s2,next_(s,cu)))].
     	  has_element_(s,cu) -> equal_(right_(s,cu),right_(s2,cu)) ->
	  equal_(right_(s,next_(s,cu)),right_(s2,next_(s,cu)))

goal equal_trans_g :
      forall l1:set. forall l2:set. forall l3:set [equal_(l2,l3),equal_(l1,l3) | equal_(l1,l2),equal_(l1,l3)].
      	     equal_(l1,l2) -> equal_(l2,l3) -> equal_(l1,l3)

goal has_element_next_right_g :
    forall s:set. forall c:cursor [has_element_(s,next_(s,c)), right_(s,c) | has_element_(right_(s,c),next_(s,c))].
    	   has_element_(s,c) -> has_element_(s,next_(s,c)) -> has_element_(right_(s,c),next_(s,c))

goal has_element_right_g :
    forall s:set. forall c:cursor. forall cu:cursor [has_element_(s,cu), right_(s,c) | has_element_(right_(s,c),cu)].
    	   has_element_(right_(s,c),cu) -> has_element_(s,cu)

goal equal_has_element_g :
     forall s1:set. forall s2:set. forall c:cursor [equal_(s1,s2), has_element_(s2,c)].
     	    has_element_(s1,c) -> equal_(s1,s2) -> has_element_(s2,c)

goal left_length_g :
      forall s:set. forall s1:set. forall cu:cursor. forall e:element_t [length_(left_(s,next_(s1,cu)))].
      	     has_element_(s,cu) ->
	     length_(left_(s,cu))+1=length_(left_(s,next_(s,cu)))

goal right_equal_next_g :
     forall s:set. forall cu:cursor.
     forall s2:set [equal_(right_(s,cu),right_(s2,cu)),next_(s,cu)].
     	  has_element_(s,cu) -> equal_(right_(s,cu),right_(s2,cu)) ->
	  next_(s,cu)=next_(s2,cu)

goal length_union_g :
      forall s1:set. forall s2:set [length_(union_(s1,s2))].
      	     is_empty_(inter_(s1,s2)) -> length_(union_(s1,s2))=length_(s1)+length_(s2)

goal length_diff_g :
      forall s1:set. forall s2:set [length_(diff_(s1,s2))].
      	     length_(diff_(s1,s2))=length_(s1)-length_(inter_(s1,s2))

goal position_right_g :
    forall s:set. forall c:cursor. forall cu:cursor [position_(right_(s,c),cu) | element_(right_(s,c),cu)].
    	   has_element_(s,c) ->
    	   position_(right_(s,c),cu)>0 -> position_(s,cu)>=position_(s,c) and element_(s,cu)=element_(right_(s,c),cu)

(* REDONDANT AXIOMS (for Alt-Ergo) *)

axiom contains_insert :
     forall l1:set. forall l2:set. forall e:element_t.
     forall i:real [insert_(l1,e,l2),contains_(l1,i)|insert_(l1,e,l2),contains_(l2,i)].
     	    insert_(l1,e,l2) -> contains_(l2,i) -> i=witness(e) or contains_(l1,i)

axiom contains_delete :
     forall l1:set. forall l2:set. forall cu:cursor.
     forall i:real [delete_(l1,cu,l2),contains_(l1,i)|delete_(l1,cu,l2),contains_(l2,i)].
     	    delete_(l1,cu,l2) -> contains_(l2,i) -> contains_(l1,i) and i<>witness(element_(l1,cu))

axiom insert_has_element :
      forall s:set. forall e:element_t. forall si:set. forall cu:cursor [insert_(s,e,si),has_element_(si,cu)].
      	     insert_(s,e,si) -> has_element_(si,cu) -> has_element_(s,cu) or cu=find_(si,witness(e))

axiom delete_has_element :
      forall s:set. forall c:cursor. forall si:set. forall cu:cursor [delete_(s,c,si),has_element_(si,cu)].
      	     delete_(s,c,si) -> has_element_(si,cu) -> has_element_(s,cu) and not cu=c

axiom left_contains :
      forall s:set. forall cu:cursor. forall i:real [contains_(left_(s,next_(s,cu)),i)].
      	     has_element_(s,cu) ->
	     (contains_(left_(s,next_(s,cu)),i) <-> contains_(left_(s,cu),i) or i=witness(element_(s,cu)))

axiom contains_left :
     forall ss:set. forall c:cursor [contains_(left_(ss,c),witness(element_(ss,c)))].
     	    has_element_(ss,c) -> not contains_(left_(ss,c),witness(element_(ss,c)))

axiom contains_element :
     forall s:set. forall cu:cursor [contains_(s,witness(element_(s,cu)))].
     	    has_element_(s,cu) -> contains_(s,witness(element_(s,cu)))

axiom is_empty_inter :
     forall s1:set. forall s2:set [is_empty_(inter_(s1,s2))].
     	    is_empty_(inter_(s1,s2)) <-> (forall i:real. not(contains_(s1,i) and contains_(s2,i)))

axiom position_next :
      forall s:set. forall cu:cursor [position_(s,next_(s,cu))].
      	     has_element_(s,next_(s,cu)) -> position_(s,next_(s,cu))=position_(s,cu)+1

axiom delete_next :
      forall s:set. forall c:cursor. forall si:set. forall cu:cursor [delete_(s,c,si),has_element_(si,next_(s,c))].
      	     delete_(s,c,si) -> has_element_(si,next_(s,c)) or next_(s,c)=no_element

axiom length_left :
      forall s:set. forall c:cursor [length_(left_(s,c))].
      	     has_element_(s,c)->length_(left_(s,c))=position_(s,c)-1

axiom equal_refl :
     forall s1:set. forall s2:set [equal_(s2,s1)].
     	    equal_(s1,s2) -> equal_(s2,s1)

axiom right_equal :
     forall s:set. forall cu:cursor. forall s2:set [equal_(right_(s,next_(s,cu)),right_(s2,next_(s,cu)))].
     	  has_element_(s,cu) -> equal_(right_(s,cu),right_(s2,cu)) ->
	  equal_(right_(s,next_(s,cu)),right_(s2,next_(s,cu)))

axiom equal_trans :
      forall l1:set. forall l2:set. forall l3:set [equal_(l2,l3),equal_(l1,l3) | equal_(l1,l2),equal_(l1,l3)].
      	     equal_(l1,l2) -> equal_(l2,l3) -> equal_(l1,l3)

axiom has_element_next_right :
    forall s:set. forall c:cursor [has_element_(s,next_(s,c)), right_(s,c) | has_element_(right_(s,c),next_(s,c))].
    	   has_element_(s,c) -> has_element_(s,next_(s,c)) -> has_element_(right_(s,c),next_(s,c))

axiom has_element_right :
    forall s:set. forall c:cursor. forall cu:cursor [has_element_(s,cu), right_(s,c) | has_element_(right_(s,c),cu)].
    	   has_element_(right_(s,c),cu) -> has_element_(s,cu)

axiom equal_has_element :
     forall s1:set. forall s2:set. forall c:cursor [equal_(s1,s2), has_element_(s2,c)].
     	    has_element_(s1,c) -> equal_(s1,s2) -> has_element_(s2,c)

axiom left_length :
      forall s:set. forall s1:set. forall cu:cursor. forall e:element_t [length_(left_(s,next_(s1,cu)))].
      	     has_element_(s,cu) ->
	     length_(left_(s,cu))+1=length_(left_(s,next_(s,cu)))

axiom right_equal_next :
     forall s:set. forall cu:cursor.
     forall s2:set [equal_(right_(s,cu),right_(s2,cu)),next_(s,cu)].
     	  has_element_(s,cu) -> equal_(right_(s,cu),right_(s2,cu)) ->
	  next_(s,cu)=next_(s2,cu)

axiom length_union :
      forall s1:set. forall s2:set [length_(union_(s1,s2))].
      	     is_empty_(inter_(s1,s2)) -> length_(union_(s1,s2))=length_(s1)+length_(s2)

axiom length_diff :
      forall s1:set. forall s2:set [length_(diff_(s1,s2))].
      	     length_(diff_(s1,s2))=length_(s1)-length_(inter_(s1,s2))

axiom position_right :
    forall s:set. forall c:cursor. forall cu:cursor [position_(right_(s,c),cu) | element_(right_(s,c),cu)].
    	   has_element_(s,c) ->
    	   position_(right_(s,c),cu)>0 -> position_(s,cu)>=position_(s,c) and element_(s,cu)=element_(right_(s,c),cu)

(*** UNIT-TESTS ***)

let test_replace_element1 (co:set ref) (cu:cursor) (cun:cursor) (e:element_t) (el:element_t)=
    { has_element_(co,cu) and has_element_(co,cun) and not cu=cun and (not contains_(co,witness(e)) or find_(co,witness(e))=cu) and
    not find_(co,witness(el))=cu and contains_(co,witness(el)) }
    replace_element co cu e
    { element_(co,cu)=e and element_(co,cun)=element_(co@,cun) and has_element_(co,cun) 
    and contains_(co,witness(e)) and contains_(co,witness(el))
    and find_(co,witness(el))=find_(co@,witness(el))  and false }

logic p : element_t -> prop

predicate p_forall_cont (co:set) =
	  forall cu:cursor.
	  	 has_element_(co,cu) -> p(element_(co,cu))

let test_replace_element2 (co:set ref) (cu:cursor) (e:element_t) (el:element_t) =
    { has_element_(co,cu) and p(e) and p_forall_cont(co) and (not contains_(co,witness(e)) or find_(co,witness(e))=cu) and
     not contains_(co,witness(el)) and witness(e)<>witness(el) }
    replace_element co cu e
    { p_forall_cont(co) and element_(co,cu)=e and contains_(co,witness(e)) and not contains_(co,witness(el)) and false }

let test_replace_element3 (co:set ref) (cu:cursor) (e:element_t) (el:element_t) =
    { has_element_(co,cu) and find_(co,witness(e))=cu and contains_(co,witness(el)) }
    replace_element co cu e
    { contains_(co,witness(element_(co@,cu))) and contains_(co,witness(el)) and false }

let test_insert1 (co:set ref) (e:element_t) (cu2:cursor) (el:element_t) =
    { p(e) and p_forall_cont(co) and has_element_(co,cu2) and not contains_(co,witness(e)) and
    contains_(co,witness(el)) }
    insert co e
    { p_forall_cont(co) and
    contains_(co,witness(e)) and
    element_(co,cu2)=element_(co@,cu2) and
    length_(co)=length_(co@)+1 and
    find_(co,witness(el))=find_(co@,witness(el)) and
    false }

let test_include1 (co:set ref) (e:element_t) (cu2:cursor) (el:element_t) =
    { p(e) and p_forall_cont(co) and has_element_(co,cu2) and not contains_(co,witness(e)) and
    contains_(co,witness(el)) }
    include_ co e
    { p_forall_cont(co) and
    contains_(co,witness(e)) and
    element_(co,cu2)=element_(co@,cu2) and
    length_(co)=length_(co@)+1 and
    find_(co,witness(el))=find_(co@,witness(el)) and
    false }

let test_include2 (co:set ref) (e:element_t) (cu2:cursor) (el:element_t) =
    { p(e) and p_forall_cont(co) and has_element_(co,cu2) and contains_(co,witness(e)) and
    witness(e)<>witness(el) and not find_(co,witness(e))=cu2 }
    include_ co e
    { p_forall_cont(co) and 
    element_(co,find_(co@,witness(e)))=e and
    element_(co,cu2)=element_(co@,cu2) and
    length_(co)=length_(co@) and
    find_(co,witness(el))=find_(co@,witness(el)) and
    false }

let test_delete (co:set ref) (cu:cursor) (el:element_t) (cun:cursor) =
    { has_element_(co,cu) and p_forall_cont(co) and not find_(co,witness(el))=cu and not cu=cun and
      has_element_(co,cun) }
    delete co cu
    { p_forall_cont(co) and
     not has_element_(co,cu) and
     not contains_(co,witness(element_(co@,cu))) and
     element_(co,cun)=element_(co@,cun) and
     find_(co,witness(el))=find_(co@,witness(el)) and
     length_(co)=length_(co@)-1 and false }

let test_insert_delete1 (co:set ref) (cun:cursor) (e:element_t) (el:element_t) =
    { p_forall_cont(co) and has_element_(co,cun) and not contains_(co,witness(e)) }
    init:
    insert co e;
    delete co (find !co e)
    { p_forall_cont(co) and element_(co,cun)=element_(co@,cun) and find_(co,witness(el))=find_(co@,witness(el)) and false }

let test_exclude (co:set ref) (cu:cursor)(cun:cursor) (e:element_t) =
    { has_element_(co,cu) and element_(co,cu)=e and has_element_(co,cun) and not cu=cun }
    exclude co e
    { element_(co,cun)=element_(co@,cun) and false }

let test_left1 (co:set) (cu:cursor) =
    { p_forall_cont(left_(co,no_element))
     and (has_element_(co,cu) or cu=no_element) }
    void
    { p_forall_cont(left_(co,cu)) and
      is_empty_(left_(co,first_(co))) and
      equal_(co,left_(co,no_element))
      and false }

let test_left2 (co:set) (cu:cursor) (cun:cursor) =
    { not has_element_(co,cu) and (has_element_(co,cun) or cun=no_element)}
    void
    { not has_element_(left_(co,cun),cu)
      and false }

let test_right1 (co:set) (cu:cursor) (e:element_t) =
    { p_forall_cont(co)
      and has_element_(co,cu) and
      position_(co,find_(co,witness(e)))>=position_(co,cu) }
    void
    { p_forall_cont(right_(co,cu)) and
      is_empty_(right_(co,no_element)) and 
      equal_(co,right_(co,first_(co))) and
      contains_(right_(co,cu),witness(e))
      and false }

let test_right2 (co:set) (cu:cursor) (cun:cursor) =
    { not has_element_(co,cu) and (has_element_(co,cun) or cun=no_element) }
    void
    { not has_element_(right_(co,cun),cu)
      and false }

let test_union1 (s1:set) (s2:set) (e:element_t) =
    { contains_(union_(s1,s2),witness(e)) and not contains_(s2,witness(e)) }
    void
    { contains_(s1,witness(e)) and false } 

let test_union2 (s1:set) (s2:set) (s3:set) =
    { is_empty_(inter_(s1,s2)) and is_empty_(inter_(s2,s3)) and is_empty_(inter_(s1,s3))}
    union s1 s2
    { is_empty_(inter_(result,s3)) and equivalent_(union_(result,s3),union_(s1,union_(s2,s3))) and false }

let test_union3 (s1:set) (s2:set) =
    { length_(s1)=length_(s2)=length_(union_(s1,s2)) }
    assert {equivalent_(s1,union_(s1,s2)) };
    void
    { equivalent_(s1,s2) and false }

let test_inter1 (s1:set) (s2:set) (e:element_t) =
    { not contains_(inter_(s1,s2),witness(e)) and contains_(s2,witness(e)) }
    void
    { not contains_(s1,witness(e)) and false }

let test_inter2 (s1:set) (s2:set) =
    { length_(s1)=length_(s2)=length_(inter_(s1,s2)) }
    assert {equivalent_(s1,inter_(s1,s2)) };
    void
    { equivalent_(s1,s2) and false }

let test_diff1 (s1:set) (s2:set) (e:element_t) =
    { not contains_(diff_(s1,s2),witness(e)) and contains_(s1,witness(e)) }
    void
    { contains_(inter_(s1,s2),witness(e)) and false }

let test_diff2 (s1:set) (s2:set) (e:element_t) =
    { contains_(union_(diff_(s1,s2),diff_(s2,s1)),witness(e)) }
    void
    { not contains_(inter_(s1,s2),witness(e)) and contains_(union_(s1,s2),witness(e)) and false }

let test_diff3 (s1:set) (s2:set) (e:element_t) =
    { not contains_(union_(diff_(s1,s2),diff_(s2,s1)),witness(e)) }
    void
    { (contains_(inter_(s1,s2),witness(e)) or (not contains_(union_(s1,s2),witness(e)))) and
      is_empty_(inter_(diff_(s1,s2),diff_(s2,s1))) and
      length_(union_(diff_(s1,s2),diff_(s2,s1)))=length_(union_(s1,s2))-length_(inter_(s1,s2)) and false }

let test_is_subset (s1:set ref) (s2:set) (e:element_t) =
    { contains_(s2,witness(e)) and is_subset_(s1,s2) }
    include_ s1 e
    { is_subset_(s1,s2) and false }

let test_false (co:set ref) (cu:cursor) =
    { position_(co,cu)>0 }
    void
    { false }

(*** TESTS ***)

(* Copys the n first element s of ss into s. *)
let test11 (s:set ref) (ss:set) (n:int) (c:cursor ref) =
    { is_empty_(s) and length_(ss)>n and n>0 }
    let i = ref 1 in
    c := first ss;
    init:
    while !i <= n do
    	  { invariant
	    ((forall e:element_t. contains_(s,witness(e)) ->
               0<position_(ss,find_(ss,witness(e)))) and
            (forall e:element_t. contains_(s,witness(e)) ->
               position_(ss,find_(ss,witness(e)))<i) and
	    length_(s)=i-1 and position_(ss,c)=i and i<=n+1)
	  }
    insert s (element ss !c);
    c := next ss !c;
    i := !i+1
    done
    { equivalent_(s,left_(ss,c)) and length_(s)=n and false }

(* A more user friendly version. *)
let test12 (s:set ref) (ss:set) (n:int) (c:cursor ref) =
    { is_empty_(s) and length_(ss)>n and n>0 }
    let i = ref 0 in
    c := first ss;
    init:
    while !i < n do
    	  { invariant
	    (has_element_(ss,c) and
	    equivalent_(s,left_(ss,c)) and
	    length_(s)=i and i<=n)
	  }
    iloop:
    insert s (element ss !c);
    c := next ss !c;
    i := !i+1
    done
    { equivalent_(s,left_(ss,c)) and length_(s)=n and false }

(* Copys every element in ss into s. *)
let test2 (s:set ref) (ss:set) =
    { is_empty_(s) and length_(ss)>0 }
    let c = ref first(ss) in
    init:
    while has_element ss !c do
    	  { invariant
	    ((has_element_(ss,c) or c=no_element) and
	    (forall e:element_t. contains_(s,witness(e)) ->
	       position_(ss,find_(ss,witness(e)))<=length_(s)) and
	    (forall e:element_t. contains_(s,witness(e)) ->
	       0<position_(ss,find_(ss,witness(e)))) and
	    (has_element_(ss,c) ->length_(s)=position_(ss,c)-1) and
	    (c=no_element -> length_(s)=length_(ss)))
	  }
    insert s (element ss !c);
    c := next ss !c
    done
    { equivalent_(s,ss) and false }

(* A more user friendly version. *)
let test22 (s:set ref) (ss:set) =
    { is_empty_(s) and length_(ss)>0 }
    let c = ref first(ss) in
    init:
    while has_element ss !c do
    	  { invariant
	    ((has_element_(ss,c) or c=no_element) and
	    equivalent_(s,left_(ss,c)))
	  }
    insert s (element ss !c);
    c := next ss !c
    done
    { equivalent_(s,ss) and false }

(* Applys f to every element in s1. *)
logic f : element_t -> element_t

let test3 (s1:set) (s2:set) =
    { forall e:element_t. contains_(s1,witness(e)) -> contains_(s2,witness(f(e))) }
    let s3 = ref empty_ in
    let c = ref first s1 in
    if has_element s1 !c then
    while has_element s1 !c do
    	  { invariant
    	    is_subset_(s3,s2)
    	  }
    include_ s3 (f(element s1 !c));
    c := next s1 !c
    done;
    !s3
    { is_subset_(result,s2) and false }

let test4 (s:set) (e:element_t) (c:cursor ref) =
    c:= first s;
    let b=ref false in
    while has_element s !c && not !b do
    	  { invariant
	    ((has_element_(s,c) or c=no_element) and
	    (b=true and has_element_(s,c) and witness(e)=witness(element_(s,c))
	    or b=false and not contains_(left_(s,c),witness(e)))) }
	    if equivalent_elements e (element s !c) then
	       b:=true
	    else c:=next s !c
    done;
    !b
    { (result=true <-> contains_(s,witness(e))) and c=find_(s,witness(e)) and false }

(*** MAX TESTS ***)

logic compare_ : element_t, element_t -> int

predicate is_max (v:set,cu:cursor) =
	  has_element_(v,cu) and
	  (forall cun:cursor.
		 has_element_(v,cun) -> compare_(element_(v,cu),element_(v,cun))>=0)

logic max_ : set -> cursor

axiom is_max_max :
      forall v:set.
      	     (not is_empty_(v) -> is_max(v,max_(v)))

parameter max :
	  v:set ->
	  { not is_empty_(v) }
	  cursor
	  { result=max_(v) }

(* Heap : all the elements of result are bigger than those still in v_min *)
let test_max (v_min:set ref) (n:int) =
    { length_(v_min)>=n }
    init:
    let i=ref 1 in
    let v_max=ref empty_ in
    if !i<=n then
    while !i<=n do
    	  { invariant
	    (length_(v_min)=length_(v_min@init)-i+1 and
	    is_empty_(inter_(v_min,v_max)) and
	    (forall cu1:cursor. forall cu2:cursor. has_element_(v_max,cu1) ->
	    has_element_(v_min,cu2) ->
	    compare_(element_(v_max, cu1),element_(v_min, cu2))>=0))}
	  iloop:
    	  insert v_max (element !v_min (max !v_min));
	  delete v_min (max !v_min);
	  i := !i+1
    done;
    !v_max
    { (forall cu1:cursor. forall cu2:cursor. has_element_(result,cu1) ->
	    has_element_(v_min,cu2) ->
	    compare_(element_(result, cu1),element_(v_min, cu2))>=0) and false}

(*** SUM_OF TESTS ***)

logic weight_ : element_t -> int
logic checkk_ : element_t -> prop

parameter weight :
	  e:element_t ->
	  {}
	  int
	  {result=weight_(e)}

axiom positive_weight :
      forall e:element_t.
      	     weight_(e)>=0

parameter checkk :
	  e:element_t ->
	  {}
	  bool
	  {if result then checkk_(e) else not checkk_(e) }

(* Sum_of_weight and some axioms *)
logic sum_of_weight : set -> int

axiom sum_of_weight_delete :
      forall v1:set. forall v2:set. forall cu:cursor.
      	     delete_(v1,cu,v2) -> sum_of_weight(v2)=sum_of_weight(v1)-weight_(element_(v1,cu))

axiom sum_of_weight_insert :
      forall v1:set. forall v2:set. forall e:element_t.
      	     insert_(v1,e,v2) -> sum_of_weight(v2)=sum_of_weight(v1)+weight_(e)

axiom sum_of_weight_null :
      forall v:set.
      	     is_empty_(v) -> sum_of_weight(v)=0

axiom sum_of_weight_equal :
      forall v1:set. forall v2:set.
      	     equal_(v1,v2) -> sum_of_weight(v1)=sum_of_weight(v2)

axiom sum_of_weight_left :
      forall v:set. forall cu:cursor.
      	     has_element_(v,cu) ->
	     sum_of_weight(left_(v,next_(v,cu)))=sum_of_weight(left_(v,cu))+weight_(element_(v,cu))

(* deletes some elements from v and then inserts an equivalent element *)
let test_sum_of (v:set ref) (w:int ref) (e:element_t) =
    { not contains_(v,witness(e)) }
    init:
    w:=0;
    let c= ref (first !v) in
    while has_element !v !c do
    	  { invariant
	    (sum_of_weight(v)=sum_of_weight(v@init)-w) and
	    not contains_(v,witness(e))
    	  }
    	  if (checkk (element !v !c)) then
	     (w := !w+(weight(element !v !c));
	     delete v !c)
	  else c:=next !v !c
    done;
    assert { weight_(e)=w }; (* IMPOSSIBLE TO PROVE *)
    insert v e
    { sum_of_weight(v)=sum_of_weight(v@) }

(* deletes elements from v until their total weight exceeds wmin *)
let test_sum_of2 (v:set ref) (w:int ref) (wmin : int) =
    { wmin <= sum_of_weight(v) }
    init:
    w:=0;
    if !w<wmin then
    while !w<wmin do
    	  { invariant
	    (sum_of_weight(v)=sum_of_weight(v@init)-w)
    	  }
    	 w := !w+(weight (element !v (first !v)));
	 delete v (first !v)
    done
    { sum_of_weight(v)=sum_of_weight(v@)-w and w>=wmin }

(* computes sum_of_weight(v) *)
let test_sum_of3 (v:set) =
    init:
    let w = ref 0 in
    let c = ref (first v) in
    if has_element v !c then
    while has_element v !c do
    	  { invariant
	    (w=sum_of_weight(left_(v,c)) and
	    (has_element_(v,c) or c=no_element))
    	  }
    	 w := !w+(weight(element v !c));
	 c := next v !c
    done;
    !w
    { sum_of_weight(v)=result }

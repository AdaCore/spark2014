include "list.why"

(* Everything works with alt-ergo (-redondance or not it depends) in 60s
   except two VC's of test3 which take less then 10s with Z3, Simplify and Yices and between 2 and 3min with Alt-Ergo *)

(*** GOALS ***)

goal left_contains_g :
      forall s:list. forall cu:cursor. forall e:element_t [contains_(left_(s,next_(s,cu)),e)].
      	     has_element_(s,cu) ->
	     contains_(left_(s,next_(s,cu)),e) -> contains_(left_(s,cu),e) or e=element_(s,cu)

goal left_length_g :
      forall s:list. forall cu:cursor. forall e:element_t [length_(left_(s,next_(s,cu)))].
      	     has_element_(s,cu) ->
	     length_(left_(s,cu))+1=length_(left_(s,next_(s,cu)))

goal right_equal_g :
     forall s:list. forall cu:cursor. forall s2:list [equal_(right_(s,next_(s,cu)),right_(s2,next_(s,cu)))].
     	  has_element_(s,cu) -> equal_(right_(s,cu),right_(s2,cu)) ->
	  equal_(right_(s,next_(s,cu)),right_(s2,next_(s,cu)))

goal right_equal_next_g :
     forall s:list. forall cu:cursor. forall s2:list [equal_(right_(s,cu),right_(s2,cu)),next_(s,cu)].
     	  has_element_(s,cu) -> equal_(right_(s,cu),right_(s2,cu)) ->
	  next_(s,cu)=next_(s2,cu)

goal right_insert_g :
     forall l1:list. forall l2:list. forall cu1:cursor.
     forall e:element_t [insert_(l1,cu1,e,l2),equal_(right_(l1,cu1),right_(l2,cu1))].
     	    insert_(l1,cu1,e,l2) -> equal_(right_(l1,cu1),right_(l2,cu1))

goal next_insert_g :
     forall l1:list. forall l2:list. forall cu1:cursor.
     forall e:element_t [insert_(l1,cu1,e,l2),next_(l2,cu1)].
      	    has_element_(l1,cu1) ->
     	    insert_(l1,cu1,e,l2) -> next_(l1,cu1)=next_(l2,cu1)

goal insert_has_element_g :
     forall l1:list. forall l2:list. forall cu1:cursor. forall cu2:cursor.
     forall e:element_t [insert_(l1,cu1,e,l2),has_element_(l2,cu2)].
     	    insert_(l1,cu1,e,l2) -> has_element_(l1,cu2) -> has_element_(l2,cu2)

goal right_delete_g :
     forall l1:list. forall l2:list. forall cu1:cursor
     [delete_(l1,cu1,l2),equal_(right_(l1,next_(l1,cu1)),right_(l2,next_(l1,cu1)))].
      	    has_element_(l1,cu1) ->
     	    delete_(l1,cu1,l2) -> equal_(right_(l1,next_(l1,cu1)),right_(l2,next_(l1,cu1)))

goal contains_insert_g :
     forall l1:list. forall l2:list. forall cu:cursor. forall e:element_t.
     forall el:element_t [insert_(l1,cu,e,l2),contains_(l1,el)].
     	    insert_(l1,cu,e,l2) -> contains_(l2,el) -> e=el or contains_(l1,el)

goal contains_delete_g :
     forall l1:list. forall l2:list. forall cu:cursor.
     forall el:element_t [delete_(l1,cu,l2),contains_(l1,el)].
     	    delete_(l1,cu,l2) -> contains_(l2,el) -> contains_(l1,el)

goal equal_refl_g :
      forall l1:list. forall l2:list.
      	     equal_(l1,l2) -> equal_(l2,l1)

goal equal_trans_g :
      forall l1:list. forall l2:list. forall l3:list [equal_(l2,l3),equal_(l1,l3) | equal_(l1,l2),equal_(l1,l3)].
      	     equal_(l1,l2) -> equal_(l2,l3) -> equal_(l1,l3)

(*** REDONDANT AXIOMS (for Alt-Ergo) *)

axiom left_contains :
      forall s:list. forall cu:cursor. forall e:element_t [contains_(left_(s,next_(s,cu)),e)].
      	     has_element_(s,cu) ->
	     contains_(left_(s,next_(s,cu)),e) -> contains_(left_(s,cu),e) or e=element_(s,cu)

axiom left_length :
      forall s:list. forall cu:cursor. forall e:element_t [length_(left_(s,next_(s,cu)))].
      	     has_element_(s,cu) ->
	     length_(left_(s,cu))+1=length_(left_(s,next_(s,cu)))

axiom right_equal :
     forall s:list. forall cu:cursor. forall s2:list [equal_(right_(s,next_(s,cu)),right_(s2,next_(s,cu)))].
     	  has_element_(s,cu) -> equal_(right_(s,cu),right_(s2,cu)) ->
	  equal_(right_(s,next_(s,cu)),right_(s2,next_(s,cu)))

axiom right_equal_next :
     forall s:list. forall cu:cursor. forall s2:list [equal_(right_(s,cu),right_(s2,cu)),next_(s,cu)].
     	  has_element_(s,cu) -> equal_(right_(s,cu),right_(s2,cu)) ->
	  next_(s,cu)=next_(s2,cu)

axiom right_insert :
     forall l1:list. forall l2:list. forall cu1:cursor.
     forall e:element_t [insert_(l1,cu1,e,l2),equal_(right_(l1,cu1),right_(l2,cu1))].
     	    insert_(l1,cu1,e,l2) -> equal_(right_(l1,cu1),right_(l2,cu1))

axiom next_insert :
     forall l1:list. forall l2:list. forall cu1:cursor.
     forall e:element_t [insert_(l1,cu1,e,l2),next_(l2,cu1)].
      	    has_element_(l1,cu1) ->
     	    insert_(l1,cu1,e,l2) -> next_(l1,cu1)=next_(l2,cu1)

axiom insert_has_element :
     forall l1:list. forall l2:list. forall cu1:cursor. forall cu2:cursor.
     forall e:element_t [insert_(l1,cu1,e,l2), has_element_(l2,cu2)].
     	    insert_(l1,cu1,e,l2) -> has_element_(l1,cu2) -> has_element_(l2,cu2)

axiom right_delete :
     forall l1:list. forall l2:list. forall cu1:cursor
     [delete_(l1,cu1,l2),equal_(right_(l1,next_(l1,cu1)),right_(l2,next_(l1,cu1)))].
      	    has_element_(l1,cu1) ->
     	    delete_(l1,cu1,l2) -> equal_(right_(l1,next_(l1,cu1)),right_(l2,next_(l1,cu1)))

axiom contains_insert :
     forall l1:list. forall l2:list. forall cu:cursor. forall e:element_t.
     forall el:element_t [insert_(l1,cu,e,l2),contains_(l1,el)].
     	    insert_(l1,cu,e,l2) -> contains_(l2,el) -> e=el or contains_(l1,el)

axiom contains_delete :
     forall l1:list. forall l2:list. forall cu:cursor.
     forall el:element_t [delete_(l1,cu,l2),contains_(l1,el) | delete_(l1,cu,l2),contains_(l2,el)].
     	    delete_(l1,cu,l2) -> contains_(l2,el) -> contains_(l1,el)

axiom equal_refl :
      forall l1:list. forall l2:list.
      	     equal_(l1,l2) -> equal_(l2,l1)

axiom equal_trans :
      forall l1:list. forall l2:list. forall l3:list [equal_(l2,l3),equal_(l1,l3) | equal_(l1,l2),equal_(l1,l3)].
      	     equal_(l1,l2) -> equal_(l2,l3) -> equal_(l1,l3)

(*** UNIT-TESTS ***)

let test_replace_element1 (co:list ref) (cu:cursor) (cun:cursor) (e:element_t) =
    { has_element_(co,cu) and has_element_(co,cun) and not cu=cun }
    replace_element co cu e
    { element_(co,cu)=e and element_(co,cun)=element_(co@,cun) and has_element_(co,cun)
    and position_(co,cun)=position_(co@,cun) and false }

logic p : element_t -> prop

predicate p_forall_cont (co:list) =
	  forall cu:cursor.
	  	 has_element_(co,cu) -> p(element_(co,cu))

let test_replace_element2 (co:list ref) (cu:cursor) (e:element_t) =
    { has_element_(co,cu) and p(e) and p_forall_cont(co) }
    replace_element co cu e
    { p_forall_cont(co) and element_(co,cu)=e and has_element_(co,cu) and false }

let test_insert1 (co:list ref) (cu:cursor) (e:element_t) (cu2:cursor) =
    { has_element_(co,cu) and p(e) and p_forall_cont(co) and has_element_(co,cu2) }
    insert co cu e
    { p_forall_cont(co) and position_(co,cu)=1+position_(co@,cu) and 
    element_(co,previous_(co,cu))=e and 
    element_(co,cu2)=element_(co@,cu2) and has_element_(co,cu2)
    and length_(co)=length_(co@)+1 and false }

let test_insert2 (co:list ref) (e:element_t) (cu2:cursor) =
    { p(e) and p_forall_cont(co) and has_element_(co,cu2) }
    insert co no_element e
    { p_forall_cont(co)  and element_(co,last_(co))=e and element_(co,cu2)=element_(co@,cu2) and
    p(element_(co@,cu2)) and
    p(element_(co,cu2)) and length_(co)=length_(co@)+1 and has_element_(co,cu2)
    and false}

let test_delete (co:list ref) (cu:cursor) (cun:cursor) =
    { has_element_(co,cu) and p_forall_cont(co) and has_element_(co,next_(co,cu)) and 
    has_element_(co,previous_(co,cu)) and has_element_(co,cun) and not cun=cu }
    delete co cu
    { p_forall_cont(co) and not has_element_(co,cu) and 
     position_(co,next_(co@,cu))=position_(co@,next_(co@,cu))-1 and
     position_(co,previous_(co@,cu))=position_(co@,previous_(co@,cu)) and
     has_element_(co,cun) and element_(co,cun)=element_(co@,cun)
     and length_(co)=length_(co@)-1 and false }

let test_insert_delete1 (co:list ref) (cu:cursor) (cun:cursor) (e:element_t) =
    { has_element_(co,cu) and p_forall_cont(co) and has_element_(co,cun) }
    insert co cu e;
    delete co (previous !co cu)
    { p_forall_cont(co) and element_(co,cun)=element_(co@,cun) and false }

let test_insert_delete2 (co:list ref) (cun:cursor) (e:element_t) =
    {p_forall_cont(co) and has_element_(co,cun) }
    insert co no_element e;
    delete co (last !co)
    { p_forall_cont(co) and element_(co,cun)=element_(co@,cun) and false }

let test_left1 (co:list) (cu:cursor) =
    { position_(co,cu)>1 }
    void
    { is_empty_(left_(co,first_(co))) and
      co=left_(co,no_element) and
      previous_(co,cu)=last_(left_(co,cu)) and
      false }

let test_left2 (co1:list) (co2:list) (cu:cursor) =
    { has_element_(co1,cu) and has_element_(co2,cu) and length_(left_(co1,cu))=length_(left_(co2,cu)) }
    void
    { position_(co1,cu)=position_(co2,cu) and
      false }

let test_left3 (co1:list) (co2:list) (cu:cursor) =
    { has_element_(co1,cu) and has_element_(co2,cu) and position_(co1,cu)=position_(co2,cu) }
    void
    { length_(left_(co1,cu))=length_(left_(co2,cu)) and
      false }

let test_right1 (co:list) (cu:cursor) (l:list) =
    { has_element_(co,cu) and right_(co,cu)=l }
    void
    { is_empty_(right_(co,no_element)) and
      first_(right_(co,cu))=cu and
      equal_(co,right_(co,first_(co))) and
      next_(co,cu)=next_(l,cu) and
      false }

let test_right2 (co1:list) (co2:list) (cu:cursor) =
    { has_element_(co2,cu) and right_(co1,cu)=right_(co2,cu) }
    void
    { has_element_(co1,cu) }

let test_find (co:list) (cu:cursor) (e:element_t) =
    { has_element_(co,cu) and element_(co,cu)=e }
    void
    { contains_(co,e) and false }

let test_false (co:list ref) (cu:cursor) =
    { not is_empty_(co) }
    void
    { false }

(*** TESTS ***)

parameter contains :
l : list -> e : element_t ->
{}
bool
{if result then contains_(l,e) else not contains_(l,e)} 

let conditional_insert (l : list ref) (e : element_t) =
	if not contains !l e then
		append l e
	{ contains_ (l, e) }

(* removing an element from a list decreases its length by one *)
let test1 (li : list ref) (c : cursor) =
  { has_element_ (li, c) }
  let n = next !li c in
  if has_element !li n then
    delete li n
  else
    delete li c
  { length_ (li) = length_ (li@) - 1}

(* take a list of 4 elements, prepend element e, remove all initial 4 elements
   and take the last element of the list, it is e *)
let test2 (li : list ref) (e : element_t) =
  { length_ (li) = 4 }
  prepend li e;
  let c = ref last !li in
  delete li !c;
  c := first !li;
  c := next !li (first !li);
  delete li !c;
  c := last !li;
  delete li !c;
  c := last !li;
  delete li !c;
  element !li (last !li)
  { result = e }

(* adding elements to a list does not invalidate an existing cursor *)
let test3 (li : list ref) (c,d,f,g,h : cursor) (e : element_t) =
  { position_ (li, c) = 4 and has_element_ (li, f) and position_ (li, h) <> 0 }
  insert li c e;
  append li e;
  if has_element !li d then
    insert li d e;
  insert li f e;
  if length !li > 5 then
    if curs_equal g (next !li c) then
      insert li g e
    else
      insert li h e
  { has_element_(li,c) }

(* iterate through the list and increment a counter, which should equal 
   the length of the list on exit *)
let test4 (li : list) =
  let n = ref 0 in
  let c = ref first li in
  while has_element li !c do
    { invariant
	(has_element_(li,c) or c=no_element) and 
      	n = length_(left_(li, c))
    }
    n := !n + 1;
    c := next li !c
  done;
  !n
  { result = length_ (li) }

(* iterate through the list by adding element e at every position. This doubles
   the size of the list *)

let test5 (li : list ref) (e : element_t) =
  { not is_empty_(li) }
  let c = ref first !li in
  init:
  while has_element !li !c do
    { invariant
	(((has_element_(li@init,c) and has_element_(li,c)) or c=no_element) and
	length_(left_(li,c))=2*length_(left_(li@init,c)) and
      	equal_(right_(li,c),right_(li@init,c)))
    }
    iloop:
    insert li !c e;
    c := next !li !c
  done
  { length_ (li) = 2 * length_ (li@) and false }

(* Removes some elements from li and stores them in removed *)
logic fun_test : element_t -> bool

let interm6 (li:list ref) (removed:list ref) (c:cursor ref) =
    { has_element_(li,c) }
    let c_int = next !li !c in
    append removed (element !li !c);
    delete li !c;
    c := c_int
    { ((has_element_(li@,c) and has_element_(li,c)) or c=no_element) and
	length_(left_(li,c))+length_(removed)=length_(left_(li@,c))+length_(removed@) and
      	equal_(right_(li,c),right_(li@,c)) and c=next_(li@,c@) }

let test6 (li:list ref) (removed:list ref) =
  { not is_empty_(li) and is_empty_(removed) }
  let c = ref first !li in
  init:
  while has_element !li !c do
    { invariant
	(((has_element_(li@init,c) and has_element_(li,c)) or c=no_element) and
	length_(left_(li,c))+length_(removed)=length_(left_(li@init,c)) and
      	equal_(right_(li,c),right_(li@init,c)))
    }
    if fun_test(element !li !c) then
    interm6 li removed c
  done
   { length_(li)+length_(removed)=length_(li@) and false }

exception Return

let test7 (s:list) (e:element_t) (c:cursor ref) =
    c:= first s;
    let res = ref false in
    try
      while has_element s !c do
    	  { invariant
	    ((has_element_(s,c) or c=no_element) and
	    (not contains_(left_(s,c),e))) }
	    if elt_equal e (element s !c) then
	       raise Return
	    else c:=next s !c
      done
    with Return -> res := true end;
    ! res
    { (result=true <-> contains_(s,e)) and find_(s,e,first_(s))=c and false }

let my_find (s : list) (e : element_t) (f : cursor) =
  { has_element_ (s, f) }
  let c = ref f in
  try
    while has_element s !c do
      { invariant
        (has_element_(right_(s, f), c) or c=no_element) and
        find_(left_(right_(s, f), c), e, f) = no_element
      }
      if elt_equal e (element s !c) then
        raise Return
      else c := next s !c
    done
  with Return -> void end;
  !c
  { result = find_(s, e, f)}

(*** MAX TESTS ***)


logic compare_ : element_t, element_t -> int

predicate is_max (v:list,cu:cursor) =
	  has_element_(v,cu) and
	  (forall e:element_t.
		 contains_(v,e) -> compare_(element_(v,cu),e)>=0)

logic max_ : list -> cursor

axiom is_max_max :
      forall v:list.
      	     (not is_empty_(v) -> is_max(v,max_(v)))

parameter max :
	  v:list ->
	  { not is_empty_(v) }
	  cursor
	  { result=max_(v) }


(* Heap : all the elements of result are bigger than those still in v_min *)
let test_max (v_min:list ref) (n:int) =
    { length_(v_min)>=n }
    init:
    let i=ref 1 in
    let v_max=ref empty_ in
    if !i<=n then
    while !i<=n do
    	  { invariant
	    (length_(v_min)=length_(v_min@init)-i+1 and
	    forall cu1:cursor. forall cu2:cursor. has_element_(v_max,cu1) ->
	    has_element_(v_min,cu2) ->
	    compare_(element_(v_max,cu1),element_(v_min,cu2))>=0)}
    	  append v_max (element !v_min (max !v_min));
	  delete v_min (max !v_min);
	  i := !i+1
    done;
    !v_max
    { (forall cu1:cursor. forall cu2:cursor. has_element_(result,cu1) ->
	    has_element_(v_min,cu2) ->
	    compare_(element_(result,cu1),element_(v_min,cu2))>=0) and false}

(* More user friendly version *)
let test_max2 (v_min:list ref) (n:int) =
    { length_(v_min)>=n }
    init:
    let i=ref 1 in
    let v_max=ref empty_ in
    if !i<=n then
    while !i<=n do
    	  { invariant
	    (length_(v_min)=length_(v_min@init)-i+1 and
	    forall e1:element_t. forall e2:element_t. contains_(v_max,e1) ->
	    contains_(v_min,e2) ->
	    compare_(e1,e2)>=0)}
    	  append v_max (element !v_min (max !v_min));
	  delete v_min (max !v_min);
	  i := !i+1
    done;
    !v_max
    { (forall e1:element_t. forall e2:element_t. contains_(result,e1) ->
	    contains_(v_min,e2) ->
	    compare_(e1,e2)>=0) and false}

(*** SUM_OF TESTS ***)

logic weight_ : element_t -> int
logic checkk_ : element_t -> prop

parameter weight :
	  e:element_t ->
	  {}
	  int
	  {result=weight_(e)}

axiom positive_weight :
      forall e:element_t.
      	     weight_(e)>=0

parameter checkk :
	  e:element_t ->
	  {}
	  bool
	  {result=true <-> checkk_(e)}

(* Sum_of_weight and some axioms *)
logic sum_of_weight : list -> int

axiom sum_of_weight_delete :
      forall v1:list. forall v2:list. forall cu:cursor [sum_of_weight(v2),delete_(v1,cu,v2)].
      	     delete_(v1,cu,v2) -> sum_of_weight(v2)=sum_of_weight(v1)-weight_(element_(v1,cu))

axiom sum_of_weight_insert :
      forall v1:list. forall v2:list. forall cu:cursor. forall e:element_t[sum_of_weight(v2),insert_(v1,cu,e,v2)].
      	     insert_(v1,cu,e,v2) -> sum_of_weight(v2)=sum_of_weight(v1)+weight_(e)

axiom sum_of_weight_null :
      forall v:list[sum_of_weight(v)].
      	     is_empty_(v) -> sum_of_weight(v)=0

axiom sum_of_weight_equal :
      forall v1:list. forall v2:list[sum_of_weight(v1)].
      	     equal_(v1,v2) -> sum_of_weight(v1)=sum_of_weight(v2)

axiom sum_of_weight_left :
      forall v:list. forall cu:cursor[sum_of_weight(left_(v,next_(v,cu)))].
      	     has_element_(v,cu) ->
	     sum_of_weight(left_(v,next_(v,cu)))=sum_of_weight(left_(v,cu))+weight_(element_(v,cu))

(* deletes some elements from v and then inserts an equivalent element *)
let test_sum_of (v:list ref) (w:int ref) (e:element_t) =
    init:
    w:=0;
    let c= ref (first !v) in
    while has_element !v !c do
    	  { invariant
	    (sum_of_weight(v)=sum_of_weight(v@init)-w)
    	  }
    	  if (checkk (element !v !c)) then
	     (w := !w+(weight(element !v !c));
	     delete v !c)
	  else c:=next !v !c
    done;
    assert { weight_(e)=w };(* IMPOSSIBLE TO PROVE *)
    append v e
    { sum_of_weight(v)=sum_of_weight(v@) }

(* deletes elements from v until their total weight exceeds wmin *)
let test_sum_of2 (v:list ref) (w:int ref) (wmin : int) =
    { wmin <= sum_of_weight(v) }
    init:
    w:=0;
    if !w<wmin then
    while !w<wmin do
    	  { invariant
	    (sum_of_weight(v)=sum_of_weight(v@init)-w)
    	  }
    	 w := !w+(weight (element !v (first !v)));
	 delete v (first !v)
    done
    { sum_of_weight(v)=sum_of_weight(v@)-w and w>=wmin }

(* computes sum_of_weight(v) *)
let test_sum_of3 (v:list) =
    init:
    let w = ref 0 in
    let c = ref (first v) in
    if has_element v !c then
    while has_element v !c do
    	  { invariant
	    (w=sum_of_weight(left_(v,c)) and
	    (has_element_(v,c) or c=no_element))
    	  }
    	 w := !w+(weight(element v !c));
	 c := next v !c
    done;
    !w
    { sum_of_weight(v)=result }

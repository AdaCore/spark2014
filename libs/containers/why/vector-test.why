include "vector.why"

(* Everything works with alt-ergo (sans -redondance) in 10s *)

(*** UNIT-TESTS ***)

(*** INDEX ***)

let test_replace_element1 (co:vector ref) (i:int) (j:int) (e:element_t) =
    { length_(co)>=i>0 and length_(co)>=j>0 and i<>j }
    replace_element co i e
    { element_(co,i)=e and element_(co,j)=element_(co@,j)
     and false }

logic p : element_t -> prop

predicate p_forall_cont (co:vector) =
	  forall i:int.
	  	 length_(co)>=i>0 -> p(element_(co,i))

let test_replace_element2 (co:vector ref) (i:int) (e:element_t) =
    { length_(co)>=i>0 and p(e) and p_forall_cont(co) }
    replace_element co i e
    { p_forall_cont(co) and element_(co,i)=e and false }

let test_insert (co:vector ref) (i:int) (e:element_t) (j:int) =
    { length_(co)+1>=i>0 and p(e) and p_forall_cont(co) and length_(co)+1>=j>0 }
    insert co i e
    { p_forall_cont(co) and element_(co,i)=e and 
    (j>i -> element_(co,j)=element_(co@,j-1)) and 
    (j<i -> element_(co,j)=element_(co@,j)) and
    length_(co)=length_(co@)+1 and false }

let test_delete (co:vector ref) (i:int) (j:int) =
    { length_(co)>=i>0 and p_forall_cont(co) and length_(co)>j>0 and i<>j }
    delete co i
    { p_forall_cont(co) and
     (j>=i -> element_(co,j)=element_(co@,j+1)) and 
     (j<i -> element_(co,j)=element_(co@,j)) and
     length_(co)=length_(co@)-1 and false }

let test_insert_delete (co:vector ref) (i:int) (e:element_t) =
    { length_(co)+1>=i>0 }
    insert co i e;
    delete co i
    { equal_(co,co@) and false }

let test_left1 (co:vector) (i:int) =
    { length_(co)>=i>0 }
    void
    { is_empty_(left_(co,1)) and
      equal_(co,left_(co,length_(co)+1)) and
      length_(left_(co,i))=i-1 and
      false }

let test_right1 (co:vector) (i:int) =
    { length_(co)>=i>1 }
    void
    { is_empty_(right_(co,length_(co)+1)) and
      element_(right_(co,i),1)=element_(co,i) and
      equal_(co,right_(co,1)) and
      false }

let test_contains (co:vector) (i:int) (e:element_t) =
    { length_(co)>=i>0 and element_(co,i)=e }
    void
    { contains_(co,e) and false }

(*** CURSOR ***)
(* Same tests but with cursors instead of index *)

let test_replace_element_curs1 (co:vector ref) (cu:cursor) (cun:cursor) (e:element_t) =
    { has_element_(co,cu) and has_element_(co,cun) and not cu=cun }
    replace_element_curs co cu e
    { element_curs_(co,cu)=e and 
     element_curs_(co,cun)=element_curs_(co@,cun)
     and false }

let test_replace_element_curs2 (co:vector ref) (cu:cursor) (e:element_t) =
    { has_element_(co,cu) and p(e) and p_forall_cont(co) }
    replace_element_curs co cu e
    { p_forall_cont(co) and element_curs_(co,cu)=e and false }

let test_insert_curs1 (co:vector ref) (cu:cursor) (e:element_t) (cun:cursor) =
    { has_element_(co,cu) and has_element_(co,cun) and p(e) and p_forall_cont(co) and length_(co)+1>=to_index_(co,cun)>0 }
    init:
    insert_curs co cu e;
    void
    { p_forall_cont(co) and 
    (0<to_index_(co,cun)<to_index_(co@,cu) -> element_curs_(co,cun)=element_curs_(co@,cun)) and
    length_(co)=length_(co@)+1 and false }

let test_insert_curs2 (co:vector ref) (e:element_t) (cun:cursor) =
    { p(e) and p_forall_cont(co) and has_element_(co,cun) }
    insert_curs co no_element e
    { p_forall_cont(co) and element_curs_(co,last_(co))=e and element_curs_(co,cun)=element_curs_(co@,cun) and
     length_(co)=length_(co@)+1 and
     false}

let test_delete_curs (co:vector ref) (cu:cursor) (cun:cursor) =
    { has_element_(co,cu) and has_element_(co,cun) and p_forall_cont(co) and
      length_(co)>to_index_(co,cun)>0 and not cu=cun }
    delete_curs co cu
    { p_forall_cont(co) and
     (0<to_index_(co,cun)<to_index_(co@,cu) -> element_curs_(co,cun)=element_curs_(co@,cun)) and
     length_(co)=length_(co@)-1 and false }

let test_insert_delete_curs1 (co:vector ref) (cu:cursor) (e:element_t) =
    {  has_element_(co,cu) }
    let i = to_index_ !co cu in
    insert_curs co cu e;
    delete_curs co (to_cursor_ !co i)
    { equal_(co,co@) and false }

let test_insert_delete_curs2 (co:vector ref) (e:element_t) =
    insert_curs co no_element e;
    delete_curs co (last !co)
    { equal_(co,co@) and false }

let test_contains_curs (co:vector) (cu:cursor) (e:element_t) =
    { has_element_(co,cu) and element_curs_(co,cu)=e }
    void
    { contains_(co,e) and false }

let test_false (co:vector ref) (cu:cursor) =
    { has_element_(co,cu) }
    void
    { false }

let test_find (s:vector) (e:element_t) (i:int ref) =
    i:= 1;
    let b=ref false in
    while !i<=length_(s) && not !b do
    	  { invariant
	    (0<i<=length_(s)+1 and
	    ((b=true and i<=length_(s) and e=element_(s,i)
	    or b=false) and not contains_(left_(s,i),e))) }
	    if elt_equal e (element s !i) then
	       b:=true
	    else i:=!i+1
    done;
    if !i=length_(s)+1 then
       i:=0;
    !b
    { (result=true <-> contains_(s,e)) and find_(s,e,1)=i and false }

(*** SUM_OF TESTS ***)

logic weight_ : element_t -> int
logic checkk_ : element_t -> prop

parameter weight :
	  e:element_t ->
	  {}
	  int
	  {result=weight_(e)}

axiom positive_weight :
      forall e:element_t.
      	     weight_(e)>=0

parameter checkk :
	  e:element_t ->
	  {}
	  bool
	  {result=true <-> checkk_(e)}

(* Sum_of_weight and some axioms *)
logic sum_of_weight : vector -> int

axiom sum_of_weight_delete :
      forall v1:vector. forall v2:vector. forall i:int [sum_of_weight(v2),delete_(v1,i,v2)].
      	     delete_(v1,i,v2) -> sum_of_weight(v2)=sum_of_weight(v1)-weight_(element_(v1,i))

axiom sum_of_weight_insert :
      forall v1:vector. forall v2:vector. forall i:int. forall e:element_t [sum_of_weight(v2),insert_(v1,i,e,v2)].
      	     insert_(v1,i,e,v2) -> sum_of_weight(v2)=sum_of_weight(v1)+weight_(e)

axiom sum_of_weight_null :
      forall v:vector[sum_of_weight(v)].
      	     is_empty_(v) -> sum_of_weight(v)=0

axiom sum_of_weight_equal :
      forall v1:vector. forall v2:vector[sum_of_weight(v1)].
      	     equal_(v1,v2) -> sum_of_weight(v1)=sum_of_weight(v2)

axiom sum_of_weight_left :
      forall v:vector. forall i:int[sum_of_weight(left_(v,i))].
      	     length_(v)+1>=i>1 -> sum_of_weight(left_(v,i))=sum_of_weight(left_(v,i-1))+weight_(element_(v,i-1))

(* deletes some elements from v *)
let test_sum_of (v:vector ref) (w:int ref) (e:element_t)  =
    init:
    w:=0;
    let c= ref (first !v) in
    while has_element !v !c do
    	  { invariant
	    (sum_of_weight(v)=sum_of_weight(v@init)-w)
    	  }
    	  if (checkk (element_curs !v !c)) then
	     (w := !w+(weight(element_curs !v !c));
	     delete_curs v !c)
	  else c:=next !v !c
    done;
    assert { weight_(e)=w };(* IMPOSSIBLE TO PROVE *)
    append v e
    { sum_of_weight(v)=sum_of_weight(v@) }

(* deletes elements from v until their total weight exceeds wmin *)
let test_sum_of2 (v:vector ref) (w:int ref) (wmin : int) =
    { wmin <= sum_of_weight(v) }
    init:
    w:=0;
    if !w<wmin then
    while !w<wmin do
    	  { invariant
	    (sum_of_weight(v)=sum_of_weight(v@init)-w)
    	  }
    	 w := !w+(weight(element !v 1));
	 delete v 1
    done
    { sum_of_weight(v)=sum_of_weight(v@)-w and w>=wmin }

(* computes sum_of_weight(v) *)
let test_sum_of3 (v:vector) =
    init:
    let w = ref 0 in
    let i = ref 1 in
    if !i<=length v then
    while !i<=length v do
    	  { invariant
	    (w=sum_of_weight(left_(v,i)) and
	    length_(v)+1>=i>0 )
    	  }
    	 w := !w+(weight(element v !i));
	 i := !i+1
    done;
    assert{equal_(v,left_(v,i))};
    !w
    { sum_of_weight(v)=result and false }

(*** MAX TESTS ***)


logic compare_ : element_t, element_t -> int

predicate is_max (v:vector,j:int) =
	  0<j<=length_(v) and
	  (forall i:int.
		 0<i<=length_(v) -> compare_(element_(v,j),element_(v,i))>=0)

logic max_ : vector -> int

axiom is_max_max :
      forall v:vector.
      	     (not is_empty_(v) -> is_max(v,max_(v)))

parameter max :
	  v:vector ->
	  { not is_empty_(v) }
	  int
	  { result=max_(v) }


(* Heap : all the elements of result are bigger than those still in v_min *)
let test_max (v_min:vector ref) (n:int) =
    { length_(v_min)>=n }
    init:
    let i=ref 1 in
    let v_max=ref empty_ in
    if !i<=n then
    while !i<=n do
    	  { invariant
	    (length_(v_min)=length_(v_min@init)-i+1 and
	    forall i1:int. forall i2:int. 0<i1<=length_(v_max) ->
	    0<i2<=length_(v_min) ->
	    compare_(element_(v_max,i1),element_(v_min,i2))>=0)}
    	  append v_max (element !v_min (max !v_min));
	  delete v_min (max !v_min);
	  i := !i+1
    done;
    !v_max
    { (forall i1:int. forall i2:int. 0<i1<=length_(result) ->
	    0<i2<=length_(v_min) ->
	    compare_(element_(result,i1),element_(v_min,i2))>=0) and false}


(* More user friendly version, not easy to prove *)
let test_max2 (v_min:vector ref) (n:int) =
    { length_(v_min)>=n }
    init:
    let i=ref 1 in
    let v_max=ref empty_ in
    if !i<=n then
    while !i<=n do
    	  { invariant
	    (length_(v_min)=length_(v_min@init)-i+1 and
	    forall e1:element_t. forall e2:element_t. contains_(v_max,e1) ->
	    contains_(v_min,e2) ->
	    compare_(e1,e2)>=0)}
    	  append v_max (element !v_min (max !v_min));
	  delete v_min (max !v_min);
	  i := !i+1
    done;
    !v_max
    { (forall e1:element_t. forall e2:element_t. contains_(result,e1) ->
	    contains_(v_min,e2) ->
	    compare_(e1,e2)>=0) and false}

(*** GOALS ***)

goal contains_insert :
     forall l1:vector. forall l2:vector. forall i:int. forall e:element_t. forall el:element_t.
     	    insert_(l1,i,e,l2) -> contains_(l2,el) -> e=el or contains_(l1,el)

goal contains_delete :
     forall l1:vector. forall l2:vector. forall i:int. forall el:element_t.
     	    delete_(l1,i,l2) -> contains_(l2,el) -> contains_(l1,el)
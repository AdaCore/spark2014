include "real.why"

(*** TYPES ***)

type cursor
type map
type element_t
type key_t

logic no_element : cursor
logic empty_ : map

(*** LENGTH ***)

logic length_ : map -> int

axiom length_gte_zero :
      forall co:map [length_(co)].
      	     0<=length_(co)

(*** EQUIVALENCE BETWEEN ELEMENTS ***)

logic witness : key_t -> real

(*** POSITION ***)

logic position_ : map, cursor -> int

axiom position_gte_zero :
      forall co:map. forall cu:cursor.
      	     0<=position_(co,cu)<=length_(co)

axiom position_no_element :
      forall co:map.
      	     position_(co, no_element) = 0

axiom position_eq :
      forall co:map. forall cu1:cursor. forall cu2:cursor.
      	     position_(co,cu1)>0 -> position_(co,cu1)=position_(co,cu2) -> cu1=cu2

(*** IS_EMPTY ***)

predicate is_empty_ (co:map)=
	  (forall cu:cursor.
	  	 position_(co,cu)=0)

axiom length_is_empty :
      forall co:map.
      	     is_empty_(co)->length_(co)=0

axiom empty_is_empty :
      is_empty_(empty_)

(*** NEXT ***)

predicate next__ (co:map, cu1:cursor, cu2:cursor) =
	  (length_(co)>position_(co,cu1)>0 or position_(co,cu2)>0 -> position_(co,cu2)=position_(co,cu1)+1)
	  and (length_(co)>0 and position_(co,cu1)=length_(co) or cu1=no_element -> cu2=no_element)

logic next_ : map, cursor -> cursor

axiom next_next :
      forall co:map. forall cu:cursor [next_(co,cu)].
      	     next__(co,cu,next_(co,cu))

(*** FIRST ***)

predicate first__ (co:map,cu:cursor) =
	  ((not is_empty_(co)) -> position_(co,cu)=1)
	  and (is_empty_(co) -> cu=no_element)

logic first_ : map -> cursor

axiom first_first :
      forall co:map [first_(co)].
      	     first__(co,first_(co))

(*** KEY ***)

logic key_ : map, cursor -> key_t


(*** FIND ***)
logic find_ : map, real -> cursor

predicate find__ (co:map,i:real,cu:cursor) =
	  ((cu=no_element and (forall cun:cursor. position_(co,cun)>0 -> witness(key_(co,cun))<>i))
	  or (position_(co,cu)>0 and witness(key_(co,cu))=i
	  and (forall cun:cursor. position_(co,cun)>0 -> 
	   cu<>cun -> witness(key_(co,cun))<>i)))

axiom find_find_val :
      forall co:map. forall i:real.
	     find__(co,i,find_(co,i)) and
	     (is_empty_(co) -> find_(co,i)=no_element)

(*** ELEMENT ***)

logic element_ : map, cursor -> element_t

(*** ELEMENT__ ***)

function element__ (m:map,i:real) : element_t =
	 element_(m,find_(m,i))

(*** LEFT ***)

predicate left_pos (co:map,i:int,col:map) =
	  forall cu:cursor.
	    (i<=position_(co,cu) -> position_(col,cu)=0)
	    and (i>position_(co,cu) -> position_(col,cu)=position_(co,cu)
	    	 and key_(col,cu)=key_(co,cu)
	    	 and element_(col,cu)=element_(co,cu))
	    and (position_(col,cu)>0 -> position_(co,cu)=position_(col,cu))

predicate left_find (co:map,i:int,col:map) =
	  forall w:real.
	    i>position_(co,find_(co,w))>0 or position_(col,find_(col,w))>0 ->
	    find_(co,w)=find_(col,w)

predicate left__ (co:map, cu:cursor, col:map) =
	  (cu=no_element -> col=co)
	  and (position_(co,cu)>0 -> 
	  length_(col)=position_(co,cu)-1 and left_pos(co,position_(co,cu),col)
	  and left_find(co,position_(co,cu),col))

logic left_ : map, cursor -> map

axiom left_left :
      forall co:map. forall cu:cursor [left_(co,cu)].
      	     left__(co,cu,left_(co,cu))


(*** RIGHT ***)

predicate right_pos (co:map,i:int,cor:map) =
	  forall cu:cursor.
	    (i>position_(co,cu) -> position_(cor,cu)=0)
	    and (i<=position_(co,cu) -> position_(cor,cu)=position_(co,cu)-i+1
	    	 and key_(cor,cu)=key_(co,cu)
	    	 and element_(cor,cu)=element_(co,cu))
	    and (position_(cor,cu)>0 -> position_(co,cu)=position_(cor,cu)+i-1)

predicate right_find (co:map,i:int,cor:map) =
	  forall w:real.
	    i<=position_(co,find_(co,w)) and i>0 or position_(cor,find_(cor,w))>0 ->
	    find_(co,w)=find_(cor,w)

predicate right__ (co:map, cu:cursor, cor:map) =
	  (cu=no_element -> cor=empty_)
	  and (position_(co,cu)>0 ->
	      length_(cor)=length_(co)-position_(co,cu)+1 and
	      right_pos(co,position_(co,cu),cor) and
	      right_find(co,position_(co,cu),cor))
	  and (forall cun:cursor.
	      	      position_(cor,cun)>0 -> position_(co,cun)>0)

logic right_ : map, cursor -> map

axiom right_right:
      forall co:map. forall cu:cursor [right_(co,cu)].
      	     right__(co,cu,right_(co,cu))

(*** REPLACE ***)

predicate replace_ (co1:map,k:key_t,e:element_t,co2:map) =
	  position_(co1,find_(co1,witness(k)))>0 and length_(co1)=length_(co2) and
	  key_(co2,find_(co1,witness(k)))=k and
	  element_(co2,find_(co1,witness(k)))=e and
	  (forall cun:cursor.
	  	 position_(co2,cun)=position_(co1,cun) and
		 (not cun=find_(co1,witness(k)) -> key_(co2,cun)=key_(co1,cun) and
		      element_(co2,cun)=element_(co1,cun))) and
(* RD *)  (forall w:real.
	  	  find_(co1,w)=find_(co2,w))

(*** REPLACE_ELEMENT ***)		 

predicate replace_element_ (co1:map,cu:cursor,e:element_t,co2:map) =
	  position_(co1,cu)>0 and
	  element_(co2,cu)=e and
	  length_(co1)=length_(co2) and
	  (forall cun:cursor.
	  	  position_(co1,cun)=position_(co2,cun) and
		 (position_(co1,cun)>0 -> 
		 	key_(co2,cun)=key_(co1,cun) and
		        (cu<>cun -> element_(co2,cun)=element_(co1,cun)))) and
	  (forall w:real.
	  	  find_(co1,w)=find_(co2,w))

(*** INSERT ***)

predicate insert_find (co1:map,k:key_t,e:element_t,co2:map) =
	  forall w:real.
	    (witness(k)<>w -> find_(co1,w)=find_(co2,w)) and
	    (witness(k)=w -> find_(co1,w)=no_element and position_(co2,find_(co2,w))>0)

predicate insert_pos (co1:map,k:key_t,e:element_t,co2:map) =
	  forall cun:cursor.
	    (position_(co1,cun)>0 -> position_(co2,cun)>0 and key_(co1,cun)=key_(co2,cun)
	    			  and element_(co1,cun)=element_(co2,cun))
	    and (position_(co1,cun)=0 -> position_(co2,cun)=0 or position_(co2,cun)>0 and key_(co2,cun)=k
	    			  and element_(co2,cun)=e)

predicate insert_inv (co1:map,k:key_t,e:element_t,co2:map) =
	  forall cun:cursor.
	    (position_(co2,cun)>0 ->
	     position_(co1,cun)=0 and key_(co2,cun)=k and element_(co2,cun)=e or
	     position_(co1,cun)>0 and
	     element_(co1,cun)=element_(co2,cun) and
	     key_(co1,cun)=key_(co2,cun)) and
	    (position_(co2,cun)=0 -> position_(co1,cun)=0)

predicate insert_ (co1:map,k:key_t,e:element_t,co2:map) =
	  position_(co2,find_(co2,witness(k)))>0 and
	  length_(co2)=length_(co1)+1 and
	  insert_pos(co1,k,e,co2) and
	  insert_inv(co1,k,e,co2) and
(* RD *)  insert_find(co1,k,e,co2)

(*** DELETE ***)

predicate delete_find (co1:map,k:key_t,co2:map) =
	  forall w:real.
	    (witness(k)<>w -> find_(co1,w)=find_(co2,w)) and
	    (witness(k)=w -> find_(co2,w)=no_element)

predicate delete_pos (co1:map, i:int, co2:map) =
	  forall cun:cursor.
	    (position_(co1,cun)=i ->
	     position_(co2,cun)=0)
	    and (position_(co1,cun)>0 and position_(co1,cun)<> i ->
	     position_(co2,cun)>0 and
	     key_(co2,cun)=key_(co1,cun) and
	     element_(co2,cun)=element_(co1,cun))

predicate delete_inv (co1:map, i:int, co2:map) =
	  forall cun:cursor.
	    (position_(co2,cun)>0 ->
	     position_(co1,cun)>0 and
	     key_(co1,cun)=key_(co2,cun) and
	     element_(co2,cun)=element_(co1,cun))

predicate delete_ (co1:map,cu:cursor,co2:map) =
	  find_(co2,witness(key_(co1,cu)))=no_element and
	  position_(co1,cu)>0 and length_(co2)=length_(co1)-1 and
	  delete_pos(co1,position_(co1,cu),co2) and
	  delete_inv(co1,position_(co1,cu),co2) and
(* RD *)  delete_find(co1,key_(co1,cu),co2)

(*** INCLUDE ***)

predicate include__ (co1:map,k:key_t,e:element_t,co2:map) =
	  (position_(co1,find_(co1,witness(k)))>0 -> replace_(co1,k,e,co2))
	  and (find_(co1,witness(k))=no_element -> insert_ (co1,k,e,co2))

(*** EXCLUDE ***)

predicate exclude_ (co1:map,k:key_t,co2:map) =
	  (position_(co1,find_(co1,witness(k)))>0 -> delete_(co1,find_(co1,witness(k)),co2))
	  and (find_(co1,witness(k))=no_element -> co1=co2)

(*** HAS_ELEMENT ***)

predicate has_element_(co:map, cu:cursor) =
	  position_(co,cu)>0

(*** CONTAINS ***)

predicate contains_ (co:map,i:real) =
	  position_(co,find_(co,i))>0 

axiom empty_contains :
     forall s:map [is_empty_(s)]. (forall i:real. not contains_(s,i)) -> is_empty_(s)

(*** EQUAL ***)

predicate equal_ (co1:map,co2:map) =
	  forall cu:cursor.
	  	 position_(co1,cu)=position_(co2,cu) and
		 (position_(co1,cu)>0 -> key_(co1,cu)=key_(co2,cu) and
	     	 element_(co2,cu)=element_(co1,cu))

(*** EQUIVALENT ***)

predicate equivalent_ (co1:map,co2:map) =
	  (forall i:real.
	  	 contains_(co1,i) -> contains_(co2,i) and
		 element__(co1,i)=element__(co2,i)) and
		 length_(co1)=length_(co2)

axiom equivalent_sym :
      forall co1:map. forall co2:map [equivalent_(co2,co1) | equivalent_(co1,co2)].
      equivalent_(co1,co2) ->
	  equivalent_(co2,co1)

(*** OVERLAP ***)

predicate no_overlaping (co1:map, co2:map) =
	  forall i:real. not contains_(co1,i) or not contains_(co2,i)

(*** PARAMETERS ***)

parameter element :
	  co:map-> cu:cursor ->
	  { has_element_(co,cu) }
	  element_t
	  { result=element_(co,cu) }

parameter key :
	  co:map-> cu:cursor ->
	  { has_element_(co,cu) }
	  key_t
	  { result=key_(co,cu) }

parameter find :
	  co:map-> k:key_t ->
	  { }
	  cursor
	  { result=find_(co,witness(k)) }

parameter replace_element :
	  co:map ref -> cu:cursor -> e:element_t ->
	  { position_(co,cu)>0 }
	  unit reads co writes co
	  { replace_element_(co@,cu,e,co) }

parameter insert :
	  co:map ref -> k:key_t -> e:element_t ->
	  { not contains_(co,witness(k)) }
	  unit reads co writes co
	  { insert_(co@,k,e,co) }

parameter replace :
	  co:map ref -> k:key_t -> e:element_t ->
	  { contains_(co,witness(k)) }
	  unit reads co writes co
	  { replace_(co@,k,e,co) }

parameter include_ :
	  co:map ref -> k:key_t -> e:element_t ->
	  {  }
	  unit reads co writes co
	  { include__ (co@,k,e,co) }

parameter delete :
	  co:map ref -> cu:cursor ->
	  { has_element_(co,cu)}
	  unit reads co writes co
	  { delete_(co@,cu,co) }

parameter exclude :
	  co:map ref -> k:key_t ->
	  {  }
	  unit reads co writes co
	  { exclude_(co@,k,co) }

parameter next :
	  co:map -> cu:cursor ->
	  { cu=no_element or has_element_(co,cu) }
	  cursor 
	  { result=next_(co,cu) }

parameter first :
	  co:map ->
	  { }
	  cursor
	  { result=first_(co) }

parameter has_element :
	  co:map -> cu:cursor ->
	  { }
	  bool
	  { if result then has_element_(co,cu) else position_(co,cu)=0 }

parameter length :
	  co:map ->
	  { }
	  int
	  { result=length_(co) }

parameter equivalent_keys :
	  k1:key_t -> k2:key_t ->
	  { }
	  bool
	  { if result then witness(k1)=witness(k2) else witness(k1)<>witness(k2) }

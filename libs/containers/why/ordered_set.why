include "real.why"

(*** TYPES ***)

type cursor
type set
type element_t

logic no_element : cursor
logic empty_ : set

(*** LENGTH ***)

logic length_ : set -> int

axiom length_gte_zero :
      forall co:set [length_(co)].
      	     0<=length_(co)

(*** EQUIVALENCE BETWEEN ELEMENTS ***)

logic witness : element_t -> real

(*** POSITION ***)

logic position_ : set, cursor -> int

axiom position_gte_zero :
      forall co:set. forall cu:cursor.
      	     0<=position_(co,cu)<=length_(co)

axiom position_no_element :
      forall co:set.
      	     position_(co, no_element) = 0

axiom position_eq :
      forall co:set. forall cu1:cursor. forall cu2:cursor.
      	     position_(co,cu1)>0 -> position_(co,cu1)=position_(co,cu2) -> cu1=cu2

(*** ELEMENT ***)

logic element_ : set, cursor -> element_t

(*** IS_EMPTY ***)

predicate is_empty_ (co:set)=
	  (forall cu:cursor.
	  	 position_(co,cu)=0)

axiom length_is_empty :
      forall co:set.
      	     is_empty_(co)->length_(co)=0

axiom empty_is_empty :
      is_empty_(empty_)


(*** PREVIOUS ***)

predicate previous__ (co:set, cu1:cursor, cu2:cursor) =
	  (position_(co,cu1)>1 -> position_(co,cu2)=position_(co,cu1)-1)
	  and (position_(co,cu1)=1 or cu1=no_element -> cu2=no_element)

logic previous_ : set, cursor -> cursor

axiom previous_previous :
      forall co:set. forall cu:cursor [previous_(co,cu)].
      	     previous__(co,cu,previous_(co,cu))

(*** NEXT ***)

predicate next__ (co:set, cu1:cursor, cu2:cursor) =
	  (length_(co)>position_(co,cu1)>0 or position_(co,cu2)>0 -> position_(co,cu2)=position_(co,cu1)+1)
	  and (length_(co)>0 and position_(co,cu1)=length_(co) or cu1=no_element -> cu2=no_element)

logic next_ : set, cursor -> cursor

axiom next_next :
      forall co:set. forall cu:cursor [next_(co,cu)].
      	     next__(co,cu,next_(co,cu))

(*** LAST ***)

predicate last__ (co:set,cu:cursor) =
	  (not is_empty_(co) -> position_(co,cu)=length_(co))
	  and (is_empty_(co) -> cu=no_element)

logic last_ : set -> cursor

axiom last_last :
      forall co:set [last_(co)].
      	     last__(co,last_(co))

(*** FIRST ***)

predicate first__ (co:set,cu:cursor) =
	  ((not is_empty_(co)) -> position_(co,cu)=1)
	  and (is_empty_(co) -> cu=no_element)

logic first_ : set -> cursor

axiom first_first :
      forall co:set [first_(co)].
      	     first__(co,first_(co))


(*** FIND ***)
logic find_ : set, real -> cursor

predicate find__ (co:set,i:real,cu:cursor) =
	  ((cu=no_element and (forall cun:cursor. position_(co,cun)>0 -> witness(element_(co,cun))<>i))
	  or (position_(co,cu)>0 and witness(element_(co,cu))=i
	  and (forall cun:cursor. position_(co,cun)>0 -> 
	  cu <> cun -> witness(element_(co,cun))<>i)))

axiom find_find_val :
      forall co:set. forall i:real.
	     find__(co,i,find_(co,i)) and
	     (is_empty_(co) -> find_(co,i)=no_element)

(*** ORDERED ***)

axiom ordered :
      forall s:set. forall cu1:cursor. forall cu2:cursor.
      	     position_(s,cu1)>0 and position_(s,cu2)>0 ->
	     (position_(s,cu2)>position_(s,cu1) <->
	     witness(element_(s,cu2))>witness(element_(s,cu1)))

(*** LEFT ***)

predicate left_pos (co:set,i:int,col:set) =
	  (forall cu:cursor.
	    (position_(co,cu)>=i -> position_(col,cu)=0)
	    and (position_(co,cu)<i -> position_(col,cu)=position_(co,cu))
	    and (position_(col,cu)>0 -> position_(co,cu)=position_(col,cu))) and
	  (forall cu:cursor.
	    position_(co,cu)<i -> element_(col,cu)=element_(co,cu))

predicate left_find (co:set,i:int,col:set) =
	  forall w:real.
	    i>position_(co,find_(co,w))>0 or position_(col,find_(col,w))>0 ->
	    find_(co,w)=find_(col,w)

predicate left__ (co:set, cu:cursor, col:set) =
	  (cu=no_element -> col=co)
	  and (position_(co,cu)>0 -> 
	  length_(col)=position_(co,cu)-1 and left_pos(co,position_(co,cu),col)
	  and left_find(co,position_(co,cu),col))

logic left_ : set, cursor -> set

axiom left_left :
      forall co:set. forall cu:cursor [left_(co,cu)].
      	     left__(co,cu,left_(co,cu))


(*** RIGHT ***)

predicate right_pos (co:set,i:int,cor:set) =
	  (forall cu:cursor.
	    (i>position_(co,cu) -> position_(cor,cu)=0)
	    and (i<=position_(co,cu) -> position_(cor,cu)=position_(co,cu)-i+1)
	    and (position_(cor,cu)>0 -> position_(co,cu)=position_(cor,cu)+i-1)) and
	  (forall cu:cursor.
	    i<=position_(co,cu) -> element_(cor,cu)=element_(co,cu))

predicate right_find (co:set,i:int,cor:set) =
	  forall w:real.
	    i<=position_(co,find_(co,w)) and i>0 or position_(cor,find_(cor,w))>0 ->
	    find_(co,w)=find_(cor,w)

predicate right__ (co:set, cu:cursor, cor:set) =
	  (cu=no_element -> cor=empty_)
	  and (position_(co,cu)>0 ->
	      length_(cor)=length_(co)-position_(co,cu)+1 and
	      right_pos(co,position_(co,cu),cor) and
	      right_find(co,position_(co,cu),cor))
	  and (forall cun:cursor.
	      	      position_(cor,cun)>0 -> position_(co,cun)>0)

logic right_ : set, cursor -> set

axiom right_right:
      forall co:set. forall cu:cursor [right_(co,cu)].
      	     right__(co,cu,right_(co,cu))

(*** REPLACE ***)

predicate replace_ (co1:set,e:element_t,co2:set) =
	  position_(co1,find_(co1,witness(e)))>0 and length_(co1)=length_(co2) and
	  element_(co2,find_(co1,witness(e)))=e and
	  (forall cun:cursor.
	  	 position_(co2,cun)=position_(co1,cun)) and
	  (forall cun:cursor.
	  	 position_(co1,cun)>0 and
		 not cun=find_(co1,witness(e)) -> element_(co2,cun)=element_(co1,cun)) and
          (forall w:real.
	  	  find_(co1,w)=find_(co2,w))

(*** REPLACE_ELEMENT ***)

predicate replace_pos (co1:set,co2:set) =
	  forall cu:cursor.
	  	 (position_(co1,cu)=0 and position_(co2,cu)=0 or
			position_(co1,cu)>0 and position_(co2,cu)>0)		 

predicate replace_element_ (co1:set,cu:cursor,e:element_t,co2:set) =
	  position_(co1,cu)>0 and
	  length_(co1)=length_(co2) and
	  element_(co2,cu)=e and
	  replace_pos(co1,co2) and
	  (forall cun:cursor.
		 (position_(co1,cun)>0 -> cu<>cun -> 
		 	element_(co2,cun)=element_(co1,cun))) and
          (forall w:real.
		  witness(e)=w -> find_(co2,w)=cu) and
          (forall w:real.
	  	  witness(e)<>w and not find_(co1,w)=cu -> find_(co1,w)=find_(co2,w))

(*** CEILING ***)

logic ceiling : set, real -> cursor

predicate is_ceiling (s:set, i:real, cu:cursor) =
	  (cu=no_element or position_(s,cu)>0) and
	  (cu=no_element ->
	    (is_empty_(s) or i>witness(element_(s,last_(s))))) and
	  (position_(s,cu)>0 -> i<=witness(element_(s,cu)) and
	  (witness(element_(s,cu))>i ->
	    find_(s,i)=no_element and
	    (cu=first_(s) or not cu=first_(s) and i>witness(element_(s,last_(left_(s,cu)))))))

axiom ceiling_is_ceiling :
      forall s:set. forall i:real [ceiling(s,i)].
      	     is_ceiling(s,i,ceiling(s,i))

(*** INSERT ***)

predicate insert_find (co1:set,e:element_t,co2:set) =
	  (forall i:real.
	    (i<>witness(e) -> find_(co1,i)=find_(co2,i))) and 
	  (ceiling(co1,witness(e))=no_element -> 
	  	find_(co2,witness(e))=last_(co2)) and
	  (position_(co1,ceiling(co1,witness(e)))>0 -> 
	  	position_(co2,find_(co2,witness(e)))=position_(co1,ceiling(co1,witness(e))))

predicate insert_pos (co1:set,e:element_t,co2:set) =
	  (forall cun:cursor.
	    position_(co1,cun)>0 ->
	    (witness(e)>witness(element_(co1,cun)) -> position_(co2,cun)=position_(co1,cun))
	    and (witness(element_(co1,cun))>witness(e) -> position_(co2,cun)=position_(co1,cun)+1)) and
	  (forall cun:cursor.
	    position_(co1,cun)>0 ->
	    element_(co1,cun)=element_(co2,cun)) and
	  (forall cun:cursor.
	    position_(co1,cun)>0 ->
	    witness(element_(co1,cun))<>witness(e))

predicate insert_inv (co1:set,e:element_t,co2:set) =
	  (forall cun:cursor.
	    0<position_(co2,cun) and witness(element_(co2,cun))=witness(e) -> position_(co1,cun)=0) and
	  (forall cun:cursor.
	    0<position_(co2,cun) and position_(co1,cun)=0 ->
	     element_(co2,cun)=e)

predicate insert_ (co1:set,e:element_t,co2:set) =
	  position_(co2,find_(co2,witness(e)))>0 and
	  length_(co2)=length_(co1)+1 and
	  insert_pos(co1,e,co2) and
	  insert_inv(co1,e,co2) and
	  insert_find(co1,e,co2)


(*** DELETE ***)

predicate delete_find (co1:set,e:element_t,co2:set) =
	  forall w:real.
	    (witness(e)<>w -> find_(co1,w)=find_(co2,w)) and
	    (witness(e)=w -> find_(co2,w)=no_element)

predicate delete_pos (co1:set, i:int, co2:set) =
	  (forall cun:cursor.
	    (position_(co1,cun)=i ->
	     position_(co2,cun)=0)
	    and (position_(co1,cun)>i ->
	     position_(co2,cun)=position_(co1,cun)-1)
	    and (i>position_(co1,cun) ->
	     position_(co2,cun)=position_(co1,cun))) and
	  (forall cun:cursor.
	    position_(co1,cun)<>i ->
	     element_(co2,cun)=element_(co1,cun))

predicate delete_inv (co1:set, i:int, co2:set) =
	  forall cun:cursor.
	    (position_(co2,cun)>0 ->
	     position_(co1,cun)>0)

predicate delete_ (co1:set,cu:cursor,co2:set) =
	  find_(co2,witness(element_(co1,cu)))=no_element and
	  position_(co1,cu)>0 and length_(co2)=length_(co1)-1 and
	  delete_pos(co1,position_(co1,cu),co2) and
	  delete_inv(co1,position_(co1,cu),co2) and
	  delete_find(co1,element_(co1,cu),co2)

(*** INCLUDE ***)

predicate include__ (co1:set,e:element_t,co2:set) =
	  (position_(co1,find_(co1,witness(e)))>0 -> replace_(co1,e,co2))
	  and (find_(co1,witness(e))=no_element -> insert_ (co1,e,co2))

(*** EXCLUDE ***)

predicate exclude_ (co1:set,e:element_t,co2:set) =
	  (position_(co1,find_(co1,witness(e)))>0 -> delete_(co1,find_(co1,witness(e)),co2))
	  and (find_(co1,witness(e))=no_element -> co1=co2)

(*** HAS_ELEMENT ***)

predicate has_element_(co:set, cu:cursor) =
	  position_(co,cu)>0

(*** CONTAINS ***)

predicate contains_ (co:set,i:real) =
	  position_(co,find_(co,i))>0 

axiom empty_contains :
     forall s:set [is_empty_(s)]. (forall i:real. not contains_(s,i)) -> is_empty_(s)

(*** EQUAL ***)

predicate equal_ (co1:set,co2:set) =
	  (forall cu:cursor.
	  	 position_(co1,cu)=position_(co2,cu)) and
	  (forall cu:cursor.
	  	 position_(co1,cu)>0 -> element_(co1,cu)=element_(co2,cu))

(*** EQUIVALENT ***)

predicate equivalent_ (co1:set,co2:set) =
	  (forall i:real.
	  	 contains_(co1,i) -> contains_(co2,i)) and
		 length_(co1)=length_(co2)

axiom equivalent_sym :
      forall co1:set. forall co2:set [equivalent_(co2,co1) | equivalent_(co1,co2)].
      equivalent_(co1,co2) ->
	  equivalent_(co2,co1)

(*** INTER ***)

logic inter_ : set, set -> set

predicate is_inter (s1:set,s2:set,i:set) =
	  forall j:real [contains_(s1,j), contains_(s2,j)|contains_(i,j)].
      	     (contains_(s1,j) and contains_(s2,j) -> contains_(i,j)) and
      	     ((not contains_(s1,j) or not contains_(s2,j)) -> not contains_(i,j))

axiom inter_is_inter :
      forall s1:set. forall s2:set [inter_(s1,s2)].
      	     is_inter(s1,s2,inter_(s1,s2)) and length_(inter_(s1,s2))=length_(inter_(s2,s1))

(*** UNION ***)

logic union_ : set, set -> set

predicate is_union (s1:set,s2:set,u:set) =
	  (forall i:real [contains_(s1,i), contains_(s2,i)|contains_(u,i)].
      	     ((contains_(s1,i) or contains_(s2,i)) -> contains_(u,i)) and
      	     (not contains_(s1,i) and not contains_(s2,i) -> not contains_(u,i))) and
	     (length_(u)=length_(s1)+length_(s2)-length_(inter_(s1,s2)))

axiom union_is_union :
      forall s1:set. forall s2:set [union_(s1,s2)].
      	     is_union(s1,s2,union_(s1,s2))

(*** DIFF ***)

logic diff_ : set, set -> set

predicate is_diff (s1:set,s2:set,d:set) =
	  (forall i:real [contains_(s1,i), contains_(s2,i)|contains_(d,i)].
      	     (contains_(s1,i) and not contains_(s2,i) -> contains_(d,i)) and
      	     ((not contains_(s1,i) or contains_(s2,i)) -> not contains_(d,i))) and
	     (length_(d)=length_(s1)-length_(inter_(s1,s2)))

axiom diff_is_diff :
      forall s1:set. forall s2:set  [diff_(s1,s2)].
      	     is_diff(s1,s2,diff_(s1,s2))

(*** IS_SUBSET ***)

predicate is_subset_ (s1:set, s2:set) =
	  forall i:real.
	  	 contains_(s1,i) -> contains_(s2,i)

(*** PARAMETERS ***)

parameter element :
	  co:set-> cu:cursor ->
	  { has_element_(co,cu) }
	  element_t
	  { result=element_(co,cu) }

parameter find :
	  co:set-> e:element_t ->
	  { }
	  cursor
	  { result=find_(co,witness(e)) }

parameter replace_element :
	  co:set ref -> cu:cursor -> e:element_t ->
	  { position_(co,cu)>0 and (not contains_(co,witness(e)) or witness(e)=witness(element_(co,cu))) }
	  unit reads co writes co
	  { replace_element_(co@,cu,e,co) }

parameter insert :
	  co:set ref -> e:element_t ->
	  { not contains_(co,witness(e)) }
	  unit reads co writes co
	  { insert_(co@,e,co) }

parameter replace :
	  co:set ref -> e:element_t ->
	  { contains_(co,witness(e)) }
	  unit reads co writes co
	  { replace_(co@,e,co) }

parameter include_ :
	  co:set ref -> e:element_t ->
	  {  }
	  unit reads co writes co
	  { include__ (co@,e,co) }

parameter delete :
	  co:set ref -> cu:cursor ->
	  { has_element_(co,cu)}
	  unit reads co writes co
	  { delete_(co@,cu,co) }

parameter exclude :
	  co:set ref -> e:element_t ->
	  {  }
	  unit reads co writes co
	  { exclude_(co@,e,co) }

parameter previous :
	  co:set -> cu:cursor ->
	  { cu = no_element or has_element_(co,cu) }
	  cursor
	  { result=previous_(co,cu) }

parameter next :
	  co:set -> cu:cursor ->
	  { cu = no_element or has_element_(co,cu) }
	  cursor 
	  { result=next_(co,cu) }

parameter first :
	  co:set ->
	  { }
	  cursor
	  { result=first_(co) }

parameter last :
	  co:set ->
	  { }
	  cursor
	  { result=last_(co) }

parameter has_element :
	  co:set -> cu:cursor ->
	  { }
	  bool
	  { if result then has_element_(co,cu) else position_(co,cu)=0 }

parameter length :
	  co:set ->
	  { }
	  int
	  { result=length_(co) }

parameter union :
	  s1:set -> s2:set ->
	  { }
	  set
	  { result=union_(s1,s2) }

parameter inter :
	  s1:set -> s2:set ->
	  { }
	  set
	  { result=inter_(s1,s2) }

parameter diff :
	  s1:set -> s2:set ->
	  { }
	  set
	  { result=diff_(s1,s2) }

parameter equivalent_elements :
	  k1:element_t -> k2:element_t ->
	  { }
	  bool
	  { if result then witness(k1)=witness(k2) else witness(k1)<>witness(k2) }

parameter lt :
	  e1:element_t -> e2:element_t ->
	  { }
	  bool
	  { if result then witness(e1)<witness(e2) else witness(e1)>=witness(e2) }

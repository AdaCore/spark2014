module Main

  use import int.Int
  use import module ref.Ref
  use import module vector.Main

(*** UNIT-TESTS ***)

(*** INDEX ***)

let test_replace_element1 (co:ref vector) (i:int) (j:int) (e:element_t) =
    { length_ !co >= i > 0 /\ length_ !co >= j > 0 /\ i <> j }
    replace_element co i e
    { element_ !co i = e /\ element_ !co j = element_ (old !co) j }

predicate p element_t

predicate p_forall_cont (co:vector) =
	  forall i:int.
	  	 length_ co >= i > 0 -> p (element_ co i)

let test_replace_element2 (co:ref vector) (i:int) (e:element_t) =
    { length_ !co >= i > 0 /\ p e /\ p_forall_cont !co }
    replace_element co i e
    { p_forall_cont !co /\ element_ !co i = e }

let test_insert (co:ref vector) (i:int) (e:element_t) (j:int) =
    { (length_ !co) + 1 >= i > 0 /\ p e /\ p_forall_cont !co /\ (length_ !co) + 1 >= j > 0 }
    insert co i e
    { p_forall_cont !co /\ element_ !co i = e /\ 
    (j > i -> element_ !co j = element_ (old !co) (j-1)) /\ 
    (j < i -> element_ !co j = element_ (old !co) j) /\
    length_ !co = (length_ (old !co)) + 1 }

let test_delete (co:ref vector) (i:int) (j:int) =
    { length_ !co >= i > 0 /\ p_forall_cont !co /\ length_ !co > j > 0 /\ i <> j }
    delete co i
    { p_forall_cont !co /\
     (j >= i -> element_ !co j = element_ (old !co) (j+1)) /\ 
     (j < i -> element_ !co j = element_ (old !co) j) /\
     length_ !co = (length_ (old !co)) - 1 }

let test_insert_delete (co:ref vector) (i:int) (e:element_t) =
    { (length_ !co) + 1 >= i > 0 }
    insert co i e;
    delete co i
    { equal_ !co (old !co) }

let test_left1 (co:vector) (i:int) =
    { length_ co >= i > 0 }
    ()
    { is_empty_ (left_ co 1) /\
      equal_ co (left_ co ((length_ co) + 1)) /\
      length_ (left_ co i) = i - 1 }

let test_right1 (co:vector) (i:int) =
    { length_ co >= i > 1 }
    ()
    { is_empty_ (right_ co ((length_ co) + 1)) /\
      element_ (right_ co i) 1 = element_ co i /\
      equal_ co (right_ co 1) }

let test_contains (co:vector) (i:int) (e:element_t) =
    { length_ co >= i > 0 /\ element_ co i = e }
    ()
    { contains_ co e }

(*** CURSOR ***)
(* Same tests but with cursors instead of index *)

let test_replace_element_curs1 (co:ref vector) (cu:cursor) (cun:cursor) (e:element_t) =
    { has_element_ !co cu /\ has_element_ !co cun /\ cu <> cun }
    replace_element_curs co cu e
    { element_curs_ !co cu = e /\ 
     element_curs_ !co cun = element_curs_ (old !co) cun }

let test_replace_element_curs2 (co:ref vector) (cu:cursor) (e:element_t) =
    { has_element_ !co cu /\ p e /\ p_forall_cont !co }
    replace_element_curs co cu e
    { p_forall_cont !co /\ element_curs_ !co cu = e }

let test_insert_curs1 (co:ref vector) (cu:cursor) (e:element_t) (cun:cursor) =
    { has_element_ !co cu /\ has_element_ !co cun /\ p e /\ p_forall_cont !co /\ 
	(length_ !co) + 1 >= to_index_ !co cun > 0 }
    insert_curs co cu e
    { p_forall_cont !co /\ 
    (0 < to_index_ !co cun < to_index_ (old !co) cu -> 
	element_curs_ !co cun = element_curs_ (old !co) cun) /\
    length_ !co = (length_ (old !co)) + 1 }

let test_insert_curs2 (co:ref vector) (e:element_t) (cun:cursor) =
    { p e /\ p_forall_cont !co /\ has_element_ !co cun }
    insert_curs co no_element e
    { p_forall_cont !co /\ element_curs_ !co (last_ !co) = e /\
     element_curs_ !co cun = element_curs_ (old !co) cun /\
     length_ !co = (length_ (old !co)) + 1 }

let test_delete_curs (co:ref vector) (cu:cursor) (cun:cursor) =
    { has_element_ !co cu /\ has_element_ !co cun /\ p_forall_cont !co /\
      length_ !co > to_index_ !co cun > 0 /\ cu <> cun }
    delete_curs co cu
    { p_forall_cont !co /\
     (0 < to_index_ !co cun < to_index_ (old !co) cu ->
	element_curs_ !co cun = element_curs_ (old !co) cun) /\
     length_ !co = (length_ (old !co)) - 1 }

let test_insert_delete_curs1 (co:ref vector) (cu:cursor) (e:element_t) =
    {  has_element_ !co cu }
    let i = to_index_ !co cu in
    insert_curs co cu e;
    delete_curs co (to_cursor_ !co i)
    { equal_ !co (old !co) }

let test_insert_delete_curs2 (co:ref vector) (e:element_t) =
    { }
    insert_curs co no_element e;
    delete_curs co (last !co)
    { equal_ !co (old !co) }

let test_contains_curs (co:vector) (cu:cursor) (e:element_t) =
    { has_element_ co cu /\ element_curs_ co cu = e }
    ()
    { contains_ co e }

let test_false (co:ref vector) (cu:cursor) =
    { has_element_ !co cu }
    ()
    { false }

let test_find (s:vector) (e:element_t) (i:ref int) =
    { }
    i := 1;
    let b = ref False in
    while !i <= length_(s) && not !b do
    	  invariant {
	    0 < !i <= (length_ s) + 1 /\
	    (!b = True /\ !i <= length_ s /\ e = element_ s !i
	    \/ !b = False) /\ not (contains_ (left_ s !i) e) }
	    if e = (element s !i) then
	       b := True
	    else i := !i+1
    done;
    if !i = (length_ s) + 1 then
       i := 0;
    !b
    { (result=True <-> contains_ s e) /\ find_ s e 1 = !i }

(*** SUM_OF TESTS ***)

function weight_ element_t : int
predicate checkk_ element_t

val weight :
	  e:element_t ->
	  { }
	  int
	  { result = weight_ e }

axiom positive_weight :
      forall e:element_t.
      	     weight_ e >= 0

val checkk :
	  e:element_t ->
	  {}
	  bool
	  { result = True <-> checkk_ e }

(* Sum_of_weight /\ some axioms *)
function sum_of_weight vector : int

axiom sum_of_weight_delete :
      forall v1:vector. forall v2:vector. forall i:int [sum_of_weight v2, delete_ v1 i v2].
      	     delete_ v1 i v2 -> sum_of_weight v2 = (sum_of_weight v1) - (weight_ (element_ v1 i))

axiom sum_of_weight_insert :
      forall v1:vector. forall v2:vector. forall i:int. forall e:element_t [sum_of_weight v2, insert_ v1 i e v2].
      	     insert_ v1 i e v2 -> sum_of_weight v2 = (sum_of_weight v1) + (weight_ e)

axiom sum_of_weight_null :
      forall v:vector[sum_of_weight v].
      	     is_empty_ v -> sum_of_weight v = 0

axiom sum_of_weight_equal :
      forall v1:vector. forall v2:vector[sum_of_weight v1].
      	     equal_ v1 v2 -> sum_of_weight v1 = sum_of_weight v2

axiom sum_of_weight_left :
      forall v:vector. forall i:int[sum_of_weight (left_ v i)].
      	     (length_ v) + 1 >= i > 1 ->
	sum_of_weight (left_ v i) = (sum_of_weight (left_ v (i - 1))) + (weight_ (element_ v (i-1)))

(* deletes some elements from v *)
let test_sum_of (v:ref vector) (w:ref int) (e:element_t)  =
    { }
    'Init:
    w := 0;
    let c= ref (first !v) in
    while has_element !v !c do
    	  invariant {
	    sum_of_weight !v = (sum_of_weight (at !v 'Init)) - !w
    	  }
    	  if (checkk (element_curs !v !c)) then
	     (w := !w+(weight(element_curs !v !c));
	     delete_curs v !c)
	  else c := next !v !c
    done;
    assert { weight_ e = !w };(* IMPOSSIBLE TO PROVE *)
    append v e
    { sum_of_weight !v = sum_of_weight (old !v) }

(* deletes elements from v until their total weight exceeds wmin *)
let test_sum_of2 (v:ref vector) (w:ref int) (wmin : int) =
    { wmin <= sum_of_weight !v }
    'Init:
    w := 0;
    if !w < wmin then
    while !w < wmin do
    	  invariant {
	    (sum_of_weight !v = (sum_of_weight (at !v 'Init)) - !w)
    	  }
    	 w := !w + (weight (element !v 1));
	 delete v 1
    done
    { sum_of_weight !v = (sum_of_weight (old !v)) - !w /\ !w >= wmin }

(* computes sum_of_weight(v) *)
let test_sum_of3 (v:vector) =
    { }
    let w = ref 0 in
    let i = ref 1 in
    if !i <= length v then
    while !i <= length v do
    	  invariant {
	    !w = sum_of_weight (left_ v !i) /\
	    (length_ v) + 1 >= !i > 0
    	  }
    	 w := !w + (weight (element v !i));
	 i := !i + 1
    done;
    assert { equal_ v (left_ v !i) };
    !w
    { sum_of_weight v = result }

(*** MAX TESTS ***)
(*
function compare_ : element_t, element_t -> int

predicate is_max (v:vector,j:int) =
	  0<j<=length_(v) /\
	  (forall i:int.
		 0<i<=length_(v) -> compare_(element_(v,j),element_(v,i))>=0)

function max_ : vector -> int

axiom is_max_max :
      forall v:vector.
      	     (not is_empty_(v) -> is_max(v,max_(v)))

parameter max :
	  v:vector ->
	  { not is_empty_(v) }
	  int
	  { result=max_(v) }


(* Heap : all the elements of result are bigger than those still in v_min *)
let test_max (v_min:ref vector) (n:int) =
    { length_(v_min)>=n }
    init:
    let i=ref 1 in
    let v_max=ref empty_ in
    if !i<=n then
    while !i<=n do
    	  { invariant
	    (length_(v_min)=length_(v_min@init)-i+1 /\
	    forall i1:int. forall i2:int. 0<i1<=length_(v_max) ->
	    0<i2<=length_(v_min) ->
	    compare_(element_(v_max,i1),element_(v_min,i2))>=0)}
    	  append v_max (element !v_min (max !v_min));
	  delete v_min (max !v_min);
	  i := !i+1
    done;
    !v_max
    { (forall i1:int. forall i2:int. 0<i1<=length_(result) ->
	    0<i2<=length_(v_min) ->
	    compare_(element_(result,i1),element_(v_min,i2))>=0) /\ false}


(* More user friendly version, not easy to prove *)
let test_max2 (v_min:ref vector) (n:int) =
    { length_(v_min)>=n }
    init:
    let i=ref 1 in
    let v_max=ref empty_ in
    if !i<=n then
    while !i<=n do
    	  { invariant
	    (length_(v_min)=length_(v_min@init)-i+1 /\
	    forall e1:element_t. forall e2:element_t. contains_(v_max,e1) ->
	    contains_(v_min,e2) ->
	    compare_(e1,e2)>=0)}
    	  append v_max (element !v_min (max !v_min));
	  delete v_min (max !v_min);
	  i := !i+1
    done;
    !v_max
    { (forall e1:element_t. forall e2:element_t. contains_(result,e1) ->
	    contains_(v_min,e2) ->
	    compare_(e1,e2)>=0) /\ false}

(*** GOALS ***)

goal contains_insert :
     forall l1:vector. forall l2:vector. forall i:int. forall e:element_t. forall el:element_t.
     	    insert_(l1,i,e,l2) -> contains_(l2,el) -> e=el \/ contains_(l1,el)

goal contains_delete :
     forall l1:vector. forall l2:vector. forall i:int. forall el:element_t.
     	    delete_(l1,i,l2) -> contains_(l2,el) -> contains_(l1,el)
*)
end

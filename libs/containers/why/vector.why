(*** TYPES ***)

type cursor
type vector
type element_t

logic no_element : cursor
logic empty_ : vector

(*** LENGTH ***)

logic length_ : vector -> int

axiom length_gte_zero :
      forall co:vector [length_(co)].
      	     length_(co)>=0

(*** TO_INDEX ***)

logic to_index_ : cursor -> int

axiom to_index_gte_zero :
      forall cu:cursor.
      	     to_index_(cu)>=0

axiom to_index_no_element :
      	     to_index_(no_element) = 0

(*** TO_CURSOR ***)

logic to_cursor_ : vector, int -> cursor

predicate to_cursor__ (co:vector, i:int, cu:cursor) =
      (to_index_(cu)=i and length_(co)>=i>0)
      or (cu=no_element and (i<=0 or i>length_(co)))

axiom to_cursor_to_cursor :
      forall co:vector. forall i:int [to_cursor_(co,i)].
      	     to_cursor__(co,i,to_cursor_(co,i))

(*** IS_EMPTY ***)

predicate is_empty_ (co:vector)=
	  length_(co)=0

axiom empty_is_empty :
      is_empty_(empty_)

(* HAS_ELEMENT *)

logic has_element_ : vector,cursor -> prop

axiom has_element_index :
      forall v:vector. forall cu:cursor.
      	     has_element_(v,cu) -> 0<to_index_(cu)<=length_(v)

axiom has_element_index_unique :
      forall v:vector. forall cu1:cursor. forall cu2:cursor.
      	     has_element_(v,cu1) -> has_element_(v,cu2) -> to_index_(cu1)=to_index_(cu2) ->
	     cu1=cu2

axiom has_element_to_cursor :
      forall v:vector. forall i:int [has_element_(v,to_cursor_(v,i))].
      	     0<i<=length_(v) -> has_element_(v,to_cursor_(v,i))


(*** PREVIOUS ***)

logic previous_ : vector,cursor -> cursor

axiom previous_to_cursor :
      forall v:vector. forall cu:cursor [previous_(v,cu)].
      	     has_element_(v,cu) -> previous_(v,cu)=to_cursor_(v,to_index_(cu)-1)

(*** NEXT ***)

logic next_ : vector,cursor -> cursor

axiom next_to_cursor :
      forall v:vector. forall cu:cursor [next_(v,cu)].
      	     has_element_(v,cu) -> next_(v,cu)=to_cursor_(v,to_index_(cu)+1)
(*** LAST ***)

function last_ (co:vector) :cursor = to_cursor_(co,length_(co))

(*** FIRST ***)

function first_ (co:vector) :cursor = to_cursor_(co,1)

(*** ELEMENT ***)

logic element_ : vector, int -> element_t
logic element_curs_ : vector, cursor -> element_t

axiom has_element_element_curs :
      forall v:vector. forall cu:cursor [element_curs_(v,cu)].
      	     has_element_(v,cu) -> element_curs_(v,cu)=element_(v,to_index_(cu))

(*** FIND ***)

logic find_ : vector, element_t, int -> int

predicate find__ (co:vector,e:element_t,i:int,j:int) =
	  length_(co)>=i>0 and
	  ((j=0 and (forall k:int. length_(co)>=k>=i -> not element_(co,k)=e))
	  or (length_(co)>=j>=i and element_(co,j)=e and (forall k:int. j>k>=i -> not element_(co,k)=e)))

axiom find_find_val :
      forall co:vector. forall e:element_t. forall i:int.
	     (length_(co)>=i>0 -> find__(co,e,i,find_(co,e,i)))
	     and (length_(co)=0 -> find_(co,e,i)=0)

(*** EQUAL ***)

predicate equal_ (co1:vector,co2:vector) =
	        length_(co1)=length_(co2) and
	  forall i:int.
	  	(length_(co1)>=i>0 -> element_(co1,i)=element_(co2,i))

(*** REPLACE_ELEMENT ***)

predicate replace_element_ (co1:vector,i:int,e:element_t,co2:vector) =
	  length_(co1)>=i>0 and length_(co1)=length_(co2) and
	  element_(co2,i)=e and
	  (forall j:int.
	  	 length_(co1)>=j>0 ->
		 (i<>j -> element_(co2,j)=element_(co1,j))) and
          (forall cu:cursor.
	  	 has_element_(co1,cu) <-> has_element_(co2,cu))

(*** LEFT ***)

predicate left__ (co:vector, i:int, col:vector) =
	  (length_(co)+1>=i>0 -> 
	  length_(col)=i-1 and 
	  (forall j:int.
	       0<j<i -> element_(col,j)=element_(co,j)) and
	  (forall cu:cursor.
	  	 (has_element_(co,cu) and to_index_(cu)<i) <-> has_element_(col,cu)))

logic left_ : vector, int -> vector

axiom left_left :
      forall co:vector. forall i:int [left_(co,i)].
      	     left__(co,i,left_(co,i))


(*** RIGHT ***)

predicate right__ (co:vector, i:int, cor:vector) =
	  (length_(co)+1>=i>0 ->
	      length_(cor)=length_(co)-i+1 and
	  (forall j:int.
	    0<j<=length_(cor) -> 
	    element_(cor,j)=element_(co,j+i-1)))

logic right_ : vector, int -> vector

axiom right_right:
      forall co:vector. forall i:int [right_(co,i)].
      	     right__(co,i,right_(co,i))

(*** INSERT ***)

predicate insert_elmt (co1:vector,i:int,e:element_t,co2:vector) =
	  element_(co2,i)=e and
	  (forall j:int.
	     (0<j<i ->
	     element_(co1,j)=element_(co2,j)) and
	     (i<j<=length_(co1)+1 ->
	     element_(co1,j-1)=element_(co2,j)))

predicate insert_curs (co1:vector, co2:vector)=
	  forall cu:cursor.
	  	 (has_element_(co1,cu) or cu=last_(co2)) <-> has_element_(co2,cu)

predicate insert_ (co1:vector,i:int,e:element_t,co2:vector) =
	  length_(co1)+1>=i>0 and length_(co2)=length_(co1)+1 and
	  insert_elmt(co1,i,e,co2) and
	  insert_curs (co1,co2)

(*** DELETE ***)

predicate delete_elmt (co1:vector, i:int, co2:vector) =
	  forall j:int.
	    (length_(co1)>j>=i ->
	     element_(co1,j+1)=element_(co2,j))
	    and (0<j<i ->
	     element_(co2,j)=element_(co1,j))

predicate delete_curs (co1:vector, co2:vector)=
	  forall cu:cursor.
	  	 (has_element_(co1,cu) and to_index_(cu)<=length_(co2)) <-> has_element_(co2,cu)

predicate delete_ (co1:vector,i:int,co2:vector) =
	  length_(co1)>=i>0 and length_(co2)=length_(co1)-1 and
	  delete_elmt(co1,i,co2) and
	  delete_curs (co1,co2)

(*** CONTAINS ***)

predicate contains_ (co:vector,e:element_t) =
	  length_(co)>=find_(co,e,1)>0

(*** PARAMETERS ***)

parameter element :
	  co:vector -> i:int ->
	  { 0<i<=length_(co) }
	  element_t
	  { result=element_(co,i) }

parameter element_curs :
	  co:vector -> cu:cursor ->
	  { has_element_(co,cu) }
	  element_t
	  { result=element_curs_(co,cu) }

parameter replace_element :
	  co:vector ref -> i:int -> e:element_t ->
	  { 0<i<=length_(co) }
	  unit writes co
	  { replace_element_(co@,i,e,co) }

parameter replace_element_curs :
	  co:vector ref -> cu:cursor -> e:element_t ->
	  { has_element_(co,cu) }
	  unit writes co
	  { replace_element_(co@,to_index_(cu),e,co) }

parameter insert :
	  co:vector ref -> i:int -> e:element_t ->
	  { length_(co)+1>=i>0 }
	  unit reads co writes co
	  { insert_(co@,i,e,co) }

parameter insert_curs :
	  co:vector ref -> cu:cursor -> e:element_t ->
	  { has_element_(co,cu) or cu=no_element }
	  unit reads co writes co
	  { (has_element_(co@,cu) -> insert_(co@,to_index_(cu),e,co))
	    and (cu=no_element -> insert_(co@,length_(co@)+1,e,co)) }

parameter prepend :
	  co:vector ref -> e:element_t ->
	  { }
	  unit reads co writes co
	  { insert_(co@,1,e,co) }

parameter append :
	  co:vector ref -> e:element_t ->
	  { }
	  unit reads co writes co
	  { insert_(co@,length_(co@)+1,e,co) }

parameter delete :
	  co:vector ref -> i:int ->
	  { length_(co)>=i>0 }
	  unit reads co writes co
	  { delete_(co@,i,co) }

parameter delete_curs :
	  co:vector ref -> cu:cursor ->
	  { has_element_(co,cu) }
	  unit reads co writes co
	  { delete_(co@,to_index_(cu),co) }

parameter previous :
	  co:vector -> cu:cursor ->
	  { has_element_(co,cu) }
	  cursor
	  { result=previous_(co,cu) }

parameter next :
	  co:vector -> cu:cursor ->
	  { has_element_(co,cu) }
	  cursor 
	  { result=next_(co,cu) }

parameter first :
	  co:vector ->
	  { }
	  cursor
	  { result=first_(co) }

parameter last :
	  co:vector ->
	  { }
	  cursor
	  { result=last_(co) }

parameter has_element :
	  co:vector -> cu:cursor ->
	  { }
	  bool
	  { if result then has_element_(co,cu) else not has_element_(co,cu) }

parameter length :
	  co:vector ->
	  { }
	  int
	  { result=length_(co) }

parameter curs_equal :
	  cu1:cursor -> cu2:cursor ->
	  { }
	  bool
	  { if result then cu1=cu2 else cu1<>cu2 }

parameter elt_equal :
	  e1:element_t -> e2:element_t ->
	  { }
	  bool
	  { if result then e1=e2 else e1<>e2 }

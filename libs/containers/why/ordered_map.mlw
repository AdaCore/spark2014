module Main
  use import real.Real
  use import int.Int
  use import module ref.Ref
  
  (*** TO BE INSTANTIATED ***)
  
  type key_t

  type element_t

  function equal_elements element_t element_t : bool

  axiom equal_refl :
  forall e : element_t [equal_elements e e].
	equal_elements e e = True

  axiom equal_sym :
  forall e1 : element_t, e2 : element_t [equal_elements e1 e2].
	equal_elements e1 e2 = equal_elements e2 e1

  axiom equal_trans :
  forall e1 : element_t, e2 : element_t, e3 : element_t [equal_elements e1 e2, equal_elements e1 e3 | equal_elements e1 e2, equal_elements e2 e3].
	equal_elements e1 e2 = True -> equal_elements e2 e3 = True -> equal_elements e1 e3 = True

  function lt key_t key_t : bool

  (**************************)
  
  type cursor
  
  type map
  
  function no_element : cursor
  
  function empty_  : map
  
  function length map : int
  
  axiom Length_gte_zero:
    (forall co:map [(length co : int)]. (Int.(<=) 0 (length co : int)))
  
  function witness key_t : real
  
  axiom Lt_witness:
    (forall k1:key_t.
      (forall k2:key_t [(lt k1 k2 : bool)].
        (((lt k1 k2 : bool) = True) <->
         (Real.(<) (witness k1 : real) (witness k2 : real)))))
  
  function position_ map cursor : int
  
  axiom Position_gte_zero:
    (forall co:map.
      (forall cu:cursor.
        ((Int.(<=) 0 (position_ co cu : int)) /\
         (Int.(<=) (position_ co cu : int) (length co : int)))))
  
  axiom Position_no_element:
    (forall co:map. ((position_ co (no_element  : cursor) : int) = 0))
  
  axiom Position_eq:
    (forall co:map.
      (forall cu1:cursor.
        (forall cu2:cursor.
          ((Int.(>) (position_ co cu1 : int) 0) ->
           (((position_ co cu1 : int) = (position_ co cu2 : int)) ->
            (cu1 = cu2))))))
  
  predicate is_empty_ (co : map) =
    (forall cu:cursor. ((position_ co cu : int) = 0))
  
  axiom Length_is_empty:
    (forall co:map. ((is_empty_ co) -> ((length co : int) = 0)))
  
  axiom Empty_is_empty: (is_empty_ (empty_  : map))
  
  predicate previous__ (co : map) (cu1 : cursor) (cu2 : cursor) =
    (((Int.(>) (position_ co cu1 : int) 1) ->
      ((position_ co cu2 : int) = (Int.(-) (position_ co cu1 : int) 1 : int))) /\
     ((((position_ co cu1 : int) = 1) \/ (cu1 = (no_element  : cursor))) ->
      (cu2 = (no_element  : cursor))))
  
  function previous_ map cursor : cursor
  
  axiom Previous_previous_:
    (forall co:map.
      (forall cu:cursor [(previous_ co cu : cursor)].
        (previous__ co cu (previous_ co cu : cursor))))
  
  predicate next__ (co : map) (cu1 : cursor) (cu2 : cursor) =
    (Int.(>) (length co : int) (position_ co cu1 : int) /\
        Int.(>) (position_ co cu1 : int) 0  -> (position_ co cu2 : int) > 0) /\
    (Int.(>) (position_ co cu2 : int) 0 ->
      (position_ co cu2 : int) = (Int.(+) (position_ co cu1 : int) 1 : int)) /\
     (((length co : int) = (position_ co cu1 : int) \/ cu1 = no_element) -> cu2 = (no_element  : cursor))
  
  function next_ map cursor : cursor
  
  axiom Next_next_:
    (forall co:map.
      (forall cu:cursor [(next_ co cu : cursor)].
        (next__ co cu (next_ co cu : cursor))))
  
  predicate last_ (co : map) (cu : cursor) =
    (((not (is_empty_ co)) -> ((position_ co cu : int) = (length co : int))) /\
     ((is_empty_ co) -> (cu = (no_element  : cursor))))
  
  function last map : cursor
  
  axiom Last_last:
    (forall co:map [(last co : cursor)]. (last_ co (last co : cursor)))
  
  predicate first_ (co : map) (cu : cursor) =
    (((not (is_empty_ co)) -> ((position_ co cu : int) = 1)) /\
     ((is_empty_ co) -> (cu = (no_element  : cursor))))
  
  function first map : cursor
  
  axiom First_first:
    (forall co:map [(first co : cursor)]. (first_ co (first co : cursor)))
  
  function key_ map cursor : key_t
  
  function find_ map real : cursor
  
  predicate find__ (co : map) (i : real) (cu : cursor) =
    (((cu = (no_element  : cursor)) /\
      (forall cun:cursor.
        ((Int.(>) (position_ co cun : int) 0) ->
         ((witness (key_ co cun : key_t) : real) <> i)))) \/
     ((Int.(>) (position_ co cu : int) 0) /\
      (((witness (key_ co cu : key_t) : real) = i) /\
       (forall cun:cursor.
         ((Int.(>) (position_ co cun : int) 0) ->
          ((cu <> cun) -> ((witness (key_ co cun : key_t) : real) <> i)))))))
  
  axiom Find_find_val:
    (forall co:map.
      (forall i:real.
        ((find__ co i (find_ co i : cursor)) /\
         ((is_empty_ co) -> ((find_ co i : cursor) = (no_element  : cursor))))))
  
  axiom Ordered:
    (forall s:map.
      (forall cu1:cursor.
        (forall cu2:cursor.
          (((Int.(>) (position_ s cu1 : int) 0) /\
            (Int.(>) (position_ s cu2 : int) 0)) ->
           ((Int.(>) (position_ s cu2 : int) (position_ s cu1 : int)) <->
            (Real.(>) (witness (key_ s cu2 : key_t) : real) (witness (key_ s cu1 : key_t) : real)))))))
  
  function element_ map cursor : element_t
  
  function element__ (m : map) (i : real) : element_t =
    (element_ m (find_ m i : cursor) : element_t)
  
  predicate left_pos (co : map) (i : int) (col : map) =
    (forall cu:cursor.
       Int.(>=) (position_ co cu : int) i ->
         position_ col cu = 0) /\
    (forall cu:cursor.
        Int.(<) (position_ co cu : int) i ->
          position_ col cu = position_ co cu) /\
    (forall cu:cursor.
         Int.(>) (position_ col cu : int) 0 ->
          (position_ co cu : int) = (position_ col cu : int)) /\
     (forall cu:cursor.
       Int.(>) (position_ col cu : int) 0 ->
        (element_ col cu : element_t) = (element_ co cu : element_t)) /\
     (forall cu:cursor.
        Int.(>) (position_ col cu : int) 0 ->
         (key_ col cu : key_t) = (key_ co cu : key_t))
  
  predicate left_find (co : map) (cu : cursor) (col : map) =
	(forall w:real [key_ co cu, find_ col w | key_ co cu, find_ co w].
		Real.(>) (witness (key_ co cu)) w -> find_ col w = find_ co w /\
		position_ col (find_ col w) = position_ co (find_ co w)) /\
	(forall w:real [key_ co cu, find_ col w].
		Real.(<=) (witness (key_ co cu)) w -> find_ col w = no_element) /\
	(forall w:real [find_ col w | find_ co w]. 
	 	position_ col (find_ col w) > 0 \/ position_ co cu > position_ co (find_ co w)
		-> find_ col w = find_ co w)
  
  predicate left__ (co : map) (cu : cursor) (col : map) =
    (((cu = (no_element  : cursor)) -> (col = co)) /\
     ((Int.(>) (position_ co cu : int) 0) ->
      (((length col : int) = (Int.(-) (position_ co cu : int) 1 : int)) /\
       ((left_pos co (position_ co cu : int) col) /\
        (left_find co cu col)))))
  
  function left_ map cursor : map
  
  axiom Left_left:
    (forall co:map.
      (forall cu:cursor [(left_ co cu : map)].
        (left__ co cu (left_ co cu : map))))
  
  predicate right_pos (co : map) (i : int) (cor : map) =
    ((forall cu:cursor.
       (((Int.(>) i (position_ co cu : int)) ->
         ((position_ cor cu : int) = 0)) /\
        (((Int.(<=) i (position_ co cu : int)) ->
          ((position_ cor cu : int) = (Int.(+) (Int.(-) (position_ co cu : int) i : int) 1 : int))) /\
         ((Int.(>) (position_ cor cu : int) 0) ->
          ((position_ co cu : int) = (Int.(-) (Int.(+) (position_ cor cu : int) i : int) 1 : int)))))) /\
     ((forall cu:cursor.
        ((Int.(>) (position_ cor cu : int) 0) ->
         ((key_ cor cu : key_t) = (key_ co cu : key_t)))) /\
      (forall cu:cursor.
        ((Int.(>) (position_ cor cu : int) 0) ->
         ((element_ cor cu : element_t) = (element_ co cu : element_t))))))
  
  predicate right_find (co : map) (i : int) (cor : map) =
    (forall w:real.
      ((((Int.(>) i 0) /\
         (Int.(<=) i (position_ co (find_ co w : cursor) : int))) \/
        (Int.(>) (position_ cor (find_ cor w : cursor) : int) 0)) ->
       ((find_ co w : cursor) = (find_ cor w : cursor))))
  
  predicate right__ (co : map) (cu : cursor) (cor : map) =
    (((cu = (no_element  : cursor)) -> (cor = (empty_  : map))) /\
     (((Int.(>) (position_ co cu : int) 0) ->
       (((length cor : int) = (Int.(+) (Int.(-) (length co : int) (position_ co cu : int) : int) 1 : int)) /\
        ((right_pos co (position_ co cu : int) cor) /\
         (right_find co (position_ co cu : int) cor)))) /\
      (forall cun:cursor.
        ((Int.(>) (position_ cor cun : int) 0) ->
         (Int.(>) (position_ co cun : int) 0)))))
  
  function right_ map cursor : map
  
  axiom Right_right:
    (forall co:map.
      (forall cu:cursor [(right_ co cu : map)].
        (right__ co cu (right_ co cu : map))))
  
  predicate replace_ (co1 : map) (k : key_t) (e : element_t) (co2 : map) =
    ((Int.(>) (position_ co1 (find_ co1 (witness k : real) : cursor) : int) 0) /\
     (((length co1 : int) = (length co2 : int)) /\
      (((key_ co2 (find_ co1 (witness k : real) : cursor) : key_t) = k) /\
       (((element_ co2 (find_ co1 (witness k : real) : cursor) : element_t) = e) /\
        ((forall cun:cursor.
           ((position_ co2 cun : int) = (position_ co1 cun : int))) /\
         ((forall cun:cursor.
            (((Int.(>) (position_ co1 cun : int) 0) /\
              (not (cun = (find_ co1 (witness k : real) : cursor)))) ->
             ((key_ co2 cun : key_t) = (key_ co1 cun : key_t)))) /\
          ((forall cun:cursor.
             (((Int.(>) (position_ co1 cun : int) 0) /\
               (not (cun = (find_ co1 (witness k : real) : cursor)))) ->
              ((element_ co2 cun : element_t) = (element_ co1 cun : element_t)))) /\
           (forall w:real. ((find_ co1 w : cursor) = (find_ co2 w : cursor))))))))))
  
  predicate replace_element_ (co1 : map) (cu : cursor) (e : element_t) (co2 : map) =
    ((Int.(>) (position_ co1 cu : int) 0) /\
     (((element_ co2 cu : element_t) = e) /\
      (((length co1 : int) = (length co2 : int)) /\
       ((forall cun:cursor.
          ((position_ co1 cun : int) = (position_ co2 cun : int))) /\
        ((forall cun:cursor.
           ((Int.(>) (position_ co1 cun : int) 0) ->
            ((key_ co2 cun : key_t) = (key_ co1 cun : key_t)))) /\
         ((forall cun:cursor.
            (((Int.(>) (position_ co1 cun : int) 0) /\ (cu <> cun)) ->
             ((element_ co2 cun : element_t) = (element_ co1 cun : element_t)))) /\
          (forall w:real. ((find_ co1 w : cursor) = (find_ co2 w : cursor)))))))))
  
  function ceiling map real : cursor
  
  predicate is_ceiling (s : map) (i : real) (cu : cursor) =
     (cu = no_element  /\
       (is_empty_ s \/
        Real.(>) i (witness (key_ s (last s : cursor))))) \/
      (Int.(>) (position_ s cu : int) 0 /\
       Real.(<=) i (witness (key_ s cu) : real) /\
	(forall cun : cursor. 0 < position_ s cun < position_ s cu
	 -> Real.(>) i (witness (key_ s cun))))
  
  axiom Ceiling_is_ceiling:
    (forall s:map.
      (forall i:real [(ceiling s i : cursor)].
        (is_ceiling s i (ceiling s i : cursor))))
  
  predicate insert_find (co1 : map) (k : key_t) (co2 : map) =
    ((forall i:real.
       ((i <> (witness k : real)) ->
        ((find_ co1 i : cursor) = (find_ co2 i : cursor)))) /\
     ((((ceiling co1 (witness k : real) : cursor) = (no_element  : cursor)) ->
       ((find_ co2 (witness k : real) : cursor) = (last co2 : cursor))) /\
      ((Int.(>) (position_ co1 (ceiling co1 (witness k : real) : cursor) : int) 0) ->
       ((position_ co2 (find_ co2 (witness k : real) : cursor) : int) = (position_ co1 (ceiling co1 (witness k : real) : cursor) : int)))))
  
  predicate insert_pos (co1 : map) (k : key_t) (co2 : map) =
    ((forall cun:cursor.
       ((Int.(>) (position_ co1 cun : int) 0) ->
        ((witness (key_ co1 cun : key_t) : real) <> (witness k : real)))) /\
     ((forall cun:cursor.
        ((Int.(>) (position_ co1 cun : int) 0) ->
         (((Real.(>) (witness k : real) (witness (key_ co1 cun : key_t) : real)) ->
           ((position_ co2 cun : int) = (position_ co1 cun : int))) /\
          ((Real.(>) (witness (key_ co1 cun : key_t) : real) (witness k : real)) ->
           ((position_ co2 cun : int) = (Int.(+) (position_ co1 cun : int) 1 : int)))))) /\
      ((forall cun:cursor.
         ((Int.(>) (position_ co1 cun : int) 0) ->
          ((element_ co1 cun : element_t) = (element_ co2 cun : element_t)))) /\
       (forall cun:cursor.
         ((Int.(>) (position_ co1 cun : int) 0) ->
          ((key_ co1 cun : key_t) = (key_ co2 cun : key_t)))))))
  
  predicate insert_inv (co1 : map) (k : key_t) (e : element_t) (co2 : map) =
    ((forall cun:cursor.
       (((Int.(>) (position_ co2 cun : int) 0) /\
         ((position_ co1 cun : int) = 0)) ->
        ((key_ co2 cun : key_t) = k))) /\
     (forall cun:cursor.
       (((Int.(>) (position_ co2 cun : int) 0) /\
         ((position_ co1 cun : int) = 0)) ->
        ((element_ co2 cun : element_t) = e))))
  
  predicate insert_ (co1 : map) (k : key_t) (e : element_t) (co2 : map) =
    ((Int.(>) (position_ co2 (find_ co2 (witness k : real) : cursor) : int) 0) /\
	(element_ co2 (find_ co2 (witness k : real) : cursor) = e) /\
     (((length co2 : int) = (Int.(+) (length co1 : int) 1 : int)) /\
      ((insert_pos co1 k co2) /\
       ((insert_inv co1 k e co2) /\ (insert_find co1 k co2)))))
  
  predicate delete_find (co1 : map) (k : key_t) (co2 : map) =
    (forall w:real.
      ((((witness k : real) <> w) ->
        ((find_ co1 w : cursor) = (find_ co2 w : cursor))) /\
       (((witness k : real) = w) ->
        ((find_ co2 w : cursor) = (no_element  : cursor)))))
  
  predicate delete_pos (co1 : map) (i : int) (co2 : map) =
    ((forall cun:cursor.
       ((((position_ co1 cun : int) = i) -> ((position_ co2 cun : int) = 0)) /\
        (((Int.(>) (position_ co1 cun : int) i) ->
          ((position_ co2 cun : int) = (Int.(-) (position_ co1 cun : int) 1 : int))) /\
         ((Int.(>) i (position_ co1 cun : int)) ->
          ((position_ co2 cun : int) = (position_ co1 cun : int)))))) /\
     ((forall cun:cursor.
        (((position_ co1 cun : int) <> i) ->
         ((element_ co2 cun : element_t) = (element_ co1 cun : element_t)))) /\
      (forall cun:cursor.
        (((position_ co1 cun : int) <> i) ->
         ((key_ co2 cun : key_t) = (key_ co1 cun : key_t))))))
  
  predicate delete_ (co1 : map) (cu : cursor) (co2 : map) =
    (((find_ co2 (witness (key_ co1 cu : key_t) : real) : cursor) = (no_element  : cursor)) /\
     ((Int.(>) (position_ co1 cu : int) 0) /\
      (((length co2 : int) = (Int.(-) (length co1 : int) 1 : int)) /\
       ((delete_pos co1 (position_ co1 cu : int) co2) /\
        (delete_find co1 (key_ co1 cu : key_t) co2)))))
  
  predicate include__ (co1 : map) (k : key_t) (e : element_t) (co2 : map) =
    (((Int.(>) (position_ co1 (find_ co1 (witness k : real) : cursor) : int) 0) ->
      (replace_ co1 k e co2)) /\
     (((find_ co1 (witness k : real) : cursor) = (no_element  : cursor)) ->
      (insert_ co1 k e co2)))
  
  predicate exclude_ (co1 : map) (k : key_t) (co2 : map) =
    (((Int.(>) (position_ co1 (find_ co1 (witness k : real) : cursor) : int) 0) ->
      (delete_ co1 (find_ co1 (witness k : real) : cursor) co2)) /\
     (((find_ co1 (witness k : real) : cursor) = (no_element  : cursor)) ->
      (co1 = co2)))
  
  predicate has_element (co : map) (cu : cursor) =
    (Int.(>) (position_ co cu : int) 0)
  
  predicate contains (co : map) (i : real) =
    (Int.(>) (position_ co (find_ co i : cursor) : int) 0)
  
  axiom Empty_contains:
    (forall s:map [(is_empty_ s)].
      ((forall i:real. (not (contains s i))) -> (is_empty_ s)))
  
  predicate strict_equal (co1 : map) (co2 : map) =
    ((forall cu:cursor.
       ((position_ co1 cu : int) = (position_ co2 cu : int))) /\
     ((forall cu:cursor.
        ((Int.(>) (position_ co1 cu : int) 0) ->
         ((key_ co1 cu : key_t) = (key_ co2 cu : key_t)))) /\
      (forall cu:cursor.
        ((Int.(>) (position_ co1 cu : int) 0) ->
         ((element_ co2 cu : element_t) = (element_ co1 cu : element_t))))))
  
  predicate equal_ (co1 : map) (co2 : map) =
    (forall i:real.
       (contains co1 i) ->
        (contains co2 i)) /\
    (forall i:real [element__ co1 i|element__ co2 i].
       (contains co1 i) ->
         (equal_elements (element__ co1 i : element_t) (element__ co2 i : element_t) = True)) /\
     (length co1 : int) = (length co2 : int)
  
  axiom Equivalent_sym:
    (forall co1:map.
      (forall co2:map [(equal_ co2 co1)| (equal_ co1 co2)].
        ((equal_ co1 co2) -> (equal_ co2 co1))))
  
  predicate no_overlaping (co1 : map) (co2 : map) =
    (forall i:real. ((not (contains co1 i)) \/ (not (contains co2 i))))

predicate equivalent_keys (k1:key_t) (k2:key_t) =
   witness k1 = witness k2

(*** PARAMETERS ***)

val element :
	  co:map-> cu:cursor ->
	  { has_element co cu }
	  element_t
	  { result = element_ co cu }

val key :
	  co:map-> cu:cursor ->
	  { has_element co cu }
	  key_t
	  { result = key_ co cu }

val find :
	  co:map-> k:key_t ->
	  { }
	  cursor
	  { result = find_ co (witness k) }

val replace_element :
	  co:ref map -> cu:cursor -> e:element_t ->
	  { position_ !co cu > 0 }
	  unit reads co writes co
	  { replace_element_ (old !co) cu e !co }

val insert :
	  co:ref map -> k:key_t -> e:element_t ->
	  { not (contains !co (witness k)) }
	  unit reads co writes co
	  { insert_ (old !co) k e !co }

val replace :
	  co:ref map -> k:key_t -> e:element_t ->
	  { contains !co (witness k) }
	  unit reads co writes co
	  { replace_ (old !co) k e !co }

val include_ :
	  co:ref map -> k:key_t -> e:element_t ->
	  {  }
	  unit reads co writes co
	  { include__ (old !co) k e !co }

val delete :
	  co:ref map -> cu:cursor ->
	  { has_element !co cu }
	  unit reads co writes co
	  { delete_ (old !co) cu !co }

val exclude :
	  co:ref map -> k:key_t ->
	  {  }
	  unit reads co writes co
	  { exclude_ (old !co) k !co }

val previous :
	  co:map -> cu:cursor ->
	  { cu = no_element \/ has_element co cu }
	  cursor
	  { result = previous_ co cu } 

val next :
	  co:map -> cu:cursor ->
	  { cu = no_element \/ has_element co cu }
	  cursor 
	  { result = next_ co cu }
  
  
end


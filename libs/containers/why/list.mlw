module Main
  use import int.Int
  use import module ref.Ref
  
  (*** TO BE INSTANTIATED ***)

  type element_t

  function equal_elements element_t element_t : bool

  axiom equal_refl :
  forall e : element_t [equal_elements e e].
	equal_elements e e = True

  axiom equal_sym :
  forall e1 : element_t, e2 : element_t [equal_elements e1 e2].
	equal_elements e1 e2 = equal_elements e2 e1

  axiom equal_trans :
  forall e1 : element_t, e2 : element_t, e3 : element_t [equal_elements e1 e2, equal_elements e1 e3 | equal_elements e1 e2, equal_elements e2 e3].
	equal_elements e1 e2 = True -> equal_elements e2 e3 = True -> equal_elements e1 e3 = True

  (**************************)

  type cursor
  
  type list
  
  function no_element  : cursor
  
  function empty_  : list
  
  function length list : int
  
  axiom Length_gte_zero:
    (forall co:list [(length co : int)]. (Int.(>=) (length co : int) 0))
  
  function position_ list cursor : int
  
  axiom Position_gte_zero:
    (forall co:list.
      (forall cu:cursor.
        (length co) >= (position_ co cu) /\
         (position_ co cu) >= 0))
  
  axiom Position_no_element:
    (forall co:list. ((position_ co (no_element  : cursor) : int) = 0))
  
  axiom Position_eq:
    (forall co:list.
      (forall cu1:cursor.
        (forall cu2:cursor.
          ((Int.(>) (position_ co cu1 : int) 0) ->
           (((position_ co cu1 : int) = (position_ co cu2 : int)) ->
            (cu1 = cu2))))))
  
  predicate is_empty_ (co : list) =
    ((forall cu:cursor. ((position_ co cu : int) = 0)) /\
     ((length co : int) = 0))
  
  axiom Empty_is_empty: (is_empty_ (empty_  : list))
  
  function previous_ list cursor : cursor
  
  axiom Previous_previous:
    ((forall co:list.
       (forall cu:cursor [(position_ co (previous_ co cu : cursor) : int)|
         (previous_ co cu : cursor), (position_ co cu : int)].
         ((Int.(>) (position_ co cu : int) 1) ->
          ((position_ co (previous_ co cu : cursor) : int) = (Int.(-) (position_ co cu : int) 1 : int))))) /\
     (forall co:list.
       (forall cu:cursor [(previous_ co cu : cursor)].
         ((((position_ co cu : int) = 1) \/ (cu = (no_element  : cursor))) ->
          ((previous_ co cu : cursor) = (no_element  : cursor))))))
  
  predicate next__ (co : list) (cu1 : cursor) (cu2 : cursor) =
    ((((Int.(>) (length co : int) (position_ co cu1 : int)) /\
       (Int.(>) (position_ co cu1 : int) 0)) ->
      ((position_ co cu2 : int) = (Int.(+) (position_ co cu1 : int) 1 : int))) /\
     ((((Int.(>) (length co : int) 0) /\
        ((position_ co cu1 : int) = (length co : int))) \/
       (cu1 = (no_element  : cursor))) ->
      (cu2 = (no_element  : cursor))))
  
  function next_ list cursor : cursor
  
  axiom Next_next:
    (forall co:list.
      (forall cu:cursor [(next_ co cu : cursor)].
        (next__ co cu (next_ co cu : cursor))))
  
  predicate last_ (co : list) (cu : cursor) =
    (((not (is_empty_ co)) -> ((position_ co cu : int) = (length co : int))) /\
     ((is_empty_ co) -> (cu = (no_element  : cursor))))
  
  function last list : cursor
  
  axiom Last_last:
    (forall co:list [(last co : cursor)]. (last_ co (last co : cursor)))
  
  predicate first_ (co : list) (cu : cursor) =
    (((not (is_empty_ co)) -> ((position_ co cu : int) = 1)) /\
     ((is_empty_ co) -> (cu = (no_element  : cursor))))
  
  function first list : cursor
  
  axiom First_first:
    (forall co:list [(first co : cursor)].
      (first_ co (first co : cursor)))
  
  function element_ list cursor : element_t
  
  predicate left_pos (co : list) (i : int) (col : list) =
    ((forall cu:cursor.
       ((Int.(<=) i (position_ co cu : int)) ->
        ((position_ col cu : int) = 0))) /\
     ((forall cu:cursor.
        ((Int.(>) i (position_ co cu : int)) ->
         ((position_ col cu : int) = (position_ co cu : int)))) /\
      ((forall cu:cursor.
         ((Int.(>) i (position_ co cu : int)) ->
          ((element_ col cu : element_t) = (element_ co cu : element_t)))) /\
       (forall cu:cursor.
         ((Int.(>) (position_ col cu : int) 0) ->
          ((position_ co cu : int) = (position_ col cu : int)))))))
  
  predicate left__ (co : list) (cu : cursor) (col : list) =
    (((cu = (no_element  : cursor)) -> (col = co)) /\
     ((Int.(>) (position_ co cu : int) 0) ->
      (((length col : int) = (Int.(-) (position_ co cu : int) 1 : int)) /\
       (left_pos co (position_ co cu : int) col))))
  
  function left_ list cursor : list
  
  axiom Left_left:
    (forall co:list.
      (forall cu:cursor [(left_ co cu : list)].
        (left__ co cu (left_ co cu : list))))
  
  predicate right_pos (co : list) (i : int) (cor : list) =
    ((forall cu:cursor.
       ((Int.(>) i (position_ co cu : int)) -> ((position_ cor cu : int) = 0))) /\
     ((forall cu:cursor.
        (((Int.(<=) i (position_ co cu : int)) ->
          ((position_ cor cu : int) = (Int.(+) (Int.(-) (position_ co cu : int) i : int) 1 : int))) /\
         ((Int.(>) (position_ cor cu : int) 0) ->
          ((position_ co cu : int) = (Int.(-) (Int.(+) (position_ cor cu : int) i : int) 1 : int))))) /\
      (forall cu:cursor.
        ((Int.(<=) i (position_ co cu : int)) ->
         ((element_ cor cu : element_t) = (element_ co cu : element_t))))))
  
  predicate right__ (co : list) (cu : cursor) (cor : list) =
    (((cu = (no_element  : cursor)) -> (cor = (empty_  : list))) /\
     (((Int.(>) (position_ co cu : int) 0) ->
       (((length cor : int) = (Int.(+) (Int.(-) (length co : int) (position_ co cu : int) : int) 1 : int)) /\
        (right_pos co (position_ co cu : int) cor))) /\
      (forall cun:cursor.
        ((Int.(>) (position_ cor cun : int) 0) ->
         (Int.(>) (position_ co cun : int) 0)))))
  
  function right_ list cursor : list
  
  axiom Right_right:
    (forall co:list.
      (forall cu:cursor [(right_ co cu : list)].
        (right__ co cu (right_ co cu : list))))
  
  function findfirst list element_t : cursor
  
  predicate find_ (co : list) (e : element_t) (cu : cursor) =
    (((cu = (no_element  : cursor)) /\
      (forall cun:cursor.
        ((Int.(>) (position_ co cun : int) 0) ->
         equal_elements (element_ co cun) e = False))) \/
     ((Int.(>) (position_ co cu : int) 0) /\
      ((equal_elements (element_ co cu : element_t) e = True) /\
       (forall cun:cursor.
         (((Int.(>) (position_ co cu : int) (position_ co cun : int)) /\
           (Int.(>) (position_ co cun : int) 0)) ->
          (equal_elements (element_ co cun : element_t) e = False))))))
  
  axiom Find_findval:
    (forall co:list, e:element_t [findfirst co e]. (find_ co e (findfirst co e : cursor)))
  
  function find (l : list) (e : element_t) (cu : cursor) : cursor =
    (findfirst (right_ l cu : list) e : cursor)
  
  predicate strict_equal (co1 : list) (co2 : list) =
    ((forall cu:cursor.
       ((position_ co1 cu : int) = (position_ co2 cu : int))) /\
     (forall cu:cursor.
       ((Int.(>) (position_ co1 cu : int) 0) ->
        (element_ co1 cu = element_ co2 cu))))

  predicate equal_ (co1 : list) (co2 : list) =
   length co1 = length co2 /\
   forall cu1 : cursor. position_ co1 cu1 > 0 ->
	exists cu2 : cursor. position_ co2 cu2 = position_ co1 cu1 /\
		element_ co2 cu2 = element_ co1 cu1
  
  predicate replace_element_ (co1 : list) (cu : cursor) (e : element_t) (co2 : list) =
    ((Int.(>) (position_ co1 cu : int) 0) /\
     (((length co1 : int) = (length co2 : int)) /\
      (((element_ co2 cu : element_t) = e) /\
       ((forall cun:cursor [position_ co2 cun, position_ co1 cun].
          ((position_ co2 cun : int) = (position_ co1 cun : int))) /\
        (forall cun:cursor [element_ co2 cun | element_ co1 cun].
          (((cu <> cun) /\ (Int.(>) (position_ co1 cun : int) 0)) ->
           ((element_ co2 cun : element_t) = (element_ co1 cun : element_t))))))))
  
  predicate insert_pos (co1 : list) (i : int) (co2 : list) =
    ((forall cun:cursor [(position_ co2 cun : int),
       (position_ co1 cun : int)].
       ((((Int.(>) i (position_ co1 cun : int)) /\
          (Int.(>) (position_ co1 cun : int) 0)) ->
         ((position_ co2 cun : int) = (position_ co1 cun : int))) /\
        ((Int.(<=) i (position_ co1 cun : int)) ->
         ((position_ co2 cun : int) = (Int.(+) (position_ co1 cun : int) 1 : int))))) /\
     (forall cun:cursor [element_ co1 cun | element_ co2 cun].
       ((Int.(>) (position_ co1 cun : int) 0) ->
        ((element_ co1 cun : element_t) = (element_ co2 cun : element_t)))))
  
  predicate insert_inv (co1 : list) (i : int) (e : element_t) (co2 : list) =
    ((forall cun:cursor [element_ co2 cun].
       (((position_ co2 cun : int) = i) ->
        ((element_ co2 cun : element_t) = e))) /\
     ((forall cun:cursor [element_ co1 cun | element_ co2 cun].
        ((((Int.(>) i (position_ co2 cun : int)) /\
           (Int.(>) (position_ co2 cun : int) 0)) ->
          ((element_ co1 cun : element_t) = (element_ co2 cun : element_t))) /\
         ((Int.(>) (position_ co2 cun : int) i) ->
          ((element_ co1 cun : element_t) = (element_ co2 cun : element_t))))) /\
      (forall cun:cursor [(position_ co2 cun : int),
        (position_ co1 cun : int)].
        ((((position_ co2 cun : int) = i) -> ((position_ co1 cun : int) = 0)) /\
         ((((Int.(>) i (position_ co2 cun : int)) /\
            (Int.(>) (position_ co2 cun : int) 0)) ->
           ((position_ co1 cun : int) = (position_ co2 cun : int))) /\
          ((Int.(>) (position_ co2 cun : int) i) ->
           ((position_ co1 cun : int) = (Int.(-) (position_ co2 cun : int) 1 : int))))))))
  
  predicate insert_ (co1 : list) (cu : cursor) (e : element_t) (co2 : list) =
    (((cu = (no_element  : cursor)) \/ (Int.(>) (position_ co1 cu : int) 0)) /\
     (((length co2 : int) = (Int.(+) (length co1 : int) 1 : int)) /\
      (((cu = (no_element  : cursor)) /\
        ((insert_pos co1 (Int.(+) (length co1 : int) 1 : int) co2) /\
         (insert_inv co1 (Int.(+) (length co1 : int) 1 : int) e co2))) \/
       ((Int.(>) (position_ co1 cu : int) 0) /\
        ((insert_pos co1 (position_ co1 cu : int) co2) /\
         (insert_inv co1 (position_ co1 cu : int) e co2))))))
  
  predicate delete_pos (co1 : list) (i : int) (co2 : list) =
    ((forall cun:cursor [(position_ co2 cun : int),
       (position_ co1 cun : int)].
       ((((position_ co1 cun : int) = i) -> ((position_ co2 cun : int) = 0)) /\
        (((Int.(>) (position_ co1 cun : int) i) ->
          ((position_ co2 cun : int) = (Int.(-) (position_ co1 cun : int) 1 : int))) /\
         ((Int.(>) i (position_ co1 cun : int)) ->
          ((position_ co2 cun : int) = (position_ co1 cun : int)))))) /\
     (forall cun:cursor [(element_ co2 cun : element_t)|
       (element_ co1 cun : element_t)].
       (((Int.(>) (position_ co1 cun : int) i) ->
         ((element_ co2 cun : element_t) = (element_ co1 cun : element_t))) /\
        ((Int.(>) i (position_ co1 cun : int)) ->
         ((element_ co2 cun : element_t) = (element_ co1 cun : element_t))))))
  
  predicate delete_inv (co1 : list) (i : int) (co2 : list) =
    ((forall cun:cursor [(element_ co2 cun : element_t)|
       (element_ co1 cun : element_t)].
       (((Int.(<=) i (position_ co2 cun : int)) ->
         ((element_ co1 cun : element_t) = (element_ co2 cun : element_t))) /\
        (((Int.(>) i (position_ co2 cun : int)) /\
          (Int.(>) (position_ co2 cun : int) 0)) ->
         ((element_ co2 cun : element_t) = (element_ co1 cun : element_t))))) /\
     (forall cun:cursor [(position_ co2 cun : int),
       (position_ co1 cun : int)].
       ((((Int.(>) i (position_ co2 cun : int)) /\
          (Int.(>) (position_ co2 cun : int) 0)) ->
         ((position_ co1 cun : int) = (position_ co2 cun : int))) /\
        ((Int.(<=) i (position_ co2 cun : int)) ->
         ((position_ co1 cun : int) = (Int.(+) (position_ co2 cun : int) 1 : int))))))
  
  predicate delete_ (co1 : list) (cu : cursor) (co2 : list) =
    ((Int.(>) (position_ co1 cu : int) 0) /\
     (((length co2 : int) = (Int.(-) (length co1 : int) 1 : int)) /\
      ((delete_pos co1 (position_ co1 cu : int) co2) /\
       (delete_inv co1 (position_ co1 cu : int) co2))))
  
  predicate has_element (co : list) (cu : cursor) =
    (Int.(>) (position_ co cu : int) 0)
  
  predicate contains (co : list) (e : element_t) =
    (Int.(>) (position_ co (findfirst co e : cursor) : int) 0)

val element :
	  co:list -> cu:cursor ->
	  { has_element co cu }
	  element_t
	  { result = element_ co cu }

val replace_element :
	  co:ref list -> cu:cursor -> e:element_t ->
	  { has_element !co cu }
	  unit writes co
	  { replace_element_ (old !co) cu e !co }

val insert :
	  co:ref list -> cu:cursor -> e:element_t ->
	  { has_element !co cu \/ cu = no_element }
	  unit reads co writes co
	  { insert_ (old !co) cu e !co }

val prepend :
	  co:ref list -> e:element_t ->
	  { }
	  unit reads co writes co
	  { insert_ (old !co) (first (old !co)) e !co }

val append :
	  co:ref list -> e:element_t ->
	  { }
	  unit reads co writes co
	  { insert_ (old !co) no_element e !co }

val delete :
	  co:ref list -> cu:cursor ->
	  { has_element !co cu }
	  unit reads co writes co
	  { delete_ (old !co) cu !co }

val previous :
	  co:list -> cu:cursor ->
	  { cu = no_element \/ has_element co cu }
	  cursor
	  { result = previous_ co cu }

val next :
	  co:list -> cu:cursor ->
	  { cu = no_element \/ has_element co cu }
	  cursor 
	  { result = next_ co cu }

end


(* a list can be used to store the set of currently enabled monitoring of a
   system. Then, we may wish to verify that if no monitoring detects failure,
   then no recovery is triggered *)

include "list.why"

type recovery_t = None | Reboot

exception Recovery of recovery_t

logic detects_failure_: element_t -> bool 

parameter detects_failure: e:element_t -> 
  {} 
  bool 
  { if result then detects_failure_(e) = true 
    else detects_failure_(e) = false }

predicate no_monitor_detects_failure (co:list) =
	  forall cu:cursor.
	      has_element_(co,cu) -> detects_failure_(element_(co,cu)) = false

let test_recovery (co:list) =
    let cu = ref (first co) in
    let res = ref None in
    try
        while has_element co !cu do
            if detects_failure (element co !cu) then
               raise (Recovery Reboot);
            cu := next co !cu
        done
    with Recovery re -> res := re end;
    !res
    { no_monitor_detects_failure(co) -> result = None }


Rod,

Here are the Eurovision Song Contest votes for the Instructor role.
(Well, they are my comments. Flo and Bob may come up with more comments
later.)

I've tried to provide comments with the instructor role in mind. I've 
also included general comments that occurred to me, and typos. Hopefully
you can filter out the typos and address them separately.

I reviewed it front to back and ran out of time towards the end so the
comments are front-loaded I'm afraid.

Reviewer: RPM
Section: Introduction
Page/para: p4, 1st bullet (and discussed further in 1.8)
Comment: I'm a bit confused about how the SPARK 2014 language will provide
for the mixing of verification evidence from code that is within the 2014
subset and code that is outside of it. I can imagine a process where you 
do this, and have a mixture of 2014 and non-2014 code, and a mixture of 
formal verification and testing, but how does this influence the 2014
language itself? Does it boil down to modularity and the ability to mix 2014
and non-2014 features at a fine level? I suppose the potential confusion
is that your whole "SPARK 2014" program may be a mixture of SPARK 2014 and
non-SPARK 2014 code, but do you still call the whole thing a SPARK 2014 program?

Reviewer: RPM
Section: 1.5
Page/para: p5, 8th para in section 1.5
Comment: Replace "except that the one exception is" with ". The one exception is"

Reviewer: RPM
Section: 4.2
Page/para: p14
Comment: The word 'null' appears quite often in SPARK 2014 aspects. I guess it is
not a 'literal' when it is used in that context?

Reviewer: RPM
Section: 4.3.4
Page/para: p15
Comment: From a teaching perspective, it seems that it would be easier to say that
multiple ranges in an array update expression are not permitted to overlap, rather
than having to explain that they may overlap and that they are performed in the order
given. Is the rule like this because it's too hard to determine whether they overlap,
or because we want to allow users more flexibility?

Reviewer: RPM
Section: 5.1
Page/para: p17, section 5.1, item 2
Comment: Typo "shall not be am" -> "shall not be an"

Reviewer: RPM
Section: 5.5.3
Page/para: p19, para 1
Comment: So a pragma Loop_Invariant is equivalent to a pragma Assert, apart from 
some extra restrictions on the placement of a pragma Loop_Invariant. That implies
that you could just use pragma Assert instead of pragma Loop_Invariant. Is that
true?

Reviewer: RPM
Section: 5.5.3
Page/para: p19, middle
Comment: It says that proving the Loop_Variant implies the termination of the loop.
I didn't spot anything that says the loop variant has to be related to any loop
exit condition. That could be deliberate, on the grounds that even if the variant
is nothing to do with any loop exit condition then it will eventually cause the 
loop to terminate with an exception when something overflows (and hopefully we 
have shown that this can't happen, therefore the variant must be related to an 
exit condition) but I thought I would mention it.

Reviewer: RPM
Section: 5.9
Page/para: p21, just before 'Examples'
Comment: "A boolean expression given by pragma Assume can be assumed to be true
for the remainder of the subprogram." Is that true? Is it invariant for the rest
of the subprogram? Couldn't something get changed later on which meant it was no
longer true?

Reviewer: RPM
Section: general 
Page/para: general
Comment: There is an inconsistent mix of Boolean and boolean throughout
the document. Should all be Boolean.

Reviewer: RPM
Section: 6.1.3
Page/para: p24
Comment: Typo "specify a mutually independent cases" -> delete the "a"

Reviewer: RPM
Section: 6.1.3
Page/para:p25
Comment: Typo "con formant" -> "conformant"

Reviewer: RPM
Section: 6.1.4
Page/para: p27
Comment: List numbering restarts after item 6. Is this intentional?

Reviewer: RPM
Section: 6.1.4
Page/para: p27
Comment: Typo "efective"

Reviewer: RPM
Section: various (e.g. 6.1.4)
Page/para: various (grep for it)
Comment: Typo. Several instances of "is used purely for static analyses purposes" 
Should be "analysis". 

Reviewer: RPM
Section: 6.1.5
Page/para: p29 
Comment: If you say "Output => (A, B, C, I (if I = 42 then D))" I assume that "I = 42"
refers to the initial value of I? I didn¡¯t spot that in the rules when I skimmed them.

Reviewer: RPM
Section: 6.1.5
Page/para: p29, item 5a
Comment: Typo "name of a object" should be "an"

Reviewer: RPM
Section: 6.1.5
Page/para: p30, example code
Comment: Typo "filed" -> "field"

Reviewer: RPM
Section: 6.1.5
Page/para: 
Comment: If I understand correctly, you can specify a global as In_Out or you can 
specify it as both Input and Output and it means the same thing. From an ease of 
teaching viewpoint I don't see the point of In_Out.

Reviewer: RPM
Section: 6.1.6
Page/para: p31, top example (same typo in 3 places)
Comment: Typo "the values remainder" -> "the values of the remainder"

Reviewer: RPM
Section: 6.1.6
Page/para: p31, 3rd case in example
Comment: In comment "I = 10" should be "K = 10".

Reviewer: RPM
Section: 6.1.7
Page/para: p33, item 8
Comment: This doesn't make sense. Looks like some sort of editing error.

Reviewer: RPM
Section: 6.1.7
Page/para: p33, item 9
Comment: Typo "my" -> "may"

Reviewer: RPM
Section: 6.1.7
Page/para: p35, final example (and preceding text too I guess)
Comment: It says that dependency aspects are only needed for functions to
describe conditional dependencies. What about null dependencies? This is 
something that caused problems in S95 when we implemented automatic flow
analysis as there were cases where it would have been much better if we
could have said that a function derives its return value from some of
its imports and derives null from other imports. I can expand on that if
required.

Reviewer: RPM
Section: 6.3.6
Page/para: p37
Comment:  Typo "consitency"

Reviewer: RPM
Section: 6.4.2
Page/para: p38, penultimate para
Comment: Typo/grammar "a function call cannot introduce aliasing and are"

Reviewer: RPM
Section: 6.4.2
Page/para: p39, 1st para
Comment: From a teaching perspective, having to know if a type is by-copy
makes this more complex. It would be simpler not to have this relaxation 
of the rule for by-copy types but I can see there is a trade-off between 
simplicity and having less restrictions.

Reviewer: RPM
Section: 7.1.6
Page/para: p51, example code
Comment: Typo "neme" -> "name"

--
Robin

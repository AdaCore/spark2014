Introduction
============

|SPARK| is a programming language and a set of verification tools
designed to meet the needs of high-assurance software development.
|SPARK| is based on Ada 2012, both subsetting the language to remove
features that defy verification, but also extending the system of
contracts and "aspects" to support modular, formal verification.

|SPARK| is a much larger and more flexible language than its
predecessor SPARK 2005. The language can be configured to suit
a number of application domains and standards, from server-class
high-assurance systems (such as air-traffic management applications),
to embedded, hard real-time, critical systems (such as avionic
systems complying with DO-178C Level A).

How to Read this Manual
-----------------------

This language reference manual is *not* a tutorial guide
to |SPARK|.  It is intended as a reference guide for
users and implementors of the language.  In this context
"implementors" includes those producing both compilers and
verification tools.

This manual is written in the style and language of the Ada 2012 LRM,
so knowledge of Ada 2012 is assumed.  Chapters 2 through 13 mirror
the structure of the Ada 2012 LRM.  Chapter 14 covers all the annexes
of the Ada LRM.

Readers interested in how SPARK 2005 constructs and idioms map into
|SPARK| should consult the appendix :ref:`mapping-spec-label`.

|SPARK| Design Goals
--------------------

Principal design goals are as follows:

- Provision of "formal analysis" as defined by DO-333, which states
  "an analysis method can only be regarded as formal analysis
  if its determination of property is sound. Sound analysis means
  that the method never asserts a property to be true when it is not true."

- The language design shall support the case for soundness of analysis.
  Language features that defy sound analysis will be eliminated or their
  use constrained to meet this goal.

- The language shall offer an *unambiguous* semantics. In Ada terminology,
  this means that all erroneous and unspecified behaviour shall
  be eliminated. Implementation-defined features will be automatically
  determined for projects using GNAT, or will be configurable (where
  possible) or rejected for other compilers.

- The |SPARK| language subset shall embody the largest subset of Ada 2012 that is
  currently amenable to formal verification, in line with the goals above, although
  future advances in verification research and computing power may allow
  for expansion of the language and the forms of verification available.

- |SPARK| shall provide for both constructive and retrospective modes of
  verification.

- |SPARK| shall provide for mixing of verification evidence generated
  by formal analysis (for code written in the |SPARK| subset) and
  evidence generated by testing or other traditional means for
  code written outside of the core |SPARK| language, including
  legacy Ada code.

Profiles and Analyses
---------------------

In addition to the core |SPARK| language subset, the language
may define a number of *Profiles* which are designed to meet
the needs of particular

- Application domains - for example, server-class air-traffic management systems,

- Standards - for example, DO-178C Level A,

- Technical requirements - for example, systems requiring software that is amenable
  to worst-case execution time (WCET) analysis or compatibility with a "zero footprint" runtime profile.

|SPARK| will be amenable to a range of formal analyses, including but not limited to:

- Data-flow analysis.

- Information-flow analysis and program slicing.

- Formal verification of robustness properties. In Ada terminology, this refers to
  the proof that a predefined check will never fail at run-time, and hence predefined
  exceptions will never be raised.

- Formal verification of functional properties, based on contracts expressed as
  pre-conditions, post-conditions, type-invariants and so on.

- Formal verification of non-functional properties, such as WCET and
  worst-case memory usage analysis.

Principal Language Restrictions
-------------------------------

To facilitate formal verification, |SPARK| enforces a number of global
simplifications to Ada 2012. While these are covered in more detail
in the remaining chapters of this document, the most notable simplifications are:

- The use of access types and allocators is not permitted.

- All expressions and functions are free of side-effects.

- Aliasing of names is not permitted.

- The goto statement is not permitted.

- The use of controlled types is not permitted.

- Tasking is not currently permitted.

- Raising and handling of user-defined exceptions is not permitted.

We describe a program unit or language feature as being "in |SPARK|" if it complies
with the restrictions required to permit formal verification.  Conversely, a program unit language
feature is "not in |SPARK|" if it does not meet these requirements, and so is not amenable
to formal verification. Within a single unit, features which are "in" and "not in" |SPARK| may be mixed
at a fine level. For example, the following combinations may be typical:

- Package specification in |SPARK|. Package body entirely not in |SPARK|.

- Visible part of package specification in |SPARK|. Private part and body not in |SPARK|.

- Package specification in |SPARK|. Package body almost entirely in |SPARK| with a small
  number of subprogram bodies not in |SPARK|.

- Package specification in |SPARK|, with all bodies imported from another language.

- Package specification contains a mixture of declarations which are in |SPARK| and not in |SPARK|.
  The latter declarations are only visible and usable from client units which are not in |SPARK|.

Such patterns are intended to allow for mixed language programming, and the development of programs
that mix formal verification and more traditional testing.

Optional Restrictions and Profiles
----------------------------------

In additional to the global simplifications of the language given above, |SPARK|
defines a number of Restrictions that may be optionally applied to an entire
project, program or unit. These restirctions may provide additional simplification
of the language that users feel necessary, may meet particular demands of standards
or coding guidelines, and may facilitate additional forms of verification, or
may improve the level of automation achievable with existing analyses.

A *Profile* is a set of such Restrictions.

Constructive and Retrospective Verification Modes
-------------------------------------------------

SPARK2005 strongly favoured the *constructive* verification style - where all program
units required mandatory contracts on their specifications.  These contracts had to be
designed and added at an early stage to assist modular verification, and then maintained
by the user as a program evolved.

In contrast, |SPARK| is designed to facilitate a more *retrospective* mode of program
construction and verification, where useful forms of verification can be achieved with
code that complies with the core |SPARK| restrictions, but otherwise does not have any contracts.
In this mode, implicit contracts can be computed from the bodies of units, and then 
used in the analysis of other units, and so on.  These implicit contracts can
be "promoted" by the user to become part of the specification of a unit, allowing the
designer to move from the retrospective to the constructive mode as a project matures.
The retrospective mode also allows for the verification of legacy code that was not
originally designed with the |SPARK| contracts in mind.

Finally, unit are do not comply with the rules of |SPARK| can be verified by testing
against the stated contracts, allowing verification goals to be met by a mixture of
analysis and test.

.. todo:: RCC: More here on the mixed proof/test mode and how it works?  I am trying hard
   here to avoid specifiying tool behaviour in the LRM, so it's difficult to know how far
   to go in terms of stating what will be possible without getting too tool-specific.
   Target: D1/CDR.


Method of Description and Syntax Notation
-----------------------------------------

In expressing the syntax and rules of |SPARK|, the remaining chapters of
this document follow the notational conventions of the Ada 2012 LRM (section 1.1.4).


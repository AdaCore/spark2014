Introduction
============

|SPARK| is a programming language and a set of verification tools
designed to meet the needs of high-assurance software development.
|SPARK| is based on Ada 2012, both subsetting the language to remove
features that defy verification, but also extending the system of
contracts and "aspects" to support modular, formal verification.

|SPARK| is a much larger and more flexible language than its
predecessor SPARK 2005. The language can be configured to suit
a number of application domains and standards, from server-class
high-assurance systems (such as air-traffic management applications),
to embedded, hard real-time, critical systems (such as avionic
systems complying with DO-178C Level A).

How to Read this Manual
-----------------------

This language reference manual is *not* a tutorial guide
to |SPARK|.  It is intended as a reference guide for
users and implementors of the language.  In this context
"implementors" includes those producing both compilers and
verification tools.

This manual is written in the style and language of the Ada 2012 LRM,
so knowledge of Ada 2012 is assumed.  Chapters 2 through 13 mirror
the structure of the Ada 2012 LRM.  Chapter 14 covers all the annexes
of the Ada LRM.

Readers interested in how SPARK 2005 constructs and idioms map into
|SPARK| should consult the appendix :ref:`mapping-spec-label`.

|SPARK| Design Goals
--------------------

Principal design goals are as follows:

- Provision of "formal analysis" as defined by DO-333, which states
  "an analysis method can only be regarded as formal analysis
  if its determination of property is sound. Sound analysis means
  that the method never asserts a property to be true when it is not true."

- The language design shall support the case for soundness of analysis.
  Language features that defy sound analysis will be eliminated or their
  use constrained to meet this goal.

- The language shall offer an *unambiguous* semantics. In Ada terminology,
  this means that all erroneous and unspecified behaviour shall
  be eliminated. Implementation-defined features will be automatically
  determined for projects using GNAT, or will be configurable (where
  possible) or rejected for other compilers.

- The |SPARK| language subset shall embody the largest subset of Ada 2012 that is
  currently amenable to formal verification, in line with the goals above, although
  future advances in verification research and computing power may allow
  for expansion of the language and the forms of verification available.

- |SPARK| shall provide for both constructive and retrospective modes of
  verification.

- |SPARK| shall provide for mixing of verification evidence generated
  by formal analysis (for code written in the |SPARK| subset) and
  evidence generated by testing or other traditional means for
  code written outside of the core |SPARK| language, including
  legacy Ada code.

Profiles and Analyses
---------------------

In addition to the core |SPARK| language subset, the language
may define a number of *Profiles* which are designed to meet
the needs of particular

- Application domains - for example, server-class air-traffic management systems,

- Standards - for example, DO-178C Level A,

- Technical requirements - for example, systems requiring software that is amenable
  to worst-case execution time (WCET) analysis or compatibility with a "zero footprint" runtime profile.

|SPARK| will be amenable to a range of formal analyses, including but not limited to:

- Data-flow analysis.

- Information-flow analysis and program slicing.

- Formal verification of robustness properties. In Ada terminology, this refers to
  the proof that a predefined check will never fail at run-time, and hence predefined
  exceptions will never be raised.

- Formal verification of functional properties, based on contracts expressed as
  pre-conditions, post-conditions, type-invariants and so on.

- Formal verification of non-functional properties, such as WCET and
  worst-case memory usage analysis.

.. todo:: Should we talk about other forms of verification here? For example, other
   forms of abstract interpretation, model-checking, symbolic execution,
   concurrency analysis, etc?  Is this
   a list of what we plan to do for release 1, or a list of what we *might* be able
   to do in the future?

Principal Language Restrictions
-------------------------------

To facilitate formal verification, |SPARK| enforces a number of global
simplifications to Ada 2012. While these are covered in more detail
in the remaining chapters of this document, the most notable simplifications are:

- The use of access types and allocators is not permitted.

- All expressions and functions are free of side-effects.

- Aliasing of names is not permitted.

- The goto statement is not permitted.

- The use of controlled types is not permitted.

- Tasking is not currently permitted.

- Raising and handling of user-defined exceptions is not permitted.

.. todo:: RCC to check other major restrictions in the GNATProve UG and
   summarize here.  As this section develops and becomes definitive,
   consider removing or reducing duplication in the UG.

Method of Description and Syntax Notation
-----------------------------------------

In expressing the syntax and rules of |SPARK|, the remaining chapters of
this document follow the notational conventions of the Ada 2012 LRM (section 1.1.4).

Original Material from TJJ
--------------------------

Material below is retained from TJJ's draft of this chapter - to be
reviewed and incorporated into the above.

Language Subset
~~~~~~~~~~~~~~~

|SPARK| is a subset of Ada 2012 which may be used to prove the absence
of run-time exceptions and, if suitable postconditions are provided,
program correctness .  |SPARK| introduces a number of new aspect marks
to use in aspect specifications to provide:

* more detailed and concise subprogram specifications;
* support for static analyses;
* facilities for constructive, modular proof and analysis - proof and
  static analyses may be performed on partial and incomplete programs;
  and
* higher levels of abstraction for data and modelling.

A number of selectable restrictions specific to |SPARK| have been
introduced to provide language profiles tailored to particular
domains, but the restrictions may be applied individually using the
pragma ``Restrictions`` or, conversely, a restriction that is in
place, possibly due to a particular profile being active, may be
overridden locally using the same pragma.

.. todo:: Should |SPARK| itself be a restriction?  It actually adds
  new features so I am not sure.  I am not entirely happy with the
  next paragraph, which is why I raise this question.  I think there
  should also be a command line switch or some way of stating that the
  whole program has to be in |SPARK| unless a deliberate escape is
  made. Alternatively, do we need the pragma/aspect |SPARK| at all.
  Could we assume that the program is |SPARK| unless we step outside
  the subset when a warning is given, and perhaps we could have a
  restriction in |SPARK| called Ada => 2012, Ada => 95, etc. which
  indicates that this part of the program is not in |SPARK| and
  therefore will not raise the warnings?

An Ada program may contain units in |SPARK| and units not in
|SPARK|. An Ada unit may contain packages and subprograms in |SPARK|
and others not in |SPARK|. The user can specify that a unit should be
in |SPARK| by using the pragma |SPARK|. Likewise, the user can specify
that a package or a subprogram should be in |SPARK| by using the
aspect |SPARK| on the entity declaration, or the pragma ``SPARK_2014``
in the body of the package or subprogram.

To perform proofs and some of the deeper static analyses of a unit the
code must be in SPARK, and depending on the type of analysis may
require some further restrictions to be applied.

.. todo:: I think we need to mention here in outline how we deal with
  the dichotomy between proven, non proven and tested and resolve
  these different parts into a coherent whole.

.. todo:: Need to describe the difference between two modes of
  working, constructive-modular and generative.

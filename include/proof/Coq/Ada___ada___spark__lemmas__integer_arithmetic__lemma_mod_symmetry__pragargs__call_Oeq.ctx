(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require int.Int.
Require int.Abs.
Require int.EuclideanDivision.
Require int.ComputerDivision.
Require bool.Bool.

Axiom us_private : Type.
Parameter us_private_WhyType : WhyType us_private.
Existing Instance us_private_WhyType.

(* Why3 assumption *)
Definition us_fixed := Numbers.BinNums.Z.

Parameter private__bool_eq: us_private -> us_private -> Init.Datatypes.bool.

Parameter us_null_ext__: us_private.

Axiom us_type_of_heap : Type.
Parameter us_type_of_heap_WhyType : WhyType us_type_of_heap.
Existing Instance us_type_of_heap_WhyType.

(* Why3 assumption *)
Inductive us_type_of_heap__ref :=
  | us_type_of_heap__ref'mk : us_type_of_heap -> us_type_of_heap__ref.
Axiom us_type_of_heap__ref_WhyType : WhyType us_type_of_heap__ref.
Existing Instance us_type_of_heap__ref_WhyType.

(* Why3 assumption *)
Definition us_type_of_heap__content (v:us_type_of_heap__ref) :
    us_type_of_heap :=
  match v with
  | us_type_of_heap__ref'mk x => x
  end.

Axiom us_image : Type.
Parameter us_image_WhyType : WhyType us_image.
Existing Instance us_image_WhyType.

(* Why3 assumption *)
Inductive int__ref :=
  | int__ref'mk : Numbers.BinNums.Z -> int__ref.
Axiom int__ref_WhyType : WhyType int__ref.
Existing Instance int__ref_WhyType.

(* Why3 assumption *)
Definition int__content (v:int__ref) : Numbers.BinNums.Z :=
  match v with
  | int__ref'mk x => x
  end.

(* Why3 assumption *)
Inductive bool__ref :=
  | bool__ref'mk : Init.Datatypes.bool -> bool__ref.
Axiom bool__ref_WhyType : WhyType bool__ref.
Existing Instance bool__ref_WhyType.

(* Why3 assumption *)
Definition bool__content (v:bool__ref) : Init.Datatypes.bool :=
  match v with
  | bool__ref'mk x => x
  end.

(* Why3 assumption *)
Inductive us_fixed__ref :=
  | us_fixed__ref'mk : Numbers.BinNums.Z -> us_fixed__ref.
Axiom us_fixed__ref_WhyType : WhyType us_fixed__ref.
Existing Instance us_fixed__ref_WhyType.

(* Why3 assumption *)
Definition us_fixed__content (v:us_fixed__ref) : Numbers.BinNums.Z :=
  match v with
  | us_fixed__ref'mk x => x
  end.

(* Why3 assumption *)
Inductive real__ref :=
  | real__ref'mk : Reals.Rdefinitions.R -> real__ref.
Axiom real__ref_WhyType : WhyType real__ref.
Existing Instance real__ref_WhyType.

(* Why3 assumption *)
Definition real__content (v:real__ref) : Reals.Rdefinitions.R :=
  match v with
  | real__ref'mk x => x
  end.

(* Why3 assumption *)
Inductive us_private__ref :=
  | us_private__ref'mk : us_private -> us_private__ref.
Axiom us_private__ref_WhyType : WhyType us_private__ref.
Existing Instance us_private__ref_WhyType.

(* Why3 assumption *)
Definition us_private__content (v:us_private__ref) : us_private :=
  match v with
  | us_private__ref'mk x => x
  end.

(* Why3 assumption *)
Definition int__ref___projection (a:int__ref) : Numbers.BinNums.Z :=
  int__content a.

(* Why3 assumption *)
Definition us_fixed__ref___projection (a:us_fixed__ref) : Numbers.BinNums.Z :=
  us_fixed__content a.

(* Why3 assumption *)
Definition bool__ref___projection (a:bool__ref) : Init.Datatypes.bool :=
  bool__content a.

(* Why3 assumption *)
Definition real__ref___projection (a:real__ref) : Reals.Rdefinitions.R :=
  real__content a.

(* Why3 assumption *)
Definition us_private__ref___projection (a:us_private__ref) : us_private :=
  us_private__content a.

Parameter bool_eq:
  Numbers.BinNums.Z -> Numbers.BinNums.Z -> Init.Datatypes.bool.

Parameter bool_ne:
  Numbers.BinNums.Z -> Numbers.BinNums.Z -> Init.Datatypes.bool.

Parameter bool_lt:
  Numbers.BinNums.Z -> Numbers.BinNums.Z -> Init.Datatypes.bool.

Parameter bool_le:
  Numbers.BinNums.Z -> Numbers.BinNums.Z -> Init.Datatypes.bool.

Parameter bool_gt:
  Numbers.BinNums.Z -> Numbers.BinNums.Z -> Init.Datatypes.bool.

Parameter bool_ge:
  Numbers.BinNums.Z -> Numbers.BinNums.Z -> Init.Datatypes.bool.

Axiom bool_eq_axiom :
  forall (x:Numbers.BinNums.Z), forall (y:Numbers.BinNums.Z),
  ((bool_eq x y) = Init.Datatypes.true) <-> (x = y).

Axiom bool_ne_axiom :
  forall (x:Numbers.BinNums.Z), forall (y:Numbers.BinNums.Z),
  ((bool_ne x y) = Init.Datatypes.true) <-> ~ (x = y).

Axiom bool_lt_axiom :
  forall (x:Numbers.BinNums.Z), forall (y:Numbers.BinNums.Z),
  ((bool_lt x y) = Init.Datatypes.true) <-> (x < y)%Z.

Axiom bool_int__le_axiom :
  forall (x:Numbers.BinNums.Z), forall (y:Numbers.BinNums.Z),
  ((bool_le x y) = Init.Datatypes.true) <-> (x <= y)%Z.

Axiom bool_gt_axiom :
  forall (x:Numbers.BinNums.Z), forall (y:Numbers.BinNums.Z),
  ((bool_gt x y) = Init.Datatypes.true) <-> (y < x)%Z.

Axiom bool_ge_axiom :
  forall (x:Numbers.BinNums.Z), forall (y:Numbers.BinNums.Z),
  ((bool_ge x y) = Init.Datatypes.true) <-> (y <= x)%Z.

Parameter length:
  Numbers.BinNums.Z -> Numbers.BinNums.Z -> Numbers.BinNums.Z.

Axiom length'def :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z),
  ((x <= y)%Z -> ((length x y) = ((y - x)%Z + 1%Z)%Z)) /\
  (~ (x <= y)%Z -> ((length x y) = 0%Z)).

Axiom integer : Type.
Parameter integer_WhyType : WhyType integer.
Existing Instance integer_WhyType.

Parameter integer'int: integer -> Numbers.BinNums.Z.

Axiom integer'axiom :
  forall (i:integer),
  ((-2147483648%Z)%Z <= (integer'int i))%Z /\
  ((integer'int i) <= 2147483647%Z)%Z.

(* Why3 assumption *)
Definition in_range (x:Numbers.BinNums.Z) : Prop :=
  ((-2147483648%Z)%Z <= x)%Z /\ (x <= 2147483647%Z)%Z.

Parameter bool_eq1:
  Numbers.BinNums.Z -> Numbers.BinNums.Z -> Init.Datatypes.bool.

Axiom bool_eq'def :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z),
  ((x = y) -> ((bool_eq1 x y) = Init.Datatypes.true)) /\
  (~ (x = y) -> ((bool_eq1 x y) = Init.Datatypes.false)).

Parameter attr__ATTRIBUTE_IMAGE: Numbers.BinNums.Z -> us_image.

Parameter attr__ATTRIBUTE_VALUE__pre_check: us_image -> Prop.

Parameter attr__ATTRIBUTE_VALUE: us_image -> Numbers.BinNums.Z.

Parameter user_eq: integer -> integer -> Init.Datatypes.bool.

Parameter dummy: integer.

(* Why3 assumption *)
Inductive integer__ref :=
  | integer__ref'mk : integer -> integer__ref.
Axiom integer__ref_WhyType : WhyType integer__ref.
Existing Instance integer__ref_WhyType.

(* Why3 assumption *)
Definition integer__content (v:integer__ref) : integer :=
  match v with
  | integer__ref'mk x => x
  end.

(* Why3 assumption *)
Definition integer__ref_integer__content__projection (a:integer__ref) :
    integer :=
  integer__content a.

(* Why3 assumption *)
Definition dynamic_invariant (temp___expr_18:Numbers.BinNums.Z)
    (temp___is_init_14:Init.Datatypes.bool)
    (temp___skip_constant_15:Init.Datatypes.bool)
    (temp___do_toplevel_16:Init.Datatypes.bool)
    (temp___do_typ_inv_17:Init.Datatypes.bool) : Prop :=
  (temp___is_init_14 = Init.Datatypes.true) \/
  ((-2147483648%Z)%Z <= 2147483647%Z)%Z -> in_range temp___expr_18.

Parameter arg1: Numbers.BinNums.Z.

Parameter attr__ATTRIBUTE_ADDRESS: Numbers.BinNums.Z.

Parameter arg2: Numbers.BinNums.Z.

Parameter attr__ATTRIBUTE_ADDRESS1: Numbers.BinNums.Z.

(* Why3 assumption *)
Definition us_rep := Numbers.BinNums.Z.

Parameter bool_eq2:
  Numbers.BinNums.Z -> Numbers.BinNums.Z -> Init.Datatypes.bool.

(* Why3 assumption *)
Definition big_integer := Numbers.BinNums.Z.

Parameter value__size: Numbers.BinNums.Z.

Parameter object__size: Numbers.BinNums.Z.

Parameter alignment: Numbers.BinNums.Z.

Axiom value__size_axiom : (0%Z <= value__size)%Z.

Axiom object__size_axiom : (0%Z <= object__size)%Z.

Axiom alignment_axiom : (0%Z <= alignment)%Z.

Parameter user_eq1:
  Numbers.BinNums.Z -> Numbers.BinNums.Z -> Init.Datatypes.bool.

Parameter dummy1: Numbers.BinNums.Z.

(* Why3 assumption *)
Inductive big_integer__ref :=
  | big_integer__ref'mk : Numbers.BinNums.Z -> big_integer__ref.
Axiom big_integer__ref_WhyType : WhyType big_integer__ref.
Existing Instance big_integer__ref_WhyType.

(* Why3 assumption *)
Definition big_integer__content (v:big_integer__ref) : Numbers.BinNums.Z :=
  match v with
  | big_integer__ref'mk x => x
  end.

(* Why3 assumption *)
Definition big_integer__ref_big_integer__content__projection
    (a:big_integer__ref) : Numbers.BinNums.Z :=
  big_integer__content a.

(* Why3 assumption *)
Definition valid_big_integer := Numbers.BinNums.Z.

(* Why3 assumption *)
Inductive valid_big_integer__ref :=
  | valid_big_integer__ref'mk : Numbers.BinNums.Z -> valid_big_integer__ref.
Axiom valid_big_integer__ref_WhyType : WhyType valid_big_integer__ref.
Existing Instance valid_big_integer__ref_WhyType.

(* Why3 assumption *)
Definition valid_big_integer__content (v:valid_big_integer__ref) :
    Numbers.BinNums.Z :=
  match v with
  | valid_big_integer__ref'mk x => x
  end.

(* Why3 assumption *)
Definition valid_big_integer__ref_valid_big_integer__content__projection
    (a:valid_big_integer__ref) : Numbers.BinNums.Z :=
  valid_big_integer__content a.

(* Why3 assumption *)
Definition dynamic_invariant1 (temp___expr_188:Numbers.BinNums.Z)
    (temp___is_init_184:Init.Datatypes.bool)
    (temp___skip_constant_185:Init.Datatypes.bool)
    (temp___do_toplevel_186:Init.Datatypes.bool)
    (temp___do_typ_inv_187:Init.Datatypes.bool) : Prop :=
  True.

(* Why3 assumption *)
Definition dynamic_predicate (temp___192:Numbers.BinNums.Z) : Prop := True.

(* Why3 goal *)
Theorem def'vc :
  dynamic_invariant arg1 Init.Datatypes.true Init.Datatypes.false
  Init.Datatypes.true Init.Datatypes.true ->
  dynamic_invariant arg2 Init.Datatypes.true Init.Datatypes.false
  Init.Datatypes.true Init.Datatypes.true -> ~ (arg2 = 0%Z) ->
  ((bool_eq (ZArith.BinInt.Z.modulo (-arg1)%Z (-arg2)%Z)
    (-(ZArith.BinInt.Z.modulo arg1 arg2))%Z)
   = Init.Datatypes.true).
Proof.
#include "lemma_mod_symmetry.prf"

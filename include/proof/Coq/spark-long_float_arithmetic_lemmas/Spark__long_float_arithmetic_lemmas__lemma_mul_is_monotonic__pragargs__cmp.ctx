(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require Reals.Rbasic_fun.
Require Reals.R_sqrt.
Require BuiltIn.
Require bool.Bool.
Require int.Int.
Require int.Abs.
Require int.EuclideanDivision.
Require real.Real.
Require real.RealInfix.
Require real.Abs.
Require real.FromInt.
Require real.Square.
Require bv.Pow2int.
Require bv.BV_Gen.

(* Why3 assumption *)
Definition unit := unit.

Axiom us_private : Type.
Parameter us_private_WhyType : WhyType us_private.
Existing Instance us_private_WhyType.

Parameter us_null_ext__: us_private.

(* Why3 assumption *)
Definition us_fixed := Z.

Axiom us_type_of_heap : Type.
Parameter us_type_of_heap_WhyType : WhyType us_type_of_heap.
Existing Instance us_type_of_heap_WhyType.

(* Why3 assumption *)
Inductive us_type_of_heap__ref :=
  | mk___type_of_heap__ref : us_type_of_heap -> us_type_of_heap__ref.
Axiom us_type_of_heap__ref_WhyType : WhyType us_type_of_heap__ref.
Existing Instance us_type_of_heap__ref_WhyType.

(* Why3 assumption *)
Definition us_type_of_heap__content
  (v:us_type_of_heap__ref): us_type_of_heap :=
  match v with
  | (mk___type_of_heap__ref x) => x
  end.

Axiom us_image : Type.
Parameter us_image_WhyType : WhyType us_image.
Existing Instance us_image_WhyType.

(* Why3 assumption *)
Inductive int__ref :=
  | mk_int__ref : Z -> int__ref.
Axiom int__ref_WhyType : WhyType int__ref.
Existing Instance int__ref_WhyType.

(* Why3 assumption *)
Definition int__content (v:int__ref): Z :=
  match v with
  | (mk_int__ref x) => x
  end.

(* Why3 assumption *)
Inductive bool__ref :=
  | mk_bool__ref : bool -> bool__ref.
Axiom bool__ref_WhyType : WhyType bool__ref.
Existing Instance bool__ref_WhyType.

(* Why3 assumption *)
Definition bool__content (v:bool__ref): bool :=
  match v with
  | (mk_bool__ref x) => x
  end.

(* Why3 assumption *)
Inductive real__ref :=
  | mk_real__ref : R -> real__ref.
Axiom real__ref_WhyType : WhyType real__ref.
Existing Instance real__ref_WhyType.

(* Why3 assumption *)
Definition real__content (v:real__ref): R :=
  match v with
  | (mk_real__ref x) => x
  end.

(* Why3 assumption *)
Inductive us_private__ref :=
  | mk___private__ref : us_private -> us_private__ref.
Axiom us_private__ref_WhyType : WhyType us_private__ref.
Existing Instance us_private__ref_WhyType.

(* Why3 assumption *)
Definition us_private__content (v:us_private__ref): us_private :=
  match v with
  | (mk___private__ref x) => x
  end.

(* Why3 assumption *)
Definition int__ref___projection (a:int__ref): Z := (int__content a).

(* Why3 assumption *)
Definition bool__ref___projection (a:bool__ref): bool := (bool__content a).

(* Why3 assumption *)
Definition real__ref___projection (a:real__ref): R := (real__content a).

(* Why3 assumption *)
Definition us_private__ref___projection (a:us_private__ref): us_private :=
  (us_private__content a).

Axiom t : Type.
Parameter t_WhyType : WhyType t.
Existing Instance t_WhyType.

Parameter nth: t -> Z -> bool.

Axiom nth_out_of_bound : forall (x:t) (n:Z),
                          ((n < 0%Z)%Z \/ (64%Z <= n)%Z) ->
                          ((nth x n) = false).

Parameter zeros: t.

Axiom Nth_zeros : forall (n:Z), ((nth zeros n) = false).

Parameter ones: t.

Axiom Nth_ones : forall (n:Z),
                  ((0%Z <= n)%Z /\ (n < 64%Z)%Z) -> ((nth ones n) = true).

Parameter bw_and: t -> t -> t.

Axiom Nth_bw_and : forall (v1:t) (v2:t) (n:Z),
                    ((0%Z <= n)%Z /\ (n < 64%Z)%Z) ->
                    ((nth (bw_and v1 v2) n) = (Init.Datatypes.andb (nth v1 n)
                    (nth v2 n))).

Parameter bw_or: t -> t -> t.

Axiom Nth_bw_or : forall (v1:t) (v2:t) (n:Z),
                   ((0%Z <= n)%Z /\ (n < 64%Z)%Z) ->
                   ((nth (bw_or v1 v2) n) = (Init.Datatypes.orb (nth v1 n)
                   (nth v2 n))).

Parameter bw_xor: t -> t -> t.

Axiom Nth_bw_xor : forall (v1:t) (v2:t) (n:Z),
                    ((0%Z <= n)%Z /\ (n < 64%Z)%Z) ->
                    ((nth (bw_xor v1 v2) n) = (Init.Datatypes.xorb (nth v1 n)
                    (nth v2 n))).

Parameter bw_not: t -> t.

Axiom Nth_bw_not : forall (v:t) (n:Z),
                    ((0%Z <= n)%Z /\ (n < 64%Z)%Z) ->
                    ((nth (bw_not v) n) = (Init.Datatypes.negb (nth v n))).

Parameter lsr: t -> Z -> t.

Axiom Lsr_nth_low : forall (b:t) (n:Z) (s:Z),
                     (0%Z <= s)%Z ->
                     ((0%Z <= n)%Z ->
                      (((n + s)%Z < 64%Z)%Z ->
                       ((nth (lsr b s) n) = (nth b (n + s)%Z)))).

Axiom Lsr_nth_high : forall (b:t) (n:Z) (s:Z),
                      (0%Z <= s)%Z ->
                      ((0%Z <= n)%Z ->
                       ((64%Z <= (n + s)%Z)%Z -> ((nth (lsr b s) n) = false))).

Axiom lsr_zeros : forall (x:t), ((lsr x 0%Z) = x).

Parameter asr: t -> Z -> t.

Axiom Asr_nth_low : forall (b:t) (n:Z) (s:Z),
                     (0%Z <= s)%Z ->
                     (((0%Z <= n)%Z /\ (n < 64%Z)%Z) ->
                      (((n + s)%Z < 64%Z)%Z ->
                       ((nth (asr b s) n) = (nth b (n + s)%Z)))).

Axiom Asr_nth_high : forall (b:t) (n:Z) (s:Z),
                      (0%Z <= s)%Z ->
                      (((0%Z <= n)%Z /\ (n < 64%Z)%Z) ->
                       ((64%Z <= (n + s)%Z)%Z ->
                        ((nth (asr b s) n) = (nth b (64%Z - 1%Z)%Z)))).

Axiom asr_zeros : forall (x:t), ((asr x 0%Z) = x).

Parameter lsl: t -> Z -> t.

Axiom Lsl_nth_high : forall (b:t) (n:Z) (s:Z),
                      ((0%Z <= s)%Z /\ ((s <= n)%Z /\ (n < 64%Z)%Z)) ->
                      ((nth (lsl b s) n) = (nth b (n - s)%Z)).

Axiom Lsl_nth_low : forall (b:t) (n:Z) (s:Z),
                     ((0%Z <= n)%Z /\ (n < s)%Z) ->
                     ((nth (lsl b s) n) = false).

Axiom lsl_zeros : forall (x:t), ((lsl x 0%Z) = x).

Parameter rotate_right: t -> Z -> t.

Axiom Nth_rotate_right : forall (v:t) (n:Z) (i:Z),
                          ((0%Z <= i)%Z /\ (i < 64%Z)%Z) ->
                          ((0%Z <= n)%Z ->
                           ((nth (rotate_right v n) i) = (nth v
                                                           (int.EuclideanDivision.mod1 (i + n)%Z
                                                             64%Z)))).

Parameter rotate_left: t -> Z -> t.

Axiom Nth_rotate_left : forall (v:t) (n:Z) (i:Z),
                         ((0%Z <= i)%Z /\ (i < 64%Z)%Z) ->
                         ((0%Z <= n)%Z ->
                          ((nth (rotate_left v n) i) = (nth v
                                                         (int.EuclideanDivision.mod1 (i - n)%Z
                                                           64%Z)))).

Parameter to_int: t -> Z.

Parameter to_uint: t -> Z.

Parameter of_int: Z -> t.

Axiom to_uint_extensionality : forall (v:t) (v':t),
                                ((to_uint v) = (to_uint v')) -> (v = v').

Axiom to_int_extensionality : forall (v:t) (v':t),
                               ((to_int v) = (to_int v')) -> (v = v').

(* Why3 assumption *)
Definition uint_in_range (i:Z): Prop :=
  (0%Z <= i)%Z /\ (i <= 18446744073709551615%Z)%Z.

Axiom to_uint_bounds : forall (v:t),
                        (0%Z <= (to_uint v))%Z
                        /\ ((to_uint v) < 18446744073709551616%Z)%Z.

Axiom to_uint_of_int : forall (i:Z),
                        ((0%Z <= i)%Z /\ (i < 18446744073709551616%Z)%Z) ->
                        ((to_uint (of_int i)) = i).

Axiom Of_int_zeros : (zeros = (of_int 0%Z)).

Axiom Of_int_ones : (ones = (of_int 18446744073709551615%Z)).

(* Why3 assumption *)
Definition ult (x:t) (y:t): Prop := ((to_uint x) < (to_uint y))%Z.

(* Why3 assumption *)
Definition ule (x:t) (y:t): Prop := ((to_uint x) <= (to_uint y))%Z.

(* Why3 assumption *)
Definition ugt (x:t) (y:t): Prop := ((to_uint y) < (to_uint x))%Z.

(* Why3 assumption *)
Definition uge (x:t) (y:t): Prop := ((to_uint y) <= (to_uint x))%Z.

(* Why3 assumption *)
Definition slt (v1:t) (v2:t): Prop := ((to_int v1) < (to_int v2))%Z.

(* Why3 assumption *)
Definition sle (v1:t) (v2:t): Prop := ((to_int v1) <= (to_int v2))%Z.

(* Why3 assumption *)
Definition sgt (v1:t) (v2:t): Prop := ((to_int v2) < (to_int v1))%Z.

(* Why3 assumption *)
Definition sge (v1:t) (v2:t): Prop := ((to_int v2) <= (to_int v1))%Z.

Parameter add: t -> t -> t.

Axiom to_uint_add : forall (v1:t) (v2:t),
                     ((to_uint (add v1 v2)) = (int.EuclideanDivision.mod1 (
                                                (to_uint v1) + (to_uint v2))%Z
                                                18446744073709551616%Z)).

Axiom to_uint_add_bounded : forall (v1:t) (v2:t),
                             (((to_uint v1) + (to_uint v2))%Z < 18446744073709551616%Z)%Z ->
                             ((to_uint (add v1 v2)) = ((to_uint v1) +
                             (to_uint v2))%Z).

Parameter sub: t -> t -> t.

Axiom to_uint_sub : forall (v1:t) (v2:t),
                     ((to_uint (sub v1 v2)) = (int.EuclideanDivision.mod1 (
                                                (to_uint v1) - (to_uint v2))%Z
                                                18446744073709551616%Z)).

Axiom to_uint_sub_bounded : forall (v1:t) (v2:t),
                             ((0%Z <= ((to_uint v1) - (to_uint v2))%Z)%Z
                              /\ (((to_uint v1) - (to_uint v2))%Z < 18446744073709551616%Z)%Z) ->
                             ((to_uint (sub v1 v2)) = ((to_uint v1) -
                             (to_uint v2))%Z).

Parameter neg: t -> t.

Axiom to_uint_neg : forall (v:t),
                     ((to_uint (neg v)) = (int.EuclideanDivision.mod1 (-
                                            (to_uint v))%Z
                                            18446744073709551616%Z)).

Parameter mul: t -> t -> t.

Axiom to_uint_mul : forall (v1:t) (v2:t),
                     ((to_uint (mul v1 v2)) = (int.EuclideanDivision.mod1 (
                                                (to_uint v1) * (to_uint v2))%Z
                                                18446744073709551616%Z)).

Axiom to_uint_mul_bounded : forall (v1:t) (v2:t),
                             (((to_uint v1) * (to_uint v2))%Z < 18446744073709551616%Z)%Z ->
                             ((to_uint (mul v1 v2)) = ((to_uint v1) *
                             (to_uint v2))%Z).

Parameter udiv: t -> t -> t.

Axiom to_uint_udiv : forall (v1:t) (v2:t),
                      ((to_uint (udiv v1 v2)) = (int.EuclideanDivision.div
                                                  (to_uint v1) (to_uint v2))).

Parameter urem: t -> t -> t.

Axiom to_uint_urem : forall (v1:t) (v2:t),
                      ((to_uint (urem v1 v2)) = (int.EuclideanDivision.mod1
                                                  (to_uint v1) (to_uint v2))).

Parameter lsr_bv: t -> t -> t.

Axiom lsr_bv_is_lsr : forall (x:t) (n:t),
                       ((lsr_bv x n) = (lsr x (to_uint n))).

Axiom to_uint_lsr : forall (v:t) (n:t),
                     ((to_uint (lsr_bv v n)) = (int.EuclideanDivision.div
                                                 (to_uint v)
                                                 (bv.Pow2int.pow2 (to_uint n)))).

Parameter asr_bv: t -> t -> t.

Axiom asr_bv_is_asr : forall (x:t) (n:t),
                       ((asr_bv x n) = (asr x (to_uint n))).

Parameter lsl_bv: t -> t -> t.

Axiom lsl_bv_is_lsl : forall (x:t) (n:t),
                       ((lsl_bv x n) = (lsl x (to_uint n))).

Axiom to_uint_lsl : forall (v:t) (n:t),
                     ((to_uint (lsl_bv v n)) = (int.EuclideanDivision.mod1 (
                                                 (to_uint v) * (bv.Pow2int.pow2
                                                                 (to_uint n)))%Z
                                                 18446744073709551616%Z)).

Parameter rotate_right_bv: t -> t -> t.

Parameter rotate_left_bv: t -> t -> t.

Axiom rotate_left_bv_is_rotate_left : forall (v:t) (n:t),
                                       ((rotate_left_bv v n) = (rotate_left v
                                                                 (to_uint n))).

Axiom rotate_right_bv_is_rotate_right : forall (v:t) (n:t),
                                         ((rotate_right_bv v n) = (rotate_right v
                                                                    (
                                                                    to_uint n))).

Parameter nth_bv: t -> t -> bool.

Axiom nth_bv_def : forall (x:t) (i:t),
                    ((nth_bv x i) = true) <->
                    ~ ((bw_and (lsr_bv x i) (of_int 1%Z)) = zeros).

Axiom Nth_bv_is_nth : forall (x:t) (i:t),
                       ((nth x (to_uint i)) = (nth_bv x i)).

Axiom Nth_bv_is_nth2 : forall (x:t) (i:Z),
                        ((0%Z <= i)%Z /\ (i < 18446744073709551616%Z)%Z) ->
                        ((nth_bv x (of_int i)) = (nth x i)).

Parameter eq_sub_bv: t -> t -> t -> t -> Prop.

Axiom eq_sub_bv_def : forall (a:t) (b:t) (i:t) (n:t),
                       let mask :=
                                   (lsl_bv (sub (lsl_bv (of_int 1%Z) n)
                                             (of_int 1%Z)) i) in
                       ((eq_sub_bv a b i n) <->
                        ((bw_and b mask) = (bw_and a mask))).

(* Why3 assumption *)
Definition eq_sub (a:t) (b:t) (i:Z) (n:Z): Prop :=
  forall (j:Z), ((i <= j)%Z /\ (j < (i + n)%Z)%Z) -> ((nth a j) = (nth b j)).

Axiom eq_sub_equiv : forall (a:t) (b:t) (i:t) (n:t),
                      (eq_sub a b (to_uint i) (to_uint n)) <-> (eq_sub_bv a b
                      i n).

Axiom Extensionality : forall (x:t) (y:t), (eq_sub x y 0%Z 64%Z) -> (x = y).

Axiom t1 : Type.
Parameter t1_WhyType : WhyType t1.
Existing Instance t1_WhyType.

Parameter truncate: R -> Z.

Axiom Truncate_int : forall (i:Z), ((truncate (Reals.Raxioms.IZR i)) = i).

Axiom Truncate_down_pos : forall (x:R),
                           (0%R <= x)%R ->
                           (((Reals.Raxioms.IZR (truncate x)) <= x)%R
                            /\ (x < (Reals.Raxioms.IZR ((truncate x) + 1%Z)%Z))%R).

Axiom Truncate_up_neg : forall (x:R),
                         (x <= 0%R)%R ->
                         (((Reals.Raxioms.IZR ((truncate x) - 1%Z)%Z) < x)%R
                          /\ (x <= (Reals.Raxioms.IZR (truncate x)))%R).

Axiom Real_of_truncate : forall (x:R),
                          ((x - 1%R)%R <= (Reals.Raxioms.IZR (truncate x)))%R
                          /\ ((Reals.Raxioms.IZR (truncate x)) <= (x + 1%R)%R)%R.

Axiom Truncate_monotonic : forall (x:R) (y:R),
                            (x <= y)%R -> ((truncate x) <= (truncate y))%Z.

Axiom Truncate_monotonic_int1 : forall (x:R) (i:Z),
                                 (x <= (Reals.Raxioms.IZR i))%R ->
                                 ((truncate x) <= i)%Z.

Axiom Truncate_monotonic_int2 : forall (x:R) (i:Z),
                                 ((Reals.Raxioms.IZR i) <= x)%R ->
                                 (i <= (truncate x))%Z.

Parameter floor: R -> Z.

Parameter ceil: R -> Z.

Axiom Floor_int : forall (i:Z), ((floor (Reals.Raxioms.IZR i)) = i).

Axiom Ceil_int : forall (i:Z), ((ceil (Reals.Raxioms.IZR i)) = i).

Axiom Floor_down : forall (x:R),
                    ((Reals.Raxioms.IZR (floor x)) <= x)%R
                    /\ (x < (Reals.Raxioms.IZR ((floor x) + 1%Z)%Z))%R.

Axiom Ceil_up : forall (x:R),
                 ((Reals.Raxioms.IZR ((ceil x) - 1%Z)%Z) < x)%R
                 /\ (x <= (Reals.Raxioms.IZR (ceil x)))%R.

Axiom Floor_monotonic : forall (x:R) (y:R),
                         (x <= y)%R -> ((floor x) <= (floor y))%Z.

Axiom Ceil_monotonic : forall (x:R) (y:R),
                        (x <= y)%R -> ((ceil x) <= (ceil y))%Z.

(* Why3 assumption *)
Inductive mode :=
  | RNE : mode
  | RNA : mode
  | RTP : mode
  | RTN : mode
  | RTZ : mode.
Axiom mode_WhyType : WhyType mode.
Existing Instance mode_WhyType.

Parameter eb: Z.

Parameter sb: Z.

Axiom eb_gt_1 : (1%Z < eb)%Z.

Axiom sb_gt_1 : (1%Z < sb)%Z.

Parameter zeroF: t1.

Parameter half: t1.

Parameter from_binary: Z -> t1.

Parameter prefix_ex: mode -> R -> t1.

Parameter abs: t1 -> t1.

Parameter neg1: t1 -> t1.

Parameter add1: mode -> t1 -> t1 -> t1.

Parameter sub1: mode -> t1 -> t1 -> t1.

Parameter mul1: mode -> t1 -> t1 -> t1.

Parameter div: mode -> t1 -> t1 -> t1.

Parameter fma: mode -> t1 -> t1 -> t1 -> t1.

Parameter sqrt: mode -> t1 -> t1.

Parameter rem: t1 -> t1 -> t1.

Parameter roundToIntegral: mode -> t1 -> t1.

Parameter min: t1 -> t1 -> t1.

Parameter max: t1 -> t1 -> t1.

Parameter le: t1 -> t1 -> Prop.

Parameter lt: t1 -> t1 -> Prop.

Parameter eq: t1 -> t1 -> Prop.

Parameter is_normal: t1 -> Prop.

Parameter is_subnormal: t1 -> Prop.

Parameter is_infinite: t1 -> Prop.

Parameter is_nan: t1 -> Prop.

Parameter is_positive: t1 -> Prop.

Parameter is_negative: t1 -> Prop.

Parameter is_finite: t1 -> Prop.

(* Why3 assumption *)
Definition is_plus_infinity (x:t1): Prop :=
  (is_infinite x) /\ (is_positive x).

(* Why3 assumption *)
Definition is_minus_infinity (x:t1): Prop :=
  (is_infinite x) /\ (is_negative x).

(* Why3 assumption *)
Definition is_plus_zero (x:t1): Prop := (eq x zeroF) /\ (is_positive x).

(* Why3 assumption *)
Definition is_minus_zero (x:t1): Prop := (eq x zeroF) /\ (is_negative x).

(* Why3 assumption *)
Definition is_not_nan (x:t1): Prop := (is_finite x) \/ (is_infinite x).

Axiom is_not_nan1 : forall (x:t1), (is_not_nan x) <-> ~ (is_nan x).

Parameter to_real: t1 -> R.

Axiom zeroF_is_positive : (is_positive zeroF).

Axiom zeroF_to_real : ((to_real zeroF) = 0%R).

Axiom half_to_real : ((to_real half) = (05 / 10)%R).

Axiom zero_to_real : forall (x:t1),
                      (eq x zeroF) <-> ((is_finite x) /\ ((to_real x) = 0%R)).

Parameter of_int1: mode -> Z -> t1.

Parameter to_int1: mode -> t1 -> Z.

Axiom zero_of_int : forall (m:mode), (zeroF = (of_int1 m 0%Z)).

Parameter round: mode -> R -> R.

Parameter max_int: Z.

Axiom max_real_int : ((9007199254740991 * 19958403095347198116563727130368385660674512604354575415025472424372118918689640657849579654926357010893424468441924952439724379883935936607391717982848314203200056729510856765175377214443629871826533567445439239933308104551208703888888552684480441575071209068757560416423584952303440099278848)%R = (Reals.Raxioms.IZR max_int)).

(* Why3 assumption *)
Definition in_range (x:R): Prop :=
  ((-(9007199254740991 * 19958403095347198116563727130368385660674512604354575415025472424372118918689640657849579654926357010893424468441924952439724379883935936607391717982848314203200056729510856765175377214443629871826533567445439239933308104551208703888888552684480441575071209068757560416423584952303440099278848)%R)%R <= x)%R
  /\ (x <= (9007199254740991 * 19958403095347198116563727130368385660674512604354575415025472424372118918689640657849579654926357010893424468441924952439724379883935936607391717982848314203200056729510856765175377214443629871826533567445439239933308104551208703888888552684480441575071209068757560416423584952303440099278848)%R)%R.

Axiom is_finite1 : forall (x:t1), (is_finite x) -> (in_range (to_real x)).

Axiom zero_is_finite : (is_finite zeroF).

Axiom half_is_finite : (is_finite half).

(* Why3 assumption *)
Definition no_overflow (m:mode) (x:R): Prop := (in_range (round m x)).

Axiom of_int_is_finite : forall (m:mode) (x:Z),
                          (no_overflow m (Reals.Raxioms.IZR x)) -> (is_finite
                          (of_int1 m x)).

Axiom of_int_to_real : forall (m:mode) (x:Z),
                        (no_overflow m (Reals.Raxioms.IZR x)) ->
                        ((to_real (of_int1 m x)) = (round m
                                                     (Reals.Raxioms.IZR x))).

Axiom Bounded_real_no_overflow : forall (m:mode) (x:R),
                                  (in_range x) -> (no_overflow m x).

Axiom Round_monotonic : forall (m:mode) (x:R) (y:R),
                         (x <= y)%R -> ((round m x) <= (round m y))%R.

Axiom Round_idempotent : forall (m1:mode) (m2:mode) (x:R),
                          ((round m1 (round m2 x)) = (round m2 x)).

Axiom Round_to_real : forall (m:mode) (x:t1),
                       (is_finite x) -> ((round m (to_real x)) = (to_real x)).

Axiom Round_down_le : forall (x:R), ((round RTN x) <= x)%R.

Axiom Round_up_ge : forall (x:R), (x <= (round RTP x))%R.

Axiom Round_down_neg : forall (x:R),
                        ((round RTN (-x)%R) = (-(round RTP x))%R).

Axiom Round_up_neg : forall (x:R), ((round RTP (-x)%R) = (-(round RTN x))%R).

Axiom Exact_rounding_for_integers : forall (m:mode) (i:Z),
                                     (((-9007199254740992%Z)%Z <= i)%Z
                                      /\ (i <= 9007199254740992%Z)%Z) ->
                                     ((round m (Reals.Raxioms.IZR i)) = (Reals.Raxioms.IZR i)).

(* Why3 assumption *)
Definition same_sign (x:t1) (y:t1): Prop :=
  ((is_positive x) /\ (is_positive y))
  \/ ((is_negative x) /\ (is_negative y)).

(* Why3 assumption *)
Definition diff_sign (x:t1) (y:t1): Prop :=
  ((is_positive x) /\ (is_negative y))
  \/ ((is_negative x) /\ (is_positive y)).

Axiom feq_eq : forall (x:t1) (y:t1),
                (is_finite x) ->
                ((is_finite y) -> ((~ (eq x zeroF)) -> ((eq x y) -> (x = y)))).

Axiom eq_feq : forall (x:t1) (y:t1),
                (is_finite x) -> ((is_finite y) -> ((x = y) -> (eq x y))).

Axiom eq_refl : forall (x:t1), (is_finite x) -> (eq x x).

Axiom eq_sym : forall (x:t1) (y:t1), (eq x y) -> (eq y x).

Axiom eq_trans : forall (x:t1) (y:t1) (z:t1),
                  (eq x y) -> ((eq y z) -> (eq x z)).

Axiom eq_zero : (eq zeroF (neg1 zeroF)).

Axiom eq_to_real_finite : forall (x:t1) (y:t1),
                           ((is_finite x) /\ (is_finite y)) ->
                           ((eq x y) <-> ((to_real x) = (to_real y))).

Axiom eq_special : forall (x:t1) (y:t1),
                    (eq x y) ->
                    ((is_not_nan x)
                     /\ ((is_not_nan y)
                         /\ (((is_finite x) /\ (is_finite y))
                             \/ ((is_infinite x)
                                 /\ ((is_infinite y) /\ (same_sign x y)))))).

Axiom lt_finite : forall (x:t1) (y:t1),
                   ((is_finite x) /\ (is_finite y)) ->
                   ((lt x y) <-> ((to_real x) < (to_real y))%R).

Axiom le_finite : forall (x:t1) (y:t1),
                   ((is_finite x) /\ (is_finite y)) ->
                   ((le x y) <-> ((to_real x) <= (to_real y))%R).

Axiom le_lt_trans : forall (x:t1) (y:t1) (z:t1),
                     ((le x y) /\ (lt y z)) -> (lt x z).

Axiom lt_le_trans : forall (x:t1) (y:t1) (z:t1),
                     ((lt x y) /\ (le y z)) -> (lt x z).

Axiom le_ge_asym : forall (x:t1) (y:t1), ((le x y) /\ (le y x)) -> (eq x y).

Axiom not_lt_ge : forall (x:t1) (y:t1),
                   ((~ (lt x y)) /\ ((is_not_nan x) /\ (is_not_nan y))) ->
                   (le y x).

Axiom not_gt_le : forall (x:t1) (y:t1),
                   ((~ (lt y x)) /\ ((is_not_nan x) /\ (is_not_nan y))) ->
                   (le x y).

Axiom le_special : forall (x:t1) (y:t1),
                    (le x y) ->
                    (((is_finite x) /\ (is_finite y))
                     \/ (((is_minus_infinity x) /\ (is_not_nan y))
                         \/ ((is_not_nan x) /\ (is_plus_infinity y)))).

Axiom lt_special : forall (x:t1) (y:t1),
                    (lt x y) ->
                    (((is_finite x) /\ (is_finite y))
                     \/ (((is_minus_infinity x)
                          /\ ((is_not_nan y) /\ ~ (is_minus_infinity y)))
                         \/ ((is_not_nan x)
                             /\ ((~ (is_plus_infinity x))
                                 /\ (is_plus_infinity y))))).

Axiom positive_to_real : forall (x:t1),
                          (is_finite x) ->
                          ((is_positive x) -> (0%R <= (to_real x))%R).

Axiom to_real_positive : forall (x:t1),
                          (is_finite x) ->
                          ((0%R < (to_real x))%R -> (is_positive x)).

Axiom negative_to_real : forall (x:t1),
                          (is_finite x) ->
                          ((is_negative x) -> ((to_real x) <= 0%R)%R).

Axiom to_real_negative : forall (x:t1),
                          (is_finite x) ->
                          (((to_real x) < 0%R)%R -> (is_negative x)).

Axiom negative_xor_positive : forall (x:t1),
                               ~ ((is_positive x) /\ (is_negative x)).

Axiom negative_or_positive : forall (x:t1),
                              (is_finite x) ->
                              ((is_positive x) \/ (is_negative x)).

Axiom diff_sign_trans : forall (x:t1) (y:t1) (z:t1),
                         ((diff_sign x y) /\ (diff_sign y z)) -> (same_sign x
                         z).

Axiom diff_sign_product : forall (x:t1) (y:t1),
                           ((is_finite x)
                            /\ ((is_finite y)
                                /\ (((to_real x) * (to_real y))%R < 0%R)%R)) ->
                           (diff_sign x y).

Axiom same_sign_product : forall (x:t1) (y:t1),
                           ((is_finite x)
                            /\ ((is_finite y) /\ (same_sign x y))) ->
                           (0%R <= ((to_real x) * (to_real y))%R)%R.

(* Why3 assumption *)
Definition product_sign (z:t1) (x:t1) (y:t1): Prop :=
  ((same_sign x y) -> (is_positive z))
  /\ ((diff_sign x y) -> (is_negative z)).

(* Why3 assumption *)
Definition overflow_value (m:mode) (x:t1): Prop :=
  match m with
  | RTN =>
      ((is_positive x) ->
       ((is_finite x)
        /\ ((to_real x) = (9007199254740991 * 19958403095347198116563727130368385660674512604354575415025472424372118918689640657849579654926357010893424468441924952439724379883935936607391717982848314203200056729510856765175377214443629871826533567445439239933308104551208703888888552684480441575071209068757560416423584952303440099278848)%R)))
      /\ ((~ (is_positive x)) -> (is_infinite x))
  | RTP =>
      ((is_positive x) -> (is_infinite x))
      /\ ((~ (is_positive x)) ->
          ((is_finite x)
           /\ ((to_real x) = (-(9007199254740991 * 19958403095347198116563727130368385660674512604354575415025472424372118918689640657849579654926357010893424468441924952439724379883935936607391717982848314203200056729510856765175377214443629871826533567445439239933308104551208703888888552684480441575071209068757560416423584952303440099278848)%R)%R)))
  | RTZ =>
      ((is_positive x) ->
       ((is_finite x)
        /\ ((to_real x) = (9007199254740991 * 19958403095347198116563727130368385660674512604354575415025472424372118918689640657849579654926357010893424468441924952439724379883935936607391717982848314203200056729510856765175377214443629871826533567445439239933308104551208703888888552684480441575071209068757560416423584952303440099278848)%R)))
      /\ ((~ (is_positive x)) ->
          ((is_finite x)
           /\ ((to_real x) = (-(9007199254740991 * 19958403095347198116563727130368385660674512604354575415025472424372118918689640657849579654926357010893424468441924952439724379883935936607391717982848314203200056729510856765175377214443629871826533567445439239933308104551208703888888552684480441575071209068757560416423584952303440099278848)%R)%R)))
  | (RNA|RNE) => (is_infinite x)
  end.

(* Why3 assumption *)
Definition sign_zero_result (m:mode) (x:t1): Prop :=
  (eq x zeroF) ->
  match m with
  | RTN => (is_negative x)
  | _ => (is_positive x)
  end.

Axiom add_finite : forall (m:mode) (x:t1) (y:t1),
                    (is_finite x) ->
                    ((is_finite y) ->
                     ((no_overflow m ((to_real x) + (to_real y))%R) ->
                      ((is_finite (add1 m x y))
                       /\ ((to_real (add1 m x y)) = (round m
                                                      ((to_real x) +
                                                      (to_real y))%R))))).

Axiom sub_finite : forall (m:mode) (x:t1) (y:t1),
                    (is_finite x) ->
                    ((is_finite y) ->
                     ((no_overflow m ((to_real x) - (to_real y))%R) ->
                      ((is_finite (sub1 m x y))
                       /\ ((to_real (sub1 m x y)) = (round m
                                                      ((to_real x) -
                                                      (to_real y))%R))))).

Axiom mul_finite : forall (m:mode) (x:t1) (y:t1),
                    (is_finite x) ->
                    ((is_finite y) ->
                     ((no_overflow m ((to_real x) * (to_real y))%R) ->
                      ((is_finite (mul1 m x y))
                       /\ ((to_real (mul1 m x y)) = (round m
                                                      ((to_real x) *
                                                      (to_real y))%R))))).

Axiom div_finite : forall (m:mode) (x:t1) (y:t1),
                    (is_finite x) ->
                    ((is_finite y) ->
                     ((~ (eq y zeroF)) ->
                      ((no_overflow m ((to_real x) / (to_real y))%R) ->
                       ((is_finite (div m x y))
                        /\ ((to_real (div m x y)) = (round m
                                                      ((to_real x) /
                                                      (to_real y))%R)))))).

Axiom neg_finite : forall (x:t1),
                    (is_finite x) ->
                    ((is_finite (neg1 x))
                     /\ ((to_real (neg1 x)) = (-(to_real x))%R)).

Axiom abs_finite : forall (x:t1),
                    (is_finite x) ->
                    ((is_finite (abs x))
                     /\ (((to_real (abs x)) = (Reals.Rbasic_fun.Rabs
                         (to_real x))) /\ (is_positive (abs x)))).

Axiom abs_universal : forall (x:t1), ~ (is_negative (abs x)).

Axiom fma_finite : forall (m:mode) (x:t1) (y:t1) (z:t1),
                    (is_finite x) ->
                    ((is_finite y) ->
                     ((is_finite z) ->
                      ((no_overflow m
                       (((to_real x) * (to_real y))%R + (to_real z))%R) ->
                       ((is_finite (fma m x y z))
                        /\ ((to_real (fma m x y z)) = (round m
                                                        (((to_real x) *
                                                        (to_real y))%R +
                                                        (to_real z))%R)))))).

Axiom sqrt_finite : forall (m:mode) (x:t1),
                     (is_finite x) ->
                     ((le zeroF x) ->
                      ((is_finite (sqrt m x))
                       /\ ((to_real (sqrt m x)) = (round m
                                                    (Reals.R_sqrt.sqrt
                                                    (to_real x)))))).

(* Why3 assumption *)
Definition same_sign_real (x:t1) (r:R): Prop :=
  ((is_positive x) /\ (0%R < r)%R) \/ ((is_negative x) /\ (r < 0%R)%R).

Axiom add_special : forall (m:mode) (x:t1) (y:t1),
                     let r := (add1 m x y) in
                     ((((is_nan x) \/ (is_nan y)) -> (is_nan r))
                      /\ ((((is_finite x) /\ (is_infinite y)) ->
                           ((is_infinite r) /\ (same_sign r y)))
                          /\ ((((is_infinite x) /\ (is_finite y)) ->
                               ((is_infinite r) /\ (same_sign r x)))
                              /\ ((((is_infinite x)
                                    /\ ((is_infinite y) /\ (same_sign x y))) ->
                                   ((is_infinite r) /\ (same_sign r x)))
                                  /\ ((((is_infinite x)
                                        /\ ((is_infinite y) /\ (diff_sign x
                                            y))) -> (is_nan r))
                                      /\ ((((is_finite x)
                                            /\ ((is_finite y)
                                                /\ ~ (no_overflow m
                                                   ((to_real x) + (to_real y))%R))) ->
                                           ((same_sign_real r
                                            ((to_real x) + (to_real y))%R)
                                            /\ (overflow_value m r)))
                                          /\ (((is_finite x) /\ (is_finite y)) ->
                                              (((same_sign x y) -> (same_sign
                                                r x))
                                               /\ ((~ (same_sign x y)) ->
                                                   (sign_zero_result m r)))))))))).

Axiom sub_special : forall (m:mode) (x:t1) (y:t1),
                     let r := (sub1 m x y) in
                     ((((is_nan x) \/ (is_nan y)) -> (is_nan r))
                      /\ ((((is_finite x) /\ (is_infinite y)) ->
                           ((is_infinite r) /\ (diff_sign r y)))
                          /\ ((((is_infinite x) /\ (is_finite y)) ->
                               ((is_infinite r) /\ (same_sign r x)))
                              /\ ((((is_infinite x)
                                    /\ ((is_infinite y) /\ (same_sign x y))) ->
                                   (is_nan r))
                                  /\ ((((is_infinite x)
                                        /\ ((is_infinite y) /\ (diff_sign x
                                            y))) ->
                                       ((is_infinite r) /\ (same_sign r x)))
                                      /\ ((((is_finite x)
                                            /\ ((is_finite y)
                                                /\ ~ (no_overflow m
                                                   ((to_real x) - (to_real y))%R))) ->
                                           ((same_sign_real r
                                            ((to_real x) - (to_real y))%R)
                                            /\ (overflow_value m r)))
                                          /\ (((is_finite x) /\ (is_finite y)) ->
                                              (((diff_sign x y) -> (same_sign
                                                r x))
                                               /\ ((~ (diff_sign x y)) ->
                                                   (sign_zero_result m r)))))))))).

Axiom mul_special : forall (m:mode) (x:t1) (y:t1),
                     let r := (mul1 m x y) in
                     ((((is_nan x) \/ (is_nan y)) -> (is_nan r))
                      /\ ((((eq x zeroF) /\ (is_infinite y)) -> (is_nan r))
                          /\ ((((is_finite x)
                                /\ ((is_infinite y) /\ ~ (eq x zeroF))) ->
                               (is_infinite r))
                              /\ ((((is_infinite x) /\ (eq y zeroF)) ->
                                   (is_nan r))
                                  /\ ((((is_infinite x)
                                        /\ ((is_finite y) /\ ~ (eq y zeroF))) ->
                                       (is_infinite r))
                                      /\ ((((is_infinite x) /\ (is_infinite
                                            y)) -> (is_infinite r))
                                          /\ ((((is_finite x)
                                                /\ ((is_finite y)
                                                    /\ ~ (no_overflow m
                                                       ((to_real x) *
                                                       (to_real y))%R))) ->
                                               (overflow_value m r))
                                              /\ ((~ (is_nan r)) ->
                                                  (product_sign r x y))))))))).

Axiom div_special : forall (m:mode) (x:t1) (y:t1),
                     let r := (div m x y) in
                     ((((is_nan x) \/ (is_nan y)) -> (is_nan r))
                      /\ ((((is_finite x) /\ (is_infinite y)) -> (eq r zeroF))
                          /\ ((((is_infinite x) /\ (is_finite y)) ->
                               (is_infinite r))
                              /\ ((((is_infinite x) /\ (is_infinite y)) ->
                                   (is_nan r))
                                  /\ ((((is_finite x)
                                        /\ ((is_finite y)
                                            /\ ((~ (eq y zeroF))
                                                /\ (no_overflow m
                                                ((to_real x) / (to_real y))%R)))) ->
                                       ((is_finite r)
                                        /\ ((to_real r) = (round m
                                                            ((to_real x) /
                                                            (to_real y))%R))))
                                      /\ ((((is_finite x)
                                            /\ ((eq y zeroF)
                                                /\ ~ (eq x zeroF))) ->
                                           (is_infinite r))
                                          /\ ((((eq x zeroF) /\ (eq y zeroF)) ->
                                               (is_nan r))
                                              /\ ((~ (is_nan r)) ->
                                                  (product_sign r x y))))))))).

Axiom neg_special : forall (x:t1),
                     ((is_nan x) -> (is_nan (neg1 x)))
                     /\ (((is_infinite x) -> (is_infinite (neg1 x)))
                         /\ ((~ (is_nan x)) -> (diff_sign x (neg1 x)))).

Axiom abs_special : forall (x:t1),
                     ((is_nan x) -> (is_nan (abs x)))
                     /\ (((is_infinite x) -> (is_infinite (abs x)))
                         /\ ((~ (is_nan x)) -> (is_positive (abs x)))).

Axiom fma_special : forall (m:mode) (x:t1) (y:t1) (z:t1),
                     let r := (fma m x y z) in
                     ((((is_nan x) \/ ((is_nan y) \/ (is_nan z))) -> (is_nan
                       r))
                      /\ ((((eq x zeroF) /\ (is_infinite y)) -> (is_nan r))
                          /\ ((((is_infinite x) /\ (eq y zeroF)) -> (is_nan
                               r))
                              /\ ((((is_finite x)
                                    /\ ((~ (eq x zeroF))
                                        /\ ((is_infinite y) /\ (is_finite z)))) ->
                                   ((is_infinite r) /\ (product_sign r x y)))
                                  /\ ((((is_finite x)
                                        /\ ((~ (eq x zeroF))
                                            /\ ((is_infinite y)
                                                /\ (is_infinite z)))) ->
                                       (((product_sign z x y) ->
                                         ((is_infinite r) /\ (same_sign r z)))
                                        /\ ((~ (product_sign z x y)) ->
                                            (is_nan r))))
                                      /\ ((((is_infinite x)
                                            /\ ((is_finite y)
                                                /\ ((~ (eq y zeroF))
                                                    /\ (is_finite z)))) ->
                                           ((is_infinite r) /\ (product_sign
                                            r x y)))
                                          /\ ((((is_infinite x)
                                                /\ ((is_finite y)
                                                    /\ ((~ (eq y zeroF))
                                                        /\ (is_infinite z)))) ->
                                               (((product_sign z x y) ->
                                                 ((is_infinite r)
                                                  /\ (same_sign r z)))
                                                /\ ((~ (product_sign z x y)) ->
                                                    (is_nan r))))
                                              /\ ((((is_infinite x)
                                                    /\ ((is_infinite y)
                                                        /\ (is_finite z))) ->
                                                   ((is_infinite r)
                                                    /\ (product_sign r x y)))
                                                  /\ ((((is_finite x)
                                                        /\ ((is_finite y)
                                                            /\ (is_infinite
                                                            z))) ->
                                                       ((is_infinite r)
                                                        /\ (same_sign r z)))
                                                      /\ ((((is_infinite x)
                                                            /\ ((is_infinite
                                                                y)
                                                                /\ (is_infinite
                                                                z))) ->
                                                           (((product_sign z
                                                             x y) ->
                                                             ((is_infinite r)
                                                              /\ (same_sign r
                                                              z)))
                                                            /\ ((~ (product_sign
                                                                 z x y)) ->
                                                                (is_nan r))))
                                                          /\ ((((is_finite x)
                                                                /\ ((is_finite
                                                                    y)
                                                                    /\ (
                                                                    (is_finite
                                                                    z)
                                                                    /\
                                                                    ~ (no_overflow
                                                                    m
                                                                    ((
                                                                    (
                                                                    to_real x) *
                                                                    (
                                                                    to_real y))%R +
                                                                    (
                                                                    to_real z))%R)))) ->
                                                               ((same_sign_real
                                                                r
                                                                (((to_real x) *
                                                                (to_real y))%R +
                                                                (to_real z))%R)
                                                                /\ (overflow_value
                                                                m r)))
                                                              /\ (((is_finite
                                                                   x)
                                                                   /\ (
                                                                   (is_finite
                                                                   y)
                                                                   /\ (is_finite
                                                                   z))) ->
                                                                  (((product_sign
                                                                    z x y) ->
                                                                    (same_sign
                                                                    r z))
                                                                   /\ (
                                                                   (~ (product_sign
                                                                    z x y)) ->
                                                                   ((((
                                                                    (
                                                                    to_real x) *
                                                                    (
                                                                    to_real y))%R +
                                                                    (
                                                                    to_real z))%R = 0%R) ->
                                                                    (
                                                                    (
                                                                    (m = RTN) ->
                                                                    (is_negative
                                                                    r))
                                                                    /\ (
                                                                    (
                                                                    ~ (m = RTN)) ->
                                                                    (is_positive
                                                                    r)))))))))))))))))).

Axiom sqrt_special : forall (m:mode) (x:t1),
                      let r := (sqrt m x) in
                      (((is_nan x) -> (is_nan r))
                       /\ (((is_plus_infinity x) -> (is_plus_infinity r))
                           /\ (((is_minus_infinity x) -> (is_nan r))
                               /\ ((((is_finite x) /\ ((to_real x) < 0%R)%R) ->
                                    (is_nan r))
                                   /\ (((eq x zeroF) -> (same_sign r x))
                                       /\ (((is_finite x)
                                            /\ (0%R < (to_real x))%R) ->
                                           (is_positive r))))))).

Axiom Min_r : forall (x:t1) (y:t1), (le y x) -> (eq (min x y) y).

Axiom Min_l : forall (x:t1) (y:t1), (le x y) -> (eq (min x y) x).

Axiom Max_r : forall (x:t1) (y:t1), (le y x) -> (eq (max x y) x).

Axiom Max_l : forall (x:t1) (y:t1), (le x y) -> (eq (max x y) y).

Axiom Min_assoc : forall (x:t1) (y:t1) (z:t1),
                   ((min (min x y) z) = (min x (min y z))).

Axiom Max_assoc : forall (x:t1) (y:t1) (z:t1),
                   ((max (max x y) z) = (max x (max y z))).

Parameter is_int: t1 -> Prop.

Axiom zeroF_is_int : (is_int zeroF).

Axiom of_int_is_int : forall (m:mode) (x:Z),
                       (((-max_int)%Z <= x)%Z /\ (x <= max_int)%Z) -> (is_int
                       (of_int1 m x)).

Axiom is_int_is_finite : forall (x:t1), (is_int x) -> (is_finite x).

Axiom int_to_real : forall (m:mode) (x:t1),
                     (is_int x) ->
                     ((to_real x) = (Reals.Raxioms.IZR (to_int1 m x))).

Axiom big_float_is_int : forall (m:mode) (i:t1),
                          (is_finite i) ->
                          (((le i (of_int1 m (-9007199254740992%Z)%Z)) /\ (le
                            (of_int1 m 9007199254740992%Z) i)) -> (is_int i)).

Axiom roundToIntegral_is_int : forall (m:mode) (x:t1),
                                (is_finite x) -> (is_int
                                (roundToIntegral m x)).

Axiom truncate_int : forall (m:mode) (i:t1),
                      (is_int i) -> (eq (roundToIntegral m i) i).

Axiom truncate_neg : forall (x:t1),
                      (is_finite x) ->
                      ((is_negative x) ->
                       ((roundToIntegral RTZ x) = (roundToIntegral RTP x))).

Axiom truncate_pos : forall (x:t1),
                      (is_finite x) ->
                      ((is_positive x) ->
                       ((roundToIntegral RTZ x) = (roundToIntegral RTN x))).

Axiom ceil_le : forall (x:t1),
                 (is_finite x) -> (le x (roundToIntegral RTP x)).

Axiom ceil_lest : forall (x:t1) (y:t1),
                   ((le x y) /\ (is_int y)) -> (le (roundToIntegral RTP x) y).

Axiom ceil_to_real : forall (m:mode) (x:t1),
                      ((le (neg1 (of_int1 m 9007199254740992%Z)) x) /\ (le x
                       (of_int1 m 9007199254740992%Z))) ->
                      ((to_real (roundToIntegral RTP x)) = (Reals.Raxioms.IZR
                      (ceil (to_real x)))).

Axiom ceil_to_int : forall (m:mode) (x:t1),
                     ((le (neg1 (of_int1 m 9007199254740992%Z)) x) /\ (le x
                      (of_int1 m 9007199254740992%Z))) ->
                     ((to_int1 m (roundToIntegral RTP x)) = (ceil (to_real x))).

Axiom floor_le : forall (x:t1),
                  (is_finite x) -> (le (roundToIntegral RTN x) x).

Axiom floor_lest : forall (x:t1) (y:t1),
                    ((le y x) /\ (is_int y)) -> (le y
                    (roundToIntegral RTN x)).

Axiom floor_to_real : forall (m:mode) (x:t1),
                       ((le (neg1 (of_int1 m 9007199254740992%Z)) x) /\ (le x
                        (of_int1 m 9007199254740992%Z))) ->
                       ((to_real (roundToIntegral RTN x)) = (Reals.Raxioms.IZR
                       (floor (to_real x)))).

Axiom floor_to_int : forall (m:mode) (x:t1),
                      ((le (neg1 (of_int1 m 9007199254740992%Z)) x) /\ (le x
                       (of_int1 m 9007199254740992%Z))) ->
                      ((to_int1 m (roundToIntegral RTN x)) = (floor (
                                                                    to_real x))).

Axiom RNA_down : forall (x:t1),
                  (lt (sub1 RNE x (roundToIntegral RTN x))
                  (sub1 RNE (roundToIntegral RTP x) x)) ->
                  ((roundToIntegral RNA x) = (roundToIntegral RTN x)).

Axiom RNA_up : forall (x:t1),
                (lt (sub1 RNE (roundToIntegral RTP x) x)
                (sub1 RNE x (roundToIntegral RTN x))) ->
                ((roundToIntegral RNA x) = (roundToIntegral RTP x)).

Axiom RNA_down_tie : forall (x:t1),
                      (eq (sub1 RNE x (roundToIntegral RTN x))
                      (sub1 RNE (roundToIntegral RTP x) x)) ->
                      ((is_negative x) ->
                       ((roundToIntegral RNA x) = (roundToIntegral RTN x))).

Axiom RNA_up_tie : forall (x:t1),
                    (eq (sub1 RNE (roundToIntegral RTP x) x)
                    (sub1 RNE x (roundToIntegral RTN x))) ->
                    ((is_positive x) ->
                     ((roundToIntegral RNA x) = (roundToIntegral RTP x))).

Axiom RNA_near_int : forall (i:t1) (x:t1),
                      (is_int i) ->
                      (((lt (neg1 half) x) /\ (lt x half)) ->
                       ((roundToIntegral RNA (add1 RNE i x)) = i)).

Axiom to_int_roundToIntegral : forall (m:mode) (x:t1),
                                ((to_int1 m x) = (to_int1 m
                                                   (roundToIntegral m x))).

Axiom to_int_monotonic : forall (m:mode) (x:t1) (y:t1),
                          (is_finite y) ->
                          ((is_finite x) ->
                           ((le x y) -> ((to_int1 m x) <= (to_int1 m y))%Z)).

Axiom to_int_monotonic_int1 : forall (m:mode) (x:t1) (i:Z),
                               (is_finite x) ->
                               ((le x (of_int1 m i)) ->
                                ((to_int1 m x) <= i)%Z).

Axiom to_int_monotonic_int2 : forall (m:mode) (x:t1) (i:Z),
                               (is_finite x) ->
                               ((le (of_int1 m i) x) ->
                                (i <= (to_int1 m x))%Z).

Axiom to_int_of_int : forall (m:mode) (i:Z),
                       (((-9007199254740992%Z)%Z <= i)%Z
                        /\ (i <= 9007199254740992%Z)%Z) ->
                       ((to_int1 m (of_int1 m i)) = i).

Axiom eq_to_int : forall (m:mode) (x:t1) (y:t1),
                   (is_finite x) ->
                   ((eq x y) -> ((to_int1 m x) = (to_int1 m y))).

Axiom roundToIntegral_is_finite : forall (m:mode) (x:t1),
                                   (is_finite x) -> (is_finite
                                   (roundToIntegral m x)).

Axiom round_bound_ne : forall (x:R),
                        (((x - ((1 / 9007199254740992)%R * (Reals.Rbasic_fun.Rabs x))%R)%R - (1 / 404804506614621236704990693437834614099113299528284236713802716054860679135990693783920767402874248990374155728633623822779617474771586953734026799881477019843034848553132722728933815484186432682479535356945490137124014966849385397236206711298319112681620113024717539104666829230461005064372655017292012526615415482186989568)%R)%R <=
                        (round RNE x))%R
                        /\ ((round RNE x) <= ((x + ((1 / 9007199254740992)%R * (Reals.Rbasic_fun.Rabs x))%R)%R + (1 / 404804506614621236704990693437834614099113299528284236713802716054860679135990693783920767402874248990374155728633623822779617474771586953734026799881477019843034848553132722728933815484186432682479535356945490137124014966849385397236206711298319112681620113024717539104666829230461005064372655017292012526615415482186989568)%R)%R)%R.

Axiom round_bound : forall (m:mode) (x:R),
                     (((x - ((1 / 4503599627370496)%R * (Reals.Rbasic_fun.Rabs x))%R)%R - (1 / 202402253307310618352495346718917307049556649764142118356901358027430339567995346891960383701437124495187077864316811911389808737385793476867013399940738509921517424276566361364466907742093216341239767678472745068562007483424692698618103355649159556340810056512358769552333414615230502532186327508646006263307707741093494784)%R)%R <=
                     (round m x))%R
                     /\ ((round m x) <= ((x + ((1 / 4503599627370496)%R * (Reals.Rbasic_fun.Rabs x))%R)%R + (1 / 202402253307310618352495346718917307049556649764142118356901358027430339567995346891960383701437124495187077864316811911389808737385793476867013399940738509921517424276566361364466907742093216341239767678472745068562007483424692698618103355649159556340810056512358769552333414615230502532186327508646006263307707741093494784)%R)%R)%R.

(* Why3 assumption *)
Definition neq (x:t1) (y:t1): Prop := ~ (eq x y).

Parameter bool_lt: t1 -> t1 -> bool.

Axiom bool_lt_def : forall (x:t1) (y:t1),
                     ((lt x y) -> ((bool_lt x y) = true))
                     /\ ((~ (lt x y)) -> ((bool_lt x y) = false)).

Parameter bool_le: t1 -> t1 -> bool.

Axiom bool_le_def : forall (x:t1) (y:t1),
                     ((le x y) -> ((bool_le x y) = true))
                     /\ ((~ (le x y)) -> ((bool_le x y) = false)).

Parameter bool_gt: t1 -> t1 -> bool.

Axiom bool_gt_def : forall (x:t1) (y:t1),
                     ((lt y x) -> ((bool_gt x y) = true))
                     /\ ((~ (lt y x)) -> ((bool_gt x y) = false)).

Parameter bool_ge: t1 -> t1 -> bool.

Axiom bool_ge_def : forall (x:t1) (y:t1),
                     ((le y x) -> ((bool_ge x y) = true))
                     /\ ((~ (le y x)) -> ((bool_ge x y) = false)).

Parameter bool_eq: t1 -> t1 -> bool.

Axiom bool_eq_def : forall (x:t1) (y:t1),
                     ((eq x y) -> ((bool_eq x y) = true))
                     /\ ((~ (eq x y)) -> ((bool_eq x y) = false)).

Parameter bool_neq: t1 -> t1 -> bool.

Axiom bool_neq_def : forall (x:t1) (y:t1),
                      ((~ (eq x y)) -> ((bool_neq x y) = true))
                      /\ ((eq x y) -> ((bool_neq x y) = false)).

Parameter one: t1.

Axiom one_is_finite : (is_finite one).

Axiom one_is_int : (is_int one).

Axiom one_to_real : ((to_real one) = 1%R).

Axiom one_of_int : (one = (of_int1 RNA 1%Z)).

(* Why3 assumption *)
Inductive t__ref :=
  | mk_t__ref : t1 -> t__ref.
Axiom t__ref_WhyType : WhyType t__ref.
Existing Instance t__ref_WhyType.

(* Why3 assumption *)
Definition t__content (v:t__ref): t1 := match v with
                                        | (mk_t__ref x) => x
                                        end.

(* Why3 assumption *)
Definition ite {a:Type} {a_WT:WhyType a} (b:bool) (x:a) (y:a): a :=
  match b with
  | true => x
  | false => y
  end.

Parameter bool_eq1: bool -> bool -> bool.

Axiom bool_eq_def1 : forall (x:bool) (y:bool),
                      ((x = y) -> ((bool_eq1 x y) = true))
                      /\ ((~ (x = y)) -> ((bool_eq1 x y) = false)).

Parameter to_int2: bool -> Z.

Axiom to_int_def : forall (b:bool),
                    ((b = true) -> ((to_int2 b) = 1%Z))
                    /\ ((~ (b = true)) -> ((to_int2 b) = 0%Z)).

Parameter of_int2: Z -> bool.

Axiom of_int_def : forall (i:Z),
                    ((i = 0%Z) -> ((of_int2 i) = false))
                    /\ ((~ (i = 0%Z)) -> ((of_int2 i) = true)).

(* Why3 assumption *)
Definition in_range1 (x:Z): Prop := (x = 0%Z) \/ (x = 1%Z).

Parameter attr__ATTRIBUTE_IMAGE: bool -> us_image.

Parameter attr__ATTRIBUTE_VALUE__pre_check: us_image -> Prop.

Parameter attr__ATTRIBUTE_VALUE: us_image -> bool.

Parameter l: t1.

Axiom l_real : ((to_real l) = (-179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368%R)%R).

Axiom l_representable : ((to_real l) = (round RNE (to_real l))).

Axiom l_bin : (l = (from_binary 18442240474082181119%Z)).

Axiom l_is_finite : (is_finite l).

Parameter l1: t1.

Axiom l_real1 : ((to_real l1) = 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368%R).

Axiom l_representable1 : ((to_real l1) = (round RNE (to_real l1))).

Axiom l_bin1 : (l1 = (from_binary 9218868437227405311%Z)).

Axiom l_is_finite1 : (is_finite l1).

Axiom long_float : Type.
Parameter long_float_WhyType : WhyType long_float.
Existing Instance long_float_WhyType.

Parameter bool_eq2: t1 -> t1 -> bool.

Axiom bool_eq_def2 : forall (x:t1) (y:t1),
                      ((eq x y) -> ((bool_eq2 x y) = true))
                      /\ ((~ (eq x y)) -> ((bool_eq2 x y) = false)).

Parameter user_eq: long_float -> long_float -> bool.

Parameter attr__ATTRIBUTE_IMAGE1: t1 -> us_image.

Parameter attr__ATTRIBUTE_VALUE__pre_check1: us_image -> Prop.

Parameter attr__ATTRIBUTE_VALUE1: us_image -> t1.

Parameter dummy: long_float.

(* Why3 assumption *)
Inductive long_float__ref :=
  | mk_long_float__ref : long_float -> long_float__ref.
Axiom long_float__ref_WhyType : WhyType long_float__ref.
Existing Instance long_float__ref_WhyType.

(* Why3 assumption *)
Definition long_float__content (v:long_float__ref): long_float :=
  match v with
  | (mk_long_float__ref x) => x
  end.

(* Why3 assumption *)
Definition long_float__ref___projection (a:long_float__ref): long_float :=
  (long_float__content a).

Axiom fl : Type.
Parameter fl_WhyType : WhyType fl.
Existing Instance fl_WhyType.

Parameter bool_eq3: t1 -> t1 -> bool.

Axiom bool_eq_def3 : forall (x:t1) (y:t1),
                      ((eq x y) -> ((bool_eq3 x y) = true))
                      /\ ((~ (eq x y)) -> ((bool_eq3 x y) = false)).

Parameter user_eq1: fl -> fl -> bool.

Parameter attr__ATTRIBUTE_IMAGE2: t1 -> us_image.

Parameter attr__ATTRIBUTE_VALUE__pre_check2: us_image -> Prop.

Parameter attr__ATTRIBUTE_VALUE2: us_image -> t1.

Parameter dummy1: fl.

(* Why3 assumption *)
Inductive fl__ref :=
  | mk_fl__ref : fl -> fl__ref.
Axiom fl__ref_WhyType : WhyType fl__ref.
Existing Instance fl__ref_WhyType.

(* Why3 assumption *)
Definition fl__content (v:fl__ref): fl :=
  match v with
  | (mk_fl__ref x) => x
  end.

(* Why3 assumption *)
Definition fl__ref___projection (a:fl__ref): fl := (fl__content a).

(* Why3 assumption *)
Definition dynamic_invariant (temp___expr_137:t1) (temp___is_init_134:bool)
  (temp___do_constant_135:bool) (temp___do_toplevel_136:bool): Prop :=
  ((temp___is_init_134 = true) \/ (le l l1)) -> (is_finite temp___expr_137).

Parameter l2: t1.

Axiom l_real2 : ((to_real l2) = 13407807929942595611008317640802934282464207265959107021466054756094376573581619054852612241927956455650759996398703782412109633178814162067569513603268608%R).

Axiom l_representable2 : ((to_real l2) = (round RNE (to_real l2))).

Axiom l_bin2 : (l2 = (from_binary 6913025428013711359%Z)).

Axiom l_is_finite2 : (is_finite l2).

Parameter val1: t1.

Parameter attr__ATTRIBUTE_ADDRESS: Z.

Parameter val2: t1.

Parameter attr__ATTRIBUTE_ADDRESS1: Z.

Parameter val3: t1.

Parameter attr__ATTRIBUTE_ADDRESS2: Z.

Parameter l3: t1.

Axiom l_real3 : ((to_real l3) = (0 / 10)%R).

Axiom l_representable3 : ((to_real l3) = (round RNE (to_real l3))).

Axiom l_bin3 : (l3 = (from_binary 0%Z)).

Axiom l_is_finite3 : (is_finite l3).

Parameter l4: t1.

Axiom l_real4 : ((to_real l4) = (-13407807929942595611008317640802934282464207265959107021466054756094376573581619054852612241927956455650759996398703782412109633178814162067569513603268608%R)%R).

Axiom l_representable4 : ((to_real l4) = (round RNE (to_real l4))).

Axiom l_bin4 : (l4 = (from_binary 16136397464868487167%Z)).

Axiom l_is_finite4 : (is_finite l4).

(* Why3 assumption *)
Definition dynamic_invariant1 (temp___expr_61:t1) (temp___is_init_58:bool)
  (temp___do_constant_59:bool) (temp___do_toplevel_60:bool): Prop :=
  ((temp___is_init_58 = true) \/ (le l l1)) -> (is_finite temp___expr_61).

(* Why3 goal *)
Theorem WP_parameter_def : ((is_finite val1)
                            /\ ((is_finite val2)
                                /\ ((is_finite val3)
                                    /\ (((le l4 val1) /\ (le val1 l2))
                                        /\ (((le l4 val2) /\ (le val2 l2))
                                            /\ (((le l3 val3) /\ (le val3 l2))
                                                /\ (le val1 val2))))))) ->
                           (*        Post => Val1 * Val3 <= Val2 * Val3;  --  MANUAL PROOF                                                                                *)
                           (*                ^ spark-floating_point_arithmetic_lemmas.ads:78:16:instantiated:spark-long_float_arithmetic_lemmas.ads:32:1:VC_POSTCONDITION *)
                           (le (mul1 RNE val1 val3) (mul1 RNE val2 val3)).
intros (h1,(h2,(h3,((h4,h5),((h6,h7),((h8,h9),h10)))))).
(* file shared by the two lemmas dealing with 64-bit multiplication *)
#include "float64_mul_common.prf"
(* file shared by the two lemmas dealing 32/64-bit mul monotonicity *)
#include "float_mul_is_monotonic.prf"
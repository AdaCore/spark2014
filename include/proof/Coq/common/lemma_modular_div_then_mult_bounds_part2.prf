(* not used anymore, as Alt-ergo manages to prove Lemma_Modular_Div_Then_Mult_Bounds_Part2 *)

intros (arg2_type,pre).
Open Scope Z_scope.
Require Import SPARK.

(* rewrite hypotheses *)
pose (to_uint_bounds arg1) as arg1_type.
pose (to_uint_bounds res) as res_type.
unfold in_range in arg2_type.
destruct arg1_type as (arg1_lb, arg1_ub), arg2_type as (arg2_lb, arg2_ub), res_type as (res_lb, res_ub).
unfold ule in arg2_lb, arg2_ub.
rewrite to_uint_of_int in arg2_lb, arg2_ub by auto with zarith.
assert (0 < to_uint arg2) as arg2_pos by auto with zarith.

(* shared lemma: no overflow in (arg1 / arg2) * arg2 *)
assert (0 <= (to_uint arg1 / to_uint arg2) * to_uint arg2 < SPARK_MAX_UINT_PLUS1) as no_ovfl_div_mul.
split.
{ assert (to_uint arg2 > 0) as arg2_pos2 by auto with zarith.
  assert (0 <= to_uint arg1 / to_uint arg2) as div_nat.
  apply (Z_div_pos _ _ arg2_pos2 arg1_lb).
  apply (Zmult_gt_0_le_0_compat _ _ arg2_pos2 div_nat).
}
{
  assert (to_uint arg1 / to_uint arg2 * to_uint arg2 <= to_uint arg1) as inter_ineq.
  apply (div_mul_le _ _ arg1_lb arg2_pos).
  auto with zarith.
}

(* shared lemma: res <= arg1 *)
assert (to_uint res <= to_uint arg1) as res_le_arg1.
rewrite pre, to_uint_mul, to_uint_udiv.
unfold EuclideanDivision.div.
case Z_le_dec; [intros|intros neg_hyp; contradict neg_hyp; apply Z_mod_lt; auto with zarith].
rewrite BV_Gen.mod1_out.
(* apply theorem *)
{ apply (div_mul_le _ _ arg1_lb arg2_pos). }
(* no overflow in (arg1 / arg2) * arg2 *)
{ exact no_ovfl_div_mul. }

(* arg1 - res < arg2 *)
unfold ult.
rewrite to_uint_sub.
rewrite BV_Gen.mod1_out by auto with zarith. (* res_le_arg1 used here *)
rewrite pre, to_uint_mul, to_uint_udiv.
unfold EuclideanDivision.div.
case Z_le_dec; [intros|intros neg_hyp; contradict neg_hyp; apply Z_mod_lt; auto with zarith].
rewrite BV_Gen.mod1_out.

(* arg1 - (arg1 / arg2) * arg2 < arg2 *)
* pose (Z.mul_succ_div_gt (to_uint arg1) (to_uint arg2) arg2_pos).
  replace (Z.succ (to_uint arg1 / to_uint arg2)) with (to_uint arg1 / to_uint arg2 + 1) in l0 by auto with zarith.
  rewrite Int.Mul_distr_l in l0.
  replace (to_uint arg2 * (to_uint arg1 / to_uint arg2)) with ((to_uint arg1 / to_uint arg2) * to_uint arg2) in l0 by auto with zarith.
  auto with zarith.

(* no overflow in (arg1 / arg2) * arg2 *)
* exact no_ovfl_div_mul.

Qed.

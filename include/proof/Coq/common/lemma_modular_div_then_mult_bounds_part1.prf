(* not used anymore, as Alt-ergo manages to prove Lemma_Modular_Div_Then_Mult_Bounds_Part1 *)

intros (arg2_type,pre).
Open Scope Z_scope.
Require Import SPARK.

(* rewrite hypotheses *)
pose (to_uint_bounds arg1) as arg1_type.
pose (to_uint_bounds res) as res_type.
unfold in_range in arg2_type.
destruct arg1_type as (arg1_lb, arg1_ub), arg2_type as (arg2_lb, arg2_ub), res_type as (res_lb, res_ub).
unfold ule in arg2_lb, arg2_ub.
rewrite to_uint_of_int in arg2_lb, arg2_ub by auto with zarith.
assert (0 < to_uint arg2) as arg2_pos by auto with zarith.

(* shared lemma: no overflow in (arg1 / arg2) * arg2 *)
assert (0 <= (to_uint arg1 / to_uint arg2) * to_uint arg2 < SPARK_MAX_UINT_PLUS1) as no_ovfl_div_mul.
split.
{ assert (to_uint arg2 > 0) as arg2_pos2 by auto with zarith.
  assert (0 <= to_uint arg1 / to_uint arg2) as div_nat.
  apply (Z_div_pos _ _ arg2_pos2 arg1_lb).
  apply (Zmult_gt_0_le_0_compat _ _ arg2_pos2 div_nat).
}
{
  assert (to_uint arg1 / to_uint arg2 * to_uint arg2 <= to_uint arg1) as inter_ineq.
  apply (div_mul_le _ _ arg1_lb arg2_pos).
  auto with zarith.
}

(* shared lemma: res <= arg1 *)
assert (to_uint res <= to_uint arg1) as res_le_arg1.
rewrite pre, to_uint_mul, to_uint_udiv.
unfold EuclideanDivision.div.
case Z_le_dec; [intros|intros neg_hyp; contradict neg_hyp; apply Z_mod_lt; auto with zarith].
rewrite BV_Gen.mod1_out.
(* apply theorem *)
{ apply (div_mul_le _ _ arg1_lb arg2_pos). }
(* no overflow in (arg1 / arg2) * arg2 *)
{ exact no_ovfl_div_mul. }

(* res <= arg1 *)
unfold ule.
exact res_le_arg1.

Qed.

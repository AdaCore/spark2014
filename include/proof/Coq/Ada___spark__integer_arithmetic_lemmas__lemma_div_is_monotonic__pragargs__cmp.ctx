(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require int.Int.
Require int.Abs.
Require int.EuclideanDivision.
Require int.ComputerDivision.
Require bool.Bool.

Axiom us_private : Type.
Parameter us_private_WhyType : WhyType us_private.
Existing Instance us_private_WhyType.

(* Why3 assumption *)
Definition us_fixed := Z.

Parameter private__bool_eq: us_private -> us_private -> bool.

Parameter us_null_ext__: us_private.

Axiom us_type_of_heap : Type.
Parameter us_type_of_heap_WhyType : WhyType us_type_of_heap.
Existing Instance us_type_of_heap_WhyType.

(* Why3 assumption *)
Inductive us_type_of_heap__ref :=
  | mk___type_of_heap__ref : us_type_of_heap -> us_type_of_heap__ref.
Axiom us_type_of_heap__ref_WhyType : WhyType us_type_of_heap__ref.
Existing Instance us_type_of_heap__ref_WhyType.

(* Why3 assumption *)
Definition us_type_of_heap__content (v:us_type_of_heap__ref) :
    us_type_of_heap :=
  match v with
  | mk___type_of_heap__ref x => x
  end.

Axiom us_image : Type.
Parameter us_image_WhyType : WhyType us_image.
Existing Instance us_image_WhyType.

(* Why3 assumption *)
Inductive int__ref :=
  | mk_int__ref : Z -> int__ref.
Axiom int__ref_WhyType : WhyType int__ref.
Existing Instance int__ref_WhyType.

(* Why3 assumption *)
Definition int__content (v:int__ref) : Z :=
  match v with
  | mk_int__ref x => x
  end.

(* Why3 assumption *)
Inductive bool__ref :=
  | mk_bool__ref : bool -> bool__ref.
Axiom bool__ref_WhyType : WhyType bool__ref.
Existing Instance bool__ref_WhyType.

(* Why3 assumption *)
Definition bool__content (v:bool__ref) : bool :=
  match v with
  | mk_bool__ref x => x
  end.

(* Why3 assumption *)
Inductive us_fixed__ref :=
  | mk___fixed__ref : Z -> us_fixed__ref.
Axiom us_fixed__ref_WhyType : WhyType us_fixed__ref.
Existing Instance us_fixed__ref_WhyType.

(* Why3 assumption *)
Definition us_fixed__content (v:us_fixed__ref) : Z :=
  match v with
  | mk___fixed__ref x => x
  end.

(* Why3 assumption *)
Inductive real__ref :=
  | mk_real__ref : R -> real__ref.
Axiom real__ref_WhyType : WhyType real__ref.
Existing Instance real__ref_WhyType.

(* Why3 assumption *)
Definition real__content (v:real__ref) : R :=
  match v with
  | mk_real__ref x => x
  end.

(* Why3 assumption *)
Inductive us_private__ref :=
  | mk___private__ref : us_private -> us_private__ref.
Axiom us_private__ref_WhyType : WhyType us_private__ref.
Existing Instance us_private__ref_WhyType.

(* Why3 assumption *)
Definition us_private__content (v:us_private__ref) : us_private :=
  match v with
  | mk___private__ref x => x
  end.

(* Why3 assumption *)
Definition int__ref___projection (a:int__ref) : Z := int__content a.

(* Why3 assumption *)
Definition us_fixed__ref___projection (a:us_fixed__ref) : Z :=
  us_fixed__content a.

(* Why3 assumption *)
Definition bool__ref___projection (a:bool__ref) : bool := bool__content a.

(* Why3 assumption *)
Definition real__ref___projection (a:real__ref) : R := real__content a.

(* Why3 assumption *)
Definition us_private__ref___projection (a:us_private__ref) : us_private :=
  us_private__content a.

Parameter val1: Z.

Parameter attr__ATTRIBUTE_ADDRESS: Z.

Parameter val2: Z.

Parameter attr__ATTRIBUTE_ADDRESS1: Z.

Parameter denom: Z.

Parameter attr__ATTRIBUTE_ADDRESS2: Z.

Axiom int__ : Type.
Parameter int___WhyType : WhyType int__.
Existing Instance int___WhyType.

Parameter int__'int: int__ -> Z.

Axiom int__'axiom :
  forall (i:int__),
  ((-2147483648%Z)%Z <= (int__'int i))%Z /\ ((int__'int i) <= 2147483647%Z)%Z.

(* Why3 assumption *)
Definition in_range (x:Z) : Prop :=
  ((-2147483648%Z)%Z <= x)%Z /\ (x <= 2147483647%Z)%Z.

Parameter bool_eq: Z -> Z -> bool.

Axiom bool_eq_def :
  forall (x:Z) (y:Z),
  ((x = y) -> ((bool_eq x y) = true)) /\
  (~ (x = y) -> ((bool_eq x y) = false)).

Parameter attr__ATTRIBUTE_IMAGE: Z -> us_image.

Parameter attr__ATTRIBUTE_VALUE__pre_check: us_image -> Prop.

Parameter attr__ATTRIBUTE_VALUE: us_image -> Z.

Parameter user_eq: int__ -> int__ -> bool.

Parameter dummy: int__.

(* Why3 assumption *)
Inductive int____ref :=
  | mk_int____ref : int__ -> int____ref.
Axiom int____ref_WhyType : WhyType int____ref.
Existing Instance int____ref_WhyType.

(* Why3 assumption *)
Definition int____content (v:int____ref) : int__ :=
  match v with
  | mk_int____ref x => x
  end.

(* Why3 assumption *)
Definition int____ref_int____content__projection (a:int____ref) : int__ :=
  int____content a.

(* Why3 assumption *)
Definition dynamic_invariant (temp___expr_158:Z) (temp___is_init_154:bool)
    (temp___skip_constant_155:bool) (temp___do_toplevel_156:bool)
    (temp___do_typ_inv_157:bool) : Prop :=
  ((temp___is_init_154 = true) \/ ((-2147483648%Z)%Z <= 2147483647%Z)%Z) ->
  in_range temp___expr_158.

Axiom pos : Type.
Parameter pos_WhyType : WhyType pos.
Existing Instance pos_WhyType.

Parameter pos'int: pos -> Z.

Axiom pos'axiom :
  forall (i:pos), (1%Z <= (pos'int i))%Z /\ ((pos'int i) <= 2147483647%Z)%Z.

(* Why3 assumption *)
Definition in_range1 (x:Z) : Prop := (1%Z <= x)%Z /\ (x <= 2147483647%Z)%Z.

Parameter bool_eq1: Z -> Z -> bool.

Axiom bool_eq_def1 :
  forall (x:Z) (y:Z),
  ((x = y) -> ((bool_eq1 x y) = true)) /\
  (~ (x = y) -> ((bool_eq1 x y) = false)).

Parameter attr__ATTRIBUTE_IMAGE1: Z -> us_image.

Parameter attr__ATTRIBUTE_VALUE__pre_check1: us_image -> Prop.

Parameter attr__ATTRIBUTE_VALUE1: us_image -> Z.

Parameter user_eq1: pos -> pos -> bool.

Parameter dummy1: pos.

(* Why3 assumption *)
Inductive pos__ref :=
  | mk_pos__ref : pos -> pos__ref.
Axiom pos__ref_WhyType : WhyType pos__ref.
Existing Instance pos__ref_WhyType.

(* Why3 assumption *)
Definition pos__content (v:pos__ref) : pos :=
  match v with
  | mk_pos__ref x => x
  end.

(* Why3 assumption *)
Definition pos__ref_pos__content__projection (a:pos__ref) : pos :=
  pos__content a.

(* Why3 assumption *)
Definition dynamic_invariant1 (temp___expr_172:Z) (temp___is_init_168:bool)
    (temp___skip_constant_169:bool) (temp___do_toplevel_170:bool)
    (temp___do_typ_inv_171:bool) : Prop :=
  ((temp___is_init_168 = true) \/ (1%Z <= 2147483647%Z)%Z) ->
  in_range1 temp___expr_172.

(* Why3 goal *)
Theorem def'VC :
  (dynamic_invariant val1 true false true true) ->
  (dynamic_invariant val2 true false true true) ->
  (dynamic_invariant1 denom true false true true) -> (val1 <= val2)%Z ->
  (*      Post => Val1 / Denom <= Val2 / Denom;  --  MANUAL PROOF              ^ spark-arithmetic_lemmas.ads:61:14:instantiated:spark-integer_arithmetic_lemmas.ads:31:1:VC_POSTCONDITION *)
  ((ZArith.BinInt.Z.quot val1 denom) <= (ZArith.BinInt.Z.quot val2 denom))%Z.
Proof.
#include "lemma_div_is_monotonic.prf"

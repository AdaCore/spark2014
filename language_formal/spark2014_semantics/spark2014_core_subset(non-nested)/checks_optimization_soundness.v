Require Export checks_optimization.
Require Export checks_generator.

Scheme expression_ind := Induction for expression Sort Prop 
                         with name_ind := Induction for name Sort Prop.

Scheme expression_x_ind := Induction for expression_x Sort Prop 
                         with name_x_ind := Induction for name_x Sort Prop.


(** * Well-Typed Stack *)
Section Well_Typed_Stack_Sec.
(** the value of variable and and record field are well-typed according to
    the symbol table;

  extract_array_index_range_x st arraytyp (Range_X l u) ->
  do_range_check i l u Success ->
  STACK.fetchG x s = Some (AggregateV (ArrayV a)) ->
  array_select a i = Some (Int v) ->
  valueO_of_array_component_type st arraytyp (IntBetween l' u') ->
  (Zge_bool v l') && (Zle_bool v u') = true.



  fetch_exp_type_x recAstNum st = Some (Record_Type t) ->
  valueO_of_record_field_type st recType fieldId (IntBetween l u) ->
  STACK.fetchG x s = Some (AggregateV (RecordV r)) ->
  record_select r fieldId = Some (Int v) ->
   (v >=? l)%Z && (v <=? u)%Z = true

    TODO: to be completed !
 *)
Inductive well_typed_stack: symboltable_x -> STACK.stack -> Prop :=
  | WTS: forall st s,
      well_typed_stack st s. 

(** for any variable in stack, its value should be in the domain of its type 
    
    TODO: to be proved !
*)
Axiom variable_value_in_type_domain: forall st s x_ast_num x v t l u,
  well_typed_stack st s ->
    eval_name_x st s (E_Identifier_X x_ast_num x nil) (Normal (BasicV (Int v))) ->
      fetch_exp_type_x x_ast_num st = Some t ->
        valueO_of_type st t (IntBetween l u) ->
          (Zge_bool v l) && (Zle_bool v u) = true.

End Well_Typed_Stack_Sec.





(** * Well-Check_Flagged *)
Section Well_Check_Flagged_Sec.

(** the well-formedness of run-time check flagged expressions that 
    are generated by expression check generator;
 *)
Inductive well_check_flagged_expr: expression_x -> Prop :=
  | WCF_Literal: forall ast_num l,
      well_check_flagged_expr (E_Literal_X ast_num l nil)
  | WCF_Name: forall ast_num n,
      well_check_flagged_name n ->
      well_check_flagged_expr (E_Name_X ast_num n nil)
  | WCF_Binary_Operation_Overflow: forall op e1 e2 ast_num,
      op = Plus \/ op = Minus \/ op = Multiply ->
      well_check_flagged_expr e1 ->
      well_check_flagged_expr e2 ->
      well_check_flagged_expr (E_Binary_Operation_X ast_num op e1 e2 (Do_Overflow_Check :: nil))
  | WCF_Binary_Operation_Division: forall e1 e2 ast_num,
      well_check_flagged_expr e1 ->
      well_check_flagged_expr e2 ->
      well_check_flagged_expr (E_Binary_Operation_X ast_num Divide e1 e2 (Do_Division_Check :: Do_Overflow_Check :: nil))
  | WCF_Binary_Operation_Others: forall op e1 e2 ast_num,
      op <> Plus /\ op <> Minus /\ op <> Multiply /\ op <> Divide ->
      well_check_flagged_expr e1 ->
      well_check_flagged_expr e2 ->
      well_check_flagged_expr (E_Binary_Operation_X ast_num op e1 e2 nil)
  | WCF_Unary_Operation_Overflow: forall e ast_num,
      well_check_flagged_expr e ->
      well_check_flagged_expr (E_Unary_Operation_X ast_num Unary_Minus e (Do_Overflow_Check :: nil))
  | WCF_Unary_Operation_Others: forall op e ast_num,
      op <> Unary_Minus ->
      well_check_flagged_expr e ->
      well_check_flagged_expr (E_Unary_Operation_X ast_num op e nil)

with well_check_flagged_name: name_x -> Prop :=
  | WCF_Identifier: forall ast_num x,
      well_check_flagged_name (E_Identifier_X ast_num x nil)
  | WCF_Indexed_Component: forall e cks1 cks2 ast_num x_ast_num x,
      exp_check_flags e = cks1 ++ Do_Range_Check :: cks2 ->
      well_check_flagged_expr (update_exp_check_flags e (cks1 ++ cks2)) ->
      well_check_flagged_name (E_Indexed_Component_X ast_num x_ast_num x e nil)
  | WCF_Selected_Component: forall ast_num x_ast_num x f,
      well_check_flagged_name (E_Selected_Component_X ast_num x_ast_num x f nil).

End Well_Check_Flagged_Sec.




(** * ZArith Help Lemmas *)
Section ZArith_Help_Lemmas.

(** In run time check semantics, Zge_bool and Zle_bool is used to define overflow check,
    and in eval_expr_value_in_domain, <= and >= are used, the following lemmas are used
    to build their relationships;
*)
Lemma le_neg_ge: forall x y,  
  (x <= y)%Z ->
    (-y <= -x)%Z.
Proof.
  admit.
  (* Infix "?=" := Pcompare: http://coq.inria.fr/V8.1/stdlib/Coq.NArith.BinPos.html
  functional induction Pcompare.
  *)
  
  (*
  intros.  
  induction x;
  intros; smack.
  
  destruct y; smack.
  unfold Zle in *. smack.
  apply H.
  unfold CompOpp in H0.
  remember (p0 ?= p)%positive as x.
  destruct x; smack.
  symmetry in Heqx.
  *)
Qed.


Lemma Zgele_Bool_Imp_GeLe_T: forall v l u,
  (Zge_bool v l) && (Zle_bool v u) = true ->
    (l <= v)%Z /\ (v <= u)%Z.
Proof.
  intros.
  specialize (andb_prop _ _ H); clear H; intros HZ.
  destruct HZ as [HZ1 HZ2].
  split.
- specialize (Zge_cases v l); intros HZ.
  rewrite HZ1 in HZ; smack.
- apply Zle_bool_imp_le; auto.  
Qed.

Lemma Zgele_Bool_Imp_GeLe_F: forall v l u,
  (Zge_bool v l) && (Zle_bool v u) = false ->
    (v < l)%Z \/ (u < v)%Z.
Proof.
  intros.
  unfold andb in H.
  remember (Zge_bool v l) as b1; 
  remember (Zle_bool v u) as b2.
  symmetry in Heqb1, Heqb2.
  destruct b1, b2; inversion H.
- specialize (Zle_cases v u); intros HZ;
  rewrite Heqb2 in HZ; smack.
- specialize (Zge_cases v l); intros HZ;
  rewrite Heqb1 in HZ; smack.
- specialize (Zge_cases v l); intros HZ;
  rewrite Heqb1 in HZ; smack.  
Qed.
  
End ZArith_Help_Lemmas.




(** TODO: move to file: checks_generator.v *)
(** * Help Lemmas for Run-Time Check Generator *)
Section Checks_Generator_Help_Lemmas.

Lemma context_check_flags_in: forall st cks e e',
  compile2_flagged_exp st cks e e' ->
    exists cks', 
      exp_check_flags e' = cks' ++ cks /\ 
      compile2_flagged_exp st nil e (update_exp_check_flags e' (cks' ++ nil)).
Proof.
  intros;
  inversion H; smack;
  match goal with
  | [|- exists cks', ?cks = cks' ++ ?cks /\ _] => exists (@nil check_flag); smack
  | [|- exists cks', ?ck :: ?cks = cks' ++ ?cks /\ _] => exists (ck :: nil); smack
  | [|- exists cks', ?ck1 :: ?ck2 :: ?cks = cks' ++ ?cks /\ _] => exists (ck1 :: ck2 :: nil); smack (*Division*)
  | _ => idtac
  end;
  match goal with
  | [|- compile2_flagged_exp _ _ _ _ ] => constructor; smack
  | _ => idtac
  end.
- (* Name *)
  match goal with
  | [H: compile2_flagged_name _ _ _ _ |- _] => inversion H; smack
  end;
  match goal with
  | [|- exists cks', ?cks = cks' ++ ?cks /\ _ ] => exists (@nil check_flag); smack
  end;
  repeat progress constructor; smack.
Qed.

Lemma context_check_flag_in: forall st ck e e',
  compile2_flagged_exp st (ck :: nil) e e' ->
    List.In ck (exp_check_flags e').
Proof.
  intros;
  inversion H; smack.
- (* Name *)
  match goal with
  | [H: compile2_flagged_name _ _ _ _ |- _] => inversion H; smack
  end.  
Qed.

End Checks_Generator_Help_Lemmas.






(** * Help Lemmas for Checks Optimizations *)
Section Checks_Optimization_Help_Lemmas.

Lemma well_check_flagged_generated_expr: forall e st e',
  compile2_flagged_exp st nil e e' ->
    well_check_flagged_expr e'.
Proof.
  apply (expression_ind
    (fun e: expression => 
       forall (st : symboltable) (e' : expression_x),
      compile2_flagged_exp st nil e e' ->
      well_check_flagged_expr e')
    (fun n: name => 
       forall (st : symboltable) (n' : name_x),
      compile2_flagged_name st nil n n' ->
      well_check_flagged_name n')
    ); intros;
  match goal with
  | [H: compile2_flagged_exp _ _ _ _ |- _] => inversion H; subst; constructor; smack
  | _ => idtac
  end;
  match goal with
  | [H: compile2_flagged_name _ _ _ _ |- _] => inversion H; subst
  end;
  try constructor.
  specialize (context_check_flags_in _ _ _ _ H8); intros HZ.
  destruct HZ as [cks HZ1].
  apply WCF_Indexed_Component with (cks1:=cks) (cks2:=nil); smack.
Qed.

Lemma well_check_flagged_generated_name: forall n n' st,
  compile2_flagged_name st nil n n' ->
    well_check_flagged_name n'.
Proof.
  intros.
  match goal with
  | [H: compile2_flagged_name _ _ _ _ |- _] => inversion H; subst
  end; 
  try constructor.
  specialize (context_check_flags_in _ _ _ _ H0); intros HZ.
  destruct HZ as [cks [HZ1 HZ2]].
  apply WCF_Indexed_Component with (cks1 := cks) (cks2:=nil); auto.
  apply well_check_flagged_generated_expr with (e:=e) (st:=st); auto.  
Qed.




(* /////////////////////////////////////////////////////// *)

Lemma remove_check_flag_unique: forall ck cks cks' cks'',
  remove_check_flag ck cks cks'  ->
    remove_check_flag ck cks cks'' ->
      cks' = cks''.
Proof.
  intros ck cks; revert ck;
  induction cks; smack.
- inversion H; inversion H0; auto.
- inversion H; inversion H0; smack.  
  specialize (IHcks _ _ _ H6 H12); smack.
Qed.


Lemma removed_check_flag_notin: forall ck cks cks',
 remove_check_flag ck cks cks' ->
   ~(List.In ck cks').
Proof.
  intros.
  induction H; smack.
  destruct ck; inversion H.  
Qed.

Lemma remove_notin_check_flag: forall ck cks,
  ~(List.In ck cks) ->
    remove_check_flag ck cks cks.
Proof.
  intros.
  induction cks.
  constructor.
  destruct a; destruct ck; smack;
  apply R_Check_Flag_Tail; smack.
Qed.

Lemma remove_a_unique_check: forall cks cks1 ck cks2,
  cks = cks1 ++ ck :: cks2 ->
    ~(List.In ck (cks1 ++ cks2)) ->
      remove_check_flag ck cks (cks1 ++ cks2).
Proof.
  intros cks cks1; revert cks.  
  induction cks1; smack.
  constructor. 
  unfold beq_check_flag; destruct ck; auto.
  specialize (remove_notin_check_flag _ _ H0); auto.
  apply R_Check_Flag_Tail; smack.
  unfold beq_check_flag; destruct ck, a; smack.
Qed.

Lemma list_components_equal: forall ls1 (e: check_flag) ls2 ls1' ls2',
  ls1 ++ e :: ls2 = ls1' ++ e :: ls2' ->
  ~(List.In e (ls1 ++ ls2)) ->
  ls1 = ls1' /\ ls2 = ls2'.
Proof.
  intro ls1; induction ls1; intros.
- destruct ls1'. 
  + smack.
  + simpl in H. inversion H; subst; smack.
- destruct ls1'.
  + simpl in H; inversion H; subst; smack.
  + inversion H; subst.
    specialize (IHls1 _ _ _ _ H3).
    unfold List.In in H0; smack.
Qed.

Lemma remove_split: forall ck cks1 cks2 cks,
  remove_check_flag ck (cks1 ++ cks2) cks ->
  exists cks1' cks2',
    remove_check_flag ck cks1 cks1' /\ 
    remove_check_flag ck cks2 cks2' /\
    cks = cks1' ++ cks2'.
Proof.
  intros ck cks1; revert ck;
  induction cks1; smack.
- exists (@nil check_flag) cks; smack.
  constructor.
- inversion H; smack;
  specialize (IHcks1 _ _ _ H5); smack.
  + exists x x0; smack.
    apply R_Check_Flag_Head; auto.
  + exists (a :: x) x0; smack.
    apply R_Check_Flag_Tail; auto.
Qed.

Lemma remove_merge: forall ck cks1 cks1' cks2 cks2',
  remove_check_flag ck cks1 cks1' ->
    remove_check_flag ck cks2 cks2' ->
      remove_check_flag ck (cks1 ++ cks2) (cks1' ++ cks2').
Proof.
  intros ck cks1; revert ck;
  induction cks1; smack.
- inversion H; smack.
- inversion H; smack.
  apply R_Check_Flag_Head; auto.
  apply R_Check_Flag_Tail; auto.
Qed.

Lemma notin_reserved_by_remove: forall ck cks ck' cks',
  ~(List.In ck cks) ->
    remove_check_flag ck' cks cks' ->
      ~(List.In ck cks').
Proof.
  intros ck cks; revert ck; 
  induction cks; smack.
- inversion H0; smack.
- inversion H0; smack.
Qed.

Lemma check_flag_notin_split: forall (ck: check_flag) cks1 cks2,
  ~(List.In ck (cks1 ++ cks2)) ->
    ~(List.In ck cks1) /\ ~(List.In ck cks2).
Proof.
  intros ck cks1; revert ck;
  induction cks1; smack.
Qed.

Lemma check_flag_notin_merge: forall (ck: check_flag) cks1 cks2,
  ~(List.In ck cks1) ->
    ~(List.In ck cks2) ->
      ~(List.In ck (cks1 ++ cks2)).
Proof.
  intros ck cks1; revert ck;
  induction cks1; smack.
Qed.


(* /////////////////////////////////////////////////////// *)


(** for an expression updated with some new check flags, its resulting check flags should
    be the newly updated check flags;
 *)

Lemma update_exp_with_new_check_flags: forall e newCheckFlags, 
  exp_check_flags (update_exp_check_flags e newCheckFlags) = newCheckFlags.
Proof.
  intros.
  destruct e; auto.
  destruct n; auto.
Qed.

Lemma update_exp_with_same_check_flags: forall e, 
  update_exp_check_flags e (exp_check_flags e) = e.
Proof.
  intros.
  destruct e; auto.
  destruct n; auto.
Qed.

(** for a stand alone expression, which does not appear in any context such 
    as index of array, then it should have no Do_Range_Check flag;
*)
Lemma range_check_not_in_expr: forall e,
  well_check_flagged_expr e ->
    ~(List.In Do_Range_Check (exp_check_flags e)).
Proof.
  intros;
  destruct e; smack;
  match goal with
  | [H: well_check_flagged_expr _ |- _] => inversion H; clear H; smack
  end;
  match goal with
  | [H: well_check_flagged_name _ |- _] => inversion H; clear H; smack
  end.
Qed.

(* TODO: this can be removed and replaced by lemma: remove_notin_check_flag *)
Lemma rm_range_check_return_same_expr_checks: forall e,
  well_check_flagged_expr e ->
    remove_check_flag Do_Range_Check (exp_check_flags e) (exp_check_flags e).
Proof.
  intros.
  specialize (range_check_not_in_expr _ H); smack.
  apply remove_notin_check_flag; auto.
Qed.



(* TODO: this can be removed and replace with lemma: remove_a_unique_check  *)
(** if e is a run-time-check-annotated expression generated by our formalized 
    run-time check generator, then it should have at most one Do_Range_Check if
    there exists Do_Range_Check in expression e;
 *)
Lemma remove_range_check_property: forall e cks1 cks2,
  exp_check_flags e = cks1 ++ Do_Range_Check :: cks2 ->
    well_check_flagged_expr (update_exp_check_flags e (cks1 ++ cks2)) ->
      remove_check_flag Do_Range_Check (exp_check_flags e) (cks1 ++ cks2).
Proof.
  intros.
  specialize (range_check_not_in_expr _ H0); intro HZ.
  rewrite update_exp_with_new_check_flags in HZ.
  specialize (remove_a_unique_check _ _ _ _ H HZ); auto.
Qed.

(*
Lemma optimize_expression_exists: forall e st, 
  exists v' e', optimize_expression_x st e (v', e').
Proof.
  apply (expression_x_ind
    (fun e: expression_x => forall (st : symboltable_x),
      exists v' e', optimize_expression_x st e (v', e'))
    (fun n: name_x => forall (st : symboltable_x),
      exists v' n', optimize_name_x st n (v', n'))
    ); intros.
- exists (eval_literalO l) (E_Literal_X a l c);
  constructor; auto.
- specialize (H st); smack.
  exists x (E_Name_X a x0 c);
  constructor; auto.
- specialize (H st); specialize (H0 st); smack.
  remember b as op.
  destruct b;
  match goal with
  | [H: op = Plus |- _] => idtac
  | [H: op = Minus |- _] => idtac
  | [H: op = Multiply |- _] => idtac
  | [H: op = Divide |- _] => idtac
  | _ => 
      exists BoolValue (E_Binary_Operation_X a op x2 x0 c); constructor; auto
  end;
  admit.
- admit.
- admit.
- admit.
- admit.
Qed.
*)

Lemma optimize_expression_reserve_range_check: forall e cks1 cks2 st v' e',
  exp_check_flags e = cks1 ++ Do_Range_Check :: cks2 ->
    optimize_expression_x st e (v', e') ->
      exists cks1' cks2',
      exp_check_flags e' = cks1' ++ Do_Range_Check :: cks2'.
Proof.
  intros e cks1; revert e;
  induction cks1; smack.
- match goal with
  | [H: optimize_expression_x _ _ _ |- _] => inversion H; subst; auto
  end;
  simpl in *; subst; exists (@nil check_flag);
  match goal with
  | [H: remove_check_flag _ _ _ |- _] => inversion H; smack
  | _ => idtac
  end; smack.
  match goal with
  | [H: optimize_name_x _ _ _ |- _] => inversion H; subst; simpl in *
  end; smack.
- match goal with
  | [H: optimize_expression_x _ _ _ |- _] => inversion H; subst; auto
  end;
  simpl in *; subst;
  match goal with
  | [|- exists cks1' cks2', ?x :: ?cks1 ++ ?ck :: ?cks2 = cks1' ++ ?ck :: cks2'] => exists (x :: cks1) cks2; auto
  | _ => idtac
  end.
  + (* name *)
    match goal with
    | [H: optimize_name_x _ _ _ |- _] => inversion H; subst; simpl in *; subst
    end;
    match goal with
    | [|- exists cks1' cks2', ?x :: ?cks1 ++ ?ck :: ?cks2 = cks1' ++ ?ck :: cks2'] => exists (x :: cks1) cks2; auto
    | _ => idtac
    end.
  + (* Plus *)  
    match goal with
    | [H: remove_check_flag _ ?cks _ |- _] => inversion H; subst
    end;
    match goal with
    | [H: remove_check_flag _ ?cks _ |- _] => specialize (remove_split _ _ _ _ H); smack
    end;
    match goal with
    | [H: remove_check_flag Do_Overflow_Check (Do_Range_Check :: ?cks) _ |- _] => inversion H; smack
    end;
    match goal with
    | [|- exists cks1' cks2', ?x :: ?cks1 ++ ?ck :: ?cks2 = cks1' ++ ?ck :: cks2'] => exists (x :: cks1) cks2; auto
    end.
  + (* Minus *)
    match goal with
    | [H: remove_check_flag _ ?cks _ |- _] => inversion H; subst
    end;
    match goal with
    | [H: remove_check_flag _ ?cks _ |- _] => specialize (remove_split _ _ _ _ H); smack
    end;
    match goal with
    | [H: remove_check_flag Do_Overflow_Check (Do_Range_Check :: ?cks) _ |- _] => inversion H; smack
    end;
    match goal with
    | [|- exists cks1' cks2', ?x :: ?cks1 ++ ?ck :: ?cks2 = cks1' ++ ?ck :: cks2'] => exists (x :: cks1) cks2; auto
    end.
  + (* Unary_Minus *)
    match goal with
    | [H: remove_check_flag _ ?cks _ |- _] => inversion H; subst
    end;
    match goal with
    | [H: remove_check_flag _ ?cks _ |- _] => specialize (remove_split _ _ _ _ H); smack
    end;
    match goal with
    | [H: remove_check_flag Do_Overflow_Check (Do_Range_Check :: ?cks) _ |- _] => inversion H; smack
    end;
    match goal with
    | [|- exists cks1' cks2', ?x :: ?cks1 ++ ?ck :: ?cks2 = cks1' ++ ?ck :: cks2'] => exists (x :: cks1) cks2; auto
    end.
Qed.

Lemma optimize_expression_range_check_notin: forall e cks1 cks2 st v' e' cks1' cks2',
  exp_check_flags e = cks1 ++ Do_Range_Check :: cks2 ->
    optimize_expression_x st e (v', e') ->
      exp_check_flags e' = cks1' ++ Do_Range_Check :: cks2' ->
        ~(List.In Do_Range_Check (cks1 ++ cks2)) ->
          ~(List.In Do_Range_Check (cks1' ++ cks2')).
Proof.
  intros.
  inversion H0; subst;
  repeat progress match goal with
  | [H: exp_check_flags _ = _ |- _] => simpl in H
  end;
  match goal with
  | [H1: ?x = _, H2: ?x = _ |- _] => rewrite H1 in H2; auto
  | _ => idtac
  end;
  match goal with
  | [H0: optimize_expression_x _ (_ _ _ ?ck) (_, (_ _ _ ?ck)),
     H1: ?ls1 ++ ?e :: ?ls2 = ?ls1' ++ ?e :: ?ls2',
     H2: ~(List.In ?e (?ls1 ++ ?ls2)) |- _ ] => 
      specialize (list_components_equal _ _ _ _ _ H1 H2); smack
  | [H0: optimize_expression_x _ (_ _ _ ?ck) (_, (_ _ _ ?ck)),
     H1: ?ls1' ++ ?e :: ?ls2' = ?ls1 ++ ?e :: ?ls2,
     H2: ~(List.In ?e (?ls1 ++ ?ls2)) |- _ ] => 
      symmetry in H1; specialize (list_components_equal _ _ _ _ _ H1 H2); smack
  | _ => idtac
  end.
- (* name *)
  inversion H0; subst.
  destruct n; inversion H5; subst;
  repeat progress match goal with
  | [H: name_check_flags _ = _ |- _] => simpl in H
  end;
  match goal with
  | [H1: ?x = _, H2: ?x = _ |- _] => rewrite H1 in H2; auto
  | _ => idtac
  end;
  match goal with
  | [H1: ?ls1 ++ ?e :: ?ls2 = ?ls1' ++ ?e :: ?ls2',
     H2: ~(List.In ?e (?ls1 ++ ?ls2)) |- _ ] => 
      specialize (list_components_equal _ _ _ _ _ H1 H2); smack
  | [H1: ?ls1' ++ ?e :: ?ls2' = ?ls1 ++ ?e :: ?ls2,
     H2: ~(List.In ?e (?ls1 ++ ?ls2)) |- _ ] => 
      symmetry in H1; specialize (list_components_equal _ _ _ _ _ H1 H2); smack
  | _ => idtac
  end.
- (* Plus *)
  match goal with
  | [H1: remove_check_flag _ ?cks _, 
     H2: ?cks = _ |- _] => rewrite H2 in H1; specialize (remove_split _ _ _ _ H1); smack
  end;
  inversion H; smack;
  match goal with
  | [H: List.In _ (?ls1 ++ ?ls2) -> False |- _] => 
      specialize (check_flag_notin_split _ _ _ H); smack
  end;
  repeat progress match goal with
  | [H1: List.In _ ?ls -> False,
     H2: remove_check_flag _ ?ls _ |- _] =>
      specialize (notin_reserved_by_remove _ _ _ _ H1 H2); clear H1; smack
  end.
  specialize (check_flag_notin_merge _ _ _ H9 H3); intros HZ.
  symmetry in H8;
  specialize (list_components_equal _ _ _ _ _ H8 HZ); smack.
- (* Minus *)
  match goal with
  | [H1: remove_check_flag _ ?cks _, 
     H2: ?cks = _ |- _] => rewrite H2 in H1; specialize (remove_split _ _ _ _ H1); smack
  end.
  inversion H; smack.
  match goal with
  | [H: List.In _ (?ls1 ++ ?ls2) -> False |- _] => 
      specialize (check_flag_notin_split _ _ _ H); smack
  end.
  repeat progress match goal with
  | [H1: List.In _ ?ls -> False,
     H2: remove_check_flag _ ?ls _ |- _] =>
      specialize (notin_reserved_by_remove _ _ _ _ H1 H2); clear H1; smack
  end.
  specialize (check_flag_notin_merge _ _ _ H9 H3); intros HZ.
  symmetry in H8;
  specialize (list_components_equal _ _ _ _ _ H8 HZ); smack.
- (* Unary_Minus *)
  match goal with
  | [H1: remove_check_flag _ ?cks _, 
     H2: ?cks = _ |- _] => rewrite H2 in H1; specialize (remove_split _ _ _ _ H1); smack
  end.
  inversion H; smack.
  match goal with
  | [H: List.In _ (?ls1 ++ ?ls2) -> False |- _] => 
      specialize (check_flag_notin_split _ _ _ H); smack
  end.
  repeat progress match goal with
  | [H1: List.In _ ?ls -> False,
     H2: remove_check_flag _ ?ls _ |- _] =>
      specialize (notin_reserved_by_remove _ _ _ _ H1 H2); clear H1; smack
  end.
  specialize (check_flag_notin_merge _ _ _ H7 H3); intros HZ.
  symmetry in H6;
  specialize (list_components_equal _ _ _ _ _ H6 HZ); smack.
Qed.


(** The way to first remove Do_Range_Check from the expression, 
    and then do other checks optimization, its resulting expression should 
    be the same as the expression optimized in the reverse way: that's, first
    optimize the expression, then remove its Do_Range_Check;
*)

Lemma optimize_expr_to_same_checkflags: forall st e l u e' checkflags checkflags' cks1 cks2,
  optimize_expression_x st e (IntBetween l u, e') ->
    remove_check_flag Do_Range_Check (exp_check_flags e') checkflags ->
      remove_check_flag Do_Range_Check (exp_check_flags e) checkflags' ->
        (* two additional property for expression e *)
        exp_check_flags e = cks1 ++ Do_Range_Check :: cks2 ->
          well_check_flagged_expr (update_exp_check_flags e (cks1 ++ cks2)) ->
            optimize_expression_x st (update_exp_check_flags e checkflags') 
                                     (IntBetween l u, (update_exp_check_flags e' checkflags)).
Proof.
  intros.
  match goal with
  | [H1: exp_check_flags ?e = _,
     H2: optimize_expression_x _ ?e _ |- _] => 
      specialize (optimize_expression_reserve_range_check _ _ _ _ _ _ H1 H2);
      intros HZ; destruct HZ as [ cks1' [cks2' HE]]
  end.
  match goal with
  | [H: well_check_flagged_expr ?e |- _] => specialize (range_check_not_in_expr _ H); intros HZ1
  end.
  rewrite update_exp_with_new_check_flags in HZ1.  
  match goal with
  | [H1: exp_check_flags ?e = _,
     H2: optimize_expression_x _ ?e (_, ?e'), 
     H3: exp_check_flags ?e' = _, 
     H4: ~(List.In _ _) |- _] => 
      specialize (optimize_expression_range_check_notin _ _ _ _ _ _ _ _ H1 H2 H3 H4); intros HZ2
  end.
  specialize (remove_a_unique_check _ _ _ _ H2 HZ1); intros HZ3.
  specialize (remove_a_unique_check _ _ _ _ HE HZ2); intros HZ4.
  specialize (remove_check_flag_unique _ _ _ _ H0 HZ4); intros HZ5.
  specialize (remove_check_flag_unique _ _ _ _ H1 HZ3); intros HZ6; subst.
  
  inversion H; smack;
  match goal with
  | [H1: ?ls1 ++ ?e :: ?ls2 = ?ls1' ++ ?e :: ?ls2',
     H2: List.In ?e (?ls1 ++ ?ls2) -> False |- _] => specialize (list_components_equal _ _ _ _ _ H1 H2); smack
  | _ => idtac
  end. 
- (* Literal *)
  constructor; auto.
- (* Name *)
  constructor; auto.
  inversion H7; subst;
  repeat progress match goal with
  | [H: name_check_flags _ = _ |- _] => simpl in H; subst
  end;
  match goal with
  | [H1: ?ls1 ++ ?e :: ?ls2 = ?ls1' ++ ?e :: ?ls2',
     H2: List.In ?e (?ls1 ++ ?ls2) -> False |- _] => specialize (list_components_equal _ _ _ _ _ H1 H2); smack
  end.
  apply O_Identifier_X with (t:=t); auto.
  apply O_Indexed_Component_Range_Pass_X with (l:=l0) (u:=u0) (e':=e') (t:=t) (l':=l') 
                                               (u':=u') (checkflags':=checkflags'); auto.
  apply O_Indexed_Component_Range_Fail_X with (l:=l0) (u:=u0) (e':=e') (t:=t) (l':=l') (u':=u'); auto.
  apply O_Indexed_Component_Range_Fail_X with (l:=l0) (u:=u0) (e':=e') (t:=t) (l':=l') (u':=u'); auto.
  apply O_Selected_Component_X with (t:=t); auto.
- (* Binary Operation Plus - overflow check pass *)
  apply O_Binary_Plus_Operation_Overflow_Pass_X; auto.
  specialize (remove_split _ _ _ _ H13); intros HZ;
  destruct HZ as [cks1'0 [cks2'0 HZ5]]. destruct HZ5 as [HZ5 [HZ6 HZ7]].
  inversion HZ6; smack.
  match goal with
  | [H1: ?ls1 ++ ?e :: ?ls2 = ?ls1' ++ ?e :: ?ls2',
     H2: List.In ?e (?ls1 ++ ?ls2) -> False |- _] => specialize (list_components_equal _ _ _ _ _ H1 H2); smack
  end.
  apply remove_merge; auto.
- (* Binary Operation Plus - overflow check fail *)
  apply O_Binary_Plus_Operation_Overflow_Fail_X with (l1:=l1) (u1:=u1) (l2:=l2) (u2:=u2); auto.
- (* Binary Operation Plus - overflow check fail *)
  apply O_Binary_Plus_Operation_Overflow_Fail_X with (l1:=l1) (u1:=u1) (l2:=l2) (u2:=u2); auto.
- (* Binary Operation Minus - overflow check pass *)
  apply O_Binary_Minus_Operation_Overflow_Pass_X; auto.
  specialize (remove_split _ _ _ _ H13); intros HZ;
  destruct HZ as [cks1'0 [cks2'0 HZ5]]. destruct HZ5 as [HZ5 [HZ6 HZ7]].
  inversion HZ6; smack.
  match goal with
  | [H1: ?ls1 ++ ?e :: ?ls2 = ?ls1' ++ ?e :: ?ls2',
     H2: List.In ?e (?ls1 ++ ?ls2) -> False |- _] => specialize (list_components_equal _ _ _ _ _ H1 H2); smack
  end.
  apply remove_merge; auto.
- (* Binary Operation Minus - overflow check fail *)
  apply O_Binary_Minus_Operation_Overflow_Fail_X with (l1:=l1) (u1:=u1) (l2:=l2) (u2:=u2); auto.
- (* Binary Operation Minus - overflow check fail *)
  apply O_Binary_Minus_Operation_Overflow_Fail_X with (l1:=l1) (u1:=u1) (l2:=l2) (u2:=u2); auto.
- (* Binary Operation Multiply *)
  apply O_Binary_Multiplying_Operation_X with (l1:=l1) (u1:=u1) (l2:=l2) (u2:=u2); auto.
- (* Binary Operation Divide *)
  apply O_Binary_Multiplying_Operation_X with (l1:=l1) (u1:=u1) (l2:=l2) (u2:=u2); auto.
- (* Unary Operation Minus - overflow check pass *)
  apply O_Unary_Minus_Operation_X with (l:=l0) (u:=u0); auto.
  specialize (remove_split _ _ _ _ H14); intros HZ;
  destruct HZ as [cks1'0 [cks2'0 HZ5]]. destruct HZ5 as [HZ5 [HZ6 HZ7]].
  inversion HZ6; smack.
  match goal with
  | [H1: ?ls1 ++ ?e :: ?ls2 = ?ls1' ++ ?e :: ?ls2',
     H2: List.In ?e (?ls1 ++ ?ls2) -> False |- _] => specialize (list_components_equal _ _ _ _ _ H1 H2); smack
  end.
  apply remove_merge; auto.
- (* Unary Operation Minus - overflow check fail *)
  apply O_Unary_Minus_Operation_Overflow_X with (l:=l0) (u:=u0) (l':=(Z.opp u0)) (u':=(Z.opp l0)); auto.
- (* Unary Operation Minus - overflow check fail *)
  apply O_Unary_Minus_Operation_Overflow_X with (l:=l0) (u:=u0) (l':=(Z.opp u0)) (u':=(Z.opp l0)); auto.
- (* Unary Operation Plus *)
  apply O_Unary_Plus_Operation_X; auto.
Qed.


Lemma extract_array_index_range_x_unique: forall st a l u l' u',
  extract_array_index_range_x st a (Range_X l u) ->
  extract_array_index_range_x st a (Range_X l' u') ->
  l = l' /\ u = u'.
Proof.
  intros.
  inversion H; inversion H0; subst.
  repeat progress match goal with
  | [H1: ?x = _, 
     H2: ?x = _ |- _] => rewrite H1 in H2; clear H1; inversion H2; subst
  end; auto.
Qed.


(* ~ ~ ~ 2014.08.15 ~ ~ ~

Lemma eval_expr_value_in_domain: forall e e' checkflags st s v l u,
  well_typed_stack st s ->
    remove_check_flag Do_Range_Check (exp_check_flags e) checkflags ->
      well_check_flagged_expr (update_exp_check_flags e checkflags) ->
        eval_expr_x st s (update_exp_check_flags e checkflags) (Normal (BasicV (Int v))) ->
          optimize_expression_x st (update_exp_check_flags e checkflags) (IntBetween l u, e') ->
            (Zge_bool v l) && (Zle_bool v u) = true.
Proof.
  apply (expression_x_ind
    (fun e: expression_x => 
       forall (e' : expression_x) (checkflags : check_flags) (st : symboltable_x) (s : STACK.stack) 
              (v l u : Z),
      well_typed_stack st s ->
      remove_check_flag Do_Range_Check (exp_check_flags e) checkflags ->
      well_check_flagged_expr (update_exp_check_flags e checkflags) ->
      eval_expr_x st s (update_exp_check_flags e checkflags) (Normal (BasicV (Int v))) ->
      optimize_expression_x st (update_exp_check_flags e checkflags) (IntBetween l u, e') ->
      (Zge_bool v l) && (Zle_bool v u) = true)
    (fun n: name_x => 
       forall (n' : name_x) (checkflags : check_flags) (st : symboltable_x) (s : STACK.stack) 
              (v l u : Z),
      well_typed_stack st s ->
      remove_check_flag Do_Range_Check (name_check_flags n) checkflags ->
      well_check_flagged_name (update_name_check_flags n checkflags) ->
      eval_name_x st s (update_name_check_flags n checkflags) (Normal (BasicV (Int v))) ->
      optimize_name_x st (update_name_check_flags n checkflags) (IntBetween l u, n') ->
      (Zge_bool v l) && (Zle_bool v u) = true)
    ); intros.
- (*Literal*)
  match goal with
  | [H: optimize_expression_x ?st ?e ?e' |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end. 
  repeat progress match goal with
  | [H: eval_literalO _ = _ |- _] => unfold eval_literalO in H
  | [H: eval_literal _ = _ |- _] => unfold eval_literal in H
  end.
  destruct l; inversion H6; inversion H7; subst.
  admit.
- (* Name *)
  match goal with
  | [H: optimize_expression_x ?st ?e ?e' |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H: well_check_flagged_expr _ |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H: remove_check_flag _ (exp_check_flags (E_Name_X _ _ _)) _ |- _] => simpl in H
  end.
  match goal with
  | [H1: forall (n' : name_x) (checkflags : check_flags) (st : symboltable_x) 
                (s : STACK.stack) (v l u : Z),
      well_typed_stack _ _ ->
      remove_check_flag Do_Range_Check (name_check_flags ?n) _ ->
      well_check_flagged_name (update_name_check_flags ?n _) ->
      eval_name_x _ _ (update_name_check_flags ?n _) _ ->
      optimize_name_x _ (update_name_check_flags ?n _) _ -> _ ,
     H2: well_typed_stack _ _,
     H3: remove_check_flag Do_Range_Check (name_check_flags ?n) _,
     H4: well_check_flagged_name (update_name_check_flags ?n _),
     H5: eval_name_x _ _ (update_name_check_flags ?n _) _,
     H6: optimize_name_x _ (update_name_check_flags ?n _) _ |- _ ] => 
      specialize (H1 _ _ _ _ _ _ _ H2 H3 H4 H5 H6); auto
  end.
- (* binary expression *)
  match goal with
  | [H: optimize_expression_x _ _ _ |- _] => inversion H; clear H; subst
  end.
  + (*1*)
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H: Val.binary_operation ?op ?v1 ?v2 = _ |- _] => 
      destruct v1, v2; inversion H; clear H;
      [ destruct v0, v1 | destruct v0 | destruct v0]; inversion H5; subst
  end.
  match goal with
  | [H: well_check_flagged_expr _ |- _] => simpl in H; inversion H; clear H; subst
  end.
  match goal with
  | [H: well_check_flagged_expr e |- _] => 
      let H1 := fresh "HZ" in 
      specialize (rm_range_check_return_same_expr_checks _ H); intros H1
  end.
  match goal with
  | [H: well_check_flagged_expr e0 |- _] => 
      let H1 := fresh "HZ" in 
      specialize (rm_range_check_return_same_expr_checks _ H); intros H1
  end.
  repeat progress match goal with
  | [H1: optimize_expression_x _ e _,
     H2: eval_expr_x _ _ e _,
     H3: well_check_flagged_expr e |- _] => 
      let HZ := fresh "HZ" in
      specialize (update_exp_with_same_check_flags e); intro HZ; rewrite <- HZ in H1, H2, H3; clear HZ
  | [H1: optimize_expression_x _ e0 _,
     H2: eval_expr_x _ _ e0 _,
     H3: well_check_flagged_expr e0 |- _] => 
      let HZ := fresh "HZ" in
      specialize (update_exp_with_same_check_flags e0); intro HZ; rewrite <- HZ in H1, H2, H3; clear HZ
  end.
  repeat progress match goal with
  | [H1: forall (e' : expression_x) (checkflags : check_flags) (st : symboltable_x) 
                (s : STACK.stack) (v l u : Z),
      well_typed_stack _ _ ->
      remove_check_flag Do_Range_Check (exp_check_flags ?e) _ ->
      well_check_flagged_expr (update_exp_check_flags ?e _) ->
      eval_expr_x _ _ (update_exp_check_flags ?e _) _ ->
      optimize_expression_x _ (update_exp_check_flags ?e _) _ -> _ ,
     H2: well_typed_stack _ _,
     H3: remove_check_flag Do_Range_Check (exp_check_flags ?e) _,
     H4: well_check_flagged_expr (update_exp_check_flags ?e _),
     H5: eval_expr_x _ _ (update_exp_check_flags ?e _) _,
     H6: optimize_expression_x _ (update_exp_check_flags ?e _) _ |- _ ] => 
      specialize (H1 _ _ _ _ _ _ _ H2 H3 H4 H5 H6); auto
  end.
  admit.
  inversion H8; smack.
  + (*2*)
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H: Val.binary_operation ?op ?v1 ?v2 = _ |- _] => 
      destruct v1, v2; inversion H; clear H;
      [ destruct v0, v1 | destruct v0 | destruct v0]; inversion H5; subst
  end.
  match goal with
  | [H: well_check_flagged_expr _ |- _] => simpl in H; inversion H; clear H; subst
  end. 
  repeat progress match goal with
  | [H: do_flagged_checks_on_binop _ ?op ?v1 ?v2 _ |- _] => inversion H; clear H; subst
  | [H: do_flagged_check_on_binop _ ?op ?v1 ?v2 _ |- _] => inversion H; clear H; subst
  | [H: do_overflow_check_on_binop ?op ?v1 ?v2 _ |- _] => inversion H; clear H; subst
  | [H: Val.binary_operation ?op ?v1 ?v2 = _ |- _] => simpl in H; inversion H; subst
  end; auto.
  inversion H8; smack.
  + (*3*)
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H: Val.binary_operation ?op ?v1 ?v2 = _ |- _] => 
      destruct v1, v2; inversion H; clear H;
      [ destruct v0, v1 | destruct v0 | destruct v0]; inversion H5; subst
  end.
  match goal with
  | [H: well_check_flagged_expr _ |- _] => simpl in H; inversion H; clear H; subst
  end.
  match goal with
  | [H: well_check_flagged_expr e |- _] => 
      let H1 := fresh "HZ" in 
      specialize (rm_range_check_return_same_expr_checks _ H); intros H1
  end.
  match goal with
  | [H: well_check_flagged_expr e0 |- _] => 
      let H1 := fresh "HZ" in 
      specialize (rm_range_check_return_same_expr_checks _ H); intros H1
  end.
  repeat progress match goal with
  | [H1: optimize_expression_x _ e _,
     H2: eval_expr_x _ _ e _,
     H3: well_check_flagged_expr e |- _] => 
      let HZ := fresh "HZ" in
      specialize (update_exp_with_same_check_flags e); intro HZ; rewrite <- HZ in H1, H2, H3; clear HZ
  | [H1: optimize_expression_x _ e0 _,
     H2: eval_expr_x _ _ e0 _,
     H3: well_check_flagged_expr e0 |- _] => 
      let HZ := fresh "HZ" in
      specialize (update_exp_with_same_check_flags e0); intro HZ; rewrite <- HZ in H1, H2, H3; clear HZ
  end.
  repeat progress match goal with
  | [H1: forall (e' : expression_x) (checkflags : check_flags) (st : symboltable_x) 
                (s : STACK.stack) (v l u : Z),
      well_typed_stack _ _ ->
      remove_check_flag Do_Range_Check (exp_check_flags ?e) _ ->
      well_check_flagged_expr (update_exp_check_flags ?e _) ->
      eval_expr_x _ _ (update_exp_check_flags ?e _) _ ->
      optimize_expression_x _ (update_exp_check_flags ?e _) _ -> _ ,
     H2: well_typed_stack _ _,
     H3: remove_check_flag Do_Range_Check (exp_check_flags ?e) _,
     H4: well_check_flagged_expr (update_exp_check_flags ?e _),
     H5: eval_expr_x _ _ (update_exp_check_flags ?e _) _,
     H6: optimize_expression_x _ (update_exp_check_flags ?e _) _ |- _ ] => 
      specialize (H1 _ _ _ _ _ _ _ H2 H3 H4 H5 H6); auto
  end.
  admit.
  inversion H8; smack.
  + (*4*)
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H: Val.binary_operation ?op ?v1 ?v2 = _ |- _] => 
      destruct v1, v2; inversion H; clear H;
      [ destruct v0, v1 | destruct v0 | destruct v0]; inversion H5; subst
  end.
  match goal with
  | [H: well_check_flagged_expr _ |- _] => simpl in H; inversion H; clear H; subst
  end.
  repeat progress match goal with
  | [H: do_flagged_checks_on_binop _ ?op ?v1 ?v2 _ |- _] => inversion H; clear H; subst
  | [H: do_flagged_check_on_binop _ ?op ?v1 ?v2 _ |- _] => inversion H; clear H; subst
  | [H: do_overflow_check_on_binop ?op ?v1 ?v2 _ |- _] => inversion H; clear H; subst
  | [H: Val.binary_operation ?op ?v1 ?v2 = _ |- _] => simpl in H; inversion H; subst
  end; auto.
  inversion H8; smack.
  + (*5. Multiply or Divide *)
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H: ?op = Multiply \/ ?op = Divide |- _] => inversion H; clear H; subst
  end.
  (* 5.1. Multiply *)
  match goal with
  | [H: Val.binary_operation ?op ?v1 ?v2 = _ |- _] => 
      destruct v1, v2; inversion H; clear H;
      [ destruct v0, v1 | destruct v0 | destruct v0]; inversion H5; subst
  end.
  match goal with
  | [H: well_check_flagged_expr _ |- _] => inversion H; subst
  end;
  repeat progress match goal with
  | [H: do_flagged_checks_on_binop _ ?op ?v1 ?v2 _ |- _] => inversion H; clear H; subst
  | [H: do_flagged_check_on_binop _ ?op ?v1 ?v2 _ |- _] => inversion H; clear H; subst
  | [H: do_overflow_check_on_binop ?op ?v1 ?v2 _ |- _] => inversion H; clear H; subst
  | [H: Val.binary_operation ?op ?v1 ?v2 = _ |- _] => simpl in H; inversion H; subst
  end; auto.
  inversion H8; smack.
  (* 5.2. Divide *)
  match goal with
  | [H: Val.binary_operation ?op ?v1 ?v2 = _ |- _] => 
      destruct v1, v2; inversion H; clear H;
      [ destruct v0, v1 | destruct v0 | destruct v0]; inversion H5; subst
  end.
  match goal with
  | [H: well_check_flagged_expr _ |- _] => inversion H; subst
  end;
  repeat progress match goal with
  | [H: do_flagged_checks_on_binop _ ?op ?v1 ?v2 _ |- _] => inversion H; clear H; subst
  | [H: do_flagged_check_on_binop _ ?op ?v1 ?v2 _ |- _] => inversion H; clear H; subst
  | [H: do_overflow_check_on_binop ?op ?v1 ?v2 _ |- _] => inversion H; clear H; subst
  | [H: Val.binary_operation ?op ?v1 ?v2 = _ |- _] => simpl in H; inversion H; subst
  end; auto.
  inversion H8; smack.
- (* unary expression *)
  match goal with
  | [H: optimize_expression_x ?st ?e ?e' |- _] => inversion H; clear H; subst
  end.
  + (*1. Unary_Minus Pass Overflow Check*)
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end.  
  match goal with
  | [H: Val.unary_operation ?op ?v1 = _ |- _] => 
      destruct v1; inversion H; clear H; subst;
      destruct v0; inversion H4;subst
  end.
  match goal with
  | [H: well_check_flagged_expr _ |- _] => simpl in H; inversion H; clear H; subst
  end;
  match goal with
  | [H: well_check_flagged_expr e |- _] => 
      let H1 := fresh "HZ" in 
      specialize (rm_range_check_return_same_expr_checks _ H); intros H1
  end;
  match goal with
  | [H1: optimize_expression_x _ e _,
     H2: eval_expr_x _ _ e _,
     H3: well_check_flagged_expr e |- _] => 
      let HZ := fresh "HZ" in
      specialize (update_exp_with_same_check_flags e); intro HZ;
      rewrite <- HZ in H1, H2, H3; clear HZ
  end;
  match goal with
  | [H1: forall (e' : expression_x) (checkflags : check_flags) (st : symboltable_x) 
                (s : STACK.stack) (v l u : Z),
      well_typed_stack _ _ ->
      remove_check_flag Do_Range_Check (exp_check_flags ?e) _ ->
      well_check_flagged_expr (update_exp_check_flags ?e _) ->
      eval_expr_x _ _ (update_exp_check_flags ?e _) _ ->
      optimize_expression_x _ (update_exp_check_flags ?e _) _ -> _ ,
     H2: well_typed_stack _ _,
     H3: remove_check_flag Do_Range_Check (exp_check_flags ?e) _,
     H4: well_check_flagged_expr (update_exp_check_flags ?e _),
     H5: eval_expr_x _ _ (update_exp_check_flags ?e _) _,
     H6: optimize_expression_x _ (update_exp_check_flags ?e _) _ |- _ ] => 
      specialize (H1 _ _ _ _ _ _ _ H2 H3 H4 H5 H6); auto
  end.
  admit.
  + (*2. Unary_Minus Fail Overflow Check *)
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H: Val.unary_operation ?op ?v1 = _ |- _] => 
      destruct v1; inversion H; clear H; subst;
      destruct v0; inversion H4;subst
  end. 
  match goal with
  | [H: well_check_flagged_expr _ |- _] => simpl in H; inversion H; clear H; subst
  end;
  repeat progress match goal with
  | [H: do_flagged_checks_on_unop _ ?op ?v _ |- _] => inversion H; clear H; subst
  | [H: do_flagged_check_on_unop _ ?op ?v _ |- _] => inversion H; clear H; subst
  | [H: do_overflow_check_on_unop ?op ?v _ |- _] => inversion H; clear H; subst
  | [H: Val.unary_operation ?op ?v = _ |- _] => simpl in H; inversion H; subst
  end; auto.
  + (*3. Unary_Plus*)
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H: Val.unary_operation ?op ?v1 = _ |- _] => 
      destruct v1; inversion H; clear H; subst;
      destruct v0; inversion H4;subst
  end.
  match goal with
  | [H: well_check_flagged_expr _ |- _] => simpl in H; inversion H; clear H; subst
  end;
  match goal with
  | [H: well_check_flagged_expr e |- _] => 
      let H1 := fresh "HZ" in 
      specialize (rm_range_check_return_same_expr_checks _ H); intros H1
  end;
  match goal with
  | [H1: optimize_expression_x _ e _,
     H2: eval_expr_x _ _ e _,
     H3: well_check_flagged_expr e |- _] => 
      let HZ := fresh "HZ" in
      specialize (update_exp_with_same_check_flags e); intro HZ; rewrite <- HZ in H1, H2, H3; clear HZ
  end;
  match goal with
  | [H1: forall (e' : expression_x) (checkflags : check_flags) (st : symboltable_x) 
                (s : STACK.stack) (v l u : Z),
      well_typed_stack _ _ ->
      remove_check_flag Do_Range_Check (exp_check_flags ?e) _ ->
      well_check_flagged_expr (update_exp_check_flags ?e _) ->
      eval_expr_x _ _ (update_exp_check_flags ?e _) _ ->
      optimize_expression_x _ (update_exp_check_flags ?e _) _ -> _ ,
     H2: well_typed_stack _ _,
     H3: remove_check_flag Do_Range_Check (exp_check_flags ?e) _,
     H4: well_check_flagged_expr (update_exp_check_flags ?e _),
     H5: eval_expr_x _ _ (update_exp_check_flags ?e _) _,
     H6: optimize_expression_x _ (update_exp_check_flags ?e _) _ |- _ ] => 
      specialize (H1 _ _ _ _ _ _ _ H2 H3 H4 H5 H6); auto
  end.
- (* identifier *)
  match goal with
  | [H: eval_name_x _ _ _ _ |- _] => inversion H; subst
  end.
  match goal with
  | [H: optimize_name_x _ _ _ |- _] => inversion H; clear H; subst
  end.
  simpl in H0, H1, H2.
  specialize (variable_value_in_type_domain _ _ _ _ _ _ _ _ H H2 H8 H13); auto.
- (* indexed component *)
  simpl in H1, H2, H3, H4.
  match goal with
  | [H: optimize_name_x _ _ _ |- _] => inversion H; clear H; subst
  end.
  + (*1*)
  match goal with
  | [H: eval_name_x _ _ _ _ |- _] => inversion H; clear H; subst
  end;
  match goal with
  | [H: well_check_flagged_name _ |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H1: ~ List.In _ ?ls,
     H2: ?ls = _ |- _] => unfold not in H1; rewrite H2 in H1; smack
  end.
  match goal with
  | [H1: exp_check_flags ?e = _,
     H2: well_check_flagged_expr (update_exp_check_flags ?e _) |- _] =>
      let HZ1 := fresh "HZ" in 
      let HZ2 := fresh "HZ" in
      specialize (remove_range_check_property _ _ _ H1 H2); intro HZ1;
      specialize (removed_check_flag_notin _ _ _ HZ1); intro HZ2
  end.
  match goal with
  | [H1: exp_check_flags ?e = ?cks1 ++ ?ck :: ?cks2, 
     H2: exp_check_flags ?e = ?cks0 ++ ?ck :: ?cks3,
     H3: ~(List.In ?ck (?cks0 ++ ?cks3)) |- _] => 
      rewrite H2 in H1; specialize (list_components_equal _ _ _ _ _ H1 H3); 
      let HZ := fresh "HZ" in intro HZ; destruct HZ; subst
  end.
  specialize (optimize_expr_to_same_checkflags _ _ _ _ _ _ _ H14 H20 HZ);
  let HZ := fresh "HZ" in intro HZ.
  match goal with
  | [H1: forall (e' : expression_x) (checkflags : check_flags) (st : symboltable_x) 
                (s : STACK.stack) (v l u : Z),
      well_typed_stack _ _ ->
      remove_check_flag Do_Range_Check (exp_check_flags ?e) _ ->
      well_check_flagged_expr (update_exp_check_flags ?e _) ->
      eval_expr_x _ _ (update_exp_check_flags ?e _) _ ->
      optimize_expression_x _ (update_exp_check_flags ?e _) _ -> _ ,
     H2: well_typed_stack _ _,
     H3: remove_check_flag Do_Range_Check (exp_check_flags ?e) _,
     H4: well_check_flagged_expr (update_exp_check_flags ?e _),
     H5: eval_expr_x _ _ (update_exp_check_flags ?e _) _,
     H6: optimize_expression_x _ (update_exp_check_flags ?e _) _ |- _ ] => 
      specialize (H1 _ _ _ _ _ _ _ H2 H3 H4 H5 H6); auto
  end.
  match goal with
  | [H1: fetch_exp_type_x ?x ?st = _,
     H2: fetch_exp_type_x ?x ?st = _ |- _] => rewrite H1 in H2; inversion H2; subst
  end.
  specialize (extract_array_index_range_x_unique _ _ _ _ _ _ H16 H22); 
  let HZ := fresh "HZ" in intro HZ; destruct HZ; subst.
  (* TODO: value of array component falls in the domain of the component type *)
  admit.  
  + (*2*)

  (* continue .... *)

  match goal with
  | [H: eval_name_x _ _ _ _ |- _] => inversion H; clear H; subst
  end;
  match goal with
  | [H: well_check_flagged_name _ |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H1: ~ List.In _ ?ls,
     H2: ?ls = _ |- _] => unfold not in H1; rewrite H2 in H1; smack
  end.
  admit.

*)


(** it's impossible to prove the following theorem directly, as we do induction 
proof on it, the proof will get stuck when e is an indexed_component, e.g. a[e]; 
the induction proof will generate a premise for e in the following theorem form,
where (eval_expr_x st s e v) is impossible to be true as e has Do_Range_Check flag, 
which is not acceptible by the semantics of eval_expr_x;

Coq.ZArith.Zorder: http://coq.inria.fr/V8.1/stdlib/Coq.ZArith.Zorder.html#Zle_ge
                   http://coq.inria.fr/V8.1/stdlib/Coq.ZArith.Zbool.html
                   http://coq.inria.fr/V8.1/stdlib/Coq.ZArith.Zbool.html#Zle_bool
*)
Lemma eval_expr_value_in_domain: forall e e' st s v l u,
  well_typed_stack st s ->
    well_check_flagged_expr e ->
      eval_expr_x st s e (Normal (BasicV (Int v))) ->
        optimize_expression_x st e (IntBetween l u, e') ->
          (l <= v)%Z /\ (v <= u)%Z.
          (* (Zge_bool v l) && (Zle_bool v u) = true. *)
Proof.
  apply (expression_x_ind
    (fun e: expression_x => 
       forall (e' : expression_x) (st : symboltable_x) (s : STACK.stack) 
              (v l u : Z),
      well_typed_stack st s ->
      well_check_flagged_expr e ->
      eval_expr_x st s e (Normal (BasicV (Int v))) ->
      optimize_expression_x st e (IntBetween l u, e') ->
      (l <= v)%Z /\ (v <= u)%Z)
    (fun n: name_x => 
       forall (n' : name_x) (st : symboltable_x) (s : STACK.stack) 
              (v l u : Z),
      well_typed_stack st s ->
      well_check_flagged_name n ->
      eval_name_x st s n (Normal (BasicV (Int v))) ->
      optimize_name_x st n (IntBetween l u, n') ->
      (l <= v)%Z /\ (v <= u)%Z)
    ); intros.
- (* Literal *)
  match goal with
  | [H: optimize_expression_x ?st ?e ?e' |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end. 
  repeat progress match goal with
  | [H: eval_literalO _ = _ |- _] => unfold eval_literalO in H
  | [H: eval_literal _ = _ |- _] => unfold eval_literal in H
  end.
  destruct l; inversion H5; inversion H6; subst.
  subst; smack.
- (* name *)
  match goal with
  | [H: optimize_expression_x ?st ?e ?e' |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H: well_check_flagged_expr _ |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H1: forall (n' : name_x) (st : symboltable_x) (s : STACK.stack) (v l u : Z),
      well_typed_stack _ _ ->
      well_check_flagged_name ?n ->
      eval_name_x _ _ ?n _ ->
      optimize_name_x _ ?n _ -> _ ,
     H2: well_typed_stack _ _,
     H3: well_check_flagged_name ?n,
     H4: eval_name_x _ _ ?n _,
     H5: optimize_name_x _ ?n _ |- _ ] => specialize (H1 _ _ _ _ _ _ H2 H3 H4 H5); auto
  end.
- (* binary expression *)
  match goal with
  | [H: optimize_expression_x ?st ?e ?e' |- _] => inversion H; clear H; subst
  end.
  + (*1*)
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H: Val.binary_operation ?op ?v1 ?v2 = _ |- _] => 
      destruct v1, v2; inversion H; clear H;
      [ destruct v0, v1 | destruct v0 | destruct v0]; inversion H4; subst
  end.
  match goal with
  | [H: well_check_flagged_expr _ |- _] => inversion H; subst
  end;
  repeat progress match goal with
  | [H1: forall (e' : expression_x) (st : symboltable_x) (s : STACK.stack) (v l u : Z),
      well_typed_stack _ _ ->
      well_check_flagged_expr ?e ->
      eval_expr_x _ _ ?e _ ->
      optimize_expression_x _ ?e _ -> _ ,
     H2: well_typed_stack _ _,
     H3: well_check_flagged_expr ?e,
     H4: eval_expr_x _ _ ?e _,
     H5: optimize_expression_x _ ?e _ |- _ ] => specialize (H1 _ _ _ _ _ _ H2 H3 H4 H5); auto
  end.
  split; apply Zplus_le_compat; smack.
  inversion H17; smack.
  + (*2*)
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H: Val.binary_operation ?op ?v1 ?v2 = _ |- _] => 
      destruct v1, v2; inversion H; clear H;
      [ destruct v0, v1 | destruct v0 | destruct v0]; inversion H4; subst
  end.
  match goal with
  | [H: well_check_flagged_expr _ |- _] => inversion H; subst
  end;
  repeat progress match goal with
  | [H1: forall (e' : expression_x) (st : symboltable_x) (s : STACK.stack) (v l u : Z),
      well_typed_stack _ _ ->
      well_check_flagged_expr ?e ->
      eval_expr_x _ _ ?e _ ->
      optimize_expression_x _ ?e _ -> _ ,
     H2: well_typed_stack _ _,
     H3: well_check_flagged_expr ?e,
     H4: eval_expr_x _ _ ?e _,
     H5: optimize_expression_x _ ?e _ |- _ ] => specialize (H1 _ _ _ _ _ _ H2 H3 H4 H5); auto
  end.
  repeat progress match goal with
  | [H: do_flagged_checks_on_binop _ ?op ?v1 ?v2 _ |- _] => inversion H; clear H; subst
  | [H: do_flagged_check_on_binop _ ?op ?v1 ?v2 _ |- _] => inversion H; clear H; subst
  | [H: do_overflow_check_on_binop ?op ?v1 ?v2 _ |- _] => inversion H; clear H; subst
  | [H: Val.binary_operation ?op ?v1 ?v2 = _ |- _] => simpl in H; inversion H; subst
  | [H: (Zge_bool ?v ?l) && (Zle_bool ?v ?u) = true |- _] => specialize (Zgele_Bool_Imp_GeLe_T _ _ _ H); auto
  end; auto.
  inversion H7; smack.
  + (*3*)
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H: Val.binary_operation ?op ?v1 ?v2 = _ |- _] => 
      destruct v1, v2; inversion H; clear H;
      [ destruct v0, v1 | destruct v0 | destruct v0]; inversion H4; subst
  end.
  match goal with
  | [H: well_check_flagged_expr _ |- _] => inversion H; subst
  end;
  repeat progress match goal with
  | [H1: forall (e' : expression_x) (st : symboltable_x) (s : STACK.stack) (v l u : Z),
      well_typed_stack _ _ ->
      well_check_flagged_expr ?e ->
      eval_expr_x _ _ ?e _ ->
      optimize_expression_x _ ?e _ -> _ ,
     H2: well_typed_stack _ _,
     H3: well_check_flagged_expr ?e,
     H4: eval_expr_x _ _ ?e _,
     H5: optimize_expression_x _ ?e _ |- _ ] => specialize (H1 _ _ _ _ _ _ H2 H3 H4 H5); auto
  end.
  (**)
  match goal with
  | [H:  (?l <= n <= ?u)%Z |- _] => destruct H as [HZ1 HZ2]
  end.
  match goal with
  | [H:  (?l <= n0 <= ?u)%Z |- _] => destruct H as [HZ3 HZ4]
  end.
  specialize (le_neg_ge _ _ HZ3); intros HZ5.
  specialize (le_neg_ge _ _ HZ4); intros HZ6.
  specialize (Zplus_le_compat _ _ _ _ HZ3 HZ6); intros HZ7.
  specialize (Zplus_le_compat _ _ _ _ HZ4 HZ5); intros HZ8. smack.
  (**)
  inversion H17; smack.
  + (*4*)
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H: Val.binary_operation ?op ?v1 ?v2 = _ |- _] => 
      destruct v1, v2; inversion H; clear H;
      [ destruct v0, v1 | destruct v0 | destruct v0]; inversion H4; subst
  end.
  match goal with
  | [H: well_check_flagged_expr _ |- _] => inversion H; subst
  end;
  repeat progress match goal with
  | [H1: forall (e' : expression_x) (st : symboltable_x) (s : STACK.stack) (v l u : Z),
      well_typed_stack _ _ ->
      well_check_flagged_expr ?e ->
      eval_expr_x _ _ ?e _ ->
      optimize_expression_x _ ?e _ -> _ ,
     H2: well_typed_stack _ _,
     H3: well_check_flagged_expr ?e,
     H4: eval_expr_x _ _ ?e _,
     H5: optimize_expression_x _ ?e _ |- _ ] => specialize (H1 _ _ _ _ _ _ H2 H3 H4 H5); auto
  end.
  repeat progress match goal with
  | [H: do_flagged_checks_on_binop _ ?op ?v1 ?v2 _ |- _] => inversion H; clear H; subst
  | [H: do_flagged_check_on_binop _ ?op ?v1 ?v2 _ |- _] => inversion H; clear H; subst
  | [H: do_overflow_check_on_binop ?op ?v1 ?v2 _ |- _] => inversion H; clear H; subst
  | [H: Val.binary_operation ?op ?v1 ?v2 = _ |- _] => simpl in H; inversion H; subst
  | [H: (Zge_bool ?v ?l) && (Zle_bool ?v ?u) = true |- _] => specialize (Zgele_Bool_Imp_GeLe_T _ _ _ H); auto
  end; auto. 
  inversion H7; smack.
  + (*5. Multiply or Divide *)
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end. 
  match goal with
  | [H: ?op = Multiply \/ ?op = Divide |- _] => inversion H; clear H; subst
  end.
  (* 5.1. Multiply *)
  match goal with
  | [H: Val.binary_operation ?op ?v1 ?v2 = _ |- _] => 
      destruct v1, v2; inversion H; clear H;
      [ destruct v0, v1 | destruct v0 | destruct v0]; inversion H4; subst
  end.
  match goal with
  | [H: well_check_flagged_expr _ |- _] => inversion H; subst
  end;
  repeat progress match goal with
  | [H: do_flagged_checks_on_binop _ ?op ?v1 ?v2 _ |- _] => inversion H; clear H; subst
  | [H: do_flagged_check_on_binop _ ?op ?v1 ?v2 _ |- _] => inversion H; clear H; subst
  | [H: do_overflow_check_on_binop ?op ?v1 ?v2 _ |- _] => inversion H; clear H; subst
  | [H: Val.binary_operation ?op ?v1 ?v2 = _ |- _] => simpl in H; inversion H; subst
  | [H: (Zge_bool ?v ?l) && (Zle_bool ?v ?u) = true |- _] => specialize (Zgele_Bool_Imp_GeLe_T _ _ _ H); auto
  end; auto.
  inversion H7; smack.
  (* 5.2. Divide *)
  match goal with
  | [H: Val.binary_operation ?op ?v1 ?v2 = _ |- _] => 
      destruct v1, v2; inversion H; clear H;
      [ destruct v0, v1 | destruct v0 | destruct v0]; inversion H4; subst
  end.
  match goal with
  | [H: well_check_flagged_expr _ |- _] => inversion H; subst
  end;
  repeat progress match goal with
  | [H: do_flagged_checks_on_binop _ ?op ?v1 ?v2 _ |- _] => inversion H; clear H; subst
  | [H: do_flagged_check_on_binop _ ?op ?v1 ?v2 _ |- _] => inversion H; clear H; subst
  | [H: do_overflow_check_on_binop ?op ?v1 ?v2 _ |- _] => inversion H; clear H; subst
  | [H: Val.binary_operation ?op ?v1 ?v2 = _ |- _] => simpl in H; inversion H; subst
  | [H: (Zge_bool ?v ?l) && (Zle_bool ?v ?u) = true |- _] => specialize (Zgele_Bool_Imp_GeLe_T _ _ _ H); auto
  end; auto.
  inversion H7; smack.
- (* unary expression *)
  match goal with
  | [H: optimize_expression_x ?st ?e ?e' |- _] => inversion H; clear H; subst
  end.
  + (*1. Unary_Minus Pass Overflow Check*)
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H: Val.unary_operation ?op ?v1 = _ |- _] => 
      destruct v1; inversion H; clear H; subst;
      destruct v0; inversion H3;subst
  end.
  match goal with
  | [H: well_check_flagged_expr _ |- _] => inversion H; subst
  end;
  repeat progress match goal with
  | [H1: forall (e' : expression_x) (st : symboltable_x) (s : STACK.stack) (v l u : Z),
      well_typed_stack _ _ ->
      well_check_flagged_expr ?e ->
      eval_expr_x _ _ ?e _ ->
      optimize_expression_x _ ?e _ -> _ ,
     H2: well_typed_stack _ _,
     H3: well_check_flagged_expr ?e,
     H4: eval_expr_x _ _ ?e _,
     H5: optimize_expression_x _ ?e _ |- _ ] => specialize (H1 _ _ _ _ _ _ H2 H3 H4 H5); auto
  end;

  match goal with
  | [H:  (?l <= n <= ?u)%Z |- _] => destruct H as [HZ1 HZ2]
  end;
  specialize (le_neg_ge _ _ HZ1); intros HZ3;
  specialize (le_neg_ge _ _ HZ2); intros HZ4; smack.
  + (*2. Unary_Minus Fail Overflow Check *)
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H: Val.unary_operation ?op ?v1 = _ |- _] => 
      destruct v1; inversion H; clear H; subst;
      destruct v0; inversion H3;subst
  end.
  match goal with
  | [H: well_check_flagged_expr _ |- _] => inversion H; subst
  end;
  repeat progress match goal with
  | [H: do_flagged_checks_on_unop _ ?op ?v _ |- _] => inversion H; clear H; subst
  | [H: do_flagged_check_on_unop _ ?op ?v _ |- _] => inversion H; clear H; subst
  | [H: do_overflow_check_on_unop ?op ?v _ |- _] => inversion H; clear H; subst
  | [H: Val.unary_operation ?op ?v = _ |- _] => simpl in H; inversion H; subst
  | [H: (Zge_bool ?v ?l) && (Zle_bool ?v ?u) = true |- _] => specialize (Zgele_Bool_Imp_GeLe_T _ _ _ H); auto
  end; smack.
  + (*3. Unary_Plus*)
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H: Val.unary_operation ?op ?v1 = _ |- _] => 
      destruct v1; inversion H; clear H; subst;
      destruct v0; inversion H3;subst
  end.
  match goal with
  | [H: well_check_flagged_expr _ |- _] => inversion H; subst
  end;
  repeat progress match goal with
  | [H1: forall (e' : expression_x) (st : symboltable_x) (s : STACK.stack) (v l u : Z),
      well_typed_stack _ _ ->
      well_check_flagged_expr ?e ->
      eval_expr_x _ _ ?e _ ->
      optimize_expression_x _ ?e _ -> _ ,
     H2: well_typed_stack _ _,
     H3: well_check_flagged_expr ?e,
     H4: eval_expr_x _ _ ?e _,
     H5: optimize_expression_x _ ?e _ |- _ ] => specialize (H1 _ _ _ _ _ _ H2 H3 H4 H5); auto
  end.
- (* identifier *)
  match goal with
  | [H: eval_name_x _ _ _ _ |- _] => inversion H; subst
  end.
  match goal with
  | [H: optimize_name_x _ _ _ |- _] => inversion H; clear H; subst
  end.
  specialize (variable_value_in_type_domain _ _ _ _ _ _ _ _ H H1 H7 H12); intros HZ;
  specialize (Zgele_Bool_Imp_GeLe_T _ _ _ HZ); auto.  
- (* indexed component *)
  match goal with
  | [H: optimize_name_x _ _ _ |- _] => inversion H; clear H; subst
  end.
  + (*1*)
  match goal with
  | [H: eval_name_x _ _ _ _ |- _] => inversion H; clear H; subst
  end;
  match goal with
  | [H: well_check_flagged_name _ |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H1: ~ List.In _ ?ls,
     H2: ?ls = _ |- _] => unfold not in H1; rewrite H2 in H1; smack
  end.
  match goal with
  | [H1: fetch_exp_type_x ?x ?st = _,
     H2: fetch_exp_type_x ?x ?st = _ |- _] => rewrite H1 in H2; clear H1; inversion H2; subst
  end.
  specialize (extract_array_index_range_x_unique _ _ _ _ _ _ H15 H21); 
  let HZ := fresh "HZ" in intro HZ; destruct HZ; subst. 
  (* value of array component should be in the domain of its type, which is enforced by
     well-typed stack;
  *)
  admit.
  + (*2*)
  match goal with
  | [H: eval_name_x _ _ _ _ |- _] => inversion H; clear H; subst
  end;
  match goal with
  | [H: well_check_flagged_name _ |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H1: ~ List.In _ ?ls,
     H2: ?ls = _ |- _] => unfold not in H1; rewrite H2 in H1; smack
  end.
  match goal with
  | [H1: fetch_exp_type_x ?x ?st = _,
     H2: fetch_exp_type_x ?x ?st = _ |- _] => rewrite H1 in H2; clear H1; inversion H2; subst
  end.
  specialize (extract_array_index_range_x_unique _ _ _ _ _ _ H15 H19); 
  let HZ := fresh "HZ" in intro HZ; destruct HZ; subst. 
  (* value of array component should be in the domain of its type, which is enforced by
     well-typed stack;
  *)
  admit.
- (* selected component *)
  match goal with
  | [H: optimize_name_x _ _ _ |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H: eval_name_x _ _ _ _ |- _] => inversion H; clear H; subst
  end;
  match goal with
  | [H: well_check_flagged_name _ |- _] => inversion H; clear H; subst
  end.
  (* value of record field should be in the domain of its type, which is enforced by
     well-typed stack;
  *)
  admit.
Qed.

End Checks_Optimization_Help_Lemmas.



(** 
It's impossible to prove the following theorem directly, as we do induction 
proof on it, the proof will get stuck when e is an indexed_component, e.g. a[e]; 
the induction proof will generate a premise for e in the following theorem form,
where (eval_expr_x st s e v) is impossible to be true as e has Do_Range_Check flag, 
which is not acceptible by the semantics of eval_expr_x;

- Theorem expression_checks_optimization_soundness: forall e e' st s v v',
    eval_expr_x st s e v ->
      optimize_expression_x st e (v', e') ->
        eval_expr_x st s e' v.
*)

Lemma expression_checks_optimization_soundness_help: forall e e' st s checkflags v v',
  well_typed_stack st s ->
    remove_check_flag Do_Range_Check (exp_check_flags e) checkflags ->
      well_check_flagged_expr (update_exp_check_flags e checkflags) ->
        eval_expr_x st s (update_exp_check_flags e checkflags) v ->
          optimize_expression_x st (update_exp_check_flags e checkflags) (v', e') ->
            eval_expr_x st s e' v.
Proof.
  apply (expression_x_ind
    (fun e: expression_x => 
       forall (e' : expression_x) (st : symboltable_x) (s : STACK.stack) (checkflags : check_flags)
              (v : Return value) (v' : valueO),
      well_typed_stack st s ->
      remove_check_flag Do_Range_Check (exp_check_flags e) checkflags ->
      well_check_flagged_expr (update_exp_check_flags e checkflags) ->
      eval_expr_x st s (update_exp_check_flags e checkflags) v ->
      optimize_expression_x st (update_exp_check_flags e checkflags) (v', e') ->
      eval_expr_x st s e' v)
    (fun n: name_x => 
       forall (n' : name_x) (st : symboltable_x) (s : STACK.stack) (checkflags : check_flags)
              (v : Return value) (v' : valueO),
      well_typed_stack st s ->
      remove_check_flag Do_Range_Check (name_check_flags n) checkflags ->
      well_check_flagged_name (update_name_check_flags n checkflags) ->
      eval_name_x st s (update_name_check_flags n checkflags) v ->
      optimize_name_x st (update_name_check_flags n checkflags) (v', n') ->
      eval_name_x st s n' v)
    ); intros.
- (*Literal*)
  match goal with
  | [H: optimize_expression_x ?st ?e ?e' |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end.
  constructor; auto.
- (* Name *)
  match goal with
  | [H: optimize_expression_x ?st ?e ?e' |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H: well_check_flagged_expr _ |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H: remove_check_flag _ (exp_check_flags (E_Name_X _ _ _)) _ |- _] => simpl in H
  end.
  match goal with
  | [H1: forall (n' : name_x) (st : symboltable_x) (s : STACK.stack) (checkflags : check_flags)
                (v : Return value) (v' : valueO),
      well_typed_stack _ _ ->
      remove_check_flag Do_Range_Check (name_check_flags ?n) _ ->
      well_check_flagged_name (update_name_check_flags ?n _) ->
      eval_name_x _ _ (update_name_check_flags ?n _) _ ->
      optimize_name_x _ (update_name_check_flags ?n _) _ -> _ ,
     H2: well_typed_stack _ _,
     H3: remove_check_flag Do_Range_Check (name_check_flags ?n) _,
     H4: well_check_flagged_name (update_name_check_flags ?n _),
     H5: eval_name_x _ _ (update_name_check_flags ?n _) _,
     H6: optimize_name_x _ (update_name_check_flags ?n _) _ |- _ ] => 
      specialize (H1 _ _ _ _ _ _ H2 H3 H4 H5 H6); auto
  end.
  constructor; auto.
- (* binary expression *)
  simpl in H2, H3, H4, H5.
  match goal with
  | [H: optimize_expression_x _ _ _ |- _] => inversion H; clear H; subst
  end.
  + (*1. Plus Overflow Pass*)
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end;
  match goal with
  | [H: well_check_flagged_expr _ |- _] => inversion H; subst; [ | smack]
  end;
  match goal with
  | [H: well_check_flagged_expr e |- _] => 
      let H1 := fresh "HZ" in 
      specialize (rm_range_check_return_same_expr_checks _ H); intros H1
  end;
  match goal with
  | [H: well_check_flagged_expr e0 |- _] => 
      let H1 := fresh "HZ" in 
      specialize (rm_range_check_return_same_expr_checks _ H); intros H1
  end;
  repeat progress match goal with
  | [H1: optimize_expression_x _ e _,
     H2: eval_expr_x _ _ e _,
     H3: well_check_flagged_expr e |- _] => 
      let HZ := fresh "HZ" in
      specialize (update_exp_with_same_check_flags e); intro HZ; rewrite <- HZ in H1, H2, H3; clear HZ
  | [H1: optimize_expression_x _ e0 _,
     H2: eval_expr_x _ _ e0 _,
     H3: well_check_flagged_expr e0 |- _] => 
      let HZ := fresh "HZ" in
      specialize (update_exp_with_same_check_flags e0); intro HZ; rewrite <- HZ in H1, H2, H3; clear HZ
  end;
  repeat progress match goal with
  | [H1: forall (e' : expression_x) (st : symboltable_x) (s : STACK.stack) (checkflags : check_flags)
                (v : Return value) (v' : valueO),
      well_typed_stack _ _ ->
      remove_check_flag Do_Range_Check (exp_check_flags ?e) _ ->
      well_check_flagged_expr (update_exp_check_flags ?e _) ->
      eval_expr_x _ _ (update_exp_check_flags ?e _) _ ->
      optimize_expression_x _ (update_exp_check_flags ?e _) _ -> _ ,
     H2: well_typed_stack _ _,
     H3: remove_check_flag Do_Range_Check (exp_check_flags ?e) _,
     H4: well_check_flagged_expr (update_exp_check_flags ?e _),
     H5: eval_expr_x _ _ (update_exp_check_flags ?e _) _,
     H6: optimize_expression_x _ (update_exp_check_flags ?e _) _ |- _ ] => 
      specialize (H1 _ _ _ _ _ _ H2 H3 H4 H5 H6); auto
  end;
  [apply Eval_E_Binary_Operation_RTE_E1_X; auto |
   apply Eval_E_Binary_Operation_RTE_E2_X with (v1 := v1); auto |
   apply Eval_E_Binary_Operation_RTE_Bin_X with (v1 := v1) (v2 := v2); auto |
   apply Eval_E_Binary_Operation_X with (v1 := v1) (v2 := v2); auto
  ].
  (* TODO: use contradiction to prove it: the value of e1 and e2 both fall in the range
           of their type, so (v1 op v2) should have no overflow !
  *)
  admit.
  inversion H18; smack. inversion H12; smack.
  constructor.
  + (*2. Plus Overflow Fail*)
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end;
  match goal with
  | [H: well_check_flagged_expr _ |- _] => simpl in H; inversion H; subst; [ | smack]
  end;
  match goal with
  | [H: well_check_flagged_expr e |- _] => 
      let H1 := fresh "HZ" in 
      specialize (rm_range_check_return_same_expr_checks _ H); intros H1
  end;
  match goal with
  | [H: well_check_flagged_expr e0 |- _] => 
      let H1 := fresh "HZ" in 
      specialize (rm_range_check_return_same_expr_checks _ H); intros H1
  end;
  repeat progress match goal with
  | [H1: optimize_expression_x _ e _,
     H2: eval_expr_x _ _ e _,
     H3: well_check_flagged_expr e |- _] => 
      let HZ := fresh "HZ" in
      specialize (update_exp_with_same_check_flags e); intro HZ; rewrite <- HZ in H1, H2, H3; clear HZ
  | [H1: optimize_expression_x _ e0 _,
     H2: eval_expr_x _ _ e0 _,
     H3: well_check_flagged_expr e0 |- _] => 
      let HZ := fresh "HZ" in
      specialize (update_exp_with_same_check_flags e0); intro HZ; rewrite <- HZ in H1, H2, H3; clear HZ
  end;
  repeat progress match goal with
  | [H1: forall (e' : expression_x) (st : symboltable_x) (s : STACK.stack) (checkflags : check_flags)
                (v : Return value) (v' : valueO),
      well_typed_stack _ _ ->
      remove_check_flag Do_Range_Check (exp_check_flags ?e) _ ->
      well_check_flagged_expr (update_exp_check_flags ?e _) ->
      eval_expr_x _ _ (update_exp_check_flags ?e _) _ ->
      optimize_expression_x _ (update_exp_check_flags ?e _) _ -> _ ,
     H2: well_typed_stack _ _,
     H3: remove_check_flag Do_Range_Check (exp_check_flags ?e) _,
     H4: well_check_flagged_expr (update_exp_check_flags ?e _),
     H5: eval_expr_x _ _ (update_exp_check_flags ?e _) _,
     H6: optimize_expression_x _ (update_exp_check_flags ?e _) _ |- _ ] => 
      specialize (H1 _ _ _ _ _ _ H2 H3 H4 H5 H6); auto
  end;
  [apply Eval_E_Binary_Operation_RTE_E1_X; auto |
   apply Eval_E_Binary_Operation_RTE_E2_X with (v1 := v1); auto |
   apply Eval_E_Binary_Operation_RTE_Bin_X with (v1 := v1) (v2 := v2); auto |
   apply Eval_E_Binary_Operation_X with (v1 := v1) (v2 := v2); auto
  ].
  + (*3. Minus Overflow Pass *)
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end;
  match goal with
  | [H: well_check_flagged_expr _ |- _] => inversion H; subst; [ | smack]
  end;
  match goal with
  | [H: well_check_flagged_expr e |- _] => 
      let H1 := fresh "HZ" in 
      specialize (rm_range_check_return_same_expr_checks _ H); intros H1
  end;
  match goal with
  | [H: well_check_flagged_expr e0 |- _] => 
      let H1 := fresh "HZ" in 
      specialize (rm_range_check_return_same_expr_checks _ H); intros H1
  end;
  repeat progress match goal with
  | [H1: optimize_expression_x _ e _,
     H2: eval_expr_x _ _ e _,
     H3: well_check_flagged_expr e |- _] => 
      let HZ := fresh "HZ" in
      specialize (update_exp_with_same_check_flags e); intro HZ; rewrite <- HZ in H1, H2, H3; clear HZ
  | [H1: optimize_expression_x _ e0 _,
     H2: eval_expr_x _ _ e0 _,
     H3: well_check_flagged_expr e0 |- _] => 
      let HZ := fresh "HZ" in
      specialize (update_exp_with_same_check_flags e0); intro HZ; rewrite <- HZ in H1, H2, H3; clear HZ
  end;
  repeat progress match goal with
  | [H1: forall (e' : expression_x) (st : symboltable_x) (s : STACK.stack) (checkflags : check_flags)
                (v : Return value) (v' : valueO),
      well_typed_stack _ _ ->
      remove_check_flag Do_Range_Check (exp_check_flags ?e) _ ->
      well_check_flagged_expr (update_exp_check_flags ?e _) ->
      eval_expr_x _ _ (update_exp_check_flags ?e _) _ ->
      optimize_expression_x _ (update_exp_check_flags ?e _) _ -> _ ,
     H2: well_typed_stack _ _,
     H3: remove_check_flag Do_Range_Check (exp_check_flags ?e) _,
     H4: well_check_flagged_expr (update_exp_check_flags ?e _),
     H5: eval_expr_x _ _ (update_exp_check_flags ?e _) _,
     H6: optimize_expression_x _ (update_exp_check_flags ?e _) _ |- _ ] => 
      specialize (H1 _ _ _ _ _ _ H2 H3 H4 H5 H6); auto
  end;
  [apply Eval_E_Binary_Operation_RTE_E1_X; auto |
   apply Eval_E_Binary_Operation_RTE_E2_X with (v1 := v1); auto |
   apply Eval_E_Binary_Operation_RTE_Bin_X with (v1 := v1) (v2 := v2); auto |
   apply Eval_E_Binary_Operation_X with (v1 := v1) (v2 := v2); auto
  ].
  (* TODO: use contradiction to prove it: the value of e1 and e2 both fall in the range
           of their type, so (v1 op v2) should have no overflow !
  *)
  admit.
  inversion H18; smack. inversion H12; smack.
  constructor.
  + (*4. Minus Overflow Fail*)
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end;
  match goal with
  | [H: well_check_flagged_expr _ |- _] => simpl in H; inversion H; subst; [ | smack]
  end;
  match goal with
  | [H: well_check_flagged_expr e |- _] => 
      let H1 := fresh "HZ" in 
      specialize (rm_range_check_return_same_expr_checks _ H); intros H1
  end;
  match goal with
  | [H: well_check_flagged_expr e0 |- _] => 
      let H1 := fresh "HZ" in 
      specialize (rm_range_check_return_same_expr_checks _ H); intros H1
  end;
  repeat progress match goal with
  | [H1: optimize_expression_x _ e _,
     H2: eval_expr_x _ _ e _,
     H3: well_check_flagged_expr e |- _] => 
      let HZ := fresh "HZ" in
      specialize (update_exp_with_same_check_flags e); intro HZ; rewrite <- HZ in H1, H2, H3; clear HZ
  | [H1: optimize_expression_x _ e0 _,
     H2: eval_expr_x _ _ e0 _,
     H3: well_check_flagged_expr e0 |- _] => 
      let HZ := fresh "HZ" in
      specialize (update_exp_with_same_check_flags e0); intro HZ; rewrite <- HZ in H1, H2, H3; clear HZ
  end;
  repeat progress match goal with
  | [H1: forall (e' : expression_x) (st : symboltable_x) (s : STACK.stack) (checkflags : check_flags)
                (v : Return value) (v' : valueO),
      well_typed_stack _ _ ->
      remove_check_flag Do_Range_Check (exp_check_flags ?e) _ ->
      well_check_flagged_expr (update_exp_check_flags ?e _) ->
      eval_expr_x _ _ (update_exp_check_flags ?e _) _ ->
      optimize_expression_x _ (update_exp_check_flags ?e _) _ -> _ ,
     H2: well_typed_stack _ _,
     H3: remove_check_flag Do_Range_Check (exp_check_flags ?e) _,
     H4: well_check_flagged_expr (update_exp_check_flags ?e _),
     H5: eval_expr_x _ _ (update_exp_check_flags ?e _) _,
     H6: optimize_expression_x _ (update_exp_check_flags ?e _) _ |- _ ] => 
      specialize (H1 _ _ _ _ _ _ H2 H3 H4 H5 H6); auto
  end;
  [apply Eval_E_Binary_Operation_RTE_E1_X; auto |
   apply Eval_E_Binary_Operation_RTE_E2_X with (v1 := v1); auto |
   apply Eval_E_Binary_Operation_RTE_Bin_X with (v1 := v1) (v2 := v2); auto |
   apply Eval_E_Binary_Operation_X with (v1 := v1) (v2 := v2); auto
  ].
  + (*5. Multiply or Divide *)
  match goal with
  | [H: ?op = Multiply \/ ?op = Divide |- _] => inversion H; clear H; subst
  end.
  * (* 5.1. Multiply *)
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end;
  match goal with
  | [H: well_check_flagged_expr _ |- _] => inversion H; subst; [ | smack]
  end;
  match goal with
  | [H: well_check_flagged_expr e |- _] => 
      let H1 := fresh "HZ" in 
      specialize (rm_range_check_return_same_expr_checks _ H); intros H1
  end;
  match goal with
  | [H: well_check_flagged_expr e0 |- _] => 
      let H1 := fresh "HZ" in 
      specialize (rm_range_check_return_same_expr_checks _ H); intros H1
  end;
  repeat progress match goal with
  | [H1: optimize_expression_x _ e _,
     H2: eval_expr_x _ _ e _,
     H3: well_check_flagged_expr e |- _] => 
      let HZ := fresh "HZ" in
      specialize (update_exp_with_same_check_flags e); intro HZ; rewrite <- HZ in H1, H2, H3; clear HZ
  | [H1: optimize_expression_x _ e0 _,
     H2: eval_expr_x _ _ e0 _,
     H3: well_check_flagged_expr e0 |- _] => 
      let HZ := fresh "HZ" in
      specialize (update_exp_with_same_check_flags e0); intro HZ; rewrite <- HZ in H1, H2, H3; clear HZ
  end;
  repeat progress match goal with
  | [H1: forall (e' : expression_x) (st : symboltable_x) (s : STACK.stack) (checkflags : check_flags)
                (v : Return value) (v' : valueO),
      well_typed_stack _ _ ->
      remove_check_flag Do_Range_Check (exp_check_flags ?e) _ ->
      well_check_flagged_expr (update_exp_check_flags ?e _) ->
      eval_expr_x _ _ (update_exp_check_flags ?e _) _ ->
      optimize_expression_x _ (update_exp_check_flags ?e _) _ -> _ ,
     H2: well_typed_stack _ _,
     H3: remove_check_flag Do_Range_Check (exp_check_flags ?e) _,
     H4: well_check_flagged_expr (update_exp_check_flags ?e _),
     H5: eval_expr_x _ _ (update_exp_check_flags ?e _) _,
     H6: optimize_expression_x _ (update_exp_check_flags ?e _) _ |- _ ] => 
      specialize (H1 _ _ _ _ _ _ H2 H3 H4 H5 H6); auto
  end;
  [apply Eval_E_Binary_Operation_RTE_E1_X; auto |
   apply Eval_E_Binary_Operation_RTE_E2_X with (v1 := v1); auto |
   apply Eval_E_Binary_Operation_RTE_Bin_X with (v1 := v1) (v2 := v2); auto |
   apply Eval_E_Binary_Operation_X with (v1 := v1) (v2 := v2); auto
  ].
  * (* 5.2. Divide *)
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end;
  match goal with
  | [H: well_check_flagged_expr _ |- _] => inversion H; subst; [smack | | smack]
  end;
  match goal with
  | [H: well_check_flagged_expr e |- _] => 
      let H1 := fresh "HZ" in 
      specialize (rm_range_check_return_same_expr_checks _ H); intros H1
  end;
  match goal with
  | [H: well_check_flagged_expr e0 |- _] => 
      let H1 := fresh "HZ" in 
      specialize (rm_range_check_return_same_expr_checks _ H); intros H1
  end;
  repeat progress match goal with
  | [H1: optimize_expression_x _ e _,
     H2: eval_expr_x _ _ e _,
     H3: well_check_flagged_expr e |- _] => 
      let HZ := fresh "HZ" in
      specialize (update_exp_with_same_check_flags e); intro HZ; rewrite <- HZ in H1, H2, H3; clear HZ
  | [H1: optimize_expression_x _ e0 _,
     H2: eval_expr_x _ _ e0 _,
     H3: well_check_flagged_expr e0 |- _] => 
      let HZ := fresh "HZ" in
      specialize (update_exp_with_same_check_flags e0); intro HZ; rewrite <- HZ in H1, H2, H3; clear HZ
  end;
  repeat progress match goal with
  | [H1: forall (e' : expression_x) (st : symboltable_x) (s : STACK.stack) (checkflags : check_flags)
                (v : Return value) (v' : valueO),
      well_typed_stack _ _ ->
      remove_check_flag Do_Range_Check (exp_check_flags ?e) _ ->
      well_check_flagged_expr (update_exp_check_flags ?e _) ->
      eval_expr_x _ _ (update_exp_check_flags ?e _) _ ->
      optimize_expression_x _ (update_exp_check_flags ?e _) _ -> _ ,
     H2: well_typed_stack _ _,
     H3: remove_check_flag Do_Range_Check (exp_check_flags ?e) _,
     H4: well_check_flagged_expr (update_exp_check_flags ?e _),
     H5: eval_expr_x _ _ (update_exp_check_flags ?e _) _,
     H6: optimize_expression_x _ (update_exp_check_flags ?e _) _ |- _ ] => 
      specialize (H1 _ _ _ _ _ _ H2 H3 H4 H5 H6); auto
  end;
  [apply Eval_E_Binary_Operation_RTE_E1_X; auto |
   apply Eval_E_Binary_Operation_RTE_E2_X with (v1 := v1); auto |
   apply Eval_E_Binary_Operation_RTE_Bin_X with (v1 := v1) (v2 := v2); auto |
   apply Eval_E_Binary_Operation_X with (v1 := v1) (v2 := v2); auto
  ].
  + (*6. Logical_Operation*)
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end;
  match goal with
  | [H: well_check_flagged_expr _ |- _] => inversion H; subst; [smack | smack | ]
  end;
  match goal with
  | [H: well_check_flagged_expr e |- _] => 
      let H1 := fresh "HZ" in 
      specialize (rm_range_check_return_same_expr_checks _ H); intros H1
  end;
  match goal with
  | [H: well_check_flagged_expr e0 |- _] => 
      let H1 := fresh "HZ" in 
      specialize (rm_range_check_return_same_expr_checks _ H); intros H1
  end;
  repeat progress match goal with
  | [H1: optimize_expression_x _ e _,
     H2: eval_expr_x _ _ e _,
     H3: well_check_flagged_expr e |- _] => 
      let HZ := fresh "HZ" in
      specialize (update_exp_with_same_check_flags e); intro HZ; rewrite <- HZ in H1, H2, H3; clear HZ
  | [H1: optimize_expression_x _ e0 _,
     H2: eval_expr_x _ _ e0 _,
     H3: well_check_flagged_expr e0 |- _] => 
      let HZ := fresh "HZ" in
      specialize (update_exp_with_same_check_flags e0); intro HZ; rewrite <- HZ in H1, H2, H3; clear HZ
  end;
  repeat progress match goal with
  | [H1: forall (e' : expression_x) (st : symboltable_x) (s : STACK.stack) (checkflags : check_flags)
                (v : Return value) (v' : valueO),
      well_typed_stack _ _ ->
      remove_check_flag Do_Range_Check (exp_check_flags ?e) _ ->
      well_check_flagged_expr (update_exp_check_flags ?e _) ->
      eval_expr_x _ _ (update_exp_check_flags ?e _) _ ->
      optimize_expression_x _ (update_exp_check_flags ?e _) _ -> _ ,
     H2: well_typed_stack _ _,
     H3: remove_check_flag Do_Range_Check (exp_check_flags ?e) _,
     H4: well_check_flagged_expr (update_exp_check_flags ?e _),
     H5: eval_expr_x _ _ (update_exp_check_flags ?e _) _,
     H6: optimize_expression_x _ (update_exp_check_flags ?e _) _ |- _ ] => 
      specialize (H1 _ _ _ _ _ _ H2 H3 H4 H5 H6); auto
  end;
  [apply Eval_E_Binary_Operation_RTE_E1_X; auto |
   apply Eval_E_Binary_Operation_RTE_E2_X with (v1 := v1); auto |
   apply Eval_E_Binary_Operation_RTE_Bin_X with (v1 := v1) (v2 := v2); auto |
   apply Eval_E_Binary_Operation_X with (v1 := v1) (v2 := v2); auto
  ].
- (* unary expression *)
  match goal with
  | [H: optimize_expression_x ?st ?e ?e' |- _] => inversion H; clear H; subst
  end.
  + (*1. Unary_Minus Pass Overflow Check*)
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end;
  match goal with
  | [H: well_check_flagged_expr _ |- _] => inversion H; subst; [ | smack]
  end;
  match goal with
  | [H: well_check_flagged_expr e |- _] => 
      let H1 := fresh "HZ" in 
      specialize (rm_range_check_return_same_expr_checks _ H); intros H1
  end;
  match goal with
  | [H1: optimize_expression_x _ e _,
     H2: eval_expr_x _ _ e _,
     H3: well_check_flagged_expr e |- _] => 
      let HZ := fresh "HZ" in
      specialize (update_exp_with_same_check_flags e); intro HZ;
      rewrite <- HZ in H1, H2, H3; clear HZ
  end;
  match goal with
  | [H1: forall (e' : expression_x) (st : symboltable_x) (s : STACK.stack) (checkflags : check_flags)
                (v : Return value) (v' : valueO),
      well_typed_stack _ _ ->
      remove_check_flag Do_Range_Check (exp_check_flags ?e) _ ->
      well_check_flagged_expr (update_exp_check_flags ?e _) ->
      eval_expr_x _ _ (update_exp_check_flags ?e _) _ ->
      optimize_expression_x _ (update_exp_check_flags ?e _) _ -> _ ,
     H2: well_typed_stack _ _,
     H3: remove_check_flag Do_Range_Check (exp_check_flags ?e) _,
     H4: well_check_flagged_expr (update_exp_check_flags ?e _),
     H5: eval_expr_x _ _ (update_exp_check_flags ?e _) _,
     H6: optimize_expression_x _ (update_exp_check_flags ?e _) _ |- _ ] => 
      specialize (H1 _ _ _ _ _ _ H2 H3 H4 H5 H6); auto
  end;
  [ apply Eval_E_Unary_Operation_RTE_E_X; auto |
    apply Eval_E_Unary_Operation_RTE_X with (v := v0); auto |
    apply Eval_E_Unary_Operation_X with (v := v0); auto
  ].
  (*TODO: use contradiction to prove it. the value of unary operation
          is in the range of its type, so it should never overflow !
  *)
  admit.
  inversion H17; smack. inversion H9; smack.
  constructor.
  + (*2. Unary_Minus Fail Overflow Check *)
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end;
  match goal with
  | [H: well_check_flagged_expr _ |- _] => inversion H; subst; [ | smack]
  end;
  match goal with
  | [H: well_check_flagged_expr e |- _] => 
      let H1 := fresh "HZ" in 
      specialize (rm_range_check_return_same_expr_checks _ H); intros H1
  end;
  match goal with
  | [H1: optimize_expression_x _ e _,
     H2: eval_expr_x _ _ e _,
     H3: well_check_flagged_expr e |- _] => 
      let HZ := fresh "HZ" in
      specialize (update_exp_with_same_check_flags e); intro HZ;
      rewrite <- HZ in H1, H2, H3; clear HZ
  end;
  match goal with
  | [H1: forall (e' : expression_x) (st : symboltable_x) (s : STACK.stack) (checkflags : check_flags)
                (v : Return value) (v' : valueO),
      well_typed_stack _ _ ->
      remove_check_flag Do_Range_Check (exp_check_flags ?e) _ ->
      well_check_flagged_expr (update_exp_check_flags ?e _) ->
      eval_expr_x _ _ (update_exp_check_flags ?e _) _ ->
      optimize_expression_x _ (update_exp_check_flags ?e _) _ -> _ ,
     H2: well_typed_stack _ _,
     H3: remove_check_flag Do_Range_Check (exp_check_flags ?e) _,
     H4: well_check_flagged_expr (update_exp_check_flags ?e _),
     H5: eval_expr_x _ _ (update_exp_check_flags ?e _) _,
     H6: optimize_expression_x _ (update_exp_check_flags ?e _) _ |- _ ] => 
      specialize (H1 _ _ _ _ _ _ H2 H3 H4 H5 H6); auto
  end;
  [ apply Eval_E_Unary_Operation_RTE_E_X; auto |
    apply Eval_E_Unary_Operation_RTE_X with (v := v0); auto |
    apply Eval_E_Unary_Operation_X with (v := v0); auto
  ].
  + (*3. Unary_Plus*)
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end;  
  match goal with
  | [H: well_check_flagged_expr _ |- _] => inversion H; subst
  end;
  match goal with
  | [H: well_check_flagged_expr e |- _] => 
      let H1 := fresh "HZ" in 
      specialize (rm_range_check_return_same_expr_checks _ H); intros H1
  end;
  match goal with
  | [H1: optimize_expression_x _ e _,
     H2: eval_expr_x _ _ e _,
     H3: well_check_flagged_expr e |- _] => 
      let HZ := fresh "HZ" in
      specialize (update_exp_with_same_check_flags e); intro HZ; rewrite <- HZ in H1, H2, H3; clear HZ
  end;
  match goal with
  | [H1: forall (e' : expression_x) (st : symboltable_x) (s : STACK.stack) (checkflags : check_flags)
                (v : Return value) (v' : valueO),
      well_typed_stack _ _ ->
      remove_check_flag Do_Range_Check (exp_check_flags ?e) _ ->
      well_check_flagged_expr (update_exp_check_flags ?e _) ->
      eval_expr_x _ _ (update_exp_check_flags ?e _) _ ->
      optimize_expression_x _ (update_exp_check_flags ?e _) _ -> _ ,
     H2: well_typed_stack _ _,
     H3: remove_check_flag Do_Range_Check (exp_check_flags ?e) _,
     H4: well_check_flagged_expr (update_exp_check_flags ?e _),
     H5: eval_expr_x _ _ (update_exp_check_flags ?e _) _,
     H6: optimize_expression_x _ (update_exp_check_flags ?e _) _ |- _ ] => 
      specialize (H1 _ _ _ _ _ _ H2 H3 H4 H5 H6); auto
  end;
  [ apply Eval_E_Unary_Operation_RTE_E_X; auto |
    apply Eval_E_Unary_Operation_RTE_X with (v := v0); auto |
    apply Eval_E_Unary_Operation_X with (v := v0); auto
  ].
  + (*4. Unary_Not*)
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end;
  match goal with
  | [H: well_check_flagged_expr _ |- _] => inversion H; subst
  end;  
  match goal with
  | [H: well_check_flagged_expr e |- _] => 
      let H1 := fresh "HZ" in 
      specialize (rm_range_check_return_same_expr_checks _ H); intros H1
  end;
  match goal with
  | [H1: optimize_expression_x _ e _,
     H2: eval_expr_x _ _ e _,
     H3: well_check_flagged_expr e |- _] => 
      let HZ := fresh "HZ" in
      specialize (update_exp_with_same_check_flags e); intro HZ; rewrite <- HZ in H1, H2, H3; clear HZ
  end;
  match goal with
  | [H1: forall (e' : expression_x) (st : symboltable_x) (s : STACK.stack) (checkflags : check_flags)
                (v : Return value) (v' : valueO),
      well_typed_stack _ _ ->
      remove_check_flag Do_Range_Check (exp_check_flags ?e) _ ->
      well_check_flagged_expr (update_exp_check_flags ?e _) ->
      eval_expr_x _ _ (update_exp_check_flags ?e _) _ ->
      optimize_expression_x _ (update_exp_check_flags ?e _) _ -> _ ,
     H2: well_typed_stack _ _,
     H3: remove_check_flag Do_Range_Check (exp_check_flags ?e) _,
     H4: well_check_flagged_expr (update_exp_check_flags ?e _),
     H5: eval_expr_x _ _ (update_exp_check_flags ?e _) _,
     H6: optimize_expression_x _ (update_exp_check_flags ?e _) _ |- _ ] => 
      specialize (H1 _ _ _ _ _ _ H2 H3 H4 H5 H6); auto
  end;
  [ apply Eval_E_Unary_Operation_RTE_E_X; auto |
    apply Eval_E_Unary_Operation_RTE_X with (v := v0); auto |
    apply Eval_E_Unary_Operation_X with (v := v0); auto
  ].
- (* identifier *)
  match goal with
  | [H: eval_name_x _ _ _ _ |- _] => inversion H; subst
  end.
  match goal with
  | [H: optimize_name_x _ _ _ |- _] => inversion H; clear H; subst
  end.
  constructor; auto.
- (* indexed component *)
  simpl in H1, H2, H3, H4.
  match goal with
  | [H: optimize_name_x _ _ _ |- _] => inversion H; clear H; subst
  end.
  + (*1. index range check pass*)
  match goal with
  | [H: eval_name_x _ _ _ _ |- _] => inversion H; clear H; subst
  end;
  match goal with
  | [H: well_check_flagged_name _ |- _] => inversion H; clear H; subst
  end;
  match goal with
  | [H1: ~ List.In _ ?ls,
     H2: ?ls = _ |- _] => unfold not in H1; rewrite H2 in H1; smack
  | _ => idtac
  end;
  
  match goal with
  | [H: well_check_flagged_expr ?e |- _] => 
      specialize (range_check_not_in_expr _ H); let HZ := fresh "HZ" in intro HZ;
      rewrite update_exp_with_new_check_flags in HZ
  end;
  match goal with
  | [H1: fetch_exp_type_x ?x ?st = _,
     H2: fetch_exp_type_x ?x ?st = _ |- _] => rewrite H1 in H2; inversion H2; subst
  | _ => idtac
  end;
  match goal with
  | [H1: exp_check_flags ?e = ?cks1 ++ ?ck :: ?cks2, 
     H2: exp_check_flags ?e = ?cks0 ++ ?ck :: ?cks3,
     H3: ~(List.In ?ck (?cks0 ++ ?cks3)) |- _] => 
      rewrite H2 in H1; specialize (list_components_equal _ _ _ _ _ H1 H3); 
      let HZ := fresh "HZ" in intro HZ; destruct HZ; subst
  end;
  specialize (remove_range_check_property _ _ _ H5 H8);
  (let HZ := fresh "HZ" in intro HZ);
  specialize (optimize_expr_to_same_checkflags _ _ _ _ _ _ _ _ _ H12 H19 HZ0 H5 H8);
  (let HZ := fresh "HZ" in intro HZ);
  match goal with
  | [H1: forall (e' : expression_x) (st : symboltable_x) (s : STACK.stack) (checkflags : check_flags)
                (v : Return value) (v' : valueO),
      well_typed_stack _ _ ->
      remove_check_flag Do_Range_Check (exp_check_flags ?e) _ ->
      well_check_flagged_expr (update_exp_check_flags ?e _) ->
      eval_expr_x _ _ (update_exp_check_flags ?e _) _ ->
      optimize_expression_x _ (update_exp_check_flags ?e _) _ -> _ ,
     H2: well_typed_stack _ _,
     H3: remove_check_flag Do_Range_Check (exp_check_flags ?e) _,
     H4: well_check_flagged_expr (update_exp_check_flags ?e _),
     H5: eval_expr_x _ _ (update_exp_check_flags ?e _) _,
     H6: optimize_expression_x _ (update_exp_check_flags ?e _) _ |- _ ] => 
      specialize (H1 _ _ _ _ _ _ H2 H3 H4 H5 H6); auto
  end.
  *
  apply Eval_E_Indexed_Component_RTE_X; auto;
  specialize (update_exp_with_new_check_flags e' checkflags');
  (let HZ := fresh "HZ" in intro HZ; rewrite HZ; clear HZ);
  specialize (removed_check_flag_notin _ _ _ H19); auto.
  *
  specialize (extract_array_index_range_x_unique _ _ _ _ _ _ H15 H22); 
  (let HZ := fresh "HZ" in intro HZ; destruct HZ); subst;
  (* TODO: use contradiction to prove:
           value of array component falls in the domain of the component type *)
  admit.  
  * 
  specialize (extract_array_index_range_x_unique _ _ _ _ _ _ H15 H22); 
  (let HZ := fresh "HZ" in intro HZ; destruct HZ; subst);
  apply Eval_E_Indexed_Component_X with (i:=i0) (a:=a1); auto;
  specialize (update_exp_with_new_check_flags e' checkflags');
  (let HZ := fresh "HZ" in intro HZ; rewrite HZ; clear HZ);
  specialize (removed_check_flag_notin _ _ _ H19); auto.
  + (*2. index range check fail*)
  match goal with
  | [H: eval_name_x _ _ _ _ |- _] => inversion H; clear H; subst
  end;
  match goal with
  | [H: well_check_flagged_name _ |- _] => inversion H; clear H; subst
  end;
  match goal with
  | [H1: ~ List.In _ ?ls,
     H2: ?ls = _ |- _] => unfold not in H1; rewrite H2 in H1; smack
  | _ => idtac
  end;
  match goal with
  | [H: well_check_flagged_expr ?e |- _] => 
      specialize (range_check_not_in_expr _ H); let HZ := fresh "HZ" in intro HZ;
      rewrite update_exp_with_new_check_flags in HZ
  end;
  match goal with
  | [H1: fetch_exp_type_x ?x ?st = _,
     H2: fetch_exp_type_x ?x ?st = _ |- _] => rewrite H1 in H2; inversion H2; subst
  | _ => idtac
  end;
  match goal with
  | [H1: exp_check_flags ?e = ?cks1 ++ ?ck :: ?cks2, 
     H2: exp_check_flags ?e = ?cks0 ++ ?ck :: ?cks3,
     H3: ~(List.In ?ck (?cks0 ++ ?cks3)) |- _] => 
      rewrite H2 in H1; specialize (list_components_equal _ _ _ _ _ H1 H3); 
      let HZ := fresh "HZ" in intro HZ; destruct HZ; subst
  end;
  specialize (remove_range_check_property _ _ _ H5 H8);
  (let HZ := fresh "HZ" in intro HZ);
  specialize (optimize_expression_reserve_range_check _ _ _ _ _ _ H5 H12); intros HZZ;
  destruct HZZ as [cks1' [cks2' HE]];
  specialize (optimize_expression_range_check_notin _ _ _ _ _ _ _ _ H5 H12 HE HZ);
  (let HZ := fresh "HZ" in intros HZ);
  
  [ apply Eval_E_Indexed_Component_E_RTE_X with (cks1:=cks1') (cks2:=cks2'); auto |
    apply Eval_E_Indexed_Component_Range_RTE_X with (cks1:=cks1') (cks2:=cks2') (i:=i0)
                                                    (t:=t0) (l:=l0) (u:=u0); auto |
    apply Eval_E_Indexed_Component_Range_X with (cks1:=cks1') (cks2:=cks2') (i:=i0) (t:=t0)
                                                (l:=l0) (u:=u0) (a:=a1); auto
  ];
  specialize (remove_a_unique_check _ _ _ _ HE HZ1); 
  (let HZ := fresh "HZ" in intros HZ);
  specialize (optimize_expr_to_same_checkflags _ _ _ _ _ _ _ _ _ H12 HZ2 HZ0 H5 H8); 
  (let HZ := fresh "HZ" in intros HZ);
  match goal with
  | [H1: forall (e' : expression_x) (st : symboltable_x) (s : STACK.stack) (checkflags : check_flags)
                (v : Return value) (v' : valueO),
      well_typed_stack _ _ ->
      remove_check_flag Do_Range_Check (exp_check_flags ?e) _ ->
      well_check_flagged_expr (update_exp_check_flags ?e _) ->
      eval_expr_x _ _ (update_exp_check_flags ?e _) _ ->
      optimize_expression_x _ (update_exp_check_flags ?e _) _ -> _ ,
     H2: well_typed_stack _ _,
     H3: remove_check_flag Do_Range_Check (exp_check_flags ?e) _,
     H4: well_check_flagged_expr (update_exp_check_flags ?e _),
     H5: eval_expr_x _ _ (update_exp_check_flags ?e _) _,
     H6: optimize_expression_x _ (update_exp_check_flags ?e _) _ |- _ ] => 
      specialize (H1 _ _ _ _ _ _ H2 H3 H4 H5 H6); auto
  end.
- (* selected component *)
  match goal with
  | [H: optimize_name_x _ _ _ |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H: eval_name_x _ _ _ _ |- _] => inversion H; clear H; subst
  end;
  match goal with
  | [H: well_check_flagged_name _ |- _] => inversion H; clear H; subst
  end.
  apply Eval_E_Selected_Component_X with (r:=r); auto.
Qed.


Lemma expression_checks_optimization_soundness: forall e e' st s v v',
  well_typed_stack st s ->
    well_check_flagged_expr e ->
      eval_expr_x st s e v ->
        optimize_expression_x st e (v', e') ->
          eval_expr_x st s e' v.
Proof.
  intros.
  specialize (rm_range_check_return_same_expr_checks _ H0); intros HZ1.
  specialize (update_exp_with_same_check_flags e); intros HZ.
  rewrite <- HZ in H0, H1, H2; clear HZ.
  specialize (expression_checks_optimization_soundness_help _ _ _ _ _ _ _ H HZ1 H0 H1 H2); 
  auto.
Qed.




  (* continue .... *)











(* 2014. 08. 16

Lemma expression_checks_optimization_soundness: forall e e' st s v v',
  well_typed_stack st s ->
    well_check_flagged_expr e ->
      eval_expr_x st s e v ->
        optimize_expression_x st e (v', e') ->
          eval_expr_x st s e' v.
Proof.
  apply (expression_x_ind
    (fun e: expression_x => 
       forall (e' : expression_x) (st : symboltable_x) (s : STACK.stack) 
              (v : Return value) (v' : valueO),
      well_typed_stack st s ->
      well_check_flagged_expr e ->
      eval_expr_x st s e v ->
      optimize_expression_x st e (v', e') ->
      eval_expr_x st s e' v)
    (fun n: name_x => 
       forall (n' : name_x) (st : symboltable_x) (s : STACK.stack) 
              (v : Return value) (v' : valueO),
      well_typed_stack st s ->
      well_check_flagged_name n ->
      eval_name_x st s n v ->
      optimize_name_x st n (v', n') ->
      eval_name_x st s n' v)
    ); intros.
- (* Literal *)
  match goal with
  | [H: optimize_expression_x ?st ?e ?e' |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end.
  constructor; auto.
- (* Name *)
  match goal with
  | [H: optimize_expression_x ?st ?e ?e' |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H: well_check_flagged_expr _ |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H1: forall (n' : name_x) (st : symboltable_x) (s : STACK.stack) (v : Return value) (v' : valueO),
      well_typed_stack _ _ ->
      well_check_flagged_name ?n ->
      eval_name_x _ _ ?n _ ->
      optimize_name_x _ ?n _ -> _ ,
     H2: well_typed_stack _ _,
     H3: well_check_flagged_name ?n,
     H4: eval_name_x _ _ ?n _,
     H5: optimize_name_x _ ?n _ |- _ ] => specialize (H1 _ _ _ _ _ H2 H3 H4 H5); auto
  end.
  constructor; auto.
- (* binary expression *)
  match goal with
  | [H: optimize_expression_x ?st ?e ?e' |- _] => inversion H; clear H; subst
  end.
  + (*1. Plus*)
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end;
  match goal with
  | [H: well_check_flagged_expr _ |- _] => inversion H; subst; [ | smack]
  end;
  repeat progress match goal with
  | [H1: forall (e' : expression_x) (st : symboltable_x) (s : STACK.stack) 
                (v : Return value) (v' : valueO),
      well_typed_stack _ _ ->
      well_check_flagged_expr ?e ->
      eval_expr_x _ _ ?e _ ->
      optimize_expression_x _ ?e _ -> _ ,
     H2: well_typed_stack _ _,
     H3: well_check_flagged_expr ?e,
     H4: eval_expr_x _ _ ?e _,
     H5: optimize_expression_x _ ?e _ |- _ ] => specialize (H1 _ _ _ _ _ H2 H3 H4 H5); auto
  end;
  [apply Eval_E_Binary_Operation_RTE_E1_X; auto |
   apply Eval_E_Binary_Operation_RTE_E2_X with (v1 := v1); auto |
   apply Eval_E_Binary_Operation_RTE_Bin_X with (v1 := v1) (v2 := v2); auto |
   apply Eval_E_Binary_Operation_X with (v1 := v1) (v2 := v2); auto
  ].
  admit.
  
  repeat progress match goal with
  | [H: remove_check_flag _ _ _ |- _] => inversion H; clear H; subst; auto
  end. 
  constructor.
  + (*2. Plus Overflow Fail *)
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end;
  match goal with
  | [H: well_check_flagged_expr _ |- _] => inversion H; subst; [ | smack]
  end;
  repeat progress match goal with
  | [H1: forall (e' : expression_x) (st : symboltable_x) (s : STACK.stack) 
                (v : Return value) (v' : valueO),
      well_typed_stack _ _ ->
      well_check_flagged_expr ?e ->
      eval_expr_x _ _ ?e _ ->
      optimize_expression_x _ ?e _ -> _ ,
     H2: well_typed_stack _ _,
     H3: well_check_flagged_expr ?e,
     H4: eval_expr_x _ _ ?e _,
     H5: optimize_expression_x _ ?e _ |- _ ] => specialize (H1 _ _ _ _ _ H2 H3 H4 H5); auto
  end;
  [apply Eval_E_Binary_Operation_RTE_E1_X; auto |
   apply Eval_E_Binary_Operation_RTE_E2_X with (v1 := v1); auto |
   apply Eval_E_Binary_Operation_RTE_Bin_X with (v1 := v1) (v2 := v2); auto |
   apply Eval_E_Binary_Operation_X with (v1 := v1) (v2 := v2); auto
  ].
  + (*3. Minus*)
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end;
  match goal with
  | [H: well_check_flagged_expr _ |- _] => inversion H; subst; [ | smack]
  end;
  repeat progress match goal with
  | [H1: forall (e' : expression_x) (st : symboltable_x) (s : STACK.stack) 
                (v : Return value) (v' : valueO),
      well_typed_stack _ _ ->
      well_check_flagged_expr ?e ->
      eval_expr_x _ _ ?e _ ->
      optimize_expression_x _ ?e _ -> _ ,
     H2: well_typed_stack _ _,
     H3: well_check_flagged_expr ?e,
     H4: eval_expr_x _ _ ?e _,
     H5: optimize_expression_x _ ?e _ |- _ ] => specialize (H1 _ _ _ _ _ H2 H3 H4 H5); auto
  end;
  [apply Eval_E_Binary_Operation_RTE_E1_X; auto |
   apply Eval_E_Binary_Operation_RTE_E2_X with (v1 := v1); auto |
   apply Eval_E_Binary_Operation_RTE_Bin_X with (v1 := v1) (v2 := v2); auto |
   apply Eval_E_Binary_Operation_X with (v1 := v1) (v2 := v2); auto
  ].
  admit.
  
  repeat progress match goal with
  | [H: remove_check_flag _ _ _ |- _] => inversion H; clear H; subst; auto
  end. 
  constructor.
  + (*4. Minus Overflow Fail *)
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end;
  match goal with
  | [H: well_check_flagged_expr _ |- _] => inversion H; subst; [ | smack]
  end;
  repeat progress match goal with
  | [H1: forall (e' : expression_x) (st : symboltable_x) (s : STACK.stack) 
                (v : Return value) (v' : valueO),
      well_typed_stack _ _ ->
      well_check_flagged_expr ?e ->
      eval_expr_x _ _ ?e _ ->
      optimize_expression_x _ ?e _ -> _ ,
     H2: well_typed_stack _ _,
     H3: well_check_flagged_expr ?e,
     H4: eval_expr_x _ _ ?e _,
     H5: optimize_expression_x _ ?e _ |- _ ] => specialize (H1 _ _ _ _ _ H2 H3 H4 H5); auto
  end;
  [apply Eval_E_Binary_Operation_RTE_E1_X; auto |
   apply Eval_E_Binary_Operation_RTE_E2_X with (v1 := v1); auto |
   apply Eval_E_Binary_Operation_RTE_Bin_X with (v1 := v1) (v2 := v2); auto |
   apply Eval_E_Binary_Operation_X with (v1 := v1) (v2 := v2); auto
  ].
  + (*5. Multiplying*)
  match goal with
  | [H: ?op = Multiply \/ ?op = Divide |- _] => inversion H; subst
  end.
  * (*5.1 Multiply*)
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end;
  match goal with
  | [H: well_check_flagged_expr _ |- _] => inversion H; subst; [ | smack]
  end;
  repeat progress match goal with
  | [H1: forall (e' : expression_x) (st : symboltable_x) (s : STACK.stack) 
                (v : Return value) (v' : valueO),
      well_typed_stack _ _ ->
      well_check_flagged_expr ?e ->
      eval_expr_x _ _ ?e _ ->
      optimize_expression_x _ ?e _ -> _ ,
     H2: well_typed_stack _ _,
     H3: well_check_flagged_expr ?e,
     H4: eval_expr_x _ _ ?e _,
     H5: optimize_expression_x _ ?e _ |- _ ] => specialize (H1 _ _ _ _ _ H2 H3 H4 H5); auto
  end;
  [apply Eval_E_Binary_Operation_RTE_E1_X; auto |
   apply Eval_E_Binary_Operation_RTE_E2_X with (v1 := v1); auto |
   apply Eval_E_Binary_Operation_RTE_Bin_X with (v1 := v1) (v2 := v2); auto |
   apply Eval_E_Binary_Operation_X with (v1 := v1) (v2 := v2); auto
  ].
  * (*5.2 Divide*)
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end;
  match goal with
  | [H: well_check_flagged_expr _ |- _] => inversion H; subst; [smack | | smack]
  end;
  repeat progress match goal with
  | [H1: forall (e' : expression_x) (st : symboltable_x) (s : STACK.stack) 
                (v : Return value) (v' : valueO),
      well_typed_stack _ _ ->
      well_check_flagged_expr ?e ->
      eval_expr_x _ _ ?e _ ->
      optimize_expression_x _ ?e _ -> _ ,
     H2: well_typed_stack _ _,
     H3: well_check_flagged_expr ?e,
     H4: eval_expr_x _ _ ?e _,
     H5: optimize_expression_x _ ?e _ |- _ ] => specialize (H1 _ _ _ _ _ H2 H3 H4 H5); auto
  end;
  [apply Eval_E_Binary_Operation_RTE_E1_X; auto |
   apply Eval_E_Binary_Operation_RTE_E2_X with (v1 := v1); auto |
   apply Eval_E_Binary_Operation_RTE_Bin_X with (v1 := v1) (v2 := v2); auto |
   apply Eval_E_Binary_Operation_X with (v1 := v1) (v2 := v2); auto
  ].
  + (*6. Logical_Operation*)
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end;
  match goal with
  | [H: well_check_flagged_expr _ |- _] => inversion H; subst; [smack | smack | ]
  end;
  repeat progress match goal with
  | [H1: forall (e' : expression_x) (st : symboltable_x) (s : STACK.stack) 
                (v : Return value) (v' : valueO),
      well_typed_stack _ _ ->
      well_check_flagged_expr ?e ->
      eval_expr_x _ _ ?e _ ->
      optimize_expression_x _ ?e _ -> _ ,
     H2: well_typed_stack _ _,
     H3: well_check_flagged_expr ?e,
     H4: eval_expr_x _ _ ?e _,
     H5: optimize_expression_x _ ?e _ |- _ ] => specialize (H1 _ _ _ _ _ H2 H3 H4 H5); auto
  end;
  [apply Eval_E_Binary_Operation_RTE_E1_X; auto |
   apply Eval_E_Binary_Operation_RTE_E2_X with (v1 := v1); auto |
   apply Eval_E_Binary_Operation_RTE_Bin_X with (v1 := v1) (v2 := v2); auto |
   apply Eval_E_Binary_Operation_X with (v1 := v1) (v2 := v2); auto
  ].
- (* unary expression *)
  match goal with
  | [H: optimize_expression_x ?st ?e ?e' |- _] => inversion H; clear H; subst
  end.
  + (*1. Unary_Minus Pass Overflow Check*)
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end; 
  match goal with
  | [H: well_check_flagged_expr _ |- _] => inversion H; subst; [ | smack]
  end;
  match goal with
  | [H1: forall (e' : expression_x) (st : symboltable_x) (s : STACK.stack) 
                (v : Return value) (v' : valueO),
      well_typed_stack _ _ ->
      well_check_flagged_expr ?e ->
      eval_expr_x _ _ ?e _ ->
      optimize_expression_x _ ?e _ -> _ ,
     H2: well_typed_stack _ _,
     H3: well_check_flagged_expr ?e,
     H4: eval_expr_x _ _ ?e _,
     H5: optimize_expression_x _ ?e _ |- _ ] => specialize (H1 _ _ _ _ _ H2 H3 H4 H5); auto
  end;
  [ apply Eval_E_Unary_Operation_RTE_E_X; auto |
    apply Eval_E_Unary_Operation_RTE_X with (v := v0); auto |
    apply Eval_E_Unary_Operation_X with (v := v0); auto
  ].
  admit.
  
  repeat progress match goal with
  | [H: remove_check_flag _ _ _ |- _] => inversion H; clear H; subst; auto
  end. 
  constructor.
  + (*2. Unary_Minus Fail Overflow Check*)
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end; 
  match goal with
  | [H: well_check_flagged_expr _ |- _] => inversion H; subst; [ | smack]
  end;
  match goal with
  | [H1: forall (e' : expression_x) (st : symboltable_x) (s : STACK.stack) 
                (v : Return value) (v' : valueO),
      well_typed_stack _ _ ->
      well_check_flagged_expr ?e ->
      eval_expr_x _ _ ?e _ ->
      optimize_expression_x _ ?e _ -> _ ,
     H2: well_typed_stack _ _,
     H3: well_check_flagged_expr ?e,
     H4: eval_expr_x _ _ ?e _,
     H5: optimize_expression_x _ ?e _ |- _ ] => specialize (H1 _ _ _ _ _ H2 H3 H4 H5); auto
  end;
  [ apply Eval_E_Unary_Operation_RTE_E_X; auto |
    apply Eval_E_Unary_Operation_RTE_X with (v := v0); auto |
    apply Eval_E_Unary_Operation_X with (v := v0); auto
  ].
  + (*3. Unary_Plus*)
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end;
  match goal with
  | [H: well_check_flagged_expr _ |- _] => inversion H; subst
  end;
  match goal with
  | [H1: forall (e' : expression_x) (st : symboltable_x) (s : STACK.stack) 
                (v : Return value) (v' : valueO),
      well_typed_stack _ _ ->
      well_check_flagged_expr ?e ->
      eval_expr_x _ _ ?e _ ->
      optimize_expression_x _ ?e _ -> _ ,
     H2: well_typed_stack _ _,
     H3: well_check_flagged_expr ?e,
     H4: eval_expr_x _ _ ?e _,
     H5: optimize_expression_x _ ?e _ |- _ ] => specialize (H1 _ _ _ _ _ H2 H3 H4 H5); auto
  end;
  [ apply Eval_E_Unary_Operation_RTE_E_X; auto |
    apply Eval_E_Unary_Operation_RTE_X with (v := v0); auto |
    apply Eval_E_Unary_Operation_X with (v := v0); auto
  ].
  + (*4. Unary_Not*)
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end;
  match goal with
  | [H: well_check_flagged_expr _ |- _] => inversion H; subst
  end;
  match goal with
  | [H1: forall (e' : expression_x) (st : symboltable_x) (s : STACK.stack) 
                (v : Return value) (v' : valueO),
      well_typed_stack _ _ ->
      well_check_flagged_expr ?e ->
      eval_expr_x _ _ ?e _ ->
      optimize_expression_x _ ?e _ -> _ ,
     H2: well_typed_stack _ _,
     H3: well_check_flagged_expr ?e,
     H4: eval_expr_x _ _ ?e _,
     H5: optimize_expression_x _ ?e _ |- _ ] => specialize (H1 _ _ _ _ _ H2 H3 H4 H5); auto
  end;
  [ apply Eval_E_Unary_Operation_RTE_E_X; auto |
    apply Eval_E_Unary_Operation_RTE_X with (v := v0); auto |
    apply Eval_E_Unary_Operation_X with (v := v0); auto
  ].
- (* identifier *)
  match goal with
  | [H: eval_name_x _ _ _ _ |- _] => inversion H; subst
  end.
  match goal with
  | [H: optimize_name_x _ _ _ |- _] => inversion H; clear H; subst
  end.
  constructor; auto.
- (* indexed component *)
  match goal with
  | [H: optimize_name_x _ _ _ |- _] => inversion H; clear H; subst
  end. 
  + (*1. index pass range check*)
  match goal with
  | [H: eval_name_x _ _ _ _ |- _] => inversion H; clear H; subst
  end.
  *
  match goal with
  | [H: well_check_flagged_name _ |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H1: ~ List.In _ ?ls,
     H2: ?ls = _ |- _] => unfold not in H1; rewrite H2 in H1; smack
  end.
  * 
  match goal with
  | [H: well_check_flagged_name _ |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H1: ~ List.In _ ?ls,
     H2: ?ls = _ |- _] => unfold not in H1; rewrite H2 in H1; smack
  end.
  * 
  match goal with
  | [H: well_check_flagged_name _ |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H: well_check_flagged_expr ?e |- _] => 
      specialize (range_check_not_in_expr _ H); let HZ := fresh "HZ" in intro HZ;
      rewrite update_exp_with_new_check_flags in HZ
  end.
  match goal with
  | [H1: exp_check_flags ?e = ?cks1 ++ ?ck :: ?cks2, 
     H2: exp_check_flags ?e = ?cks0 ++ ?ck :: ?cks3,
     H3: ~(List.In ?ck (?cks0 ++ ?cks3)) |- _] => 
      rewrite H2 in H1; specialize (list_components_equal _ _ _ _ _ H1 H3); 
      let HZ := fresh "HZ" in intro HZ; destruct HZ; subst
  end.
  specialize (remove_range_check_property _ _ _ H4 H7);
  let HZ := fresh "HZ" in intro HZ.
  specialize (optimize_expr_to_same_checkflags _ _ _ _ _ _ _ H11 H18 HZ0);
  let HZ := fresh "HZ" in intro HZ.
  apply Eval_E_Indexed_Component_RTE_X.
  admit.
  (* get stuck here ! ! ! *)

  match goal with
  | [H1: forall (e' : expression_x) (st : symboltable_x) (s : STACK.stack) 
                (v : Return value) (v' : valueO),
      well_typed_stack _ _ ->
      well_check_flagged_expr ?e ->
      eval_expr_x _ _ ?e _ ->
      optimize_expression_x _ ?e _ -> _ ,
     H2: well_typed_stack _ _,
     H3: well_check_flagged_expr ?e,
     H4: eval_expr_x _ _ ?e _,
     H5: optimize_expression_x _ ?e _ |- _ ] => specialize (H1 _ _ _ _ _ H2 H3 H4 H5); auto
  end.
  + (*2. index fail range check*)
  match goal with
  | [H: eval_name_x _ _ _ _ |- _] => inversion H; clear H; subst
  end;
  match goal with
  | [H: well_check_flagged_name _ |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H1: ~ List.In _ ?ls,
     H2: ?ls = _ |- _] => unfold not in H1; rewrite H2 in H1; smack
  end.
  match goal with
  | [H1: fetch_exp_type_x ?x ?st = _,
     H2: fetch_exp_type_x ?x ?st = _ |- _] => rewrite H1 in H2; clear H1; inversion H2; subst
  end.
  specialize (extract_array_index_range_x_unique _ _ _ _ _ _ H15 H19); 
  let HZ := fresh "HZ" in intro HZ; destruct HZ; subst. 
  admit.
- (* selected component *)
  match goal with
  | [H: optimize_name_x _ _ _ |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H: eval_name_x _ _ _ _ |- _] => inversion H; clear H; subst
  end;
  match goal with
  | [H: well_check_flagged_name _ |- _] => inversion H; clear H; subst
  end.
  admit.
Qed.
*)






(*
Lemma expression_checks_optimization_soundness: forall e checkflags st s v v' e',
  remove_check_flag Do_Range_Check (exp_check_flags e) checkflags ->
      eval_expr_x st s (update_exp_check_flags e checkflags) v ->
        optimize_expression_x st (update_exp_check_flags e checkflags) (v', e') ->
          eval_expr_x st s e' v.
*)
Lemma statement_checks_optimization_soundness: forall st s c s' c',
  eval_stmt_x st s c s' ->
    optimize_statement_x st c c' ->
      eval_stmt_x st s c' s'.
Proof.
  intros st s c s' c' H; revert c'.
  induction H; intros.
- admit.
- match goal with
  | [H: optimize_statement_x _ _ _ |- _] => inversion H; clear H; subst
  end.
  apply Eval_S_Assignment_RTE_X; auto; admit.
  apply Eval_S_Assignment_RTE_X; auto; admit.
- match goal with
  | [H: optimize_statement_x _ _ _ |- _] => inversion H; clear H; subst
  end.
  apply Eval_S_Assignment_X with (v := v); auto; admit.
  apply Eval_S_Assignment_X with (v := v); auto; admit.
- match goal with
  | [H: optimize_statement_x _ _ _ |- _] => inversion H; clear H; subst
  end.
  apply Eval_S_Assignment_RTE_X; auto; admit.
  apply Eval_S_Assignment_E_RTE_X with (cks1 := cks1) (cks2 := cks2); auto.
  
Qed.






(*/////////////////////////////////////////////////////////////////////////////*)
(*/////////////////////////////////////////////////////////////////////////////*)
(*/////////////////////////////////////////////////////////////////////////////*)



(** 
It's impossible to prove the following theorem directly, as we do induction 
proof on it, the proof will get stuck when e is an indexed_component, e.g. a[e]; 
the induction proof will generate a premise for e in the following theorem form,
where (eval_expr_x st s e v) is impossible to be true as e has Do_Range_Check flag, 
which is not acceptible by the semantics of eval_expr_x;

- Theorem expression_checks_optimization_soundness: forall e e' st s v v',
    eval_expr_x st s e v ->
      optimize_expression_x st e (v', e') ->
        eval_expr_x st s e' v.
*)

Lemma expression_checks_optimization_soundness: forall e e' st s v v',
  eval_expr_x st s e v ->
    optimize_expression_x st e (v', e') ->
      eval_expr_x st s e' v.
Proof.
  apply (expression_x_ind
    (fun e: expression_x => 
       forall (e' : expression_x) (st: symboltable_x) (s : STACK.stack) (v: Return value) (v': valueO),
      eval_expr_x st s e v ->
      optimize_expression_x st e (v', e') ->
      eval_expr_x st s e' v)
    (fun n: name_x => 
       forall (n' : name_x) (st: symboltable_x) (s : STACK.stack) (v: Return value) (v': valueO),
      eval_name_x st s n v ->
      optimize_name_x st n (v', n') ->
      eval_name_x st s n' v)
    ); smack.
- match goal with
  | [H: optimize_expression_x ?st ?e ?e' |- _] => inversion H; clear H; subst; auto
  end.
- match goal with
  | [H: optimize_expression_x ?st ?e ?e' |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H: eval_expr_x ?st ?s ?e ?v |- _] => inversion H; clear H; subst
  end.
  specialize (H _ _ _ _ _ H8 H4).
  constructor; auto.
- 
(*
  match goal with
  | [H: optimize_expression_x ?st ?e ?e' |- _] => inversion H; clear H; subst
  end;
  match goal with
  | [H: eval_expr_x ?st ?s ?e ?v |- _] => inversion H; clear H; subst
  end;
  repeat progress match goal with
  | [H1: forall (e' : expression_x) (st : symboltable_x) 
        (s : STACK.stack) (v : Return value) (v' : valueO),
      eval_expr_x _ _ ?e _ ->
      optimize_expression_x _ ?e _ -> eval_expr_x _ _ _ _,
     H2: eval_expr_x _ _ ?e _,
     H3: optimize_expression_x _ ?e _ |- _] => 
    specialize (H1 _ _ _ _ _ H2 H3)
  end;
  solve 
  [ apply Eval_E_Binary_Operation_RTE_E1_X; auto |
    apply Eval_E_Binary_Operation_RTE_E2_X with (v1 := v1); auto |
    apply Eval_E_Binary_Operation_RTE_Bin_X with (v1 := v1) (v2 := v2); auto; admit |
    apply Eval_E_Binary_Operation_X with (v1 := v1) (v2 := v2); auto; admit
  ].
*)
  match goal with
  | [H: optimize_expression_x ?st ?e ?e' |- _] => inversion H; clear H; subst
  end.
  + (* 1 *)
  match goal with
  | [H: eval_expr_x ?st ?s ?e ?v |- _] => inversion H; clear H; subst
  end;
  repeat progress match goal with
  | [H1: forall (e' : expression_x) (st : symboltable_x) 
        (s : STACK.stack) (v : Return value) (v' : valueO),
      eval_expr_x _ _ ?e _ ->
      optimize_expression_x _ ?e _ -> eval_expr_x _ _ _ _,
     H2: eval_expr_x _ _ ?e _,
     H3: optimize_expression_x _ ?e _ |- _] => 
    specialize (H1 _ _ _ _ _ H2 H3)
  end;
  solve 
  [ apply Eval_E_Binary_Operation_RTE_E1_X; auto |
    apply Eval_E_Binary_Operation_RTE_E2_X with (v1 := v1); auto |
    apply Eval_E_Binary_Operation_RTE_Bin_X with (v1 := v1) (v2 := v2); auto; admit |
    apply Eval_E_Binary_Operation_X with (v1 := v1) (v2 := v2); auto; admit
  ].
  + (* 2 *)
  match goal with
  | [H: eval_expr_x ?st ?s ?e ?v |- _] => inversion H; clear H; subst
  end;
  repeat progress match goal with
  | [H1: forall (e' : expression_x) (st : symboltable_x) 
        (s : STACK.stack) (v : Return value) (v' : valueO),
      eval_expr_x _ _ ?e _ ->
      optimize_expression_x _ ?e _ -> eval_expr_x _ _ _ _,
     H2: eval_expr_x _ _ ?e _,
     H3: optimize_expression_x _ ?e _ |- _] => 
    specialize (H1 _ _ _ _ _ H2 H3)
  end;
  [ apply Eval_E_Binary_Operation_RTE_E1_X; auto |
    apply Eval_E_Binary_Operation_RTE_E2_X with (v1 := v1); auto |
    apply Eval_E_Binary_Operation_RTE_Bin_X with (v1 := v1) (v2 := v2); auto; admit |
    apply Eval_E_Binary_Operation_X with (v1 := v1) (v2 := v2); auto; admit
  ].
  + (* 3 *)
  match goal with
  | [H: eval_expr_x ?st ?s ?e ?v |- _] => inversion H; clear H; subst
  end;
  repeat progress match goal with
  | [H1: forall (e' : expression_x) (st : symboltable_x) 
        (s : STACK.stack) (v : Return value) (v' : valueO),
      eval_expr_x _ _ ?e _ ->
      optimize_expression_x _ ?e _ -> eval_expr_x _ _ _ _,
     H2: eval_expr_x _ _ ?e _,
     H3: optimize_expression_x _ ?e _ |- _] => 
    specialize (H1 _ _ _ _ _ H2 H3)
  end;
  [ apply Eval_E_Binary_Operation_RTE_E1_X; auto |
    apply Eval_E_Binary_Operation_RTE_E2_X with (v1 := v1); auto |
    apply Eval_E_Binary_Operation_RTE_Bin_X with (v1 := v1) (v2 := v2); auto; admit |
    apply Eval_E_Binary_Operation_X with (v1 := v1) (v2 := v2); auto; admit
  ].  
  + (* 4 *)
  match goal with
  | [H: eval_expr_x ?st ?s ?e ?v |- _] => inversion H; clear H; subst
  end;
  repeat progress match goal with
  | [H1: forall (e' : expression_x) (st : symboltable_x) 
        (s : STACK.stack) (v : Return value) (v' : valueO),
      eval_expr_x _ _ ?e _ ->
      optimize_expression_x _ ?e _ -> eval_expr_x _ _ _ _,
     H2: eval_expr_x _ _ ?e _,
     H3: optimize_expression_x _ ?e _ |- _] => 
    specialize (H1 _ _ _ _ _ H2 H3)
  end;
  [ apply Eval_E_Binary_Operation_RTE_E1_X; auto |
    apply Eval_E_Binary_Operation_RTE_E2_X with (v1 := v1); auto |
    apply Eval_E_Binary_Operation_RTE_Bin_X with (v1 := v1) (v2 := v2); auto; admit |
    apply Eval_E_Binary_Operation_X with (v1 := v1) (v2 := v2); auto; admit
  ].
  + (* 5 *)
  match goal with
  | [H: eval_expr_x ?st ?s ?e ?v |- _] => inversion H; clear H; subst
  end;
  repeat progress match goal with
  | [H1: forall (e' : expression_x) (st : symboltable_x) 
        (s : STACK.stack) (v : Return value) (v' : valueO),
      eval_expr_x _ _ ?e _ ->
      optimize_expression_x _ ?e _ -> eval_expr_x _ _ _ _,
     H2: eval_expr_x _ _ ?e _,
     H3: optimize_expression_x _ ?e _ |- _] => 
    specialize (H1 _ _ _ _ _ H2 H3)
  end;
  [ apply Eval_E_Binary_Operation_RTE_E1_X; auto |
    apply Eval_E_Binary_Operation_RTE_E2_X with (v1 := v1); auto |
    apply Eval_E_Binary_Operation_RTE_Bin_X with (v1 := v1) (v2 := v2); auto; admit |
    apply Eval_E_Binary_Operation_X with (v1 := v1) (v2 := v2); auto; admit
  ].
  + (* 6 *)
  match goal with
  | [H: eval_expr_x ?st ?s ?e ?v |- _] => inversion H; clear H; subst
  end;
  repeat progress match goal with
  | [H1: forall (e' : expression_x) (st : symboltable_x) 
        (s : STACK.stack) (v : Return value) (v' : valueO),
      eval_expr_x _ _ ?e _ ->
      optimize_expression_x _ ?e _ -> eval_expr_x _ _ _ _,
     H2: eval_expr_x _ _ ?e _,
     H3: optimize_expression_x _ ?e _ |- _] => 
    specialize (H1 _ _ _ _ _ H2 H3)
  end;
  [ apply Eval_E_Binary_Operation_RTE_E1_X; auto |
    apply Eval_E_Binary_Operation_RTE_E2_X with (v1 := v1); auto |
    apply Eval_E_Binary_Operation_RTE_Bin_X with (v1 := v1) (v2 := v2); auto; admit |
    apply Eval_E_Binary_Operation_X with (v1 := v1) (v2 := v2); auto; admit
  ].
- match goal with
  | [H: optimize_expression_x ?st ?e ?e' |- _] => inversion H; clear H; subst
  end;
  match goal with
  | [H: eval_expr_x ?st ?s ?e ?v |- _] => inversion H; clear H; subst
  end;
  match goal with
  | [H1: forall (e' : expression_x) (st : symboltable_x) 
        (s : STACK.stack) (v : Return value) (v' : valueO),
      eval_expr_x _ _ ?e _ ->
      optimize_expression_x _ ?e _ -> eval_expr_x _ _ _ _,
     H2: eval_expr_x _ _ ?e _,
     H3: optimize_expression_x _ ?e _ |- _] => 
    specialize (H1 _ _ _ _ _ H2 H3)
  end;
  solve
  [ apply Eval_E_Unary_Operation_RTE_E_X; auto |
    apply Eval_E_Unary_Operation_RTE_X with (v := v0); auto; admit |
    apply Eval_E_Unary_Operation_X with (v := v0); auto; admit
  ].
- match goal with
  | [H: optimize_name_x ?st ?n ?n' |- _] => inversion H; clear H; subst
  end;
  match goal with
  | [H: eval_name_x ?st ?s ?n ?v |- _] => inversion H; clear H; subst
  end.
  constructor; auto.
- match goal with
  | [H: optimize_name_x ?st ?n ?n' |- _] => inversion H; clear H; subst
  end.
  + 
  match goal with
  | [H: eval_name_x ?st ?s ?n ?v |- _] => inversion H; clear H; subst
  end;
  match goal with
  | [H1: forall (e' : expression_x) (st : symboltable_x) 
        (s : STACK.stack) (v : Return value) (v' : valueO),
      eval_expr_x _ _ ?e _ ->
      optimize_expression_x _ ?e _ -> eval_expr_x _ _ _ _,
     H2: eval_expr_x _ _ ?e _,
     H3: optimize_expression_x _ ?e _ |- _] => 
    specialize (H1 _ _ _ _ _ H2 H3)
  | _ => idtac
  end.
  apply Eval_E_Indexed_Component_RTE_X; auto; admit.
  apply Eval_E_Indexed_Component_X with (i := i0) (a := a1); auto; admit.
  apply Eval_E_Indexed_Component_E_RTE_X.
  apply Eval_E_Indexed_Component_Range_RTE_X.
  apply Eval_E_Indexed_Component_Range_X.
  constructor; auto.








Qed.


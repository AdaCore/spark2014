Require Export checks_optimization.
Require Export checks_generator.

Scheme expression_x_ind := Induction for expression_x Sort Prop 
                         with name_x_ind := Induction for name_x Sort Prop.

Section Checks_Optimization_Help_Lemmas.

(*
Lemma no_range_check_on_top_expr: forall e st s v,
  eval_expr_x st s e v ->
     ~(List.In Do_Range_Check (exp_check_flags e)).
Proof.
  apply (expression_x_ind
    (fun e: expression_x => 
       forall (st: symboltable_x) (s : STACK.stack) (v: Return value),
      eval_expr_x st s e v ->
      ~(List.In Do_Range_Check (exp_check_flags e)))
    (fun n: name_x => 
       forall (st: symboltable_x) (s : STACK.stack) (v: Return value),
      eval_name_x st s n v ->
      ~(List.In Do_Range_Check (name_check_flags n)))
    ); intros.
- match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; smack 
  end.
- match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; smack 
  end. 
- match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; smack 
  end.
  specialize (H _ _ _ H10).
  apply H. auto.
  
Qed.
*)

(** the value of variable and and record field are well-typed according to
    the symbol table;

    TODO: to be completed !
 *)
Inductive well_typed_stack: symboltable_x -> STACK.stack -> Prop :=
  | WTS: forall st s,
      well_typed_stack st s. 

(** the well-formedness of run-time check flagged expressions that 
    are generated by expression check generator;
 *)
Inductive well_check_flagged_expr: expression_x -> Prop :=
  | WCF_Literal: forall ast_num l,
      well_check_flagged_expr (E_Literal_X ast_num l nil)
  | WCF_Name: forall ast_num n,
      well_check_flagged_name n ->
      well_check_flagged_expr (E_Name_X ast_num n nil)
  | WCF_Binary_Operation_Overflow: forall op e1 e2 ast_num,
      op = Plus \/ op = Minus \/ op = Multiply ->
      well_check_flagged_expr e1 ->
      well_check_flagged_expr e2 ->
      well_check_flagged_expr (E_Binary_Operation_X ast_num op e1 e2 (Do_Overflow_Check :: nil))
  | WCF_Binary_Operation_Division: forall e1 e2 ast_num,
      well_check_flagged_expr e1 ->
      well_check_flagged_expr e2 ->
      well_check_flagged_expr (E_Binary_Operation_X ast_num Divide e1 e2 (Do_Division_Check :: Do_Overflow_Check :: nil))
  | WCF_Binary_Operation_Others: forall op e1 e2 ast_num,
      op <> Plus /\ op <> Minus /\ op <> Multiply /\ op <> Divide ->
      well_check_flagged_expr e1 ->
      well_check_flagged_expr e2 ->
      well_check_flagged_expr (E_Binary_Operation_X ast_num op e1 e2 nil)
  | WCF_Unary_Operation_Overflow: forall e ast_num,
      well_check_flagged_expr e ->
      well_check_flagged_expr (E_Unary_Operation_X ast_num Unary_Minus e (Do_Overflow_Check :: nil))
  | WCF_Unary_Operation_Others: forall op e ast_num,
      op <> Unary_Minus ->
      well_check_flagged_expr e ->
      well_check_flagged_expr (E_Unary_Operation_X ast_num op e nil)

with well_check_flagged_name: name_x -> Prop :=
  | WCF_Identifier: forall ast_num x,
      well_check_flagged_name (E_Identifier_X ast_num x nil)
  | WCF_Indexed_Component: forall e cks1 cks2 ast_num x_ast_num x,
      exp_check_flags e = cks1 ++ Do_Range_Check :: cks2 ->
      well_check_flagged_expr (update_exp_check_flags e (cks1 ++ cks2)) ->
      well_check_flagged_name (E_Indexed_Component_X ast_num x_ast_num x e nil)
  | WCF_Selected_Component: forall ast_num x_ast_num x f,
      well_check_flagged_name (E_Selected_Component_X ast_num x_ast_num x f nil).

Axiom well_check_flagged_generated_expr: forall st e e',
  compile2_flagged_exp st nil e e' ->
    well_check_flagged_expr e'.

Axiom well_check_flagged_generated_name: forall st n n',
  compile2_flagged_name st nil n n' ->
    well_check_flagged_name n'.

(** for an expression updated with some new check flags, its resulting check flags should
    be the newly updated check flags;
 *)

Lemma update_exp_with_new_check_flags: forall e newCheckFlags, 
 (exp_check_flags (update_exp_check_flags e newCheckFlags)) = newCheckFlags.
Proof.
  intros.
  destruct e; auto.
  destruct n; auto.
Qed.


(** for a stand alone expression, which does not appear in any context such 
    as index of array, then it should have no Do_Range_Check flag;
*)
Lemma range_check_not_in_expr: forall e,
  well_check_flagged_expr e ->
    ~(List.In Do_Range_Check (exp_check_flags e)).
Proof.
  intros;
  destruct e; smack;
  match goal with
  | [H: well_check_flagged_expr _ |- _] => inversion H; clear H; smack
  end;
  match goal with
  | [H: well_check_flagged_name _ |- _] => inversion H; clear H; smack
  end.
Qed.

Lemma rm_range_check_return_same_expr_checks: forall e,
  well_check_flagged_expr e ->
    remove_check_flag Do_Range_Check (exp_check_flags e) (exp_check_flags e).
Proof.
  intros.
  specialize (range_check_not_in_expr _ H); smack.
  induction (exp_check_flags e).
  constructor.
  destruct a; smack;
  apply R_Check_Flag_Tail; smack.
Qed.

Axiom list_components_equal: forall ls1 (e: check_flag) ls2 ls1' ls2',
  ls1 ++ e :: ls2 = ls1' ++ e :: ls2' ->
  ~(List.In e (ls1 ++ ls2)) ->
  ls1 = ls1' /\ ls2 = ls2'.


(** for any variable in stack, its value should be in the domain of its type 
    
    TODO: to be proved !
*)
Axiom variable_value_in_type_domain: forall st s x_ast_num x v t l u,
  well_typed_stack st s ->
    eval_name_x st s (E_Identifier_X x_ast_num x nil) (Normal (BasicV (Int v))) ->
      fetch_exp_type_x x_ast_num st = Some t ->
        valueO_of_type st t (IntBetween l u) ->
          (Zge_bool v l) && (Zle_bool v u) = true.

(** if e is a run-time-check-annotated expression generated by our formalized 
    run-time check generator, then it should have at most one Do_Range_Check if
    there exists Do_Range_Check in expression e;
 *)
Axiom remove_range_check_property: forall e cks1 cks2,
  exp_check_flags e = cks1 ++ Do_Range_Check :: cks2 ->
  well_check_flagged_expr (update_exp_check_flags e (cks1 ++ cks2)) ->
  remove_check_flag Do_Range_Check (exp_check_flags e) (cks1 ++ cks2).


(** Do_Range_Check is performed and optimized by the context where the expression
    appears, and the expression itself can only perform and optimize Do_Overflow_Check
    and Do_Division_Check, so whether removing Do_Range_Check or not doesn't affect 
    the value of the expression itself in optimize_expression_x;
 *)

Axiom optimize_expr_to_same_rangevalue: forall e checkflags st l u e' l' u' e'',
  remove_check_flag Do_Range_Check (exp_check_flags e) checkflags ->
  optimize_expression_x st (update_exp_check_flags e checkflags) (IntBetween l u, e') ->
  optimize_expression_x st e (IntBetween l' u', e'') ->
  l = l' /\ u = u'.


(** The way to first remove Do_Range_Check from the expression, 
    and then do other checks optimization, its resulting expression should 
    be the same as the expression optimized in the reverse way: that's, first
    optimize the expression, then remove its Do_Range_Check;
*)
(*
Axiom optimize_expr_to_same_checkflags: forall e checkflags st l u e' l' u' e'' checkflags',
  remove_check_flag Do_Range_Check (exp_check_flags e) checkflags ->
  optimize_expression_x st (update_exp_check_flags e checkflags) (IntBetween l u, e') ->
  optimize_expression_x st e (IntBetween l' u', e'') ->
  remove_check_flag Do_Range_Check (exp_check_flags e'') checkflags' ->
  checkflags' = (exp_check_flags e').
*)
Axiom optimize_expr_to_same_checkflags: forall st e l u e' checkflags checkflags',
  optimize_expression_x st e (IntBetween l u, e') ->
  remove_check_flag Do_Range_Check (exp_check_flags e') checkflags ->
  remove_check_flag Do_Range_Check (exp_check_flags e) checkflags' ->
  optimize_expression_x st (update_exp_check_flags e checkflags') 
                           (IntBetween l u, (update_exp_check_flags e' checkflags)).


Lemma eval_expr_value_in_domain: forall e e' checkflags st s v l u,
  well_typed_stack st s ->
    remove_check_flag Do_Range_Check (exp_check_flags e) checkflags ->
      well_check_flagged_expr (update_exp_check_flags e checkflags) ->
        eval_expr_x st s (update_exp_check_flags e checkflags) (Normal (BasicV (Int v))) ->
          optimize_expression_x st (update_exp_check_flags e checkflags) (IntBetween l u, e') ->
            (Zge_bool v l) && (Zle_bool v u) = true.
Proof.
  apply (expression_x_ind
    (fun e: expression_x => 
       forall (e' : expression_x) (checkflags : check_flags) (st : symboltable_x) (s : STACK.stack) 
              (v l u : Z),
      well_typed_stack st s ->
      remove_check_flag Do_Range_Check (exp_check_flags e) checkflags ->
      well_check_flagged_expr (update_exp_check_flags e checkflags) ->
      eval_expr_x st s (update_exp_check_flags e checkflags) (Normal (BasicV (Int v))) ->
      optimize_expression_x st (update_exp_check_flags e checkflags) (IntBetween l u, e') ->
      (Zge_bool v l) && (Zle_bool v u) = true)
    (fun n: name_x => 
       forall (n' : name_x) (checkflags : check_flags) (st : symboltable_x) (s : STACK.stack) 
              (v l u : Z),
      well_typed_stack st s ->
      remove_check_flag Do_Range_Check (name_check_flags n) checkflags ->
      well_check_flagged_name (update_name_check_flags n checkflags) ->
      eval_name_x st s (update_name_check_flags n checkflags) (Normal (BasicV (Int v))) ->
      optimize_name_x st (update_name_check_flags n checkflags) (IntBetween l u, n') ->
      (Zge_bool v l) && (Zle_bool v u) = true)
    ); intros.
- (*Literal*)
  match goal with
  | [H: optimize_expression_x ?st ?e ?e' |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end. 
  repeat progress match goal with
  | [H: eval_literalO _ = _ |- _] => unfold eval_literalO in H
  | [H: eval_literal _ = _ |- _] => unfold eval_literal in H
  end.
  destruct l; inversion H6; inversion H7; subst.
  admit.
- (* Name *)
  match goal with
  | [H: optimize_expression_x ?st ?e ?e' |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H: well_check_flagged_expr _ |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H: remove_check_flag _ (exp_check_flags (E_Name_X _ _ _)) _ |- _] => simpl in H
  end.
  match goal with
  | [H1: forall (n' : name_x) (checkflags : check_flags) (st : symboltable_x) 
                (s : STACK.stack) (v l u : Z),
      well_typed_stack _ _ ->
      remove_check_flag Do_Range_Check (name_check_flags ?n) _ ->
      well_check_flagged_name (update_name_check_flags ?n _) ->
      eval_name_x _ _ (update_name_check_flags ?n _) _ ->
      optimize_name_x _ (update_name_check_flags ?n _) _ -> _ ,
     H2: well_typed_stack _ _,
     H3: remove_check_flag Do_Range_Check (name_check_flags ?n) _,
     H4: well_check_flagged_name (update_name_check_flags ?n _),
     H5: eval_name_x _ _ (update_name_check_flags ?n _) _,
     H6: optimize_name_x _ (update_name_check_flags ?n _) _ |- _ ] => 
      specialize (H1 _ _ _ _ _ _ _ H2 H3 H4 H5 H6); auto
  end.
- (* binary expression *)
  match goal with
  | [H: optimize_expression_x _ _ _ |- _] => inversion H; clear H; subst
  end.
  + (*1*)
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H: Val.binary_operation ?op ?v1 ?v2 = _ |- _] => 
      destruct v1, v2; inversion H; clear H;
      [ destruct v0, v1 | destruct v0 | destruct v0]; inversion H5; subst
  end.
  match goal with
  | [H: well_check_flagged_expr _ |- _] => simpl in H; inversion H; clear H; subst
  end.
  match goal with
  | [H: well_check_flagged_expr e |- _] => 
      let H1 := fresh "HZ" in 
      specialize (rm_range_check_return_same_expr_checks _ H); intros H1
  end.
  match goal with
  | [H: well_check_flagged_expr e0 |- _] => 
      let H1 := fresh "HZ" in 
      specialize (rm_range_check_return_same_expr_checks _ H); intros H1
  end.
  repeat progress match goal with
  | [H1: optimize_expression_x _ e _,
     H2: eval_expr_x _ _ e _,
     H3: well_check_flagged_expr e |- _] => 
      let HZ := fresh "HZ" in
      specialize (update_exp_with_new_check_flags e); intro HZ; rewrite <- HZ in H1, H2, H3; clear HZ
  | [H1: optimize_expression_x _ e0 _,
     H2: eval_expr_x _ _ e0 _,
     H3: well_check_flagged_expr e0 |- _] => 
      let HZ := fresh "HZ" in
      specialize (update_exp_with_new_check_flags e0); intro HZ; rewrite <- HZ in H1, H2, H3; clear HZ
  end.
  repeat progress match goal with
  | [H1: forall (e' : expression_x) (checkflags : check_flags) (st : symboltable_x) 
                (s : STACK.stack) (v l u : Z),
      well_typed_stack _ _ ->
      remove_check_flag Do_Range_Check (exp_check_flags ?e) _ ->
      well_check_flagged_expr (update_exp_check_flags ?e _) ->
      eval_expr_x _ _ (update_exp_check_flags ?e _) _ ->
      optimize_expression_x _ (update_exp_check_flags ?e _) _ -> _ ,
     H2: well_typed_stack _ _,
     H3: remove_check_flag Do_Range_Check (exp_check_flags ?e) _,
     H4: well_check_flagged_expr (update_exp_check_flags ?e _),
     H5: eval_expr_x _ _ (update_exp_check_flags ?e _) _,
     H6: optimize_expression_x _ (update_exp_check_flags ?e _) _ |- _ ] => 
      specialize (H1 _ _ _ _ _ _ _ H2 H3 H4 H5 H6); auto
  end.
  admit.
  inversion H8; smack.
  + (*2*)
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H: Val.binary_operation ?op ?v1 ?v2 = _ |- _] => 
      destruct v1, v2; inversion H; clear H;
      [ destruct v0, v1 | destruct v0 | destruct v0]; inversion H5; subst
  end.
  match goal with
  | [H: well_check_flagged_expr _ |- _] => simpl in H; inversion H; clear H; subst
  end.
  match goal with
  | [H: well_check_flagged_expr e |- _] => 
      let H1 := fresh "HZ" in 
      specialize (rm_range_check_return_same_expr_checks _ H); intros H1
  end.
  match goal with
  | [H: well_check_flagged_expr e0 |- _] => 
      let H1 := fresh "HZ" in 
      specialize (rm_range_check_return_same_expr_checks _ H); intros H1
  end.
  repeat progress match goal with
  | [H1: optimize_expression_x _ e _,
     H2: eval_expr_x _ _ e _,
     H3: well_check_flagged_expr e |- _] => 
      let HZ := fresh "HZ" in
      specialize (update_exp_with_new_check_flags e); intro HZ; rewrite <- HZ in H1, H2, H3; clear HZ
  | [H1: optimize_expression_x _ e0 _,
     H2: eval_expr_x _ _ e0 _,
     H3: well_check_flagged_expr e0 |- _] => 
      let HZ := fresh "HZ" in
      specialize (update_exp_with_new_check_flags e0); intro HZ; rewrite <- HZ in H1, H2, H3; clear HZ
  end.
  repeat progress match goal with
  | [H1: forall (e' : expression_x) (checkflags : check_flags) (st : symboltable_x) 
                (s : STACK.stack) (v l u : Z),
      well_typed_stack _ _ ->
      remove_check_flag Do_Range_Check (exp_check_flags ?e) _ ->
      well_check_flagged_expr (update_exp_check_flags ?e _) ->
      eval_expr_x _ _ (update_exp_check_flags ?e _) _ ->
      optimize_expression_x _ (update_exp_check_flags ?e _) _ -> _ ,
     H2: well_typed_stack _ _,
     H3: remove_check_flag Do_Range_Check (exp_check_flags ?e) _,
     H4: well_check_flagged_expr (update_exp_check_flags ?e _),
     H5: eval_expr_x _ _ (update_exp_check_flags ?e _) _,
     H6: optimize_expression_x _ (update_exp_check_flags ?e _) _ |- _ ] => 
      specialize (H1 _ _ _ _ _ _ _ H2 H3 H4 H5 H6); auto
  end.
  repeat progress match goal with
  | [H: do_flagged_checks_on_binop _ ?op ?v1 ?v2 _ |- _] => inversion H; clear H; subst
  | [H: do_flagged_check_on_binop _ ?op ?v1 ?v2 _ |- _] => inversion H; clear H; subst
  | [H: do_overflow_check_on_binop ?op ?v1 ?v2 _ |- _] => inversion H; clear H; subst
  | [H: Val.binary_operation ?op ?v1 ?v2 = _ |- _] => simpl in H; inversion H; subst
  end; auto.
  inversion H8; smack.
  + (*3*)
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H: Val.binary_operation ?op ?v1 ?v2 = _ |- _] => 
      destruct v1, v2; inversion H; clear H;
      [ destruct v0, v1 | destruct v0 | destruct v0]; inversion H5; subst
  end.
  match goal with
  | [H: well_check_flagged_expr _ |- _] => simpl in H; inversion H; clear H; subst
  end.
  match goal with
  | [H: well_check_flagged_expr e |- _] => 
      let H1 := fresh "HZ" in 
      specialize (rm_range_check_return_same_expr_checks _ H); intros H1
  end.
  match goal with
  | [H: well_check_flagged_expr e0 |- _] => 
      let H1 := fresh "HZ" in 
      specialize (rm_range_check_return_same_expr_checks _ H); intros H1
  end.
  repeat progress match goal with
  | [H1: optimize_expression_x _ e _,
     H2: eval_expr_x _ _ e _,
     H3: well_check_flagged_expr e |- _] => 
      let HZ := fresh "HZ" in
      specialize (update_exp_with_new_check_flags e); intro HZ; rewrite <- HZ in H1, H2, H3; clear HZ
  | [H1: optimize_expression_x _ e0 _,
     H2: eval_expr_x _ _ e0 _,
     H3: well_check_flagged_expr e0 |- _] => 
      let HZ := fresh "HZ" in
      specialize (update_exp_with_new_check_flags e0); intro HZ; rewrite <- HZ in H1, H2, H3; clear HZ
  end.
  repeat progress match goal with
  | [H1: forall (e' : expression_x) (checkflags : check_flags) (st : symboltable_x) 
                (s : STACK.stack) (v l u : Z),
      well_typed_stack _ _ ->
      remove_check_flag Do_Range_Check (exp_check_flags ?e) _ ->
      well_check_flagged_expr (update_exp_check_flags ?e _) ->
      eval_expr_x _ _ (update_exp_check_flags ?e _) _ ->
      optimize_expression_x _ (update_exp_check_flags ?e _) _ -> _ ,
     H2: well_typed_stack _ _,
     H3: remove_check_flag Do_Range_Check (exp_check_flags ?e) _,
     H4: well_check_flagged_expr (update_exp_check_flags ?e _),
     H5: eval_expr_x _ _ (update_exp_check_flags ?e _) _,
     H6: optimize_expression_x _ (update_exp_check_flags ?e _) _ |- _ ] => 
      specialize (H1 _ _ _ _ _ _ _ H2 H3 H4 H5 H6); auto
  end.
  admit.
  inversion H8; smack.
  + (*4*)
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H: Val.binary_operation ?op ?v1 ?v2 = _ |- _] => 
      destruct v1, v2; inversion H; clear H;
      [ destruct v0, v1 | destruct v0 | destruct v0]; inversion H5; subst
  end.
  match goal with
  | [H: well_check_flagged_expr _ |- _] => simpl in H; inversion H; clear H; subst
  end.
  match goal with
  | [H: well_check_flagged_expr e |- _] => 
      let H1 := fresh "HZ" in 
      specialize (rm_range_check_return_same_expr_checks _ H); intros H1
  end.
  match goal with
  | [H: well_check_flagged_expr e0 |- _] => 
      let H1 := fresh "HZ" in 
      specialize (rm_range_check_return_same_expr_checks _ H); intros H1
  end.
  repeat progress match goal with
  | [H1: optimize_expression_x _ e _,
     H2: eval_expr_x _ _ e _,
     H3: well_check_flagged_expr e |- _] => 
      let HZ := fresh "HZ" in
      specialize (update_exp_with_new_check_flags e); intro HZ; rewrite <- HZ in H1, H2, H3; clear HZ
  | [H1: optimize_expression_x _ e0 _,
     H2: eval_expr_x _ _ e0 _,
     H3: well_check_flagged_expr e0 |- _] => 
      let HZ := fresh "HZ" in
      specialize (update_exp_with_new_check_flags e0); intro HZ; rewrite <- HZ in H1, H2, H3; clear HZ
  end.
  repeat progress match goal with
  | [H1: forall (e' : expression_x) (checkflags : check_flags) (st : symboltable_x) 
                (s : STACK.stack) (v l u : Z),
      well_typed_stack _ _ ->
      remove_check_flag Do_Range_Check (exp_check_flags ?e) _ ->
      well_check_flagged_expr (update_exp_check_flags ?e _) ->
      eval_expr_x _ _ (update_exp_check_flags ?e _) _ ->
      optimize_expression_x _ (update_exp_check_flags ?e _) _ -> _ ,
     H2: well_typed_stack _ _,
     H3: remove_check_flag Do_Range_Check (exp_check_flags ?e) _,
     H4: well_check_flagged_expr (update_exp_check_flags ?e _),
     H5: eval_expr_x _ _ (update_exp_check_flags ?e _) _,
     H6: optimize_expression_x _ (update_exp_check_flags ?e _) _ |- _ ] => 
      specialize (H1 _ _ _ _ _ _ _ H2 H3 H4 H5 H6); auto
  end.
  repeat progress match goal with
  | [H: do_flagged_checks_on_binop _ ?op ?v1 ?v2 _ |- _] => inversion H; clear H; subst
  | [H: do_flagged_check_on_binop _ ?op ?v1 ?v2 _ |- _] => inversion H; clear H; subst
  | [H: do_overflow_check_on_binop ?op ?v1 ?v2 _ |- _] => inversion H; clear H; subst
  | [H: Val.binary_operation ?op ?v1 ?v2 = _ |- _] => simpl in H; inversion H; subst
  end; auto.
  inversion H8; smack.
  + (*5. Multiply or Divide *)
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H: ?op = Multiply \/ ?op = Divide |- _] => inversion H; clear H; subst
  end.
  (* 5.1. Multiply *)
  match goal with
  | [H: Val.binary_operation ?op ?v1 ?v2 = _ |- _] => 
      destruct v1, v2; inversion H; clear H;
      [ destruct v0, v1 | destruct v0 | destruct v0]; inversion H5; subst
  end.
  match goal with
  | [H: well_check_flagged_expr _ |- _] => inversion H; subst
  end;
  repeat progress match goal with
  | [H: do_flagged_checks_on_binop _ ?op ?v1 ?v2 _ |- _] => inversion H; clear H; subst
  | [H: do_flagged_check_on_binop _ ?op ?v1 ?v2 _ |- _] => inversion H; clear H; subst
  | [H: do_overflow_check_on_binop ?op ?v1 ?v2 _ |- _] => inversion H; clear H; subst
  | [H: Val.binary_operation ?op ?v1 ?v2 = _ |- _] => simpl in H; inversion H; subst
  end; auto.
  inversion H8; smack.
  (* 5.2. Divide *)
  match goal with
  | [H: Val.binary_operation ?op ?v1 ?v2 = _ |- _] => 
      destruct v1, v2; inversion H; clear H;
      [ destruct v0, v1 | destruct v0 | destruct v0]; inversion H5; subst
  end.
  match goal with
  | [H: well_check_flagged_expr _ |- _] => inversion H; subst
  end;
  repeat progress match goal with
  | [H: do_flagged_checks_on_binop _ ?op ?v1 ?v2 _ |- _] => inversion H; clear H; subst
  | [H: do_flagged_check_on_binop _ ?op ?v1 ?v2 _ |- _] => inversion H; clear H; subst
  | [H: do_overflow_check_on_binop ?op ?v1 ?v2 _ |- _] => inversion H; clear H; subst
  | [H: Val.binary_operation ?op ?v1 ?v2 = _ |- _] => simpl in H; inversion H; subst
  end; auto.
  inversion H8; smack.
- (* unary expression *)
  match goal with
  | [H: optimize_expression_x ?st ?e ?e' |- _] => inversion H; clear H; subst
  end.
  + (*1. Unary_Minus Pass Overflow Check*)
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end.  
  match goal with
  | [H: Val.unary_operation ?op ?v1 = _ |- _] => 
      destruct v1; inversion H; clear H; subst;
      destruct v0; inversion H4;subst
  end.
  match goal with
  | [H: well_check_flagged_expr _ |- _] => simpl in H; inversion H; clear H; subst
  end;
  match goal with
  | [H: well_check_flagged_expr e |- _] => 
      let H1 := fresh "HZ" in 
      specialize (rm_range_check_return_same_expr_checks _ H); intros H1
  end;
  match goal with
  | [H1: optimize_expression_x _ e _,
     H2: eval_expr_x _ _ e _,
     H3: well_check_flagged_expr e |- _] => 
      let HZ := fresh "HZ" in
      specialize (update_exp_with_new_check_flags e); intro HZ; rewrite <- HZ in H1, H2, H3; clear HZ
  end;
  match goal with
  | [H1: forall (e' : expression_x) (checkflags : check_flags) (st : symboltable_x) 
                (s : STACK.stack) (v l u : Z),
      well_typed_stack _ _ ->
      remove_check_flag Do_Range_Check (exp_check_flags ?e) _ ->
      well_check_flagged_expr (update_exp_check_flags ?e _) ->
      eval_expr_x _ _ (update_exp_check_flags ?e _) _ ->
      optimize_expression_x _ (update_exp_check_flags ?e _) _ -> _ ,
     H2: well_typed_stack _ _,
     H3: remove_check_flag Do_Range_Check (exp_check_flags ?e) _,
     H4: well_check_flagged_expr (update_exp_check_flags ?e _),
     H5: eval_expr_x _ _ (update_exp_check_flags ?e _) _,
     H6: optimize_expression_x _ (update_exp_check_flags ?e _) _ |- _ ] => 
      specialize (H1 _ _ _ _ _ _ _ H2 H3 H4 H5 H6); auto
  end.
  admit.
  + (*2. Unary_Minus Fail Overflow Check *)
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H: Val.unary_operation ?op ?v1 = _ |- _] => 
      destruct v1; inversion H; clear H; subst;
      destruct v0; inversion H4;subst
  end.
  match goal with
  | [H: well_check_flagged_expr _ |- _] => simpl in H; inversion H; clear H; subst
  end;
  match goal with
  | [H: well_check_flagged_expr e |- _] => 
      let H1 := fresh "HZ" in 
      specialize (rm_range_check_return_same_expr_checks _ H); intros H1
  end;
  match goal with
  | [H1: optimize_expression_x _ e _,
     H2: eval_expr_x _ _ e _,
     H3: well_check_flagged_expr e |- _] => 
      let HZ := fresh "HZ" in
      specialize (update_exp_with_new_check_flags e); intro HZ; rewrite <- HZ in H1, H2, H3; clear HZ
  end;
  match goal with
  | [H1: forall (e' : expression_x) (checkflags : check_flags) (st : symboltable_x) 
                (s : STACK.stack) (v l u : Z),
      well_typed_stack _ _ ->
      remove_check_flag Do_Range_Check (exp_check_flags ?e) _ ->
      well_check_flagged_expr (update_exp_check_flags ?e _) ->
      eval_expr_x _ _ (update_exp_check_flags ?e _) _ ->
      optimize_expression_x _ (update_exp_check_flags ?e _) _ -> _ ,
     H2: well_typed_stack _ _,
     H3: remove_check_flag Do_Range_Check (exp_check_flags ?e) _,
     H4: well_check_flagged_expr (update_exp_check_flags ?e _),
     H5: eval_expr_x _ _ (update_exp_check_flags ?e _) _,
     H6: optimize_expression_x _ (update_exp_check_flags ?e _) _ |- _ ] => 
      specialize (H1 _ _ _ _ _ _ _ H2 H3 H4 H5 H6); auto
  end.
  repeat progress match goal with
  | [H: do_flagged_checks_on_unop _ ?op ?v _ |- _] => inversion H; clear H; subst
  | [H: do_flagged_check_on_unop _ ?op ?v _ |- _] => inversion H; clear H; subst
  | [H: do_overflow_check_on_unop ?op ?v _ |- _] => inversion H; clear H; subst
  | [H: Val.unary_operation ?op ?v = _ |- _] => simpl in H; inversion H; subst
  end; auto.
  + (*3. Unary_Plus*)
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H: Val.unary_operation ?op ?v1 = _ |- _] => 
      destruct v1; inversion H; clear H; subst;
      destruct v0; inversion H4;subst
  end.
  match goal with
  | [H: well_check_flagged_expr _ |- _] => simpl in H; inversion H; clear H; subst
  end;
  match goal with
  | [H: well_check_flagged_expr e |- _] => 
      let H1 := fresh "HZ" in 
      specialize (rm_range_check_return_same_expr_checks _ H); intros H1
  end;
  match goal with
  | [H1: optimize_expression_x _ e _,
     H2: eval_expr_x _ _ e _,
     H3: well_check_flagged_expr e |- _] => 
      let HZ := fresh "HZ" in
      specialize (update_exp_with_new_check_flags e); intro HZ; rewrite <- HZ in H1, H2, H3; clear HZ
  end;
  match goal with
  | [H1: forall (e' : expression_x) (checkflags : check_flags) (st : symboltable_x) 
                (s : STACK.stack) (v l u : Z),
      well_typed_stack _ _ ->
      remove_check_flag Do_Range_Check (exp_check_flags ?e) _ ->
      well_check_flagged_expr (update_exp_check_flags ?e _) ->
      eval_expr_x _ _ (update_exp_check_flags ?e _) _ ->
      optimize_expression_x _ (update_exp_check_flags ?e _) _ -> _ ,
     H2: well_typed_stack _ _,
     H3: remove_check_flag Do_Range_Check (exp_check_flags ?e) _,
     H4: well_check_flagged_expr (update_exp_check_flags ?e _),
     H5: eval_expr_x _ _ (update_exp_check_flags ?e _) _,
     H6: optimize_expression_x _ (update_exp_check_flags ?e _) _ |- _ ] => 
      specialize (H1 _ _ _ _ _ _ _ H2 H3 H4 H5 H6); auto
  end.
- (* identifier *)
  match goal with
  | [H: eval_name_x _ _ _ _ |- _] => inversion H; subst
  end.
  match goal with
  | [H: optimize_name_x _ _ _ |- _] => inversion H; clear H; subst
  end.
  simpl in H0, H1, H2.
  specialize (variable_value_in_type_domain _ _ _ _ _ _ _ _ H H2 H8 H13); auto.
- (* indexed component *)
  simpl in H1, H2, H3, H4.
  match goal with
  | [H: optimize_name_x _ _ _ |- _] => inversion H; clear H; subst
  end.
  + (*1*)
  match goal with
  | [H: eval_name_x _ _ _ _ |- _] => inversion H; clear H; subst
  end;
  match goal with
  | [H: well_check_flagged_name _ |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H1: ~ List.In _ ?ls,
     H2: ?ls = _ |- _] => unfold not in H1; rewrite H2 in H1; smack
  end.
  match goal with
  | [H1: exp_check_flags ?e = _,
     H2: well_check_flagged_expr (update_exp_check_flags ?e _) |- _] =>
      let HZ := fresh "HZ" in specialize (remove_range_check_property _ _ _ H1 H2); intro HZ
  end.
  let HZ := fresh "HZ" in specialize (range_check_not_in_expr _ H8); intro HZ.
  rewrite H5 in H10.
  (* continue .... *)
  
  admit.

Lemma update_exp_with_new_check_flags: forall e checkflags, 
 (exp_check_flags (update_exp_check_flags e checkflags)) = checkflags.

Lemma list_component_equal: forall ls1 e ls2 ls1' ls2',
  ls1 ++ e :: ls2 = ls1' ++ e :: ls2' ->
  ~(List.In e (ls1 ++ ls2)) ->
  ls1 = ls1' /\ ls2 = ls2'.

Axiom optimize_expr_to_same_checkflags: forall e checkflags st l u e' l' u' e'' checkflags',
  optimize_expression_x st e (IntBetween l u, e') ->
  remove_check_flag Do_Range_Check (exp_check_flags e') checkflags ->
  remove_check_flag Do_Range_Check (exp_check_flags e) checkflags' ->
  optimize_expression_x st (update_exp_check_flags e checkflags') 
                           (IntBetween l u, (update_exp_check_flags e' checkflags)).


Lemma range_check_not_in_expr: forall e,
  well_check_flagged_expr e ->
    ~(List.In Do_Range_Check (exp_check_flags e)).

Axiom remove_range_check_property: forall e cks1 cks2,
  exp_check_flags e = cks1 ++ Do_Range_Check :: cks2 ->
  well_check_flagged_expr (update_exp_check_flags e (cks1 ++ cks2)) ->
  remove_check_flag Do_Range_Check (exp_check_flags e) (cks1 ++ cks2).

Axiom optimize_expr_to_same_rangevalue: forall e checkflags st l u e' l' u' e'',
  remove_check_flag Do_Range_Check (exp_check_flags e) checkflags ->
  optimize_expression_x st (update_exp_check_flags e checkflags) (IntBetween l u, e') ->
  optimize_expression_x st e (IntBetween l' u', e'') ->
  l = l' /\ u = u'.

Axiom optimize_expr_to_same_checkflags: forall e checkflags st l u e' l' u' e'' checkflags',
  optimize_expression_x st e (IntBetween l u, e') ->
  remove_check_flag Do_Range_Check (exp_check_flags e') checkflags ->
  remove_check_flag Do_Range_Check (exp_check_flags e) checkflags' ->
  optimize_expression_x st (update_exp_check_flags e checkflags') 
                           (IntBetween l u, (update_exp_check_flags e' checkflags)).





  + (*2*)
  match goal with
  | [H: eval_name_x _ _ _ _ |- _] => inversion H; clear H; subst
  end;
  match goal with
  | [H: well_check_flagged_name _ |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H1: ~ List.In _ ?ls,
     H2: ?ls = _ |- _] => unfold not in H1; rewrite H2 in H1; smack
  end.
  admit.








(** it's impossible to prove the following theorem directly, as we do induction 
proof on it, the proof will get stuck when e is an indexed_component, e.g. a[e]; 
the induction proof will generate a premise for e in the following theorem form,
where (eval_expr_x st s e v) is impossible to be true as e has Do_Range_Check flag, 
which is not acceptible by the semantics of eval_expr_x;

Lemma eval_expr_value_in_domain: forall e e' st s v l u,
  well_typed_stack st s ->
    eval_expr_x st s e (Normal (BasicV (Int v))) ->
      optimize_expression_x st e (IntBetween l u, e') ->
        Zge_bool v l = true /\ Zle_bool v u = true.


Lemma eval_expr_value_in_domain: forall e e' st s checkflags v l u,
  well_typed_stack st s ->
    remove_check_flag Do_Range_Check (exp_check_flags e) checkflags ->
      eval_expr_x st s (update_exp_check_flags e checkflags) (Normal (BasicV (Int v))) ->
        optimize_expression_x st (update_exp_check_flags e checkflags) (IntBetween l u, e') ->
          Zge_bool v l = true /\ Zle_bool v u = true.
*)
Lemma eval_expr_value_in_domain: forall e e' st s v l u,
  well_typed_stack st s ->
    well_check_flagged_expr e ->
      eval_expr_x st s e (Normal (BasicV (Int v))) ->
        optimize_expression_x st e (IntBetween l u, e') ->
          (Zge_bool v l) && (Zle_bool v u) = true.
Proof.
  apply (expression_x_ind
    (fun e: expression_x => 
       forall (e' : expression_x) (st : symboltable_x) (s : STACK.stack) 
              (v l u : Z),
      well_typed_stack st s ->
      well_check_flagged_expr e ->
      eval_expr_x st s e (Normal (BasicV (Int v))) ->
      optimize_expression_x st e (IntBetween l u, e') ->
      (Zge_bool v l) && (Zle_bool v u) = true)
    (fun n: name_x => 
       forall (n' : name_x) (st : symboltable_x) (s : STACK.stack) 
              (v l u : Z),
      well_typed_stack st s ->
      well_check_flagged_name n ->
      eval_name_x st s n (Normal (BasicV (Int v))) ->
      optimize_name_x st n (IntBetween l u, n') ->
      (Zge_bool v l) && (Zle_bool v u) = true)
    ); intros.
- match goal with
  | [H: optimize_expression_x ?st ?e ?e' |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end. 
  repeat progress match goal with
  | [H: eval_literalO _ = _ |- _] => unfold eval_literalO in H
  | [H: eval_literal _ = _ |- _] => unfold eval_literal in H
  end.
  destruct l; inversion H5; inversion H6; subst.  
  admit.
- match goal with
  | [H: optimize_expression_x ?st ?e ?e' |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H: well_check_flagged_expr _ |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H1: forall (n' : name_x) (st : symboltable_x) (s : STACK.stack) (v l u : Z),
      well_typed_stack _ _ ->
      well_check_flagged_name ?n ->
      eval_name_x _ _ ?n _ ->
      optimize_name_x _ ?n _ -> _ ,
     H2: well_typed_stack _ _,
     H3: well_check_flagged_name ?n,
     H4: eval_name_x _ _ ?n _,
     H5: optimize_name_x _ ?n _ |- _ ] => specialize (H1 _ _ _ _ _ _ H2 H3 H4 H5); auto
  end.
- (* binary expression *)
  match goal with
  | [H: optimize_expression_x ?st ?e ?e' |- _] => inversion H; clear H; subst
  end.
  + (*1*)
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H: Val.binary_operation ?op ?v1 ?v2 = _ |- _] => 
      destruct v1, v2; inversion H; clear H;
      [ destruct v0, v1 | destruct v0 | destruct v0]; inversion H4; subst
  end.
  match goal with
  | [H: well_check_flagged_expr _ |- _] => inversion H; subst
  end;
  repeat progress match goal with
  | [H1: forall (e' : expression_x) (st : symboltable_x) (s : STACK.stack) (v l u : Z),
      well_typed_stack _ _ ->
      well_check_flagged_expr ?e ->
      eval_expr_x _ _ ?e _ ->
      optimize_expression_x _ ?e _ -> _ ,
     H2: well_typed_stack _ _,
     H3: well_check_flagged_expr ?e,
     H4: eval_expr_x _ _ ?e _,
     H5: optimize_expression_x _ ?e _ |- _ ] => specialize (H1 _ _ _ _ _ _ H2 H3 H4 H5); auto
  end.
  admit.
  inversion H17; smack.
  + (*2*)
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H: Val.binary_operation ?op ?v1 ?v2 = _ |- _] => 
      destruct v1, v2; inversion H; clear H;
      [ destruct v0, v1 | destruct v0 | destruct v0]; inversion H4; subst
  end.
  match goal with
  | [H: well_check_flagged_expr _ |- _] => inversion H; subst
  end;
  repeat progress match goal with
  | [H1: forall (e' : expression_x) (st : symboltable_x) (s : STACK.stack) (v l u : Z),
      well_typed_stack _ _ ->
      well_check_flagged_expr ?e ->
      eval_expr_x _ _ ?e _ ->
      optimize_expression_x _ ?e _ -> _ ,
     H2: well_typed_stack _ _,
     H3: well_check_flagged_expr ?e,
     H4: eval_expr_x _ _ ?e _,
     H5: optimize_expression_x _ ?e _ |- _ ] => specialize (H1 _ _ _ _ _ _ H2 H3 H4 H5); auto
  end.
  repeat progress match goal with
  | [H: do_flagged_checks_on_binop _ ?op ?v1 ?v2 _ |- _] => inversion H; clear H; subst
  | [H: do_flagged_check_on_binop _ ?op ?v1 ?v2 _ |- _] => inversion H; clear H; subst
  | [H: do_overflow_check_on_binop ?op ?v1 ?v2 _ |- _] => inversion H; clear H; subst
  | [H: Val.binary_operation ?op ?v1 ?v2 = _ |- _] => simpl in H; inversion H; subst
  end; auto.
  inversion H7; smack.
  + (*3*)
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H: Val.binary_operation ?op ?v1 ?v2 = _ |- _] => 
      destruct v1, v2; inversion H; clear H;
      [ destruct v0, v1 | destruct v0 | destruct v0]; inversion H4; subst
  end.
  match goal with
  | [H: well_check_flagged_expr _ |- _] => inversion H; subst
  end;
  repeat progress match goal with
  | [H1: forall (e' : expression_x) (st : symboltable_x) (s : STACK.stack) (v l u : Z),
      well_typed_stack _ _ ->
      well_check_flagged_expr ?e ->
      eval_expr_x _ _ ?e _ ->
      optimize_expression_x _ ?e _ -> _ ,
     H2: well_typed_stack _ _,
     H3: well_check_flagged_expr ?e,
     H4: eval_expr_x _ _ ?e _,
     H5: optimize_expression_x _ ?e _ |- _ ] => specialize (H1 _ _ _ _ _ _ H2 H3 H4 H5); auto
  end.
  admit.
  inversion H17; smack.
  + (*4*)
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H: Val.binary_operation ?op ?v1 ?v2 = _ |- _] => 
      destruct v1, v2; inversion H; clear H;
      [ destruct v0, v1 | destruct v0 | destruct v0]; inversion H4; subst
  end.
  match goal with
  | [H: well_check_flagged_expr _ |- _] => inversion H; subst
  end;
  repeat progress match goal with
  | [H1: forall (e' : expression_x) (st : symboltable_x) (s : STACK.stack) (v l u : Z),
      well_typed_stack _ _ ->
      well_check_flagged_expr ?e ->
      eval_expr_x _ _ ?e _ ->
      optimize_expression_x _ ?e _ -> _ ,
     H2: well_typed_stack _ _,
     H3: well_check_flagged_expr ?e,
     H4: eval_expr_x _ _ ?e _,
     H5: optimize_expression_x _ ?e _ |- _ ] => specialize (H1 _ _ _ _ _ _ H2 H3 H4 H5); auto
  end.
  repeat progress match goal with
  | [H: do_flagged_checks_on_binop _ ?op ?v1 ?v2 _ |- _] => inversion H; clear H; subst
  | [H: do_flagged_check_on_binop _ ?op ?v1 ?v2 _ |- _] => inversion H; clear H; subst
  | [H: do_overflow_check_on_binop ?op ?v1 ?v2 _ |- _] => inversion H; clear H; subst
  | [H: Val.binary_operation ?op ?v1 ?v2 = _ |- _] => simpl in H; inversion H; subst
  end; auto.
  inversion H7; smack.
  + (*5. Multiply or Divide *)
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end. 
  match goal with
  | [H: ?op = Multiply \/ ?op = Divide |- _] => inversion H; clear H; subst
  end.
  (* 5.1. Multiply *)
  match goal with
  | [H: Val.binary_operation ?op ?v1 ?v2 = _ |- _] => 
      destruct v1, v2; inversion H; clear H;
      [ destruct v0, v1 | destruct v0 | destruct v0]; inversion H4; subst
  end.
  match goal with
  | [H: well_check_flagged_expr _ |- _] => inversion H; subst
  end;
  repeat progress match goal with
  | [H: do_flagged_checks_on_binop _ ?op ?v1 ?v2 _ |- _] => inversion H; clear H; subst
  | [H: do_flagged_check_on_binop _ ?op ?v1 ?v2 _ |- _] => inversion H; clear H; subst
  | [H: do_overflow_check_on_binop ?op ?v1 ?v2 _ |- _] => inversion H; clear H; subst
  | [H: Val.binary_operation ?op ?v1 ?v2 = _ |- _] => simpl in H; inversion H; subst
  end; auto.
  inversion H7; smack.
  (* 5.2. Divide *)
  match goal with
  | [H: Val.binary_operation ?op ?v1 ?v2 = _ |- _] => 
      destruct v1, v2; inversion H; clear H;
      [ destruct v0, v1 | destruct v0 | destruct v0]; inversion H4; subst
  end.
  match goal with
  | [H: well_check_flagged_expr _ |- _] => inversion H; subst
  end;
  repeat progress match goal with
  | [H: do_flagged_checks_on_binop _ ?op ?v1 ?v2 _ |- _] => inversion H; clear H; subst
  | [H: do_flagged_check_on_binop _ ?op ?v1 ?v2 _ |- _] => inversion H; clear H; subst
  | [H: do_overflow_check_on_binop ?op ?v1 ?v2 _ |- _] => inversion H; clear H; subst
  | [H: Val.binary_operation ?op ?v1 ?v2 = _ |- _] => simpl in H; inversion H; subst
  end; auto.
  inversion H7; smack.
- (* unary expression *)
  match goal with
  | [H: optimize_expression_x ?st ?e ?e' |- _] => inversion H; clear H; subst
  end.
  + (*1. Unary_Minus Pass Overflow Check*)
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H: Val.unary_operation ?op ?v1 = _ |- _] => 
      destruct v1; inversion H; clear H; subst;
      destruct v0; inversion H3;subst
  end.
  match goal with
  | [H: well_check_flagged_expr _ |- _] => inversion H; subst
  end;
  repeat progress match goal with
  | [H1: forall (e' : expression_x) (st : symboltable_x) (s : STACK.stack) (v l u : Z),
      well_typed_stack _ _ ->
      well_check_flagged_expr ?e ->
      eval_expr_x _ _ ?e _ ->
      optimize_expression_x _ ?e _ -> _ ,
     H2: well_typed_stack _ _,
     H3: well_check_flagged_expr ?e,
     H4: eval_expr_x _ _ ?e _,
     H5: optimize_expression_x _ ?e _ |- _ ] => specialize (H1 _ _ _ _ _ _ H2 H3 H4 H5); auto
  end.
  admit.
  + (*2. Unary_Minus Fail Overflow Check *)
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H: Val.unary_operation ?op ?v1 = _ |- _] => 
      destruct v1; inversion H; clear H; subst;
      destruct v0; inversion H3;subst
  end.
  match goal with
  | [H: well_check_flagged_expr _ |- _] => inversion H; subst
  end;
  repeat progress match goal with
  | [H1: forall (e' : expression_x) (st : symboltable_x) (s : STACK.stack) (v l u : Z),
      well_typed_stack _ _ ->
      well_check_flagged_expr ?e ->
      eval_expr_x _ _ ?e _ ->
      optimize_expression_x _ ?e _ -> _ ,
     H2: well_typed_stack _ _,
     H3: well_check_flagged_expr ?e,
     H4: eval_expr_x _ _ ?e _,
     H5: optimize_expression_x _ ?e _ |- _ ] => specialize (H1 _ _ _ _ _ _ H2 H3 H4 H5); auto
  end.
  repeat progress match goal with
  | [H: do_flagged_checks_on_unop _ ?op ?v _ |- _] => inversion H; clear H; subst
  | [H: do_flagged_check_on_unop _ ?op ?v _ |- _] => inversion H; clear H; subst
  | [H: do_overflow_check_on_unop ?op ?v _ |- _] => inversion H; clear H; subst
  | [H: Val.unary_operation ?op ?v = _ |- _] => simpl in H; inversion H; subst
  end; auto.
  + (*3. Unary_Plus*)
  match goal with
  | [H: eval_expr_x _ _ _ _ |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H: Val.unary_operation ?op ?v1 = _ |- _] => 
      destruct v1; inversion H; clear H; subst;
      destruct v0; inversion H3;subst
  end.
  match goal with
  | [H: well_check_flagged_expr _ |- _] => inversion H; subst
  end;
  repeat progress match goal with
  | [H1: forall (e' : expression_x) (st : symboltable_x) (s : STACK.stack) (v l u : Z),
      well_typed_stack _ _ ->
      well_check_flagged_expr ?e ->
      eval_expr_x _ _ ?e _ ->
      optimize_expression_x _ ?e _ -> _ ,
     H2: well_typed_stack _ _,
     H3: well_check_flagged_expr ?e,
     H4: eval_expr_x _ _ ?e _,
     H5: optimize_expression_x _ ?e _ |- _ ] => specialize (H1 _ _ _ _ _ _ H2 H3 H4 H5); auto
  end.
- (* identifier *)
  match goal with
  | [H: eval_name_x _ _ _ _ |- _] => inversion H; subst
  end.
  match goal with
  | [H: optimize_name_x _ _ _ |- _] => inversion H; clear H; subst
  end.
  specialize (variable_value_in_type_domain _ _ _ _ _ _ _ _ H H1 H7 H12); auto.
- (* indexed component *)
  match goal with
  | [H: optimize_name_x _ _ _ |- _] => inversion H; clear H; subst
  end.
  + (*1*)
  match goal with
  | [H: eval_name_x _ _ _ _ |- _] => inversion H; clear H; subst
  end;
  match goal with
  | [H: well_check_flagged_name _ |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H1: ~ List.In _ ?ls,
     H2: ?ls = _ |- _] => unfold not in H1; rewrite H2 in H1; smack
  end.
  
  (* !!! get stuck here !!! *)
  

  match goal with
  | [H: optimize_name_x _ _ _ |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H1: forall (e' : expression_x) (st : symboltable_x) (s : STACK.stack) (v l u : Z),
      well_typed_stack _ _ ->
      well_check_flagged_expr ?e ->
      eval_expr_x _ _ ?e _ ->
      optimize_expression_x _ ?e _ -> _ ,
     H2: well_typed_stack _ _,
     H3: well_check_flagged_expr ?e,
     H4: eval_expr_x _ _ ?e _,
     H5: optimize_expression_x _ ?e _ |- _ ] => specialize (H1 _ _ _ _ _ _ H2 H3 H4 H5); auto
  end.
  admit.

  + (*2*)
  match goal with
  | [H: optimize_name_x _ _ _ |- _] => inversion H; clear H; subst
  end.

  match goal with
  | [H1: forall (e' : expression_x) (st : symboltable_x) (s : STACK.stack) (v l u : Z),
      eval_expr_x _ _ ?e _ ->
      optimize_expression_x _ ?e _ -> _ ,
     H2: eval_expr_x _ _ ?e _,
     H3: optimize_expression_x _ ?e _ |- _ ] => specialize (H1 _ _ _ _ _ _ H2 H3); auto
  end.
  admit.
- (* selected component *)
  admit.


  
Qed.

Axiom removed_check_flag_notin: forall ck cks cks',
  remove_check_flag ck cks cks' ->
    ~(List.In ck cks').



End Checks_Optimization_Help_Lemmas.



(**
   - add constrain to expression e to specify that only the index expression can have range check
   - 
*)

Lemma expression_checks_optimization_soundness: forall e st s v v' e',
  ~(List.In Do_Range_Check (exp_check_flags e)) ->
      eval_expr_x st s e v ->
        optimize_expression_x st e (v', e') ->
          eval_expr_x st s e' v.
Proof.
  apply (expression_x_ind
    (fun e: expression_x => 
       forall (st: symboltable_x) (s : STACK.stack) 
              (v: Return value) (v': valueO) (e' : expression_x),
      ~(List.In Do_Range_Check (exp_check_flags e)) ->
      eval_expr_x st s e v ->
      optimize_expression_x st e (v', e') ->
      eval_expr_x st s e' v)
    (fun n: name_x => 
       forall (st: symboltable_x) (s : STACK.stack) 
              (v: Return value) (v': valueO) (n' : name_x),
      ~(List.In Do_Range_Check (name_check_flags n)) ->
      eval_name_x st s n v ->
      optimize_name_x st n (v', n') ->
      eval_name_x st s n' v)
    ); smack.
- match goal with
  | [H: optimize_expression_x ?st ?e ?e' |- _] => inversion H; clear H; subst; auto
  end.
- match goal with
  | [H: optimize_expression_x ?st ?e ?e' |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H: eval_expr_x ?st ?s ?e ?v |- _] => inversion H; clear H; subst
  end.
  specialize (H _ _ _ _ _ H0 H9 H5).
  constructor; auto.
- match goal with
  | [H: optimize_expression_x ?st ?e ?e' |- _] => inversion H; clear H; subst
  end.
(*
  + (*1*)
  match goal with
  | [H: eval_expr_x ?st ?s ?e ?v |- _] => inversion H; clear H; subst
  end.
  { apply Eval_E_Binary_Operation_RTE_E1_X.
    apply H with (v' := IntBetween l1 u1); auto.
    admit.
  }
*)















Lemma expression_checks_optimization_soundness: forall e checkflags st s v v' e',
  remove_check_flag Do_Range_Check (exp_check_flags e) checkflags ->
      eval_expr_x st s (update_exp_check_flags e checkflags) v ->
        optimize_expression_x st (update_exp_check_flags e checkflags) (v', e') ->
          eval_expr_x st s e' v.
Proof.
  apply (expression_x_ind
    (fun e: expression_x => 
       forall (checkflags : check_flags) (st: symboltable_x) (s : STACK.stack) 
              (v: Return value) (v': valueO) (e' : expression_x),
      remove_check_flag Do_Range_Check (exp_check_flags e) checkflags ->
      eval_expr_x st s (update_exp_check_flags e checkflags) v ->
      optimize_expression_x st (update_exp_check_flags e checkflags) (v', e') ->
      eval_expr_x st s e' v)
    (fun n: name_x => 
       forall (checkflags : check_flags) (st: symboltable_x) (s : STACK.stack) 
              (v: Return value) (v': valueO) (n' : name_x),
      remove_check_flag Do_Range_Check (name_check_flags n) checkflags ->
      eval_name_x st s (update_name_check_flags n checkflags) v ->
      optimize_name_x st (update_name_check_flags n checkflags) (v', n') ->
      eval_name_x st s n' v)
    ); smack.
- match goal with
  | [H: optimize_expression_x ?st ?e ?e' |- _] => inversion H; clear H; subst; auto
  end.
- match goal with
  | [H: optimize_expression_x ?st ?e ?e' |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H: eval_expr_x ?st ?s ?e ?v |- _] => inversion H; clear H; subst
  end.
  specialize (H _ _ _ _ _ _ H0 H9 H5).
  constructor; auto.
- match goal with
  | [H: optimize_expression_x ?st ?e ?e' |- _] => inversion H; clear H; subst
  end.
  + (*1*)
  match goal with
  | [H: eval_expr_x ?st ?s ?e ?v |- _] => inversion H; clear H; subst
  end.
  { apply Eval_E_Binary_Operation_RTE_E1_X; auto. 
    
  }



  
  admit.
(*
  match goal with
  | [H1: forall (checkflags : check_flags) (st : symboltable_x) (s : STACK.stack)
                (v : Return value) (v' : valueO) (e' : expression_x),
      remove_check_flag _ (exp_check_flags ?e) _ ->
      eval_expr_x _ _ (update_exp_check_flags ?e _) _ ->
      optimize_expression_x _ (update_exp_check_flags ?e _) _ ->
      eval_expr_x _ _ _ _,
     H2: remove_check_flag _ (exp_check_flags ?e) _,
     H3: eval_expr_x _ _ (update_exp_check_flags ?e _) _,
     H4: optimize_expression_x _ (update_exp_check_flags ?e _) _ |- _] => 
    specialize (H1 _ _ _ _ _ _ H2 H3 H4)
  end.
  solve 
  [ apply Eval_E_Binary_Operation_RTE_E1_X; auto |
    apply Eval_E_Binary_Operation_RTE_E2_X with (v1 := v1); auto |
    apply Eval_E_Binary_Operation_RTE_Bin_X with (v1 := v1) (v2 := v2); auto; admit |
    apply Eval_E_Binary_Operation_X with (v1 := v1) (v2 := v2); auto; admit
  ].
*)
- match goal with
  | [H: optimize_expression_x ?st ?e ?e' |- _] => inversion H; clear H; subst
  end;
  match goal with
  | [H: eval_expr_x ?st ?s ?e ?v |- _] => inversion H; clear H; subst
  end;
  admit.
(*
  match goal with
  | [H1: forall (checkflags : check_flags) (st : symboltable_x) (s : STACK.stack)
                (v : Return value) (v' : valueO) (e' : expression_x),
      remove_check_flag _ (exp_check_flags ?e) _ ->
      eval_expr_x _ _ (update_exp_check_flags ?e _) _ ->
      optimize_expression_x _ (update_exp_check_flags ?e _) _ ->
      eval_expr_x _ _ _ _,
     H2: remove_check_flag _ (exp_check_flags ?e) _,
     H3: eval_expr_x _ _ (update_exp_check_flags ?e _) _,
     H4: optimize_expression_x _ (update_exp_check_flags ?e _) _ |- _] => 
    specialize (H1 _ _ _ _ _ _ H2 H3 H4)
  end;
  solve
  [ apply Eval_E_Unary_Operation_RTE_E_X; auto |
    apply Eval_E_Unary_Operation_RTE_X with (v := v0); auto; admit |
    apply Eval_E_Unary_Operation_X with (v := v0); auto; admit
  ].
*)
- match goal with
  | [H: optimize_name_x ?st ?n ?n' |- _] => inversion H; clear H; subst
  end;
  match goal with
  | [H: eval_name_x ?st ?s ?n ?v |- _] => inversion H; clear H; subst
  end.
  constructor; auto.
- admit.
(*
  match goal with
  | [H: optimize_name_x ?st ?n ?n' |- _] => inversion H; clear H; subst
  end.
  + 
  match goal with
  | [H: eval_name_x ?st ?s ?n ?v |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H1: forall (checkflags : check_flags) (st : symboltable_x) (s : STACK.stack)
                (v : Return value) (v' : valueO) (e' : expression_x),
      remove_check_flag _ (exp_check_flags ?e) _ ->
      eval_expr_x _ _ (update_exp_check_flags ?e _) _ ->
      optimize_expression_x _ (update_exp_check_flags ?e _) _ ->
      eval_expr_x _ _ _ _,
     H2: remove_check_flag _ (exp_check_flags ?e) _,
     H3: eval_expr_x _ _ (update_exp_check_flags ?e _) _,
     H4: optimize_expression_x _ (update_exp_check_flags ?e _) _ |- _] => 
    specialize (H1 _ _ _ _ _ _ H2 H3 H4)
  | _ => idtac
  end.
  apply Eval_E_Indexed_Component_RTE_X; auto; admit.
  apply Eval_E_Indexed_Component_X with (i := i0) (a := a1); auto; admit.
  apply Eval_E_Indexed_Component_RTE_X; auto; admit.
  apply Eval_E_Indexed_Component_E_RTE_X with (cks1 := cks1) (cks2 := cks2); auto.
  apply Eval_E_Indexed_Component_Range_RTE_X.
  apply Eval_E_Indexed_Component_Range_X.
  constructor; auto.
*)
- match goal with
  | [H: optimize_name_x ?st ?n ?n' |- _] => inversion H; clear H; subst
  end;
  match goal with
  | [H: eval_name_x ?st ?s ?n ?v |- _] => inversion H; clear H; subst
  end.
  apply Eval_E_Selected_Component_X with (r := r); auto.
Qed.


(*
Lemma expression_checks_optimization_soundness: forall e checkflags st s v v' e',
  remove_check_flag Do_Range_Check (exp_check_flags e) checkflags ->
      eval_expr_x st s (update_exp_check_flags e checkflags) v ->
        optimize_expression_x st (update_exp_check_flags e checkflags) (v', e') ->
          eval_expr_x st s e' v.
*)
Lemma statement_checks_optimization_soundness: forall st s c s' c',
  eval_stmt_x st s c s' ->
    optimize_statement_x st c c' ->
      eval_stmt_x st s c' s'.
Proof.
  intros st s c s' c' H; revert c'.
  induction H; intros.
- admit.
- match goal with
  | [H: optimize_statement_x _ _ _ |- _] => inversion H; clear H; subst
  end.
  apply Eval_S_Assignment_RTE_X; auto; admit.
  apply Eval_S_Assignment_RTE_X; auto; admit.
- match goal with
  | [H: optimize_statement_x _ _ _ |- _] => inversion H; clear H; subst
  end.
  apply Eval_S_Assignment_X with (v := v); auto; admit.
  apply Eval_S_Assignment_X with (v := v); auto; admit.
- match goal with
  | [H: optimize_statement_x _ _ _ |- _] => inversion H; clear H; subst
  end.
  apply Eval_S_Assignment_RTE_X; auto; admit.
  apply Eval_S_Assignment_E_RTE_X with (cks1 := cks1) (cks2 := cks2); auto.
  
Qed.






(*/////////////////////////////////////////////////////////////////////////////*)
(*/////////////////////////////////////////////////////////////////////////////*)
(*/////////////////////////////////////////////////////////////////////////////*)



(** 
It's impossible to prove the following theorem directly, as we do induction 
proof on it, the proof will get stuck when e is an indexed_component, e.g. a[e]; 
the induction proof will generate a premise for e in the following theorem form,
where (eval_expr_x st s e v) is impossible to be true as e has Do_Range_Check flag, 
which is not acceptible by the semantics of eval_expr_x;

- Theorem expression_checks_optimization_soundness: forall e e' st s v v',
    eval_expr_x st s e v ->
      optimize_expression_x st e (v', e') ->
        eval_expr_x st s e' v.
*)

Lemma expression_checks_optimization_soundness: forall e e' st s v v',
  eval_expr_x st s e v ->
    optimize_expression_x st e (v', e') ->
      eval_expr_x st s e' v.
Proof.
  apply (expression_x_ind
    (fun e: expression_x => 
       forall (e' : expression_x) (st: symboltable_x) (s : STACK.stack) (v: Return value) (v': valueO),
      eval_expr_x st s e v ->
      optimize_expression_x st e (v', e') ->
      eval_expr_x st s e' v)
    (fun n: name_x => 
       forall (n' : name_x) (st: symboltable_x) (s : STACK.stack) (v: Return value) (v': valueO),
      eval_name_x st s n v ->
      optimize_name_x st n (v', n') ->
      eval_name_x st s n' v)
    ); smack.
- match goal with
  | [H: optimize_expression_x ?st ?e ?e' |- _] => inversion H; clear H; subst; auto
  end.
- match goal with
  | [H: optimize_expression_x ?st ?e ?e' |- _] => inversion H; clear H; subst
  end.
  match goal with
  | [H: eval_expr_x ?st ?s ?e ?v |- _] => inversion H; clear H; subst
  end.
  specialize (H _ _ _ _ _ H8 H4).
  constructor; auto.
- 
(*
  match goal with
  | [H: optimize_expression_x ?st ?e ?e' |- _] => inversion H; clear H; subst
  end;
  match goal with
  | [H: eval_expr_x ?st ?s ?e ?v |- _] => inversion H; clear H; subst
  end;
  repeat progress match goal with
  | [H1: forall (e' : expression_x) (st : symboltable_x) 
        (s : STACK.stack) (v : Return value) (v' : valueO),
      eval_expr_x _ _ ?e _ ->
      optimize_expression_x _ ?e _ -> eval_expr_x _ _ _ _,
     H2: eval_expr_x _ _ ?e _,
     H3: optimize_expression_x _ ?e _ |- _] => 
    specialize (H1 _ _ _ _ _ H2 H3)
  end;
  solve 
  [ apply Eval_E_Binary_Operation_RTE_E1_X; auto |
    apply Eval_E_Binary_Operation_RTE_E2_X with (v1 := v1); auto |
    apply Eval_E_Binary_Operation_RTE_Bin_X with (v1 := v1) (v2 := v2); auto; admit |
    apply Eval_E_Binary_Operation_X with (v1 := v1) (v2 := v2); auto; admit
  ].
*)
  match goal with
  | [H: optimize_expression_x ?st ?e ?e' |- _] => inversion H; clear H; subst
  end.
  + (* 1 *)
  match goal with
  | [H: eval_expr_x ?st ?s ?e ?v |- _] => inversion H; clear H; subst
  end;
  repeat progress match goal with
  | [H1: forall (e' : expression_x) (st : symboltable_x) 
        (s : STACK.stack) (v : Return value) (v' : valueO),
      eval_expr_x _ _ ?e _ ->
      optimize_expression_x _ ?e _ -> eval_expr_x _ _ _ _,
     H2: eval_expr_x _ _ ?e _,
     H3: optimize_expression_x _ ?e _ |- _] => 
    specialize (H1 _ _ _ _ _ H2 H3)
  end;
  solve 
  [ apply Eval_E_Binary_Operation_RTE_E1_X; auto |
    apply Eval_E_Binary_Operation_RTE_E2_X with (v1 := v1); auto |
    apply Eval_E_Binary_Operation_RTE_Bin_X with (v1 := v1) (v2 := v2); auto; admit |
    apply Eval_E_Binary_Operation_X with (v1 := v1) (v2 := v2); auto; admit
  ].
  + (* 2 *)
  match goal with
  | [H: eval_expr_x ?st ?s ?e ?v |- _] => inversion H; clear H; subst
  end;
  repeat progress match goal with
  | [H1: forall (e' : expression_x) (st : symboltable_x) 
        (s : STACK.stack) (v : Return value) (v' : valueO),
      eval_expr_x _ _ ?e _ ->
      optimize_expression_x _ ?e _ -> eval_expr_x _ _ _ _,
     H2: eval_expr_x _ _ ?e _,
     H3: optimize_expression_x _ ?e _ |- _] => 
    specialize (H1 _ _ _ _ _ H2 H3)
  end;
  [ apply Eval_E_Binary_Operation_RTE_E1_X; auto |
    apply Eval_E_Binary_Operation_RTE_E2_X with (v1 := v1); auto |
    apply Eval_E_Binary_Operation_RTE_Bin_X with (v1 := v1) (v2 := v2); auto; admit |
    apply Eval_E_Binary_Operation_X with (v1 := v1) (v2 := v2); auto; admit
  ].
  + (* 3 *)
  match goal with
  | [H: eval_expr_x ?st ?s ?e ?v |- _] => inversion H; clear H; subst
  end;
  repeat progress match goal with
  | [H1: forall (e' : expression_x) (st : symboltable_x) 
        (s : STACK.stack) (v : Return value) (v' : valueO),
      eval_expr_x _ _ ?e _ ->
      optimize_expression_x _ ?e _ -> eval_expr_x _ _ _ _,
     H2: eval_expr_x _ _ ?e _,
     H3: optimize_expression_x _ ?e _ |- _] => 
    specialize (H1 _ _ _ _ _ H2 H3)
  end;
  [ apply Eval_E_Binary_Operation_RTE_E1_X; auto |
    apply Eval_E_Binary_Operation_RTE_E2_X with (v1 := v1); auto |
    apply Eval_E_Binary_Operation_RTE_Bin_X with (v1 := v1) (v2 := v2); auto; admit |
    apply Eval_E_Binary_Operation_X with (v1 := v1) (v2 := v2); auto; admit
  ].  
  + (* 4 *)
  match goal with
  | [H: eval_expr_x ?st ?s ?e ?v |- _] => inversion H; clear H; subst
  end;
  repeat progress match goal with
  | [H1: forall (e' : expression_x) (st : symboltable_x) 
        (s : STACK.stack) (v : Return value) (v' : valueO),
      eval_expr_x _ _ ?e _ ->
      optimize_expression_x _ ?e _ -> eval_expr_x _ _ _ _,
     H2: eval_expr_x _ _ ?e _,
     H3: optimize_expression_x _ ?e _ |- _] => 
    specialize (H1 _ _ _ _ _ H2 H3)
  end;
  [ apply Eval_E_Binary_Operation_RTE_E1_X; auto |
    apply Eval_E_Binary_Operation_RTE_E2_X with (v1 := v1); auto |
    apply Eval_E_Binary_Operation_RTE_Bin_X with (v1 := v1) (v2 := v2); auto; admit |
    apply Eval_E_Binary_Operation_X with (v1 := v1) (v2 := v2); auto; admit
  ].
  + (* 5 *)
  match goal with
  | [H: eval_expr_x ?st ?s ?e ?v |- _] => inversion H; clear H; subst
  end;
  repeat progress match goal with
  | [H1: forall (e' : expression_x) (st : symboltable_x) 
        (s : STACK.stack) (v : Return value) (v' : valueO),
      eval_expr_x _ _ ?e _ ->
      optimize_expression_x _ ?e _ -> eval_expr_x _ _ _ _,
     H2: eval_expr_x _ _ ?e _,
     H3: optimize_expression_x _ ?e _ |- _] => 
    specialize (H1 _ _ _ _ _ H2 H3)
  end;
  [ apply Eval_E_Binary_Operation_RTE_E1_X; auto |
    apply Eval_E_Binary_Operation_RTE_E2_X with (v1 := v1); auto |
    apply Eval_E_Binary_Operation_RTE_Bin_X with (v1 := v1) (v2 := v2); auto; admit |
    apply Eval_E_Binary_Operation_X with (v1 := v1) (v2 := v2); auto; admit
  ].
  + (* 6 *)
  match goal with
  | [H: eval_expr_x ?st ?s ?e ?v |- _] => inversion H; clear H; subst
  end;
  repeat progress match goal with
  | [H1: forall (e' : expression_x) (st : symboltable_x) 
        (s : STACK.stack) (v : Return value) (v' : valueO),
      eval_expr_x _ _ ?e _ ->
      optimize_expression_x _ ?e _ -> eval_expr_x _ _ _ _,
     H2: eval_expr_x _ _ ?e _,
     H3: optimize_expression_x _ ?e _ |- _] => 
    specialize (H1 _ _ _ _ _ H2 H3)
  end;
  [ apply Eval_E_Binary_Operation_RTE_E1_X; auto |
    apply Eval_E_Binary_Operation_RTE_E2_X with (v1 := v1); auto |
    apply Eval_E_Binary_Operation_RTE_Bin_X with (v1 := v1) (v2 := v2); auto; admit |
    apply Eval_E_Binary_Operation_X with (v1 := v1) (v2 := v2); auto; admit
  ].
- match goal with
  | [H: optimize_expression_x ?st ?e ?e' |- _] => inversion H; clear H; subst
  end;
  match goal with
  | [H: eval_expr_x ?st ?s ?e ?v |- _] => inversion H; clear H; subst
  end;
  match goal with
  | [H1: forall (e' : expression_x) (st : symboltable_x) 
        (s : STACK.stack) (v : Return value) (v' : valueO),
      eval_expr_x _ _ ?e _ ->
      optimize_expression_x _ ?e _ -> eval_expr_x _ _ _ _,
     H2: eval_expr_x _ _ ?e _,
     H3: optimize_expression_x _ ?e _ |- _] => 
    specialize (H1 _ _ _ _ _ H2 H3)
  end;
  solve
  [ apply Eval_E_Unary_Operation_RTE_E_X; auto |
    apply Eval_E_Unary_Operation_RTE_X with (v := v0); auto; admit |
    apply Eval_E_Unary_Operation_X with (v := v0); auto; admit
  ].
- match goal with
  | [H: optimize_name_x ?st ?n ?n' |- _] => inversion H; clear H; subst
  end;
  match goal with
  | [H: eval_name_x ?st ?s ?n ?v |- _] => inversion H; clear H; subst
  end.
  constructor; auto.
- match goal with
  | [H: optimize_name_x ?st ?n ?n' |- _] => inversion H; clear H; subst
  end.
  + 
  match goal with
  | [H: eval_name_x ?st ?s ?n ?v |- _] => inversion H; clear H; subst
  end;
  match goal with
  | [H1: forall (e' : expression_x) (st : symboltable_x) 
        (s : STACK.stack) (v : Return value) (v' : valueO),
      eval_expr_x _ _ ?e _ ->
      optimize_expression_x _ ?e _ -> eval_expr_x _ _ _ _,
     H2: eval_expr_x _ _ ?e _,
     H3: optimize_expression_x _ ?e _ |- _] => 
    specialize (H1 _ _ _ _ _ H2 H3)
  | _ => idtac
  end.
  apply Eval_E_Indexed_Component_RTE_X; auto; admit.
  apply Eval_E_Indexed_Component_X with (i := i0) (a := a1); auto; admit.
  apply Eval_E_Indexed_Component_E_RTE_X.
  apply Eval_E_Indexed_Component_Range_RTE_X.
  apply Eval_E_Indexed_Component_Range_X.
  constructor; auto.








Qed.

Lemma expression_checks_soundness: forall e e' st st' s v,
  eval_expr st s e v ->
    compile2_flagged_exp st nil e e' ->
      compile2_flagged_symbol_table st st' ->
        eval_expr_x st' s e' v.
Proof.
  apply (expression_ind
    (fun e: expression => forall (e' : expression_x) (st: symboltable) (st': symboltable_x) (s : STACK.stack) (v: Return value),
      eval_expr st s e v ->
      compile2_flagged_exp st nil e e' ->
      compile2_flagged_symbol_table st st' ->
      eval_expr_x st' s e' v)
    (fun n: name => forall (n': name_x) (st: symboltable) (st': symboltable_x) (s : STACK.stack) (v: Return value),
      eval_name st s n v ->
      compile2_flagged_name st nil n n' ->
      compile2_flagged_symbol_table st st' ->
      eval_name_x st' s n' v)
    ); smack.


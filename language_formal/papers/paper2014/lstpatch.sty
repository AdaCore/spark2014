%%
%% This is file `lstpatch.sty', generated manually.
%%
%% (w)(c) 2004 Carsten Heinz
%%
%% This file may be distributed under the terms of the LaTeX Project Public
%% License from CTAN archives in directory  macros/latex/base/lppl.txt.
%% Either version 1.0 or, at your option, any later version.
%%
%% Send comments and ideas on the package, error reports and additional
%% programming languages to <cheinz@gmx.de>.
%%
%% This patch file will remove the following bugs from the listings package.
%% Each item contains the bug finder with date of report and first bug fix
%% version, a short description of the problem, and the reason for the bug
%% in parenthesis.
%%
%%  1) Frank Atanassow, 2004/10/07, 1.3b
%%
%%     space after mathescape is not preserved
%%     (\lst@newlines>0)
%%
%%  2) Benjamin Lings, 2004/10/15, 1.3b (2004/10/17)
%%
%%     \usepackage{xy,listings} yields:
%%     "Forbidden control sequence found while scanning use of \lst@lExtend"
%%     (xy-pic correctly resets catcode of ^^L (to active), which is \outer)
%%
%%
%% The following features are added to the base package.
%%
%% 1.3a (2004/09/07)
%%
%%  a) H I G H L Y   E X P E R I M E N T A L
%%
%%     Use the options
%%        rangeprefix=<prefix for begin and end of range>
%%        rangesuffix=<suffix for begin and end of range>
%%
%%        rangebeginprefix=<prefix for begin of range>
%%        rangebeginsuffix=<suffix for begin of range>
%%
%%        rangeendprefix=<prefix for end of range>
%%        rangeendsuffix=<suffix for end of range>
%%
%%        includerangemarker=true|false
%%     together with
%%        firstline=<begin marker>
%%        lastline=<end marker>
%%     or
%%        linerange={<begin marker 1>-<end marker 1>,
%%                   <begin marker 2>-<end marker 2>, ...}
%%     The according markers in the source code are
%%           <prefix><marker><suffix>
%%     for begin respectively end of range. Moreover, one can use
%%        includerangemarker=true|false
%%     to show or hide the range markers in the output.
%%
%% 1.3b (2004/10/17)
%%
%%  b) multicols=<number> (requires loaded multicol package)
%%
%%
\lst@CheckVersion{1.3}
{\typeout{^^J%
    ***^^J%
    *** This is a patch for listings 1.3, but you're using^^J%
    *** version \lst@version.^^J%
    ***^^J
    *** Patch file not loaded.^^J%
    ***^^J}%
    \endinput
}
\def\fileversion{1.3b}
\def\filedate{2004/10/17}
\ProvidesFile{lstpatch.sty}[\filedate\space\fileversion\space (Carsten Heinz)]
%
% 0) Insert % after #1.
\def\@@xbitor #1{\@tempcntb \count#1%
   \ifnum \@tempcnta =\z@
   \else
     \divide\@tempcntb\@tempcnta
     \ifodd\@tempcntb \@testtrue\fi
   \fi}
%
% 1) Reset \lst@newlines at end of escape.
\def\lstpatch@escape{%
\gdef\lst@Escape##1##2##3##4{%
    \lst@CArgX ##1\relax\lst@CDefX
        {}%
        {\lst@ifdropinput\else
         \lst@TrackNewLines\lst@OutputLostSpace \lst@XPrintToken
         \lst@InterruptModes
         \lst@EnterMode{\lst@TeXmode}{\lst@modetrue}%
         \ifx\^^M##2%
             \lst@CArg ##2\relax\lst@ActiveCDefX
                 {}%
                 {\lst@escapeend ##4\lst@LeaveAllModes\lst@ReenterModes}%
                 {\lst@MProcessListing}%
         \else
             \lst@CArg ##2\relax\lst@ActiveCDefX
                 {}%
                 {\lst@escapeend ##4\lst@LeaveAllModes\lst@ReenterModes
                  \lst@newlines\z@ \lst@whitespacefalse}%
                 {}%
         \fi
         ##3\lst@escapebegin
         \fi}%
        {}}%
}
%
% 2) Deactivate \outer definition of ^^L temporarily (inside and outside
%    of \lst@ScanChars) and restore \catcode at end of package.
\begingroup \catcode12=\active\let^^L\@empty
\gdef\lst@ScanChars{%
  \let\lsts@ssL^^L%
  \def^^L{\par}%
    \lst@GetChars\lst@RestoreOrigCatcodes\@ne {128}%
  \let^^L\lsts@ssL
    \lst@GetChars\lst@RestoreOrigExtendedCatcodes{128}{256}}
\endgroup
\lst@lAddTo\lst@RestoreCatcodes{\catcode12\active}
%
% a) Let's start with the options:
\lst@Key{rangeprefix}\relax{\def\lst@rangebeginprefix{#1}%
                            \def\lst@rangeendprefix{#1}}
\lst@Key{rangesuffix}\relax{\def\lst@rangebeginsuffix{#1}%
                            \def\lst@rangeendsuffix{#1}}
\lst@Key{rangebeginprefix}{}{\def\lst@rangebeginprefix{#1}}
\lst@Key{rangebeginsuffix}{}{\def\lst@rangebeginsuffix{#1}}
\lst@Key{rangeendprefix}{}{\def\lst@rangeendprefix{#1}}
\lst@Key{rangeendsuffix}{}{\def\lst@rangeendsuffix{#1}}
\lst@Key{includerangemarker}{true}[t]{\lstKV@SetIf{#1}\lst@ifincluderangemarker}
%
%    The key is a redefinition of \lst@GLI@ checking for numbers.
\def\lst@GLI@#1-#2-#3\@nil{%
    \lst@IfNumber{#1}%
    {\ifx\@empty#1\@empty
         \let\lst@firstline\@ne
     \else
         \def\lst@firstline{#1\relax}%
     \fi
     \ifx\@empty#3\@empty
         \def\lst@lastline{9999999\relax}%
     \else
         \ifx\@empty#2\@empty
             \let\lst@lastline\lst@firstline
         \else
             \def\lst@lastline{#2\relax}%
         \fi
     \fi}%
%
%    If we've found a general marker, we set firstline and lastline to 9999999.
%    This prevents (almost) anything to be printed for now.
    {\def\lst@firstline{9999999\relax}%
     \let\lst@lastline\lst@firstline
%
%    We add the prefixes and suffixes to the markers.
     \let\lst@rangebegin\lst@rangebeginprefix
     \lst@AddTo\lst@rangebegin{#1}\lst@Extend\lst@rangebegin\lst@rangebeginsuffix
     \ifx\@empty#3\@empty
         \let\lst@rangeend\lst@rangeendprefix
         \lst@AddTo\lst@rangeend{#1}\lst@Extend\lst@rangeend\lst@rangeendsuffix
     \else
         \ifx\@empty#2\@empty
             \let\lst@rangeend\@empty
         \else
             \let\lst@rangeend\lst@rangeendprefix
             \lst@AddTo\lst@rangeend{#2}\lst@Extend\lst@rangeend\lst@rangeendsuffix
         \fi
     \fi
%    The following definition will be executed in the SelectCharTable hook
%    and here right now if we are already processing a listing.
     \global\def\lst@DefRange{\expandafter\lst@CArgX\lst@rangebegin\relax\lst@DefRangeB}%
     \ifnum\lst@mode=\lst@Pmode \expandafter\lst@DefRange \fi}}
%    \lst@DefRange is not inserted via a hook anymore. Instead it is now called
%    directly from \lst@SelectCharTable. This was necessary to get rid of an
%    interference with the escape-to-LaTeX-feature. The bug was reported by
%    \lsthelper{Michael~Bachmann}{2004/07/21}{Keine label-Referenzierung
%    m\"oglich...}. Another chance is due to the same bug: \lst@DefRange is
%    redefined globally when the begin of code is found, see below. The bug was
%    reported by \lsthelper{Tobias~Rapp}{2004/04/06}{undetected end of range if
%    listing crosses page break} \lsthelper{Markus~Luisser}{2004/08/13}{Bug mit
%    'linerangemarker' in umgebrochenen listings}
%\lst@AddToHook{SelectCharTable}{\lst@DefRange}
\lst@AddToHookExe{DeInit}{\global\let\lst@DefRange\@empty}
%
%    Actually defining the marker (via \lst@GLI@, \lst@DefRange, \lst@CArgX as
%    seen above) is similar to \lst@DefDelimB---except that we unfold the first
%    parameter and use different <execute>, <pre>, and <post> statements.
\def\lst@DefRangeB#1#2{\lst@DefRangeB@#1#2}
\def\lst@DefRangeB@#1#2#3#4{%
    \lst@CDef{#1{#2}{#3}}#4{}%
    {\lst@ifincluderangemarker
         \lst@LeaveMode
         \let#1#4%
         \lst@DefRangeEnd
         \lst@InitLstNumber
     \else
         \@tempcnta\lst@lineno \advance\@tempcnta\@ne
         \edef\lst@firstline{\the\@tempcnta\relax}%
         \gdef\lst@OnceAtEOL{\let#1#4\lst@DefRangeEnd}%
         \lst@InitLstNumber
     \fi
	 \global\let\lst@DefRange\lst@DefRangeEnd
     \lst@CArgEmpty}%
    \@empty}
%
% Modify labels and define |\lst@InitLstNumber| used above.
% \lsthelper{Omair-Inam~Abdul-Matin}{2004/05/10}{experimental linerange
% feature does not work with firstnumber}
\def\lstpatch@labels{%
\gdef\lst@SetFirstNumber{%
    \ifx\lst@firstnumber\@undefined
        \@tempcnta 0\csname\@lst no@\lst@intname\endcsname\relax
        \ifnum\@tempcnta=\z@ \else
            \lst@nololtrue
            \advance\@tempcnta\lst@advancenumber
            \edef\lst@firstnumber{\the\@tempcnta\relax}%
        \fi
    \fi}%
}
\lst@AddToAtTop\lsthk@PreInit
    {\ifx\lst@firstnumber\@undefined
         \def\lst@firstnumber{\lst@lineno}%
     \fi}
\def\lst@InitLstNumber{%
     \global\c@lstnumber\lst@firstnumber
     \global\advance\c@lstnumber\lst@advancenumber
     \global\advance\c@lstnumber-\lst@advancelstnum
     \ifx \lst@firstnumber\c@lstnumber
         \global\advance\c@lstnumber-\lst@advancelstnum
     \fi}
%
%    The end-marker is defined if and only if it's not empty. The definition is
%    similar to \lst@DefDelimE---with the above exceptions and except that we
%    define the re-entry point \lst@DefRangeE@@ as it is defined in the new
%    version of \lst@MProcessListing above.
\def\lst@DefRangeEnd{%
    \ifx\lst@rangeend\@empty\else
        \expandafter\lst@CArgX\lst@rangeend\relax\lst@DefRangeE
    \fi}
\def\lst@DefRangeE#1#2{\lst@DefRangeE@#1#2}
\def\lst@DefRangeE@#1#2#3#4{%
    \lst@CDef{#1#2{#3}}#4{}%
    {\let#1#4%
     \edef\lst@lastline{\the\lst@lineno\relax}%
     \lst@DefRangeE@@}%
    \@empty}
\def\lst@DefRangeE@@#1\@empty{%
    \lst@ifincluderangemarker
        #1\lst@XPrintToken
    \fi
    \lst@LeaveModeToPmode
    \lst@BeginDropInput{\lst@Pmode}}
%
\def\lst@LeaveModeToPmode{%
    \ifnum\lst@mode=\lst@Pmode
        \expandafter\lsthk@EndGroup
    \else
        \expandafter\egroup\expandafter\lst@LeaveModeToPmode
    \fi}
%
%    Eventually we shouldn't forget to install \lst@OnceAtEOL, which must
%    also be called in \lst@MSkipToFirst.
\lst@AddToHook{EOL}{\lst@OnceAtEOL\global\let\lst@OnceAtEOL\@empty}
\gdef\lst@OnceAtEOL{}% Init
\def\lst@MSkipToFirst{%
    \global\advance\lst@lineno\@ne
    \ifnum \lst@lineno=\lst@firstline
        \def\lst@next{\lst@LeaveMode \global\lst@newlines\z@
        \lst@OnceAtEOL \global\let\lst@OnceAtEOL\@empty
        \lst@InitLstNumber % Added to work with modified \lsthk@PreInit.
        \lsthk@InitVarsBOL
        \lst@BOLGobble}%
        \expandafter\lst@next
    \fi}
\def\lst@SkipToFirst{%
    \ifnum \lst@lineno<\lst@firstline
        \def\lst@next{\lst@BeginDropInput\lst@Pmode
        \lst@Let{13}\lst@MSkipToFirst
        \lst@Let{10}\lst@MSkipToFirst}%
        \expandafter\lst@next
    \else
        \expandafter\lst@BOLGobble
    \fi}
%
%    Finally the service macro \lst@IfNumber:
\def\lst@IfNumber#1{%
    \ifx\@empty#1\@empty
        \let\lst@next\@firstoftwo
    \else
        \lst@IfNumber@#1\@nil
    \fi
    \lst@next}
\def\lst@IfNumber@#1#2\@nil{%
    \let\lst@next\@secondoftwo
    \ifnum`#1>47\relax \ifnum`#1>57\relax\else
        \let\lst@next\@firstoftwo
    \fi\fi}
%
% b) The following is known to fail with some keys.
\lst@Key{multicols}{}{\@tempcnta=0#1\relax\def\lst@multicols{#1}}
\def\lst@Init#1{%
    \begingroup
    \ifx\lst@float\relax\else
        \edef\@tempa{\noexpand\lst@beginfloat{lstlisting}[\lst@float]}%
        \expandafter\@tempa
    \fi
% chmod begin
    \ifx\lst@multicols\@empty\else
        \edef\lst@next{\noexpand\multicols{\lst@multicols}}
        \expandafter\lst@next
    \fi
% chmod end
    \ifhmode\ifinner \lst@boxtrue \fi\fi
    \lst@ifbox
        \lsthk@BoxUnsafe
        \hbox to\z@\bgroup
             $\if t\lst@boxpos \vtop
        \else \if b\lst@boxpos \vbox
        \else \vcenter \fi\fi
        \bgroup \par\noindent
    \else
        \lst@ifdisplaystyle
            \lst@EveryDisplay
            \par\penalty-50\relax
            \vspace\lst@aboveskip
        \fi
    \fi
    \normalbaselines
    \abovecaptionskip\lst@abovecaption\relax
    \belowcaptionskip\lst@belowcaption\relax
    \lst@MakeCaption t%
    \lsthk@PreInit \lsthk@Init
    \lst@ifdisplaystyle
        \global\let\lst@ltxlabel\@empty
        \if@inlabel
            \lst@ifresetmargins
                \leavevmode
            \else
                \xdef\lst@ltxlabel{\the\everypar}%
                \lst@AddTo\lst@ltxlabel{%
                    \global\let\lst@ltxlabel\@empty
                    \everypar{\lsthk@EveryLine\lsthk@EveryPar}}%
            \fi
        \fi
        \everypar\expandafter{\lst@ltxlabel
                              \lsthk@EveryLine\lsthk@EveryPar}%
    \else
        \everypar{}\let\lst@NewLine\@empty
    \fi
    \lsthk@InitVars \lsthk@InitVarsBOL
    \lst@Let{13}\lst@MProcessListing
    \let\lst@Backslash#1%
    \lst@EnterMode{\lst@Pmode}{\lst@SelectCharTable}%
    \lst@InitFinalize}
\def\lst@DeInit{%
    \lst@XPrintToken \lst@EOLUpdate
    \global\advance\lst@newlines\m@ne
    \lst@ifshowlines
        \lst@DoNewLines
    \else
        \setbox\@tempboxa\vbox{\lst@DoNewLines}%
    \fi
    \lst@ifdisplaystyle \par\removelastskip \fi
    \lsthk@ExitVars\everypar{}\lsthk@DeInit\normalbaselines\normalcolor
    \lst@MakeCaption b%
    \lst@ifbox
        \egroup $\hss \egroup
        \vrule\@width\lst@maxwidth\@height\z@\@depth\z@
    \else
        \lst@ifdisplaystyle
            \par\penalty-50\vspace\lst@belowskip
        \fi
    \fi
% chmod begin
    \ifx\lst@multicols\@empty\else
        \def\lst@next{\global\let\@checkend\@gobble
                      \endmulticols
                      \global\let\@checkend\lst@@checkend}
        \expandafter\lst@next
    \fi
% chmod end
    \ifx\lst@float\relax\else
        \expandafter\lst@endfloat
    \fi
    \endgroup}
\let\lst@@checkend\@checkend
%%
\endinput
%%
%% End of file `lstpatch.sty'.

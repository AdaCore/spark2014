\section{Introduction}
\subsection{Background}

\subsection{Motivations}
%\subsection{Using Formal Semantics for Certification}
%First, certification process of SPARK technology can be stressed by the use of 
%formal semantics.
We believe that the certification process of SPARK technology can be
stressed by the use of formal semantics.
Indeed, the software certification process as required by the DO-178-C \cite{RTCA:DO-178} 
standard allows formal verification to replace some forms of testing. 
This is one of the goals pursued by the SPARK toolchain resulting from 
the Hi-Lite project \cite{Hi-Lite:URL}. On the other hand, the DO-333 
supplement \cite{RTCA:DO-333} (formal method supplement to DO-178-C) recommends that 
when using formal methods "all assumptions related to each formal 
analysis should be described and justified". As any formal static 
analysis must rely on the behavior of the language being analyzed, a 
precise and unambiguous definition of the semantics of this language 
becomes clearly a requirement in the certification process.

%\subsection{}
%Second, enforce the theoretical foundation of the GNATprove
%toolchain.
We also aim to strengthen the theoretical foundation of the GNATprove
toolchain.
The Ada reference manual \cite{Ada:URL} introduces the notion of $\mathit{errors}$.
These correspond to error situations that must be detected 
at run time as well as erroneous executions that need not to be 
detected. In Ada, the former are detected by run-time checks 
(RTCs) inserted by the compiler. Both must be guaranteed never to
occur during the process of proving SPARK (or Ada) subprograms within
the GNATprove toolchain \cite{Gnatprove:URL}. This can be ensured either by static
analysis or by generating verification conditions (VCs) showing that 
the corresponding error situations never occur at that point in the 
subprogram. The generated VCs must be discharged in order to prove the 
subprogram.  Tools within the GNATprove toolchain strongly rely on the 
completeness of this VCs generation process. Our semantics setting on 
top of a proof assistant open the possibility to formally (and 
mechanically) verify (to some extent) this completeness. In practice, 
since VCs are actually generated from the RTCs generated by the 
compiler, this completeness verification amounts to analyzing the RTCs 
inserted by the compiler in the abstract syntax tree produced by the 
GNAT compiler.

%\subsection{}
%Third, formal proofs of analyzers and certified compilers.
Finally, one of our long-term goals is to provide infrastructure that can be 
leveraged in a variety of ways to support machine-verified proofs of 
correctness of SPARK 2014 static analysis and 
translations. To this end, we will build a translation framework 
from SPARK 2014 to Coq, which puts in place crucial infrastructure 
necessary for supporting formal proofs of SPARK analysis. Together 
with the formal semantics of SPARK, it provides the potential to 
connect to the Compcert \cite{Leroy:09} certified compiler framework.

\subsection{Contributions}
The major contributions in this paper are:
\begin{itemize}
\item Formalize a core subset of SPARK 2014 Language in Coq Proof Assistant and
run-time checks are formalized as an important integrant to provide run-time
errors free SPARK programs.
\item Verify a nontrivial subset of run-time check flags generated by Gnat
front end, and at the same time it also helps to patch Gnat front end in case of
any implementation errors resulting in missing or wrong run-time check flags.
\item Optimize run-time checks and prove its soundess.  
\item Build a tool chain from SPARK to Coq formalization and make it possible to
integrate our SPARK formalization work into GnatProve tool chain.
\item Run-time check evaluation on real SPARK programs.
\end{itemize}
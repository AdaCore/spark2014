\section{Overview}
In the long path through the definition of complete semantics for SPARK 2014, a
very important step is to build a tool chain allowing its application in formal
verification and proof on real SPARK 2014 programs. It also makes it possible to
integrate our SPARK formalization work into GnatProve toolchain to serve as
a soundness verification tool for run-time check flags generated by Gnat front
end.

\paragraph{SPARK Translation Toolchain}
In the front end of this tool chain, Gnat2XML, developed by AdaCore, translates
SPARK programs to a fully resolved XML abstract syntax tree (AST) representation
with an accompanying XML schema. As part of the Sireum analysis framework [5],
we have furtherly developed a tool called Jago [4] that translates XML
representation of the GNAT compiler's ASTs into a Scala-based representation in
Sireum. This open-source framework enables one to build code translators and
analysis tools for SPARK 2014 in Scala. Scala's blending of functional and
object-oriented program styles have proven quite useful in other contexts for
syntax tree manipulation and analysis. Integrated into Jago are two kinds of
translations: (1) type translation to translate Gnat2XML-generated XML schema to
inductive type definition in Coq; (2) program translation to translate
Gnat2XML-generated XML AST representation into Coq based representations.

\paragraph{Formalization and Proof in Coq}
With Coq inductive type definition for SPARK AST syntax produced by Jago type
translator, formal semantics encoding run-time checks for SPARK has
been developed within Coq, which is refered as SPARK reference semantics.
Besides, a formal semantics for SPARK AST extended with run-time check flags
are defined, where run-time checks are performed only if the appropriate check
flags are set for the operations. And an AST translator from a SPARK AST to a
run-time check flagged AST is provided and proved correct with respect to the
SPARK reference semantics.

\paragraph{Run-Time Checks Verification}
In GnatProve tool chain, the run-time check flags set by GNAT frontend for SPARK
AST will trigger the corresponding checks verification in its back end by
applying formal verification methods. It happens that some formally proved SPARK
programs get into run-time errors because of missing or misplaced run-time check
flags in SPARK AST. For example, at AdaCore, they developed a small Tetris
program in SPARK for a demonstration of SPARK in GNAT Pro Industrial Day. But
the program runs into a constraint error even though it has been proved to be
free of run-time errors because of a missing range check on an expression
inside a 'Update attribute reference.
To verify the completeness of run-time check flags in SPARK AST as required by
SPARK semantics, a formally proved run-time checks generator and verification
tool are developed. For easy use of run-time checks verification, any incorrect
checks on SPARK AST will be mapped back to the SPARK source code. 

\paragraph{Run-Time Checks Optimization}
Instead of putting a full list of run-time check flags in SPARK ASTs, GNAT
frontend is smart enough to remove those unnecessary run-time cheks by
performing some simple optimizations. To verify the correctness of these checks
optimizations, we haved formalized some simple checks optimization rules in Coq
and have proved their soundess with respect to the SPARK reference semantics.


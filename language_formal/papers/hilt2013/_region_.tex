\message{ !name(intro.tex)}
\message{ !name(intro.tex) !offset(-2) }
\section{Introduction}
\label{sec:intro}

Though first proposed as researchers have looked for techniques that automatically discover
wide-ranging properties of a
program's behavior with little or no developer intervention.


Though it was originally proposed in Symbolic execution
undergone a re
Recent interest in symbolic execution...
\begin{itemize}
\item Symbolic execution has experienced a resurgence within the past
  years.
\item Has been used for assertion checking, bug finding, test case
  generation, visualization/understanding.
\item Much of the work has been carried out in the context of OO
  languages such as Java, C++, and C\#.
\end{itemize}

Potential for contract checking for safety/security-critical languages
(this could potentially be merged with the paragraph above)...
\begin{itemize}
\item Work has grown out of the model checking community, provides
  automatic abstraction, emphasizes systematic exploration.
\item While most work has focused on bug-finding or test case
  generation in OO languages, we believe that symbolic execution can serve as a 
true verification technique that can provide high-confidence in the
domain of embedded safety/security-critical systems.
\item Our past work has emphasized a foundational approach to symbolic
  execution; using it not just for bug-finding but for
  contract-checking.  In addition, we have sought to rigorously
  justify symbolic execution algorithms by providing proofs of
  correctness for complex optimizations and by providing mathematical
  approaches to calculate minimum number of test-cases and execution
  paths needed to achieve certain levels of coverage.
\end{itemize}
[Possible transition from the paragraph above:  while sym exe can be
applied in most any context, we are especially interested in pushing
forward in contexts that target critical systems, languages designed
for verification.]


Spark...
\begin{itemize}
\item SPARK -- a framework for critical system development focusing on
  embedded systems.
\item Language is designed for verification.  No OO, no dynamically
  allocated data, no recursion, no exceptions.
\item Accompanying tools provide light-weight static of dataflow
  properties (uninitialized variables, ineffective assignments, dead
  code), information flow dependences between input and output
  variables.
\item Tools also include assertion and contract checking using
  verification condition (VC) generation with VCs subsequently
  discharged using decision procedures (in the SPARK Simplifier tool)
  and an interactive theorem prover (the SPARK Proof Checker tool).
\item Used in a number of important applications including iFACTS,
  Tokeneer, etc.
\item Because it lacks dynamically allocated data, most data structures are
  implemented in SPARK using arrays.
\end{itemize}

SPARK disadvantages...
\begin{itemize}
\item While SPARK is an exemplar of practical application of formal methods
  in critical applications, most users employ the static analysis
  techniques while the contract checking framework is seldom used.
\item This is because the existing SPARK Simplifier has not tracked
  state-of-the-art decision procedures and Proof Checker framework is
  almost completely driven by manual user steps and is in no way
  comparable to a modern tactic-based theorem prover.
\item This has led to the unfortunate situation where the typical
  SPARK user gets no benefit from the SPARK contract language.
\item We found this situation to be especially discouraging since we
  were using SPARK in an industrial collaboration targetting the
  development and certification of embedded security devices.
\end{itemize}

Sym Exe can help Spark and similar languages...
\begin{itemize}
\item We believe that the foundational approach to symbolic execution 
that we have been pursuing can improve significantly the useability
and effectiveness of the SPARK contract language by providing a
completely automated bounded verification technology that scales to 
very complex SPARK contracts.
\item Our experience to-date has uncovered the following interesting
  aspects about applying symbolic execution for SPARK...
\item Symbolic execution
  technology can provide checking of contracts that one would
  typically never even attempt to check with existing SPARK tools because the manual
efforts involved in using the SPARK Proof Checker would be too great.
\item The style of bounded checking, while technically not providing
  the complete checking provided by a VC gen + theorem prover
  framework, in practice many time provides complete verification of
  procedures in embedded applications because such applications often 
  have procedures that have no loops (SymExe is typically bounded by
  unrolling loops to a specific depth).
\item In addition, embedded applications usually statically bound the
  size of data structures -- in SPARK, all data structures must be
  statically bounded.  Compared to conventional applications, this
  increases the likelihood signficant portions of a program's
  state-space can be covered within the bounding employed by the
  symbolic execution engine.
\end{itemize}

How is Sym Exe for SPARK different that Sym Exe for other languages...
\begin{itemize}
\item Most of the recent work on symbolic execution has focused on
  languages such as Java, C, and C\#.  
\item Because these languages emphasize representing data structures 
via heap-allocated data, there has been a substantial amount of work
on developing optimizations for handling heap-based data.
\item In contrast, while these languages include arrays, there has
  been relatively little work on investigating and evaluating array representations
  for symbolic execution.
\item 
\end{itemize}

In this paper, we propose and evaluate a collection of strategies for
symbolic execution of static array-based data structures such as those
occuring in SPARK and other languages used for embedded critical systems.


The contributions of this paper are...
\begin{itemize}
\item a formalization of symbolic execution for static arrays that uses a
   symbolic-state-based representation sufficient for supporting
   symbolic execution for multi-dimensional nested arrays such as
   those found in SPARK 
\item a robust, open source implementation of
   this strategy 
\item evaluations that demonstrate dramatic improvements to the levels of 
   automation required for verifying SPARK code against contracts in
   applications that use array-based data structures
   
   \emph{Advance over baseline: 
     our approach provides much greater automation than existing
   Praxis tools}
\item experimental studies that evaluate the proposed
   strategies against other sym exe strategies for heap-based data and
   purely logical representations used in existing verification
   condition-based approaches
   
   \emph{Advance over baseline:
   \begin{itemize} 
     \item our approach enables checking of executable specs
       (not supported by existing Praxis tools or VC Gen based
       approaches)
     \item for declarative specs,
        our approach improves over a naive adapation of existing sym
       exe approaches for dealing with heap data
     \item for declarative specs,
        our approach improves on existing VC gen approaches that use
        logical representations of arrays.
   \end{itemize}}
\end{itemize}


\message{ !name(intro.tex) !offset(-162) }

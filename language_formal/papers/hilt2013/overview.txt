// Is a simple text file ok?


title "Towards a formalisation of the SPARK 2014 semantics within Coq"

We present our ongoing work of writing a formal semantics for SPARK
2014. The semantics is written in the Coq proof assistant together
with proved correct executable semantics and other properties.

MOTIVATIONS

+ Certification process of Spark technology needs some formal semantics

The software certification process as required by the DO-178-C
standard allows formal verification to replace some forms of testing.
This is one of the goals pursued by the spark toolchain. On the other
hand DO-333 (formal method supplement to DO-178-C) recommends that
when using formal methods "all assumptions related to each formal
analysis should be described and justified". As formal static analysis
rely on the behaviour of the language being analyzed, a precise and
unambiguous definition of semantics of this language becomes clearly
needed.

+ Enforce the theoretical foundation of gnatprove toolchain

Ada reference manual makes use of the notion of errors, which covers
incorrect executions that must be detected at runtime and erroneous
execution that *may* be detected at runtime. In Ada, this errors are
detected by runtime checks (RCs) inserted by the compiler. In
contrast, in Spark the same errors must be guaranteed to never
happen. This is ensured either by static analysis or by generation
of verification conditions (VCs) that must be discharged to prove
the program. The tools of the gnatprove toolchain strongly rely on
the completeness of the VCs generation. The definition of spark
semantics in a proof assistant opens the possibility to formally
verify this completeness. In practice, since VCs are actually
generated from the RCs generated by the compiler, this verification
amounts to analyzing the RCs in the abstract syntax tree generated
by the compiler.

+ Formal proofs of analyzers + proof of a compiler
It also opens the road to the certification of static analyzers and
even to the implementation of a certified compiler Ã  la
Compcert[compcert].


DESCRIPTION OF THE WORK
+ xml + coq translation toolchain

Our final goal is to build the tool chain from SPARK 2014 source file
to certified program evaluation with respect to appropriate run-time
checks, for example division by zero check and overflow check. In the
front end of this tool chain, a series of transformations from SPARK
source file to an intermediate representation is performed, first
SPARK program is translated into XML AST by GNAT2XML , and then the
XML AST is translated into Coq AST by Jago tool. In the backend of the
tool chain, a certified interpreter for the Coq AST is being developed
in Coq.

We define the formal semantic of SPARK 2014 subset language according
to its reference manual with appropriate checks performed on top of
the AST tree according to the checking rules. This semantics can be
checked and verified by the SPARK experts, it's the trust base of the
whole formalization and certification work, and it serves as the
reference semantics for the language. We prove that programs with
right checks put at the right places should behave the same as it's
interpreted under this reference semantics. An interpreter is
implemented and certified with regard to this reference semantics. So
the results outputted by this certified interpreter should be our
expected ones.

+ Properties

It is proved that a well typed and well formed program
will not generate some class of errors at execution.

CONCLUSION

+ Validation of the semantics

The usual question about formal semantics is the following: how
certain are we that the formalized semantics is the right one? There
are two answers: first the semantics should be read and validated by
Ada and spark experts and second we provide an interpreter proved
correct with respect to the semantics, on which we can perform tests
to compare the results of the interpreter and compiled program.

---
Related work
---

A formal semantics was previously defined for SPARK Ada 83 in [1,2].
This definition includes both the static and the dynamic semantics of
the language and rely on a precise notation inspired by the Z
notation. Formalising the full SPARK subset was clearly a challenging
task and the result is indeed quite impressive: more than 500 pages
were required for the complete set of rules. However, this semantics
was not executable (it was only given on paper) and no tool was used
to check the soundness of the definition. Moreover, no property was
proved using this semantics.


[1] Formal Semantics of SPARK
Static Semantics
William Marsh - October 1994

The Static Semantics, or well-formation rules, of the SPARK Ada subset
are formally defined using inference rules in the Structured
Operational Semantics style.


[2] Formal Semantics of SPARK
Dynamic Semantics
Ian O'Neill - October 1994

The Dynamic Semantics, or evaluation rules, of the SPARK Ada subset
are formally defined using inference rules in the Structured
Operational Semantics style.

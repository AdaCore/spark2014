(* This file is generated by Why3's Coq-realize driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require int.Int.
Require int.Abs.
Require int.EuclideanDivision.
Require int.ComputerDivision.

(* Why3 goal *)
Definition mod1 :
  Numbers.BinNums.Z -> Numbers.BinNums.Z -> Numbers.BinNums.Z.
Proof.
  exact (fun (x y : Z) => let r := EuclideanDivision.mod1 x y in if (Zge_bool y 0%Z) then r else if (Zeq_bool 0%Z r) then 0%Z else (r + y)%Z).
Defined.

Ltac des_lt x y := pose proof (Zlt_cases x y); destruct (x <? y)%Z.
Ltac des_le x y := pose proof (Zle_cases x y); destruct (x <=? y)%Z.
Ltac des_ge x y := pose proof (Zge_cases x y); destruct (x >=? y)%Z.
Ltac des_eq x y := pose proof (Zeq_bool_if x y); destruct (Zeq_bool x y).

(* Why3 goal *)
Lemma mod'def :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z),
  let r := int.EuclideanDivision.mod1 x y in
  ((0%Z <= y)%Z -> ((mod1 x y) = r)) /\
  (~ (0%Z <= y)%Z ->
   ((r = 0%Z) -> ((mod1 x y) = 0%Z)) /\
   (~ (r = 0%Z) -> ((mod1 x y) = (r + y)%Z))).
Proof.
  intros x y r; split; unfold mod1; intros;
  des_ge y 0%Z; auto; try omega.
  split; intros; fold r; des_eq 0%Z r; omega.
Qed.

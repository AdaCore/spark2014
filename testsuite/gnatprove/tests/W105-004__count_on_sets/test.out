ho_sets.adb:8:07: medium: implicit terminating annotation on "Count" could be incorrect, call via access-to-subprogram might be nonterminating
ho_sets.adb:9:16: info: pointer dereference check proved (CVC5: 1 VC)
ho_sets.adb:9:22: info: precondition proved (CVC5: 1 VC)
ho_sets.adb:9:58: info: predicate check proved (Trivial: 1 VC)
ho_sets.adb:9:79: info: predicate check proved (Trivial: 1 VC)
ho_sets.adb:10:09: info: predicate check proved (Trivial: 1 VC)
ho_sets.adb:10:09: info: subprogram variant proved (CVC5: 1 VC)
ho_sets.adb:10:16: info: precondition proved (CVC5: 1 VC)
ho_sets.adb:10:35: info: precondition proved (CVC5: 1 VC)
ho_sets.adb:17:10: info: predicate check proved (Trivial: 1 VC)
ho_sets.adb:17:27: info: predicate check proved (Trivial: 1 VC)
ho_sets.adb:19:37: info: precondition proved (CVC5: 1 VC)
ho_sets.adb:21:13: info: precondition proved (CVC5: 1 VC)
ho_sets.adb:21:13: info: subprogram variant proved (CVC5: 1 VC)
ho_sets.adb:21:42: info: null exclusion check proved (CVC5: 1 VC)
ho_sets.adb:22:13: info: precondition proved (CVC5: 1 VC)
ho_sets.adb:22:13: info: subprogram variant proved (CVC5: 1 VC)
ho_sets.adb:22:29: info: precondition proved (CVC5: 1 VC)
ho_sets.adb:22:47: info: precondition proved (CVC5: 1 VC)
ho_sets.adb:32:31: info: precondition proved (CVC5: 1 VC)
ho_sets.adb:35:10: info: precondition proved (CVC5: 1 VC)
ho_sets.adb:35:10: info: subprogram variant proved (CVC5: 1 VC)
ho_sets.adb:35:30: info: precondition proved (CVC5: 1 VC)
ho_sets.adb:36:10: info: precondition proved (Z3: 1 VC)
ho_sets.adb:36:10: info: subprogram variant proved (CVC5: 1 VC)
ho_sets.adb:36:26: info: precondition proved (CVC5: 1 VC)
ho_sets.adb:36:34: info: precondition proved (CVC5: 1 VC)
ho_sets.adb:36:64: info: precondition proved (CVC5: 1 VC)
ho_sets.adb:36:72: info: precondition proved (CVC5: 1 VC)
ho_sets.adb:36:102: info: null exclusion check proved (CVC5: 1 VC)
ho_sets.adb:37:10: info: precondition proved (CVC5: 1 VC)
ho_sets.adb:37:10: info: subprogram variant proved (CVC5: 1 VC)
ho_sets.adb:37:30: info: precondition proved (CVC5: 1 VC)
ho_sets.ads:8:13: info: function contract might not be available on recursive calls
ho_sets.ads:10:28: info: function contract feasibility proved (Trivial: 1 VC)
ho_sets.ads:14:42: info: range check proved (CVC5: 1 VC)
ho_sets.ads:15:06: warning: Always_Return annotation is useless
ho_sets.ads:15:06: warning: function "Count" has implicit Always_Return annotation
ho_sets.ads:16:14: info: postcondition proved (CVC5: 1 VC)
ho_sets.ads:16:19: info: predicate check proved (Trivial: 1 VC)
ho_sets.ads:16:30: info: predicate check proved (Trivial: 1 VC)
ho_sets.ads:18:14: info: implicit terminating annotation on "Lemma_Count_Eq" has been proved, subprogram will terminate
ho_sets.ads:20:30: info: function contract feasibility proved (Trivial: 1 VC)
ho_sets.ads:24:06: warning: Always_Return annotation is useless
ho_sets.ads:24:06: warning: automatically instantiated lemma "Lemma_Count_Eq" has implicit Always_Return annotation
ho_sets.ads:25:42: info: range check proved (CVC5: 1 VC)
ho_sets.ads:27:14: info: postcondition proved (CVC5: 1 VC)
ho_sets.ads:27:14: info: predicate check proved (Trivial: 1 VC)
ho_sets.ads:27:27: info: null exclusion check proved (CVC5: 1 VC)
ho_sets.ads:27:35: info: predicate check proved (Trivial: 1 VC)
ho_sets.ads:27:49: info: null exclusion check proved (CVC5: 1 VC)
ho_sets.ads:32:28: info: function contract feasibility proved (Trivial: 1 VC)
ho_sets.ads:36:06: warning: Always_Return annotation is useless
ho_sets.ads:36:06: warning: automatically instantiated lemma "Lemma_Count_Remove" has implicit Always_Return annotation
ho_sets.ads:37:42: info: predicate check proved (Trivial: 1 VC)
ho_sets.ads:37:61: medium: range check might fail [reason for check: expression of type Big_Integer must be non-negative]
ho_sets.ads:37:63: info: predicate check proved (Trivial: 1 VC)
ho_sets.ads:39:14: info: postcondition proved (CVC5: 1 VC)
ho_sets.ads:39:14: info: predicate check proved (Trivial: 1 VC)
ho_sets.ads:39:32: info: null exclusion check proved (CVC5: 1 VC)
ho_sets.ads:39:38: medium: implicit terminating annotation on "Lemma_Count_Remove" could be incorrect, call via access-to-subprogram might be nonterminating
ho_sets.ads:40:10: info: predicate check proved (Trivial: 1 VC)
ho_sets.ads:40:17: info: precondition proved (CVC5: 1 VC)
ho_sets.ads:40:43: info: null exclusion check proved (CVC5: 1 VC)
ho_sets.ads:41:16: info: pointer dereference check proved (CVC5: 1 VC)
ho_sets.ads:41:44: info: predicate check proved (Trivial: 1 VC)
ho_sets.ads:41:65: info: predicate check proved (Trivial: 1 VC)
use_sets.adb:9:70: info: function contract feasibility proved (Trivial: 1 VC)
use_sets.adb:13:14: info: postcondition proved (CVC5: 1 VC)
use_sets.adb:13:14: info: predicate check proved (Trivial: 1 VC)
use_sets.adb:13:21: info: precondition proved (CVC5: 1 VC)
use_sets.adb:13:33: info: null exclusion check proved (CVC5: 1 VC)
use_sets.adb:13:38: info: predicate check proved (Trivial: 1 VC)
use_sets.adb:13:48: info: null exclusion check proved (CVC5: 1 VC)
use_sets.adb:13:57: info: pointer dereference check proved (CVC5: 1 VC)
use_sets.adb:13:79: info: predicate check proved (Trivial: 1 VC)
use_sets.adb:13:89: info: predicate check proved (Trivial: 1 VC)
use_sets.adb:17:73: info: function contract feasibility proved (Trivial: 1 VC)
use_sets.adb:21:14: info: postcondition proved (CVC5: 1 VC)
use_sets.adb:21:14: info: predicate check proved (Trivial: 1 VC)
use_sets.adb:21:21: info: precondition proved (CVC5: 1 VC)
use_sets.adb:21:36: info: null exclusion check proved (CVC5: 1 VC)
use_sets.adb:21:41: info: predicate check proved (Trivial: 1 VC)
use_sets.adb:21:51: info: null exclusion check proved (CVC5: 1 VC)
use_sets.adb:21:60: info: pointer dereference check proved (CVC5: 1 VC)
use_sets.adb:21:82: info: predicate check proved (Trivial: 1 VC)
use_sets.adb:21:92: info: predicate check proved (Trivial: 1 VC)
use_sets.adb:27:13: info: function contract might not be available on implicit recursive calls
use_sets.adb:27:13: info: implicit terminating annotation on "Count_Values_In_Range" has been proved, subprogram will terminate
use_sets.adb:27:45: warning: unused variable "A"
use_sets.adb:27:48: warning: unused variable "B"
use_sets.adb:28:14: info: postcondition proved (CVC5: 1 VC)
use_sets.adb:28:35: info: predicate check proved (Trivial: 1 VC)
use_sets.adb:28:46: info: predicate check proved (Trivial: 1 VC)
use_sets.adb:31:16: info: implicit terminating annotation on "In_Range" has been proved, subprogram will terminate
use_sets.adb:33:16: info: implicit terminating annotation on "Count_In_Range" has been proved, subprogram will terminate
use_sets.adb:41:17: info: postcondition proved (CVC5: 1 VC)
use_sets.adb:41:17: info: predicate check proved (Trivial: 1 VC)
use_sets.adb:41:33: info: precondition proved (CVC5: 1 VC)
use_sets.adb:41:47: info: predicate check proved (Trivial: 1 VC)
use_sets.adb:41:100: info: predicate check proved (Trivial: 1 VC)
use_sets.adb:41:110: info: predicate check proved (Trivial: 1 VC)
use_sets.adb:48:17: info: postcondition proved (CVC5: 1 VC)
use_sets.adb:48:17: info: predicate check proved (Trivial: 1 VC)
use_sets.adb:48:33: info: precondition proved (CVC5: 1 VC)
use_sets.adb:48:50: info: predicate check proved (Trivial: 1 VC)
use_sets.adb:48:103: info: predicate check proved (Trivial: 1 VC)
use_sets.adb:48:113: info: predicate check proved (Trivial: 1 VC)

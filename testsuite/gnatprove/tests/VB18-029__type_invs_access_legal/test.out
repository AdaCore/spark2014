pred.ads:4:13: info: implicit aspect Always_Terminates on "Get" has been proved, subprogram will terminate
pred.ads:7:13: info: implicit aspect Always_Terminates on "Bad_New_T" has been proved, subprogram will terminate
pred.ads:7:13: medium: for the result of "Bad_New_T" at pred.ads:7
pred.ads:7:13: medium: in inlined invariant at pred.ads:10
pred.ads:7:13: medium: invariant check might fail, cannot prove T >= 0 (e.g. when Bad_New_T'Result.all = (Content => -1)) [provers reached step limit before completing the proof]
pred.ads:8:13: info: for the result of "Ok_New_T" at pred.ads:8
pred.ads:8:13: info: implicit aspect Always_Terminates on "Ok_New_T" has been proved, subprogram will terminate
pred.ads:8:13: info: invariant check proved (CVC5: 1 VC; Trivial: 1 VC)
pred.ads:10:09: info: invariant check proved on default value (CVC5: 1 VC)
pred.ads:10:74: info: in default value of private type at pred.ads:3
pred.ads:10:74: info: range check proved (CVC5: 2 VC)
pred.ads:11:09: info: invariant check proved on default value (CVC5: 1 VC)
pred.ads:14:09: info: invariant check proved on default value (CVC5: 1 VC; Trivial: 1 VC)
pred.ads:16:13: info: implicit aspect Always_Terminates on "Priv_New_T" has been proved, subprogram will terminate
use_preds.ads:7:13: info: implicit aspect Always_Terminates on "All_Pos" has been proved, subprogram will terminate
use_preds.ads:7:13: warning: "All_Pos" is recursive; its contract might not be available on recursive calls from contracts and assertions [contracts-recursive]
use_preds.ads:9:14: info: postcondition proved (CVC5: 1 VC)
use_preds.ads:17:36: info: pointer dereference check proved (CVC5: 1 VC)
use_preds.ads:17:49: info: subprogram variant proved (Trivial)
use_preds.ads:17:59: info: pointer dereference check proved (CVC5: 1 VC)

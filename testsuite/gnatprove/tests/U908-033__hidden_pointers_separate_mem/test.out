abstract_maps.ads:21:23: warning: unused variable "K"
abstract_maps.ads:47:13: info: subprogram "Is_Empty" will terminate, terminating annotation has been proved, in instantiation at pointers_with_aliasing.ads:24, in instantiation at example_recursive.adb:10
abstract_maps.ads:48:07: info: precondition proved (Trivial: 1 VC), in instantiation at pointers_with_aliasing.ads:24, in instantiation at example_recursive.adb:10
abstract_maps.ads:48:15: warning: unused variable "K"
abstract_maps.ads:49:09: info: data dependencies proved, in instantiation at pointers_with_aliasing.ads:24, in instantiation at example_recursive.adb:10
example_recursive.adb:21:07: info: precondition proved (Trivial: 1 VC)
example_recursive.adb:21:25: info: precondition proved (CVC5: 1 VC)
example_recursive.adb:34:41: info: precondition proved (CVC5: 1 VC)
example_recursive.adb:34:41: info: tag check proved (CVC5: 1 VC)
example_recursive.adb:35:32: info: precondition proved (CVC5: 1 VC)
example_recursive.adb:35:32: info: tag check proved (CVC5: 1 VC)
example_recursive.adb:36:19: info: precondition proved (CVC5: 1 VC)
example_recursive.adb:36:19: info: subprogram variant proved (CVC5: 1 VC)
example_recursive.adb:36:51: info: precondition proved (CVC5: 1 VC)
example_recursive.adb:36:51: info: tag check proved (CVC5: 1 VC)
example_recursive.adb:36:69: info: range check proved (CVC5: 2 VC)
example_recursive.adb:38:06: info: data dependencies proved
example_recursive.adb:44:16: info: precondition proved (CVC5: 1 VC)
example_recursive.adb:50:31: info: precondition proved (CVC5: 8 VC)
example_recursive.adb:50:31: info: subprogram variant proved (CVC5: 1 VC)
example_recursive.adb:50:62: info: precondition proved (CVC5: 1 VC)
example_recursive.adb:50:62: info: tag check proved (CVC5: 1 VC)
example_recursive.adb:50:81: info: range check proved (CVC5: 2 VC)
example_recursive.adb:52:06: info: data dependencies proved
example_recursive.adb:54:39: info: precondition proved (CVC5: 1 VC)
example_recursive.adb:62:06: info: data dependencies proved
example_recursive.adb:63:67: info: precondition proved (CVC5: 1 VC)
example_recursive.adb:65:16: info: precondition proved (Trivial: 1 VC)
example_recursive.adb:66:22: info: precondition proved (CVC5: 8 VC)
example_recursive.adb:67:48: info: precondition proved (CVC5: 1 VC)
example_recursive.adb:67:63: info: precondition proved (CVC5: 1 VC)
example_recursive.adb:68:14: info: precondition proved (CVC5: 1 VC)
example_recursive.adb:68:14: medium: in inlined expression function body at example_recursive.adb:36
example_recursive.adb:68:14: medium: postcondition might fail, cannot prove Valid_List (F, Address (L_Cell (Get (M, A)).N), L - 1, M)
example_recursive.adb:76:10: info: precondition proved (CVC5: 12 VC; Trivial: 1 VC)
example_recursive.adb:76:10: info: subprogram variant proved (CVC5: 1 VC)
example_recursive.adb:76:53: info: precondition proved (CVC5: 1 VC)
example_recursive.adb:76:53: info: tag check proved (CVC5: 1 VC)
example_recursive.adb:76:72: info: range check proved (CVC5: 2 VC)
example_recursive.adb:77:25: info: precondition proved (CVC5: 1 VC)
example_recursive.adb:77:25: medium: assertion might fail, cannot prove Address (L_Cell (Get (M, A)).N) /= F
example_recursive.adb:77:25: medium: in inlined expression function body at example_recursive.adb:35
example_recursive.adb:86:06: info: data dependencies proved
example_recursive.adb:87:67: info: precondition proved (CVC5: 1 VC)
example_recursive.adb:89:16: info: precondition proved (Trivial: 1 VC)
example_recursive.adb:90:22: info: precondition proved (CVC5: 8 VC)
example_recursive.adb:91:48: info: precondition proved (CVC5: 1 VC)
example_recursive.adb:91:63: info: precondition proved (CVC5: 1 VC)
example_recursive.adb:92:45: info: precondition proved (CVC5: 8 VC)
example_recursive.adb:92:45: medium: postcondition might fail, cannot prove Reachable (F, A, L, A2, M1) = Reachable (F, A, L, A2, M2)
example_recursive.adb:92:75: info: precondition proved (CVC5: 8 VC)
example_recursive.adb:98:10: info: precondition proved (CVC5: 12 VC; Trivial: 1 VC)
example_recursive.adb:98:10: info: subprogram variant proved (CVC5: 1 VC)
example_recursive.adb:98:53: info: precondition proved (CVC5: 1 VC)
example_recursive.adb:98:53: info: tag check proved (CVC5: 1 VC)
example_recursive.adb:98:72: info: range check proved (CVC5: 2 VC)
example_recursive.adb:100:07: info: precondition proved (CVC5: 12 VC; Trivial: 1 VC)
example_recursive.adb:103:13: info: implicit function contract might not be available on recursive calls
example_recursive.adb:104:29: info: precondition proved (CVC5: 1 VC)
example_recursive.adb:104:29: info: tag check proved (CVC5: 1 VC)
example_recursive.adb:105:12: info: precondition proved (CVC5: 10 VC)
example_recursive.adb:105:12: info: subprogram variant proved (CVC5: 1 VC)
example_recursive.adb:105:37: info: precondition proved (CVC5: 1 VC)
example_recursive.adb:105:37: info: tag check proved (CVC5: 1 VC)
example_recursive.adb:105:55: info: range check proved (CVC5: 2 VC)
example_recursive.adb:105:62: info: range check proved (CVC5: 2 VC)
example_recursive.adb:107:06: info: data dependencies proved
example_recursive.adb:109:15: info: precondition proved (CVC5: 1 VC)
example_recursive.adb:113:07: info: precondition proved (CVC5: 10 VC)
example_recursive.adb:115:06: info: data dependencies proved
example_recursive.adb:120:14: medium: postcondition might fail, cannot prove Valid_List (Create'result)
example_recursive.adb:122:15: info: precondition proved (CVC5: 3 VC)
example_recursive.adb:125:07: info: absence of resource or memory leak at end of scope proved (CVC5: 1 VC)
example_recursive.adb:126:07: info: initialization of "F" proved
example_recursive.adb:137:49: info: precondition proved (CVC5: 1 VC)
example_recursive.adb:137:60: info: null exclusion check proved (CVC5: 1 VC)
example_recursive.adb:139:13: info: tag check proved (Z3: 1 VC)
example_recursive.adb:139:27: info: pointer dereference check proved (CVC5: 1 VC)
example_recursive.adb:143:22: medium: assertion might fail
example_recursive.adb:144:22: info: assertion proved (Z3: 1 VC)
example_recursive.adb:144:30: info: precondition proved (Z3: 1 VC)
example_recursive.adb:144:30: info: tag check proved (Z3: 1 VC)
example_recursive.adb:151:14: medium: in inlined expression function body at example_recursive.adb:44
example_recursive.adb:151:14: medium: postcondition might fail, cannot prove Valid_List (Address (L.F), Address (L.F), L.L, +L.M)
example_recursive.adb:151:52: info: overflow check proved (CVC5: 2 VC)
example_recursive.adb:154:35: info: precondition proved (CVC5: 1 VC)
example_recursive.adb:154:35: info: tag check proved (Z3: 1 VC)
example_recursive.adb:155:07: info: initialization of "New_P" proved
example_recursive.adb:159:22: medium: assertion might fail
example_recursive.adb:166:46: medium: precondition might fail
example_recursive.adb:166:57: info: null exclusion check proved (CVC5: 1 VC)
example_recursive.adb:168:10: medium: tag check might fail
example_recursive.adb:168:24: info: pointer dereference check proved (CVC5: 1 VC)
example_recursive.adb:171:22: medium: assertion might fail
example_recursive.adb:172:22: medium: assertion might fail [possible fix: you should consider adding a postcondition to function Get or turning it into an expression function in its unit spec]
example_recursive.adb:172:30: info: tag check proved (Z3: 1 VC)
example_recursive.adb:172:30: medium: precondition might fail
example_recursive.adb:173:22: medium: assertion might fail [possible fix: you should consider adding a postcondition to function Get or turning it into an expression function in its unit spec]
example_recursive.adb:173:30: medium: precondition might fail
example_recursive.adb:173:30: medium: tag check might fail [possible fix: you should consider adding a postcondition to function Get or turning it into an expression function in its unit spec]
example_recursive.adb:176:10: medium: in inlined expression function body at example_recursive.adb:33
example_recursive.adb:176:10: medium: precondition might fail, cannot prove F /= 0
example_recursive.adb:176:70: info: range check proved (CVC5: 2 VC)
example_recursive.adb:179:18: info: overflow check proved (CVC5: 1 VC; Z3: 1 VC)
example_recursive.adb:182:04: medium: resource or memory leak might occur at end of scope
example_recursive.adb:183:04: medium: resource or memory leak might occur at end of scope
example_recursive.adb:186:04: info: precondition proved (CVC5: 3 VC)
example_recursive.adb:187:04: info: precondition proved (CVC5: 3 VC)
example_recursive.adb:188:04: info: precondition proved (CVC5: 3 VC)
example_recursive.adb:189:04: info: precondition proved (CVC5: 3 VC)
example_recursive.adb:190:19: info: assertion proved (CVC5: 1 VC)
example_recursive.adb:191:19: info: assertion proved (CVC5: 1 VC)
pointers_with_aliasing.ads:16:13: info: subprogram "Check_No_Deep_Objects" will terminate, terminating annotation has been proved, in instantiation at example_recursive.adb:10
pointers_with_aliasing.ads:45:16: info: subprogram "None" will terminate, terminating annotation has been proved, in instantiation at example_recursive.adb:10
pointers_with_aliasing.ads:48:16: info: subprogram "Only" will terminate, terminating annotation has been proved, in instantiation at example_recursive.adb:10
pointers_with_aliasing.ads:52:16: info: subprogram "Writes" will terminate, terminating annotation has been proved, in instantiation at example_recursive.adb:10
pointers_with_aliasing.ads:57:18: info: precondition proved (CVC5: 1 VC), in instantiation at example_recursive.adb:10
pointers_with_aliasing.ads:57:32: info: precondition proved (CVC5: 1 VC), in instantiation at example_recursive.adb:10
pointers_with_aliasing.ads:60:16: info: subprogram "Allocates" will terminate, terminating annotation has been proved, in instantiation at example_recursive.adb:10
pointers_with_aliasing.ads:69:16: info: subprogram "Deallocates" will terminate, terminating annotation has been proved, in instantiation at example_recursive.adb:10
pointers_with_aliasing.ads:143:35: info: precondition proved (CVC5: 1 VC), in instantiation at example_recursive.adb:10
pointers_with_aliasing.ads:154:13: info: subprogram "At_End" will terminate, terminating annotation has been proved, in instantiation at example_recursive.adb:10
pointers_with_aliasing.ads:155:07: info: dynamic accessibility check proved (Trivial), in instantiation at example_recursive.adb:10
pointers_with_aliasing.ads:159:13: info: subprogram "At_End" will terminate, terminating annotation has been proved, in instantiation at example_recursive.adb:10
pointers_with_aliasing.ads:160:07: info: dynamic accessibility check proved (Trivial), in instantiation at example_recursive.adb:10
pointers_with_aliasing.ads:166:29: info: pointer dereference check proved (CVC5: 1 VC), in instantiation at example_recursive.adb:10

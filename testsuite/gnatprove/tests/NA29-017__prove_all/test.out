sorting.adb:25:07: info: flow dependencies proved
sorting.adb:28:18: high: overflow check might fail, cannot prove upper bound for A_First + Length (e.g. when A_First = Natural'Last and Length = 1) [reason for check: result of addition must fit in a 32-bits machine integer] [possible fix: use "and then" instead of "and" in precondition]
sorting.adb:28:37: high: overflow check might fail, cannot prove upper bound for A'Last + 1 (e.g. when A = (others => -1) and A'First = 0 and A'Last = Natural'Last) [reason for check: result of addition must fit in a 32-bits machine integer] [possible fix: use pragma Overflow_Mode or switch -gnato13 or unit SPARK.Big_Integers]
sorting.adb:30:18: high: overflow check might fail, cannot prove upper bound for B_First + Length (e.g. when B_First = 1 and Length = Natural'Last) [reason for check: result of addition must fit in a 32-bits machine integer] [possible fix: use "and then" instead of "and" in precondition]
sorting.adb:30:37: high: overflow check might fail, cannot prove upper bound for B'Last + 1 (e.g. when B = (others => Integer'Last) and B'First = 0 and B'Last = Natural'Last) [reason for check: result of addition must fit in a 32-bits machine integer] [possible fix: use pragma Overflow_Mode or switch -gnato13 or unit SPARK.Big_Integers]
sorting.adb:31:15: info: postcondition proved (CVC5: 2 VC; Trivial: 2 VC)
sorting.adb:31:24: info: range check proved (CVC5: 2 VC)
sorting.adb:32:38: info: overflow check proved (CVC5: 2 VC)
sorting.adb:33:16: info: index check proved (CVC5: 2 VC)
sorting.adb:33:32: medium: overflow check might fail, cannot prove upper bound for A_First + J [reason for check: result of addition must fit in a 32-bits machine integer] [possible fix: use pragma Overflow_Mode or switch -gnato13 or unit SPARK.Big_Integers]
sorting.adb:33:36: info: index check proved (CVC5: 2 VC)
sorting.adb:33:36: info: overflow check proved (CVC5: 2 VC)
sorting.adb:34:42: medium: overflow check might fail, cannot prove upper bound for B_First + Length [reason for check: result of addition must fit in a 32-bits machine integer] [possible fix: use pragma Overflow_Mode or switch -gnato13 or unit SPARK.Big_Integers]
sorting.adb:35:16: info: index check proved (CVC5: 2 VC)
sorting.adb:35:28: info: index check proved (CVC5: 2 VC)
sorting.adb:38:09: info: range check proved (CVC5: 2 VC)
sorting.adb:41:10: info: loop invariant initialization proved (CVC5: 2 VC; Trivial: 2 VC)
sorting.adb:41:10: info: loop invariant preservation proved (CVC5: 2 VC; Trivial: 2 VC)
sorting.adb:41:18: info: range check proved (CVC5: 4 VC)
sorting.adb:42:41: info: overflow check proved (CVC5: 4 VC)
sorting.adb:43:19: info: index check proved (CVC5: 4 VC)
sorting.adb:43:35: medium: overflow check might fail, cannot prove upper bound for A_First + J [reason for check: result of addition must fit in a 32-bits machine integer] [possible fix: use pragma Overflow_Mode or switch -gnato13 or unit SPARK.Big_Integers]
sorting.adb:43:39: info: index check proved (CVC5: 4 VC)
sorting.adb:43:39: info: overflow check proved (CVC5: 4 VC)
sorting.adb:44:45: info: overflow check proved (CVC5: 4 VC)
sorting.adb:45:19: info: index check proved (CVC5: 4 VC)
sorting.adb:45:38: info: index check proved (CVC5: 4 VC)
sorting.adb:47:18: info: index check proved (CVC5: 2 VC)
sorting.adb:47:18: info: overflow check proved (CVC5: 2 VC)
sorting.adb:47:37: info: index check proved (CVC5: 2 VC)
sorting.adb:47:37: info: overflow check proved (CVC5: 2 VC)
sorting.adb:49:10: info: assertion proved (CVC5: 2 VC; Trivial: 2 VC)
sorting.adb:49:18: info: range check proved (CVC5: 2 VC)
sorting.adb:50:41: info: overflow check proved (CVC5: 2 VC)
sorting.adb:50:46: info: overflow check proved (CVC5: 2 VC)
sorting.adb:51:19: info: index check proved (CVC5: 2 VC)
sorting.adb:51:35: high: overflow check might fail, cannot prove upper bound for A_First + J (e.g. when A_First = 2 and B = (Natural'Last-1 => 0) and J = Integer'Last-1) [reason for check: result of addition must fit in a 32-bits machine integer] [possible fix: use pragma Overflow_Mode or switch -gnato13 or unit SPARK.Big_Integers]
sorting.adb:51:39: info: index check proved (CVC5: 2 VC)
sorting.adb:51:39: info: overflow check proved (CVC5: 2 VC)
sorting.adb:52:45: medium: overflow check might fail, cannot prove upper bound for B_First + (I + 1) [reason for check: result of addition must fit in a 32-bits machine integer] [possible fix: use pragma Overflow_Mode or switch -gnato13 or unit SPARK.Big_Integers]
sorting.adb:52:50: info: overflow check proved (CVC5: 2 VC)
sorting.adb:53:19: info: index check proved (CVC5: 2 VC)
sorting.adb:53:38: info: index check proved (CVC5: 2 VC)
sorting.adb:66:07: info: flow dependencies proved
sorting.adb:68:40: info: overflow check proved (CVC5: 2 VC)
sorting.adb:68:50: high: overflow check might fail, cannot prove upper bound for A_First + Length1 + Length2 (e.g. when A_First = 1 and Length1 = 0 and Length2 = Natural'Last) [reason for check: result of addition must fit in a 32-bits machine integer] [possible fix: use "and then" instead of "and" in precondition]
sorting.adb:68:70: high: overflow check might fail, cannot prove upper bound for A'Last + 1 (e.g. when A = (others => 0) and A'First = 0 and A'Last = Natural'Last) [reason for check: result of addition must fit in a 32-bits machine integer] [possible fix: use pragma Overflow_Mode or switch -gnato13 or unit SPARK.Big_Integers]
sorting.adb:69:17: info: overflow check proved (CVC5: 2 VC)
sorting.adb:69:31: high: range check might fail, cannot prove upper bound for B'Length (e.g. when B = (others => 0) and B'First = 0 and B'Last = Natural'Last)
sorting.adb:69:51: medium: overflow check might fail, cannot prove upper bound for Length1 + Length2 [reason for check: result of addition must fit in a 32-bits machine integer] [possible fix: use "and then" instead of "and" in precondition]
sorting.adb:70:61: medium: overflow check might fail, cannot prove upper bound for A_First + Length1 [reason for check: result of addition must fit in a 32-bits machine integer] [possible fix: use "and then" instead of "and" in precondition]
sorting.adb:73:09: medium: postcondition might fail, cannot prove Sorted (A, A_First, Length1 + Length2) [possible fix: you should consider adding a postcondition to function Sorted or turning it into an expression function in its unit spec]
sorting.adb:73:37: info: overflow check proved (CVC5: 2 VC)
sorting.adb:74:42: info: overflow check proved (CVC5: 2 VC)
sorting.adb:75:18: info: range check proved (CVC5: 2 VC)
sorting.adb:76:44: info: overflow check proved (CVC5: 2 VC)
sorting.adb:76:54: medium: overflow check might fail, cannot prove upper bound for A_First + Length1 + Length2 [reason for check: result of addition must fit in a 32-bits machine integer] [possible fix: use pragma Overflow_Mode or switch -gnato13 or unit SPARK.Big_Integers]
sorting.adb:77:18: info: index check proved (CVC5: 2 VC)
sorting.adb:77:30: info: index check proved (CVC5: 2 VC)
sorting.adb:79:05: info: initialization of "I" proved
sorting.adb:79:08: info: initialization of "J" proved
sorting.adb:87:11: medium: loop invariant might fail in first iteration, cannot prove Sorted (B, B'First, I + J) [possible fix: you should consider adding a postcondition to function Sorted or turning it into an expression function in its unit spec]
sorting.adb:87:11: medium: loop invariant might not be preserved by an arbitrary iteration, cannot prove Sorted (B, B'First, I + J) [possible fix: you should consider adding a postcondition to function Sorted or turning it into an expression function in its unit spec]
sorting.adb:87:23: info: range check proved (CVC5: 4 VC)
sorting.adb:87:33: info: overflow check proved (CVC5: 4 VC)
sorting.adb:88:41: info: overflow check proved (CVC5: 4 VC)
sorting.adb:88:53: info: range check proved (CVC5: 4 VC)
sorting.adb:89:28: info: range check proved (CVC5: 4 VC)
sorting.adb:89:44: info: overflow check proved (CVC5: 4 VC)
sorting.adb:89:51: info: overflow check proved (CVC5: 4 VC)
sorting.adb:89:64: info: overflow check proved (CVC5: 4 VC)
sorting.adb:89:64: info: range check proved (CVC5: 4 VC)
sorting.adb:90:28: info: range check proved (CVC5: 4 VC)
sorting.adb:90:44: medium: overflow check might fail, cannot prove upper bound for A_First + Length1 [reason for check: result of addition must fit in a 32-bits machine integer] [possible fix: use pragma Overflow_Mode or switch -gnato13 or unit SPARK.Big_Integers]
sorting.adb:90:54: medium: overflow check might fail, cannot prove upper bound for A_First + Length1 + J [reason for check: result of addition must fit in a 32-bits machine integer] [possible fix: use pragma Overflow_Mode or switch -gnato13 or unit SPARK.Big_Integers]
sorting.adb:90:61: info: overflow check proved (CVC5: 4 VC)
sorting.adb:90:74: info: overflow check proved (CVC5: 4 VC)
sorting.adb:90:74: info: range check proved (CVC5: 4 VC)
sorting.adb:98:43: info: index check proved (CVC5: 2 VC)
sorting.adb:98:43: info: overflow check proved (CVC5: 2 VC)
sorting.adb:98:63: info: overflow check proved (CVC5: 2 VC)
sorting.adb:98:74: info: index check proved (CVC5: 2 VC)
sorting.adb:98:74: info: overflow check proved (CVC5: 2 VC)
sorting.adb:100:22: info: index check proved (CVC5: 2 VC)
sorting.adb:100:22: info: overflow check proved (CVC5: 2 VC)
sorting.adb:100:27: info: overflow check proved (CVC5: 2 VC)
sorting.adb:100:47: info: index check proved (CVC5: 2 VC)
sorting.adb:100:47: info: overflow check proved (CVC5: 2 VC)
sorting.adb:101:18: info: overflow check proved (CVC5: 2 VC)
sorting.adb:103:22: info: index check proved (CVC5: 2 VC)
sorting.adb:103:22: info: overflow check proved (CVC5: 2 VC)
sorting.adb:103:27: info: overflow check proved (CVC5: 2 VC)
sorting.adb:103:48: info: overflow check proved (CVC5: 2 VC)
sorting.adb:103:59: info: index check proved (CVC5: 2 VC)
sorting.adb:103:59: info: overflow check proved (CVC5: 2 VC)
sorting.adb:104:18: info: overflow check proved (CVC5: 2 VC)
sorting.adb:108:05: info: precondition proved (CVC5: 4 VC)
sorting.adb:108:18: info: range check proved (CVC5: 2 VC)
sorting.adb:108:34: info: overflow check proved (CVC5: 2 VC)
sorting.adb:119:05: info: initialization of "I" proved
sorting.adb:119:08: info: initialization of "L" proved
sorting.adb:119:11: info: initialization of "K" proved
sorting.adb:125:10: info: loop invariant preservation proved (CVC5: 3 VC; Trivial: 1 VC)
sorting.adb:126:19: medium: overflow check might fail, cannot prove upper bound for J * L [reason for check: result of multiplication must fit in a 32-bits machine integer] [possible fix: use pragma Overflow_Mode or switch -gnato13 or unit SPARK.Big_Integers]
sorting.adb:127:14: medium: loop invariant might fail in first iteration, cannot prove Sorted (A, A_First + J * L, Natural'Min (L, Length - J * L)) [possible fix: you should consider adding a postcondition to function Sorted or turning it into an expression function in its unit spec]
sorting.adb:127:33: info: overflow check proved (CVC5: 4 VC)
sorting.adb:127:37: info: overflow check proved (CVC5: 4 VC)
sorting.adb:127:49: info: range check proved (CVC5: 4 VC)
sorting.adb:127:65: info: overflow check proved (CVC5: 4 VC)
sorting.adb:127:69: info: overflow check proved (CVC5: 4 VC)
sorting.adb:134:13: info: loop invariant initialization proved (CVC5: 6 VC; Trivial: 3 VC)
sorting.adb:135:33: medium: loop invariant might not be preserved by an arbitrary iteration, cannot prove I mod (L * 2) = 0
sorting.adb:135:35: info: division check proved (CVC5: 2 VC)
sorting.adb:135:42: medium: overflow check might fail, cannot prove upper bound for (L * 2) [reason for check: result of multiplication must fit in a 32-bits machine integer] [possible fix: use pragma Overflow_Mode or switch -gnato13 or unit SPARK.Big_Integers]
sorting.adb:137:22: medium: overflow check might fail, cannot prove upper bound for J * L [reason for check: result of multiplication must fit in a 32-bits machine integer] [possible fix: use pragma Overflow_Mode or switch -gnato13 or unit SPARK.Big_Integers]
sorting.adb:137:26: medium: overflow check might fail, cannot prove upper bound for J * L * 2 [reason for check: result of multiplication must fit in a 32-bits machine integer] [possible fix: use pragma Overflow_Mode or switch -gnato13 or unit SPARK.Big_Integers]
sorting.adb:138:36: info: overflow check proved (CVC5: 4 VC)
sorting.adb:138:40: info: overflow check proved (CVC5: 4 VC)
sorting.adb:138:44: info: overflow check proved (CVC5: 4 VC)
sorting.adb:138:56: info: range check proved (CVC5: 4 VC)
sorting.adb:138:64: info: overflow check proved (CVC5: 4 VC)
sorting.adb:138:76: info: overflow check proved (CVC5: 4 VC)
sorting.adb:138:80: info: overflow check proved (CVC5: 4 VC)
sorting.adb:138:84: info: overflow check proved (CVC5: 4 VC)
sorting.adb:140:22: medium: overflow check might fail, cannot prove upper bound for J * L [reason for check: result of multiplication must fit in a 32-bits machine integer] [possible fix: use pragma Overflow_Mode or switch -gnato13 or unit SPARK.Big_Integers]
sorting.adb:140:35: info: overflow check proved (CVC5: 4 VC)
sorting.adb:141:36: info: overflow check proved (CVC5: 4 VC)
sorting.adb:141:40: info: overflow check proved (CVC5: 4 VC)
sorting.adb:141:44: info: overflow check proved (CVC5: 4 VC)
sorting.adb:141:56: info: range check proved (CVC5: 4 VC)
sorting.adb:141:72: info: overflow check proved (CVC5: 4 VC)
sorting.adb:141:76: info: overflow check proved (CVC5: 4 VC)
sorting.adb:141:80: info: overflow check proved (CVC5: 4 VC)
sorting.adb:145:36: info: overflow check proved (CVC5: 2 VC)
sorting.adb:147:22: info: range check proved (CVC5: 2 VC)
sorting.adb:147:39: info: overflow check proved (CVC5: 2 VC)
sorting.adb:147:44: info: overflow check proved (CVC5: 2 VC)
sorting.adb:148:10: medium: precondition might fail, cannot prove Sorted (A, A_First + Length1, Length2) [possible fix: loop invariant at line 133 should mention K]
sorting.adb:148:31: info: overflow check proved (CVC5: 2 VC)
sorting.adb:149:17: info: overflow check proved (CVC5: 2 VC)
sorting.adb:149:22: info: overflow check proved (CVC5: 2 VC)
sorting.adb:154:19: medium: overflow check might fail, cannot prove upper bound for J * L [reason for check: result of multiplication must fit in a 32-bits machine integer] [possible fix: use pragma Overflow_Mode or switch -gnato13 or unit SPARK.Big_Integers]
sorting.adb:154:23: medium: overflow check might fail, cannot prove upper bound for J * L * 2 [reason for check: result of multiplication must fit in a 32-bits machine integer] [possible fix: use pragma Overflow_Mode or switch -gnato13 or unit SPARK.Big_Integers]
sorting.adb:155:14: medium: assertion might fail, cannot prove Sorted (A, A_First + J * L * 2, Natural'Min (L * 2, Length - J * L * 2)) [possible fix: you should consider adding a postcondition to function Sorted or turning it into an expression function in its unit spec]
sorting.adb:155:33: info: overflow check proved (CVC5: 2 VC)
sorting.adb:155:37: info: overflow check proved (CVC5: 2 VC)
sorting.adb:155:41: info: overflow check proved (CVC5: 2 VC)
sorting.adb:155:53: info: range check proved (CVC5: 2 VC)
sorting.adb:155:61: info: overflow check proved (CVC5: 2 VC)
sorting.adb:155:73: info: overflow check proved (CVC5: 2 VC)
sorting.adb:155:77: info: overflow check proved (CVC5: 2 VC)
sorting.adb:155:81: info: overflow check proved (CVC5: 2 VC)
sorting.adb:158:24: info: overflow check proved (CVC5: 2 VC)
sorting.adb:159:14: info: overflow check proved (CVC5: 2 VC)
sorting.ads:22:11: info: flow dependencies proved
sorting.ads:23:54: high: overflow check might fail, cannot prove upper bound for A_First + Length (e.g. when A_First = Natural'Last and Length = 1) [reason for check: result of addition must fit in a 32-bits machine integer] [possible fix: use "and then" instead of "and" in precondition]
sorting.ads:23:73: high: overflow check might fail, cannot prove upper bound for A'Last + 1 (e.g. when A = (others => 0) and A'First = 0 and A'Last = Natural'Last) [reason for check: result of addition must fit in a 32-bits machine integer] [possible fix: use pragma Overflow_Mode or switch -gnato13 or unit SPARK.Big_Integers]
sorting.ads:23:92: high: range check might fail, cannot prove upper bound for B'Length (e.g. when B = (others => 0) and B'First = 0 and B'Last = Natural'Last)
sorting.ads:24:23: medium: postcondition might fail, cannot prove Sorted (A, A_First, Length) [possible fix: you should consider adding a postcondition to function Sorted or turning it into an expression function in its unit spec]

constant_access.adb:24:17: medium: memory leak might occur [possible explanation: allocator for an access-to-constant type leaks memory]
constant_access.adb:24:35: info: pointer dereference check proved (CVC4: 1 VC)
constant_access.adb:24:38: info: pointer dereference check proved (CVC4: 1 VC)
constant_access.adb:25:46: info: pointer dereference check proved (CVC4: 1 VC)
constant_access.adb:34:16: info: function contract might not be available on recursive calls
constant_access.adb:36:17: info: postcondition proved (CVC4: 2 VC)
constant_access.adb:42:13: medium: "Deep_Copy_Ann" is recursive, terminating annotation could be incorrect
constant_access.adb:42:35: info: null exclusion check proved (CVC4: 1 VC)
constant_access.adb:42:49: info: pointer dereference check proved (CVC4: 1 VC)
constant_access.adb:42:52: info: pointer dereference check proved (CVC4: 1 VC)
constant_access.adb:43:51: info: pointer dereference check proved (CVC4: 1 VC)
constant_access.adb:47:22: info: assertion proved (CVC4: 2 VC)
constant_access.adb:47:23: medium: memory leak might occur [possible explanation: call to allocating function inside an assertion leaks memory]
constant_access.adb:48:22: info: assertion proved (CVC4: 2 VC)
constant_access.adb:48:37: medium: memory leak might occur [possible explanation: call to allocating function inside an assertion leaks memory]
constant_access.adb:49:14: medium: memory leak might occur [possible explanation: conversion to access-to-constant type leaks memory]

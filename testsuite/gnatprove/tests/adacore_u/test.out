aliasing.adb:21:14: info: non-aliasing of formal parameters "X" and "Y" proved
aliasing.adb:26:13: medium: formal parameters "X" and "Y" might be aliased (SPARK RM 6.4.2)
aliasing.adb:26:16: high: array index check might fail (e.g. when A'First = 1 and A'Last = 0 and I = 0) [reason for check: value must be a valid index into the array] [possible fix: add precondition (I in A'First .. A'Last) to subprogram at aliasing.ads:17]
aliasing.adb:26:23: medium: array index check might fail [reason for check: value must be a valid index into the array] [possible fix: add precondition (J in A'First .. A'Last) to subprogram at aliasing.ads:17]
global_stack.ads:4:12: error: function "Pop" with output global "Top" is not allowed in SPARK [E0005]
global_stack.ads:4:12: error: launch "gnatprove --explain=E0005" for more information
global_stack.ads:4:12: error: violation of aspect SPARK_Mode at line 1
search_array.adb:7:24: info: cannot unroll loop (too many loop iterations)
search_array.adb:9:20: info: range check proved (CVC5: 2 VC)
search_array.adb:12:07: medium: unexpected exception might be raised
search_array.ads:5:13: info: implicit aspect Always_Terminates on "Search_Zero_P" has been proved, subprogram will terminate
use_access.adb:3:41: medium: range check might fail, cannot prove lower bound for W (W'First) [reason for check: default component value must fit in the type] [possible fix: subprogram at use_access.ads:4 should mention W in a precondition]
use_access.adb:3:45: medium: array index check might fail [reason for check: value must be a valid index into the array]
gnatprove: error during flow analysis and proof
p.adb:8:09: info: data dependencies proved
p.adb:13:41: info: index check proved (CVC5: 2 VC)
p.adb:14:16: info: index check proved (CVC5: 2 VC)
p.adb:16:16: info: index check proved (CVC5: 2 VC)
p.adb:16:25: info: index check proved (CVC5: 2 VC)
p.adb:16:28: info: overflow check proved (CVC5: 2 VC)
p.adb:20:24: info: cannot unroll loop (too many loop iterations)
p.adb:22:31: info: index check proved (CVC5: 2 VC)
p.adb:22:31: info: overflow check proved (CVC5: 2 VC)
p.adb:24:10: info: precondition proved (CVC5: 2 VC)
p.adb:33:24: info: cannot unroll loop (too many loop iterations)
p.adb:54:33: info: loop invariant initialization proved (CVC5: 1 VC)
p.adb:54:33: info: loop invariant preservation proved (CVC5: 1 VC)
p.adb:54:65: info: index check proved (CVC5: 4 VC)
p.adb:56:07: info: only expected exception raised (CVC5: 1 VC)
p.adb:63:24: info: cannot unroll loop (too many loop iterations)
p.adb:65:20: info: discriminant check proved (CVC5: 1 VC; Trivial: 1 VC)
p.adb:70:14: info: discriminant check proved (CVC5: 1 VC; Trivial: 1 VC)
p.adb:76:07: info: initialization of "End_Of_Seq" proved
p.adb:78:38: high: overflow check might fail, cannot prove lower bound for A'First - 1 (e.g. when A'First = Integer'First and A'Last = 0) [reason for check: result of subtraction must fit in a 32-bits machine integer]
p.adb:81:09: info: data dependencies proved
p.adb:82:31: info: initialization of "End_Of_Seq" proved
p.adb:84:09: info: flow dependencies proved
p.adb:88:30: high: overflow check might fail, cannot prove upper bound for Beginning + 1 (e.g. when Beginning = Integer'Last) [reason for check: result of addition must fit in a 32-bits machine integer] [possible fix: use pragma Overflow_Mode or switch -gnato13 or unit SPARK.Big_Integers]
p.adb:89:20: info: postcondition proved (CVC5: 2 VC)
p.adb:89:41: high: overflow check might fail, cannot prove lower bound for A'First - 1 (e.g. when A = (others => 1) and A'First = Integer'First and A'Last = 0) [reason for check: result of subtraction must fit in a 32-bits machine integer] [possible fix: use pragma Overflow_Mode or switch -gnato13 or unit SPARK.Big_Integers]
p.adb:93:16: info: index check proved (CVC5: 2 VC)
p.adb:94:23: info: index check proved (CVC5: 2 VC)
p.adb:99:42: high: overflow check might fail, cannot prove upper bound for Current_Index - Beginning (e.g. when Beginning = Integer'First and Current_Index = 0) [reason for check: result of subtraction must fit in a 32-bits machine integer]
p.adb:99:42: info: range check proved (CVC5: 2 VC)
p.adb:107:33: info: loop invariant initialization proved (CVC5: 2 VC)
p.adb:107:33: info: loop invariant preservation proved (CVC5: 2 VC)
p.adb:107:43: info: overflow check proved (CVC5: 4 VC)
p.adb:108:10: info: precondition proved (CVC5: 4 VC)
p.adb:118:24: info: cannot unroll loop (too many loop iterations)
p.adb:119:19: info: range check proved (CVC5: 2 VC)
p.adb:124:37: info: index check proved (CVC5: 2 VC)
p.adb:126:10: info: index check proved (CVC5: 2 VC)
p.adb:126:19: info: index check proved (CVC5: 2 VC)
p.adb:127:10: info: index check proved (CVC5: 2 VC)
p.adb:131:07: info: initialization of "A" proved
p.adb:131:07: info: range check proved (CVC5: 2 VC)
p.adb:134:34: info: overflow check proved (CVC5: 2 VC)
p.adb:134:38: info: cannot unroll loop (too many loop iterations)
p.adb:135:10: info: precondition proved (CVC5: 5 VC)
p.adb:135:24: info: overflow check proved (CVC5: 2 VC)
p.ads:6:28: medium: "Result" might not be initialized in "Search_Array" [reason for check: OUT parameter should be initialized on return] [possible fix: initialize "Result" on all paths or make "Result" an IN OUT parameter]
p.ads:7:28: info: initialization of "Found" proved
p.ads:20:28: info: initialization of "Result" proved
p.ads:25:28: info: initialization of "Result" proved
p.ads:26:42: info: index check proved (CVC5: 2 VC)
p.ads:30:13: info: implicit aspect Always_Terminates on "Size_Of_Biggest_Increasing_Sequence" has been proved, subprogram will terminate
p.ads:30:13: info: implicit function contract might not be available on implicit recursive calls
p.ads:35:20: info: initialization of "A" proved
p.ads:40:13: info: implicit aspect Always_Terminates on "Cyclic_Permutation" has been proved, subprogram will terminate
p.ads:43:06: info: flow dependencies proved
p.ads:47:06: info: flow dependencies proved
lists.adb:5:28: info: discriminant check proved (CVC5: 1 VC)
lists.adb:13:19: info: discriminant check proved (CVC5: 1 VC; Trivial: 1 VC)
lists.ads:5:13: info: implicit aspect Always_Terminates on "Goes_To" has been proved, subprogram will terminate
lists.ads:7:13: info: implicit aspect Always_Terminates on "Goes_To2" has been proved, subprogram will terminate
lists.ads:10:14: info: postcondition proved (CVC5: 1 VC)
lists.ads:26:46: info: discriminant check proved (CVC5: 1 VC)
p.adb:7:16: info: add a contract to analyze it separately from calling contexts
p.adb:7:16: info: implicit aspect Always_Terminates on "ReadOne" has been proved, subprogram will terminate
p.adb:7:16: info: local subprogram "ReadOne" only analyzed in the context of calls
p.adb:12:52: info: overflow check proved (CVC5: 2 VC), in call inlined at p.adb:20
p.adb:12:52: info: overflow check proved (CVC5: 2 VC), in call inlined at p.adb:23
p.adb:12:52: info: overflow check proved (CVC5: 2 VC), in call inlined at p.adb:24
p.adb:12:52: info: overflow check proved (CVC5: 2 VC), in call inlined at p.adb:26
p.adb:20:15: info: analyzing call to "ReadOne" in context
p.adb:22:60: info: overflow check proved (CVC5: 2 VC)
p.adb:22:64: info: overflow check proved (CVC5: 2 VC)
p.adb:23:16: info: analyzing call to "ReadOne" in context
p.adb:24:16: info: analyzing call to "ReadOne" in context
p.adb:24:36: info: overflow check proved (CVC5: 2 VC)
p.adb:25:52: info: overflow check proved (CVC5: 2 VC)
p.adb:26:16: info: analyzing call to "ReadOne" in context
p.adb:26:31: info: overflow check proved (CVC5: 2 VC)
p.adb:32:17: info: overflow check proved (CVC5: 2 VC)
p.adb:34:17: info: overflow check proved (CVC5: 2 VC)
p.adb:36:17: info: overflow check proved (CVC5: 2 VC)
p.ads:17:06: info: disjoint contract cases proved (CVC5: 1 VC)
p.ads:17:06: medium: contract cases might not be complete
p.ads:17:25: info: contract case proved (CVC5: 1 VC; Trivial: 1 VC)
p.ads:18:25: info: contract case proved (CVC5: 1 VC; Trivial: 1 VC)
p.ads:19:25: info: contract case proved (CVC5: 1 VC; Trivial: 1 VC)
p.ads:20:25: info: contract case proved (CVC5: 1 VC; Trivial: 1 VC)
stacks.adb:5:10: info: only expected exception raised (CVC5: 1 VC)
stacks.adb:8:22: info: range check proved (CVC5: 2 VC)
stacks.adb:9:19: info: index check proved (CVC5: 2 VC)
stacks.ads:8:14: info: postcondition proved (CVC5: 1 VC)
stacks.ads:10:13: info: implicit aspect Always_Terminates on "Peek" has been proved, subprogram will terminate
stacks.ads:12:13: info: implicit aspect Always_Terminates on "Is_Full" has been proved, subprogram will terminate
stacks.ads:27:52: info: index check proved (CVC5: 2 VC)
abstraction_ext.ads:2:13: info: implicit aspect Always_Terminates on "Id" has been proved, subprogram will terminate
abstraction_ext.ads:2:13: info: implicit function contract might not be available on calls from enclosing unit
communication.adb:5:15: medium: length check might fail [reason for check: array must be of the appropriate length] [possible fix: subprogram at communication.ads:9 should mention Address in a precondition]
communication.adb:19:25: high: array index check might fail (e.g. when B = (Content => ?, First => 1, Length => 0) and B.Content'First = 1 and B.Content'Last = 0) [reason for check: value must be a valid index into the array] [possible fix: subprogram at communication.ads:17 should mention B in a precondition]
communication.adb:20:32: high: overflow check might fail, cannot prove upper bound for B.First + 1 (e.g. when B = (Content => (others => 0), First => Positive'Last, Length => Natural'Last) and B.Content'First = 1 and B.Content'Last = Integer'Last) [reason for check: result of addition must fit in a 32-bits machine integer] [possible fix: subprogram at communication.ads:17 should mention B in a precondition]
communication.adb:21:24: high: overflow check might fail, cannot prove upper bound for B.First + B.Length (e.g. when B = (Content => (others => Data'Last), First => Positive'Last, Length => 1) and B.Content'First = 1 and B.Content'Last = 2) [reason for check: result of addition must fit in a 32-bits machine integer] [possible fix: subprogram at communication.ads:17 should mention B in a precondition]
communication.adb:22:32: info: overflow check proved (CVC5: 2 VC)
communication.adb:22:43: high: array index check might fail (e.g. when B = (Content => (1 => 0), First => 1, Length => 0) and Max = 1) [reason for check: result of subtraction must be a valid index into the array] [possible fix: subprogram at communication.ads:17 should mention B in a precondition]
communication.adb:22:43: info: overflow check proved (CVC5: 2 VC)
communication.adb:23:34: info: overflow check proved (CVC5: 2 VC)
communication.adb:25:32: info: index check proved (CVC5: 2 VC)
communication.adb:25:32: info: overflow check proved (CVC5: 2 VC)
communication.adb:26:34: info: overflow check proved (CVC5: 2 VC)
communication.adb:35:30: high: array index check might fail (e.g. when B = (Content => ?, First => 1, Length => 1) and B.Content'First = 1 and B.Content'Last = 0) [reason for check: value must be a valid index into the array] [possible fix: subprogram at communication.ads:18 should mention B in a precondition]
communication.adb:36:34: info: range check proved (CVC5: 2 VC)
communication.adb:39:30: info: index check proved (CVC5: 2 VC)
communication.adb:40:34: info: range check proved (CVC5: 2 VC)
communication.adb:41:32: info: overflow check proved (CVC5: 2 VC)
communication.ads:5:03: info: flow dependencies proved
communication.ads:9:14: info: implicit aspect Always_Terminates on "Create" has been proved, subprogram will terminate
communication.ads:11:23: info: initialization of "Message" proved
communication.ads:14:11: info: flow dependencies proved
communication.ads:18:26: info: initialization of "E" proved
communication.ads:19:33: medium: range check might fail, cannot prove lower bound for V_Ext (e.g. when Max = 0 and V_Ext = -1) [reason for check: default component value must fit in the type]
communication.ads:21:07: info: range check proved (CVC5: 2 VC)
communication.ads:22:07: medium: type "Buffer" is not fully initialized
counting.adb:7:35: info: initialization of "Black_Counter" constituent of "State" proved
counting.adb:13:38: info: overflow check proved (CVC5: 2 VC)
counting.adb:18:35: info: initialization of "Red_Counter" constituent of "State" proved
counting.adb:24:34: info: overflow check proved (CVC5: 2 VC)
counting.ads:5:06: info: data dependencies proved
counting.ads:6:16: info: postcondition proved (CVC5: 1 VC)
counting.ads:9:14: info: postcondition proved (CVC5: 1 VC)
counting.ads:9:52: info: overflow check proved (CVC5: 2 VC)
counting.ads:10:13: info: implicit aspect Always_Terminates on "Get_Black_Count" has been proved, subprogram will terminate
counting.ads:13:06: info: data dependencies proved
counting.ads:14:16: info: postcondition proved (CVC5: 1 VC)
counting.ads:17:14: info: postcondition proved (CVC5: 1 VC)
counting.ads:17:48: info: overflow check proved (CVC5: 2 VC)
counting.ads:18:13: info: implicit aspect Always_Terminates on "Get_Red_Count" has been proved, subprogram will terminate
counting.ads:20:14: info: initialization of "Black_Counter" constituent of "State" proved
counting.ads:20:14: info: initialization of "Red_Counter" constituent of "State" proved
counting.ads:21:06: info: data dependencies proved
data_package.adb:6:07: info: initialization of "Data" proved
data_package.adb:8:07: medium: implicit aspect Always_Terminates on "Data_Package" could be incorrect, call to "Read_Data_From_File" might be nonterminating [possible fix: annotate "Read_Data_From_File" with aspect Always_Terminates]
data_package.ads:3:01: info: flow dependencies proved
data_package.ads:6:04: info: initialization of "Data_1" proved
data_package.ads:7:04: info: initialization of "Data_2" proved
data_package.ads:8:04: info: initialization of "Data_3" proved
external_interface.ads:2:49: info: flow dependencies proved
stack.adb:9:21: high: array index check might fail (e.g. when Top = 0) [reason for check: value must be a valid index into the array] [possible fix: subprogram at stack.ads:12 should mention Top in a precondition]
stack.adb:10:18: info: range check proved (CVC5: 2 VC)
stack.adb:14:18: high: range check might fail, cannot prove upper bound for Top + 1 (e.g. when Top = Length_Type'Last) [reason for check: result of addition must fit in the target type of the assignment] [possible fix: subprogram at stack.ads:17 should mention Top in a precondition]
stack.adb:15:16: info: index check proved (CVC5: 2 VC)
stack.adb:24:23: high: array index check might fail (e.g. when B_Top = 0) [reason for check: value must be a valid index into the array] [possible fix: subprogram at stack.ads:22 should mention B_Top in a precondition]
stack.adb:25:22: info: range check proved (CVC5: 2 VC)
stack.adb:32:22: high: range check might fail, cannot prove upper bound for B_Top + 1 (e.g. when B_Top = Length_Type'Last) [reason for check: result of addition must fit in the target type of the assignment] [possible fix: subprogram at stack.ads:25 should mention B_Top in a precondition]
stack.adb:33:18: info: index check proved (CVC5: 2 VC)
stack.adb:41:22: info: range check proved (CVC5: 2 VC)
stack.adb:42:18: info: index check proved (CVC5: 2 VC)
stack.adb:45:48: info: index check proved (CVC5: 2 VC)
stack.adb:54:22: info: range check proved (CVC5: 2 VC)
stack.adb:55:18: info: index check proved (CVC5: 2 VC)
stack.ads:1:51: warning: no subprogram exists that can initialize abstract state "Stack.The_Stack"
stack.ads:1:62: warning: no subprogram exists that can initialize abstract state "Stack.P_Stack"
stack.ads:12:20: info: initialization of "E" proved
stack.ads:13:06: info: data dependencies proved
stack.ads:15:06: info: flow dependencies proved
stack.ads:18:06: info: data dependencies proved
stack.ads:19:06: info: flow dependencies proved
stack.ads:22:21: info: initialization of "E" proved
stack.ads:23:06: info: data dependencies proved
stack.ads:24:06: info: flow dependencies proved
stack.ads:26:06: info: data dependencies proved
stack.ads:27:06: info: flow dependencies proved
stack.ads:30:14: info: postcondition proved (CVC5: 3 VC)
stack.ads:31:58: info: precondition proved (CVC5: 1 VC)
stack.ads:32:13: info: implicit aspect Always_Terminates on "Get_Stack" has been proved, subprogram will terminate
stack.ads:33:13: info: implicit aspect Always_Terminates on "Peek" has been proved, subprogram will terminate
stack.ads:35:13: info: implicit aspect Always_Terminates on "Is_Full" has been proved, subprogram will terminate
stack.ads:36:13: info: implicit aspect Always_Terminates on "Is_Empty" has been proved, subprogram will terminate
stack.ads:39:14: info: postcondition proved (CVC5: 3 VC)
stack.ads:40:61: info: precondition proved (CVC5: 1 VC)
stack.ads:41:13: info: implicit aspect Always_Terminates on "Get_Stack2" has been proved, subprogram will terminate
stack.ads:42:13: info: implicit aspect Always_Terminates on "Peek2" has been proved, subprogram will terminate
stack.ads:44:13: info: implicit aspect Always_Terminates on "Is_Full2" has been proved, subprogram will terminate
stack.ads:45:13: info: implicit aspect Always_Terminates on "Is_Empty2" has been proved, subprogram will terminate
stack.ads:57:49: info: index check proved (CVC5: 2 VC)
use_stack.adb:3:10: medium: precondition of main program might fail, cannot prove not Is_Empty
use_stack.adb:3:14: medium: "Stack.The_Stack" might not be initialized after elaboration of main program "Use_Stack"
use_stack.adb:3:31: medium: "Stack.P_Stack" might not be initialized after elaboration of main program "Use_Stack"
use_stack.adb:5:04: info: initialization of "F" proved
use_stack.adb:7:09: info: precondition proved (CVC5: 1 VC)
use_stack.adb:7:09: medium: "Stack.The_Stack" might not be initialized after elaboration of main program "Use_Stack"
use_stack.adb:8:04: medium: "Stack.The_Stack" might not be initialized after elaboration of main program "Use_Stack"
use_stack.adb:9:19: info: precondition proved (CVC5: 1 VC)
use_stack.adb:9:19: medium: assertion might fail [possible fix: you should consider adding a postcondition to function Peek or turning it into an expression function in its unit spec]
use_stack.adb:9:31: info: precondition proved (CVC5: 1 VC)
use_stack.adb:10:09: info: precondition proved (CVC5: 1 VC)
use_stack.adb:10:09: medium: "Stack.P_Stack" might not be initialized after elaboration of main program "Use_Stack"
use_stack.adb:11:04: medium: "Stack.P_Stack" might not be initialized after elaboration of main program "Use_Stack"
use_stack.adb:12:19: info: assertion proved (CVC5: 1 VC)
use_stack.adb:12:19: info: precondition proved (CVC5: 1 VC)
use_stack.adb:12:32: info: precondition proved (CVC5: 1 VC)
p_max_array.adb:4:07: info: initialization of "R" proved
p_max_array.adb:4:07: info: range check proved (CVC5: 2 VC)
p_max_array.adb:8:33: info: loop invariant initialization proved (CVC5: 2 VC)
p_max_array.adb:8:33: info: loop invariant preservation proved (CVC5: 2 VC)
p_max_array.adb:9:33: info: loop invariant initialization proved (CVC5: 1 VC)
p_max_array.adb:9:33: info: loop invariant preservation proved (CVC5: 1 VC)
p_max_array.adb:9:39: info: overflow check proved (CVC5: 4 VC)
p_max_array.adb:9:49: info: overflow check proved (CVC5: 4 VC)
p_max_array.adb:10:24: info: index check proved (CVC5: 2 VC)
p_max_array.adb:13:25: info: index check proved (CVC5: 2 VC)
p_max_array.adb:15:17: info: overflow check proved (CVC5: 2 VC)
p_max_array.adb:21:07: info: range check proved (CVC5: 2 VC)
p_max_array.adb:21:34: info: length check proved (CVC5: 3 VC; Trivial: 1 VC)
p_max_array.adb:25:33: info: loop invariant initialization proved (CVC5: 2 VC)
p_max_array.adb:25:33: info: loop invariant preservation proved (CVC5: 2 VC)
p_max_array.adb:26:33: info: loop invariant initialization proved (CVC5: 1 VC)
p_max_array.adb:26:33: info: loop invariant preservation proved (CVC5: 1 VC)
p_max_array.adb:26:39: info: overflow check proved (CVC5: 4 VC)
p_max_array.adb:26:49: info: overflow check proved (CVC5: 4 VC)
p_max_array.adb:28:13: info: loop invariant initialization proved (CVC5: 2 VC)
p_max_array.adb:28:13: info: loop invariant preservation proved (CVC5: 2 VC)
p_max_array.adb:28:40: info: overflow check proved (CVC5: 4 VC)
p_max_array.adb:29:24: info: index check proved (CVC5: 4 VC)
p_max_array.adb:29:34: info: overflow check proved (CVC5: 4 VC)
p_max_array.adb:29:44: info: index check proved (CVC5: 4 VC)
p_max_array.adb:29:44: info: overflow check proved (CVC5: 4 VC)
p_max_array.adb:30:25: info: index check proved (CVC5: 4 VC)
p_max_array.adb:30:33: info: index check proved (CVC5: 4 VC)
p_max_array.adb:31:26: info: index check proved (CVC5: 4 VC)
p_max_array.adb:31:36: info: overflow check proved (CVC5: 4 VC)
p_max_array.adb:31:46: info: index check proved (CVC5: 4 VC)
p_max_array.adb:31:46: info: overflow check proved (CVC5: 4 VC)
p_max_array.adb:32:24: info: index check proved (CVC5: 2 VC)
p_max_array.adb:35:25: info: index check proved (CVC5: 2 VC)
p_max_array.adb:37:17: info: overflow check proved (CVC5: 2 VC)
p_max_array.adb:46:33: info: loop invariant initialization proved (CVC5: 2 VC)
p_max_array.adb:46:33: info: loop invariant preservation proved (CVC5: 2 VC)
p_max_array.adb:47:33: info: loop invariant initialization proved (CVC5: 1 VC)
p_max_array.adb:47:33: info: loop invariant preservation proved (CVC5: 1 VC)
p_max_array.adb:47:39: info: overflow check proved (CVC5: 4 VC)
p_max_array.adb:47:49: info: overflow check proved (CVC5: 4 VC)
p_max_array.adb:49:13: info: loop invariant initialization proved (CVC5: 2 VC)
p_max_array.adb:49:13: info: loop invariant preservation proved (CVC5: 2 VC)
p_max_array.adb:49:40: info: overflow check proved (CVC5: 4 VC)
p_max_array.adb:50:35: info: index check proved (CVC5: 4 VC)
p_max_array.adb:50:45: info: overflow check proved (CVC5: 4 VC)
p_max_array.adb:50:55: info: index check proved (CVC5: 4 VC)
p_max_array.adb:50:55: info: overflow check proved (CVC5: 4 VC)
p_max_array.adb:51:25: info: index check proved (CVC5: 4 VC)
p_max_array.adb:51:44: info: index check proved (CVC5: 4 VC)
p_max_array.adb:52:26: info: index check proved (CVC5: 4 VC)
p_max_array.adb:52:36: info: overflow check proved (CVC5: 4 VC)
p_max_array.adb:52:46: info: index check proved (CVC5: 4 VC)
p_max_array.adb:52:46: info: overflow check proved (CVC5: 4 VC)
p_max_array.adb:54:13: info: loop invariant initialization proved (CVC5: 1 VC)
p_max_array.adb:54:13: info: loop invariant preservation proved (CVC5: 1 VC)
p_max_array.adb:54:44: info: index check proved (CVC5: 4 VC)
p_max_array.adb:54:63: info: index check proved (CVC5: 4 VC)
p_max_array.adb:55:24: info: index check proved (CVC5: 2 VC)
p_max_array.adb:56:25: info: index check proved (CVC5: 2 VC)
p_max_array.adb:58:17: info: overflow check proved (CVC5: 2 VC)
p_max_array.ads:5:13: info: implicit aspect Always_Terminates on "Max_Array_1" has been proved, subprogram will terminate
p_max_array.ads:8:13: info: implicit aspect Always_Terminates on "Max_Array_2" has been proved, subprogram will terminate
p_max_array.ads:10:14: info: postcondition proved (CVC5: 2 VC)
p_max_array.ads:11:24: info: index check proved (CVC5: 2 VC)
p_max_array.ads:11:34: info: overflow check proved (CVC5: 2 VC)
p_max_array.ads:11:44: info: index check proved (CVC5: 2 VC)
p_max_array.ads:11:44: info: overflow check proved (CVC5: 2 VC)
p_max_array.ads:12:42: info: index check proved (CVC5: 2 VC)
p_max_array.ads:12:50: info: index check proved (CVC5: 2 VC)
p_max_array.ads:13:43: info: index check proved (CVC5: 2 VC)
p_max_array.ads:13:53: info: overflow check proved (CVC5: 2 VC)
p_max_array.ads:13:63: info: index check proved (CVC5: 2 VC)
p_max_array.ads:13:63: info: overflow check proved (CVC5: 2 VC)
p_max_array.ads:17:14: info: postcondition proved (CVC5: 2 VC)
p_max_array.ads:18:28: info: index check proved (CVC5: 2 VC)
p_max_array.ads:18:38: info: overflow check proved (CVC5: 2 VC)
p_max_array.ads:18:48: info: index check proved (CVC5: 2 VC)
p_max_array.ads:18:48: info: overflow check proved (CVC5: 2 VC)
p_max_array.ads:19:25: info: index check proved (CVC5: 2 VC)
p_max_array.ads:19:37: info: index check proved (CVC5: 2 VC)
p_max_array.ads:20:26: info: index check proved (CVC5: 2 VC)
p_max_array.ads:20:36: info: overflow check proved (CVC5: 2 VC)
p_max_array.ads:20:46: info: index check proved (CVC5: 2 VC)
p_max_array.ads:20:46: info: overflow check proved (CVC5: 2 VC)
ring_buffer.adb:8:35: info: predicate check proved (Trivial: 1 VC)
ring_buffer.adb:11:34: info: precondition proved (CVC5: 2 VC)
ring_buffer.adb:11:56: info: range check proved (CVC5: 2 VC)
ring_buffer.adb:13:34: info: precondition proved (CVC5: 2 VC)
ring_buffer.adb:13:67: info: range check proved (CVC5: 2 VC)
ring_buffer.adb:16:35: info: predicate check proved (Trivial: 1 VC)
ring_buffer.adb:19:34: info: precondition proved (CVC5: 2 VC)
ring_buffer.adb:19:52: info: range check proved (CVC5: 2 VC)
ring_buffer.adb:21:34: info: precondition proved (CVC5: 2 VC)
ring_buffer.adb:21:63: info: range check proved (CVC5: 2 VC)
ring_buffer.adb:23:06: info: refined post proved (CVC5: 2 VC; Trivial: 1 VC)
ring_buffer.adb:25:15: info: precondition proved (CVC5: 2 VC)
ring_buffer.adb:25:23: info: range check proved (CVC5: 2 VC)
ring_buffer.adb:25:43: info: index check proved (CVC5: 2 VC)
ring_buffer.adb:25:43: info: overflow check proved (CVC5: 2 VC)
ring_buffer.adb:27:17: info: precondition proved (CVC5: 2 VC)
ring_buffer.adb:27:25: info: range check proved (CVC5: 2 VC)
ring_buffer.adb:27:41: info: overflow check proved (CVC5: 2 VC)
ring_buffer.adb:27:52: info: overflow check proved (CVC5: 2 VC)
ring_buffer.adb:27:60: info: index check proved (CVC5: 2 VC)
ring_buffer.adb:27:60: info: overflow check proved (CVC5: 2 VC)
ring_buffer.adb:30:07: info: initialization of "R" proved
ring_buffer.adb:32:16: info: range check proved (CVC5: 2 VC)
ring_buffer.adb:35:33: info: loop invariant initialization proved (CVC5: 1 VC)
ring_buffer.adb:35:33: info: loop invariant preservation proved (CVC5: 1 VC)
ring_buffer.adb:35:39: info: predicate check proved (Trivial: 2 VC)
ring_buffer.adb:35:67: info: overflow check proved (CVC5: 4 VC)
ring_buffer.adb:35:67: info: range check proved (CVC5: 4 VC)
ring_buffer.adb:37:13: info: loop invariant initialization proved (CVC5: 1 VC; Trivial: 1 VC)
ring_buffer.adb:37:13: info: loop invariant preservation proved (CVC5: 1 VC; Trivial: 1 VC)
ring_buffer.adb:38:34: info: overflow check proved (CVC5: 4 VC)
ring_buffer.adb:39:34: info: precondition proved (CVC5: 4 VC)
ring_buffer.adb:39:52: info: range check proved (CVC5: 4 VC)
ring_buffer.adb:40:15: info: precondition proved (CVC5: 1 VC)
ring_buffer.adb:44:33: info: loop invariant initialization proved (CVC5: 1 VC)
ring_buffer.adb:44:33: info: loop invariant preservation proved (CVC5: 1 VC)
ring_buffer.adb:44:39: info: predicate check proved (Trivial: 2 VC)
ring_buffer.adb:44:75: info: overflow check proved (CVC5: 4 VC)
ring_buffer.adb:44:75: info: range check proved (CVC5: 4 VC)
ring_buffer.adb:46:13: info: loop invariant initialization proved (CVC5: 2 VC; Trivial: 1 VC)
ring_buffer.adb:46:13: info: loop invariant preservation proved (CVC5: 2 VC; Trivial: 1 VC)
ring_buffer.adb:48:35: info: precondition proved (CVC5: 4 VC)
ring_buffer.adb:48:53: info: range check proved (CVC5: 4 VC)
ring_buffer.adb:50:35: info: precondition proved (CVC5: 4 VC)
ring_buffer.adb:50:64: info: range check proved (CVC5: 4 VC)
ring_buffer.adb:51:15: info: precondition proved (CVC5: 1 VC)
ring_buffer.adb:59:25: info: index check proved (CVC5: 2 VC)
ring_buffer.adb:61:37: info: index check proved (CVC5: 2 VC)
ring_buffer.adb:63:24: info: range check proved (CVC5: 2 VC)
ring_buffer.adb:68:16: info: precondition proved (CVC5: 1 VC)
ring_buffer.adb:70:25: info: index check proved (CVC5: 2 VC)
ring_buffer.adb:72:37: info: index check proved (CVC5: 2 VC)
ring_buffer.adb:74:24: info: range check proved (CVC5: 2 VC)
ring_buffer.adb:79:16: info: precondition proved (CVC5: 2 VC)
ring_buffer.adb:81:24: info: range check proved (CVC5: 2 VC)
ring_buffer.adb:83:25: info: range check proved (CVC5: 2 VC)
ring_buffer.adb:90:17: info: add a contract to analyze it separately from calling contexts
ring_buffer.adb:90:17: info: local subprogram "Update_Model" only analyzed in the context of calls
ring_buffer.adb:92:19: info: predicate check proved (Trivial: 1 VC), in call inlined at ring_buffer.adb:106
ring_buffer.adb:92:37: info: predicate check proved (Trivial: 1 VC), in call inlined at ring_buffer.adb:106
ring_buffer.adb:93:22: info: precondition proved (CVC5: 2 VC), in call inlined at ring_buffer.adb:106
ring_buffer.adb:99:27: info: range check proved (CVC5: 2 VC)
ring_buffer.adb:101:28: info: range check proved (CVC5: 2 VC)
ring_buffer.adb:106:07: info: analyzing call to "Update_Model" in context
ring_buffer.ads:14:13: info: implicit aspect Always_Terminates on "Is_Append" has been proved, subprogram will terminate
ring_buffer.ads:15:25: info: predicate check proved (Trivial: 1 VC)
ring_buffer.ads:15:39: info: predicate check proved (Trivial: 1 VC)
ring_buffer.ads:15:53: info: predicate check proved (Trivial: 1 VC)
ring_buffer.ads:16:18: info: precondition proved (CVC5: 2 VC)
ring_buffer.ads:18:13: info: implicit aspect Always_Terminates on "Is_Prepend" has been proved, subprogram will terminate
ring_buffer.ads:19:08: info: predicate check proved (Trivial: 1 VC)
ring_buffer.ads:19:22: info: predicate check proved (Trivial: 1 VC)
ring_buffer.ads:19:36: info: predicate check proved (Trivial: 1 VC)
ring_buffer.ads:20:18: info: precondition proved (CVC5: 2 VC)
ring_buffer.ads:22:43: info: precondition proved (CVC5: 2 VC)
ring_buffer.ads:22:52: info: range check proved (CVC5: 2 VC)
ring_buffer.ads:22:57: info: precondition proved (CVC5: 2 VC)
ring_buffer.ads:22:68: info: overflow check proved (CVC5: 2 VC)
ring_buffer.ads:22:68: info: range check proved (CVC5: 2 VC)
ring_buffer.ads:26:04: info: initialization of "Model" proved
ring_buffer.ads:28:13: info: implicit aspect Always_Terminates on "Valid_Model" has been proved, subprogram will terminate
ring_buffer.ads:29:13: info: implicit aspect Always_Terminates on "Valid_Model" has been proved, subprogram will terminate
ring_buffer.ads:31:13: info: implicit aspect Always_Terminates on "Get_Model" has been proved, subprogram will terminate
ring_buffer.ads:32:14: info: postcondition proved (CVC5: 3 VC; Trivial: 1 VC)
ring_buffer.ads:35:14: info: predicate check proved (Trivial: 1 VC)
ring_buffer.ads:36:14: info: postcondition proved (CVC5: 3 VC)
ring_buffer.ads:39:30: info: predicate check proved (Trivial: 1 VC)
ring_buffer.ads:40:14: info: postcondition proved (CVC5: 6 VC; Trivial: 1 VC)
ring_buffer.ads:42:25: info: initialization of "E" proved
ring_buffer.ads:43:30: info: predicate check proved (Trivial: 1 VC)
ring_buffer.ads:43:47: info: predicate check proved (Trivial: 1 VC)
ring_buffer.ads:44:14: info: postcondition proved (CVC5: 6 VC; Trivial: 1 VC)
ring_buffer.ads:50:24: info: postcondition proved (CVC5: 3 VC; Trivial: 1 VC)
ring_buffer.ads:52:07: info: contract case proved (CVC5: 3 VC; Trivial: 1 VC)
ring_buffer.ads:52:07: info: predicate check proved (Trivial: 1 VC)
ring_buffer.ads:52:24: info: predicate check proved (Trivial: 1 VC)
ring_buffer.ads:53:07: info: contract case proved (CVC5: 2 VC; Trivial: 1 VC)
bundling_abstract_state.adb:5:04: high: "X" constituent of "State" is not written in "Bundling_Abstract_State" [reason for check: encapsulating state is mentioned in the Initializes contract of the package declaration] [possible fix: initialize "X" constituent of "State" at declaration or in the package body statements]
bundling_abstract_state.adb:5:04: high: initialization of "Bundling_Abstract_State.State" is specified at bundling_abstract_state.ads:4
bundling_abstract_state.ads:4:08: info: flow dependencies proved
copy_values.adb:8:25: info: float overflow check proved (Z3: 1 VC)
copy_values.adb:17:22: medium: float overflow check might fail [reason for check: result of floating-point addition must be bounded]
copy_values.adb:17:31: info: division check proved (CVC5: 1 VC)
copy_values.adb:17:31: info: float overflow check proved (Trivial)
copy_values.ads:8:06: info: flow dependencies proved
copy_values.ads:13:14: info: initialization of "Data" proved
copy_values.ads:14:06: info: flow dependencies proved
diff_pair.ads:11:13: info: implicit aspect Always_Terminates on "Max" has been proved, subprogram will terminate
diff_pair.ads:13:14: medium: postcondition might fail (e.g. when Max'Result = 0)
diff_pair.ads:15:13: info: implicit aspect Always_Terminates on "Max2" has been proved, subprogram will terminate
diff_pair.ads:17:14: info: postcondition proved (CVC5: 1 VC)
external_abstract_state.adb:9:04: high: "AR" constituent of "AR_State" is not written in "External_Abstract_State" [reason for check: variable is mentioned in the generated Initializes contract] [possible fix: initialize "AR" constituent of "AR_State" at declaration or in the package body statements]
external_abstract_state.adb:11:04: high: "EW" constituent of "AR_State" is not written in "External_Abstract_State" [reason for check: variable is mentioned in the generated Initializes contract] [possible fix: initialize "EW" constituent of "AR_State" at declaration or in the package body statements]
trivial.ads:10:04: medium: address in address clause might not be an integral multiple of alignment of object [possible fix: overlaying object should have an Alignment representation clause]
trivial.ads:10:04: warning: address specification on "X" is imprecisely supported: assuming no concurrent accesses to non-atomic object and no writes to a potential alias [E0012]
trivial.ads:10:04: warning: launch "gnatprove --explain=E0012" for more information
trivial.ads:10:04: warning: make sure that all overlapping objects have Async_Writers set to True
trivial.ads:12:19: info: initialization of "Val" proved
trivial.ads:13:06: info: data dependencies proved
trivial.ads:14:06: info: flow dependencies proved
trivial_async_properties.adb:7:22: medium: assertion might fail
trivial_async_properties.ads:10:04: medium: address in address clause might not be an integral multiple of alignment of object [possible fix: overlaying object should have an Alignment representation clause]
trivial_async_properties.ads:10:04: warning: address specification on "X" is imprecisely supported: assuming no concurrent accesses to non-atomic object, correct volatile properties, and no writes to a potential alias [E0012]
trivial_async_properties.ads:10:04: warning: launch "gnatprove --explain=E0012" for more information
trivial_async_properties.ads:10:04: warning: make sure that all overlapping objects have Async_Writers set to True
trivial_async_properties.ads:11:04: medium: address in address clause might not be an integral multiple of alignment of object [possible fix: overlaying object should have an Alignment representation clause]
trivial_async_properties.ads:11:04: warning: address specification on "Y" is imprecisely supported: assuming no concurrent accesses to non-atomic object and correct volatile properties [E0012]
trivial_async_properties.ads:11:04: warning: launch "gnatprove --explain=E0012" for more information
trivial_async_properties.ads:13:14: info: initialization of "X" proved
trivial_async_properties.ads:14:06: info: flow dependencies proved
trivial_effective_properties.ads:10:04: medium: address in address clause might not be an integral multiple of alignment of object [possible fix: overlaying object should have an Alignment representation clause]
trivial_effective_properties.ads:10:04: warning: address specification on "X" is imprecisely supported: assuming no concurrent accesses to non-atomic object, correct volatile properties, and no writes to a potential alias [E0012]
trivial_effective_properties.ads:10:04: warning: launch "gnatprove --explain=E0012" for more information
trivial_effective_properties.ads:10:04: warning: make sure that all overlapping objects have Async_Writers set to True
trivial_effective_properties.ads:12:04: medium: address in address clause might not be an integral multiple of alignment of object [possible fix: overlaying object should have an Alignment representation clause]
trivial_effective_properties.ads:12:04: warning: address specification on "Y" is imprecisely supported: assuming no concurrent accesses to non-atomic object and correct volatile properties [E0012]
trivial_effective_properties.ads:12:04: warning: launch "gnatprove --explain=E0012" for more information
trivial_effective_properties.ads:15:14: info: initialization of "X" proved
trivial_effective_properties.ads:16:06: info: flow dependencies proved
trivial_no_output.ads:10:04: medium: address in address clause might not be an integral multiple of alignment of object [possible fix: overlaying object should have an Alignment representation clause]
trivial_no_output.ads:10:04: warning: address specification on "X" is imprecisely supported: assuming no concurrent accesses to non-atomic object, correct volatile properties, and no writes to a potential alias [E0012]
trivial_no_output.ads:10:04: warning: launch "gnatprove --explain=E0012" for more information
trivial_no_output.ads:10:04: warning: make sure that all overlapping objects have Async_Writers set to True
trivial_no_output.ads:13:19: info: initialization of "Val" proved
trivial_no_output.ads:14:06: info: data dependencies proved
trivial_no_output.ads:15:06: info: flow dependencies proved
volatile_functions.ads:12:13: error: launch "gnatprove --explain=E0006" for more information
volatile_functions.ads:12:13: error: nonvolatile function "Read_Non_Volatile" with volatile input global "AW" is not allowed in SPARK [E0006]
volatile_functions.ads:12:13: error: violation of aspect SPARK_Mode at line 4
volatile_functions.ads:16:13: error: function "Read_ER" with output global "ER" is not allowed in SPARK [E0005]
volatile_functions.ads:16:13: error: launch "gnatprove --explain=E0005" for more information
volatile_functions.ads:16:13: error: violation of aspect SPARK_Mode at line 4
volatile_placement.ads:9:13: info: implicit aspect Always_Terminates on "Reg" has been proved, subprogram will terminate
volatile_placement.ads:12:13: info: implicit aspect Always_Terminates on "Reg2" has been proved, subprogram will terminate
volatile_variable_values.adb:9:22: info: assertion proved (CVC5: 1 VC)
volatile_variable_values.adb:10:22: info: assertion proved (CVC5: 2 VC)
volatile_variable_values.adb:11:22: info: assertion proved (CVC5: 1 VC)
volatile_variable_values.adb:16:04: warning: analyzing unreferenced procedure "Read_Value"
volatile_variable_values.adb:19:22: info: assertion proved (CVC5: 1 VC)
volatile_variable_values.ads:13:14: warning: subprogram "Check" has no effect
volatile_variables.adb:17:07: info: analyzing call to "Set" in context
volatile_variables.ads:14:13: error: function "Read_ER" with output global "ER" is not allowed in SPARK [E0005]
volatile_variables.ads:14:13: error: launch "gnatprove --explain=E0005" for more information
volatile_variables.ads:14:13: error: violation of aspect SPARK_Mode at line 4
gnatprove: error during flow analysis and proof
protected_complex.adb:7:24: error: from profile "Jorvik" at Concurrency/spark.adc:1
protected_complex.adb:7:24: error: violation of restriction "Pure_Barriers"
rendezvous.adb:3:04: error: from profile "Jorvik" at Concurrency/spark.adc:1
rendezvous.adb:3:04: error: violation of restriction "No_Task_Hierarchy"
rendezvous.adb:4:07: error: from profile "Jorvik" at Concurrency/spark.adc:1
rendezvous.adb:4:07: error: violation of restriction "Max_Task_Entries = 0"
gnatprove: error during generation of Global contracts
abstract_ints.adb:12:30: info: overflow check proved (CVC5: 2 VC)
abstract_ints.adb:29:10: info: precondition proved (CVC5: 1 VC)
abstract_ints.adb:33:08: medium: overflow check might fail, cannot prove upper bound for abs (Arg1.Value - Arg2.Value) [reason for check: result of absolute value must fit in a 32-bits machine integer] [possible fix: add precondition (abs (Arg1.Value - Arg2.Value) <= Integer'Last) to subprogram at abstract_ints.ads:21]
abstract_ints.adb:33:24: medium: overflow check might fail, cannot prove lower bound for (Arg1.Value - Arg2.Value) [reason for check: result of subtraction must fit in a 32-bits machine integer] [possible fix: add precondition (if Arg2.Value >= 0 then Arg1.Value >= Integer'First + Arg2.Value else Arg1.Value <= Integer'Last + Arg2.Value) to subprogram at abstract_ints.ads:21]
abstract_ints.adb:33:56: medium: overflow check might fail, cannot prove upper bound for Arg1.Precision + Arg2.Precision [reason for check: result of addition must fit in a 32-bits machine integer] [possible fix: add precondition (Arg1.Precision <= Integer'Last - Arg2.Precision) to subprogram at abstract_ints.ads:21]
abstract_ints.adb:37:30: info: overflow check proved (CVC5: 2 VC)
abstract_ints.adb:55:38: medium: overflow check might fail, cannot prove upper bound for Arg.Precision + 1 [reason for check: result of addition must fit in a 32-bits machine integer] [possible fix: subprogram at abstract_ints.ads:28 should mention Arg in a precondition]
abstract_ints.ads:7:13: info: implicit aspect Always_Terminates on "Equal" has been proved, subprogram will terminate
abstract_ints.ads:8:13: info: implicit aspect Always_Terminates on "Get_Value" has been proved, subprogram will terminate
abstract_ints.ads:9:13: info: implicit aspect Always_Terminates on "Small" has been proved, subprogram will terminate
abstract_ints.ads:12:20: info: postcondition proved (CVC5: 1 VC)
abstract_ints.ads:12:20: info: postcondition proved (CVC5: 1 VC), in inherited contract at abstract_ints.ads:23
abstract_ints.ads:17:14: info: postcondition proved (CVC5: 1 VC)
abstract_ints.ads:21:24: info: implicit aspect Always_Terminates on "Equal" has been proved, subprogram will terminate
abstract_ints.ads:22:24: info: implicit aspect Always_Terminates on "Small" has been proved, subprogram will terminate
abstract_ints.ads:40:70: medium: overflow check might fail, cannot prove lower bound for Arg.Max - 10 [reason for check: result of subtraction must fit in a 32-bits machine integer] [possible fix: add precondition (Arg.Max >= Integer'First + 10) to subprogram at line 9]
distributed_file_system.ads:9:20: info: class-wide postcondition is stronger than overridden one (CVC5: 1 VC)
distributed_file_system.ads:14:20: info: class-wide precondition is weaker than overridden one (CVC5: 1 VC)
distributed_file_system.ads:15:20: info: class-wide postcondition is stronger than overridden one (CVC5: 1 VC)
distributed_file_system.ads:20:20: info: class-wide precondition is weaker than overridden one (CVC5: 1 VC)
distributed_file_system.ads:21:20: info: class-wide postcondition is stronger than overridden one (CVC5: 2 VC)
distributed_file_system.ads:26:20: medium: class-wide precondition might be stronger than overridden one, cannot prove F.Is_Synchronized [possible fix: you should consider adding a postcondition to function Is_Open and function Is_Synchronized or turning them into expression functions in their unit spec]
distributed_file_system.ads:27:20: info: class-wide postcondition is stronger than overridden one (CVC5: 1 VC)
ints.adb:12:30: info: overflow check proved (CVC5: 2 VC)
ints.adb:29:10: info: precondition proved (CVC5: 1 VC)
ints.adb:34:34: medium: overflow check might fail, cannot prove lower bound for Arg.Max - 10 [reason for check: result of subtraction must fit in a 32-bits machine integer] [possible fix: use pragma Overflow_Mode or switch -gnato13 or unit SPARK.Big_Integers]
ints.adb:35:14: info: postcondition proved (CVC5: 1 VC)
ints.adb:38:21: info: precondition proved (CVC5: 1 VC)
ints.adb:42:08: medium: overflow check might fail, cannot prove upper bound for abs (Arg1.Value - Arg2.Value) [reason for check: result of absolute value must fit in a 32-bits machine integer] [possible fix: add precondition (abs (Arg1.Value - Arg2.Value) <= Integer'Last) to subprogram at ints.ads:23]
ints.adb:42:24: medium: overflow check might fail, cannot prove lower bound for (Arg1.Value - Arg2.Value) [reason for check: result of subtraction must fit in a 32-bits machine integer] [possible fix: add precondition (if Arg2.Value >= 0 then Arg1.Value >= Integer'First + Arg2.Value else Arg1.Value <= Integer'Last + Arg2.Value) to subprogram at ints.ads:23]
ints.adb:42:56: medium: overflow check might fail, cannot prove upper bound for Arg1.Precision + Arg2.Precision [reason for check: result of addition must fit in a 32-bits machine integer] [possible fix: add precondition (Arg1.Precision <= Integer'Last - Arg2.Precision) to subprogram at ints.ads:23]
ints.adb:46:30: info: overflow check proved (CVC5: 2 VC)
ints.adb:64:38: medium: overflow check might fail, cannot prove upper bound for Arg.Precision + 1 [reason for check: result of addition must fit in a 32-bits machine integer] [possible fix: subprogram at ints.ads:29 should mention Arg in a precondition]
ints.ads:9:13: info: implicit aspect Always_Terminates on "Equal" has been proved, subprogram will terminate
ints.ads:11:40: medium: overflow check might fail, cannot prove lower bound for Arg.Max - 10 [reason for check: result of subtraction must fit in a 32-bits machine integer] [possible fix: use pragma Overflow_Mode or switch -gnato13 or unit SPARK.Big_Integers]
ints.ads:12:20: info: postcondition proved (CVC5: 1 VC)
ints.ads:12:20: info: postcondition proved (CVC5: 1 VC), in inherited contract at ints.ads:24
ints.ads:16:34: medium: overflow check might fail, cannot prove lower bound for Arg.Max - 10 [reason for check: result of subtraction must fit in a 32-bits machine integer] [possible fix: use pragma Overflow_Mode or switch -gnato13 or unit SPARK.Big_Integers]
ints.ads:17:14: info: postcondition proved (CVC5: 1 VC)
ints.ads:23:24: info: implicit aspect Always_Terminates on "Equal" has been proved, subprogram will terminate
predicate_ints.adb:12:30: info: overflow check proved (CVC5: 2 VC)
predicate_ints.adb:31:39: medium: overflow check might fail, cannot prove lower bound for Arg1.Value + Arg2.Value [reason for check: result of addition must fit in a 32-bits machine integer] [possible fix: add precondition (if Arg2.Value >= 0 then Arg1.Value <= Integer'Last - Arg2.Value else Arg1.Value >= Integer'First - Arg2.Value) to subprogram at predicate_ints.ads:15]
predicate_ints.adb:43:10: info: precondition proved (CVC5: 1 VC)
predicate_ints.adb:48:34: medium: overflow check might fail, cannot prove lower bound for Arg.Max - 10 [reason for check: result of subtraction must fit in a 32-bits machine integer] [possible fix: use pragma Overflow_Mode or switch -gnato13 or unit SPARK.Big_Integers]
predicate_ints.adb:49:14: info: postcondition proved (CVC5: 1 VC)
predicate_ints.adb:52:21: info: precondition proved (CVC5: 1 VC)
predicate_ints.adb:56:08: medium: overflow check might fail, cannot prove upper bound for abs (Arg1.Value - Arg2.Value) [reason for check: result of absolute value must fit in a 32-bits machine integer] [possible fix: add precondition (abs (Arg1.Value - Arg2.Value) <= Integer'Last) to subprogram at predicate_ints.ads:28]
predicate_ints.adb:56:24: medium: overflow check might fail, cannot prove lower bound for (Arg1.Value - Arg2.Value) [reason for check: result of subtraction must fit in a 32-bits machine integer] [possible fix: add precondition (if Arg2.Value >= 0 then Arg1.Value >= Integer'First + Arg2.Value else Arg1.Value <= Integer'Last + Arg2.Value) to subprogram at predicate_ints.ads:28]
predicate_ints.adb:56:56: medium: overflow check might fail, cannot prove upper bound for Arg1.Precision + Arg2.Precision [reason for check: result of addition must fit in a 32-bits machine integer] [possible fix: add precondition (Arg1.Precision <= Integer'Last - Arg2.Precision) to subprogram at predicate_ints.ads:28]
predicate_ints.adb:60:30: info: overflow check proved (CVC5: 2 VC)
predicate_ints.adb:78:25: info: precondition proved (CVC5: 2 VC)
predicate_ints.adb:86:38: medium: overflow check might fail, cannot prove upper bound for Arg.Precision + 1 [reason for check: result of addition must fit in a 32-bits machine integer] [possible fix: subprogram at predicate_ints.ads:36 should mention Arg in a precondition]
predicate_ints.ads:10:13: info: implicit aspect Always_Terminates on "Equal" has been proved, subprogram will terminate
predicate_ints.ads:12:40: medium: overflow check might fail, cannot prove lower bound for Arg.Max - 10 [reason for check: result of subtraction must fit in a 32-bits machine integer] [possible fix: use pragma Overflow_Mode or switch -gnato13 or unit SPARK.Big_Integers]
predicate_ints.ads:13:20: info: postcondition proved (CVC5: 1 VC)
predicate_ints.ads:13:20: info: postcondition proved (CVC5: 1 VC), in inherited contract at predicate_ints.ads:29
predicate_ints.ads:15:13: info: implicit aspect Always_Terminates on overriding operator "+" has been proved, subprogram will terminate
predicate_ints.ads:17:21: info: initialization of "Arg" proved
predicate_ints.ads:18:13: info: implicit aspect Always_Terminates on "Zero" has been proved, subprogram will terminate
predicate_ints.ads:21:34: medium: overflow check might fail, cannot prove lower bound for Arg.Max - 10 [reason for check: result of subtraction must fit in a 32-bits machine integer] [possible fix: use pragma Overflow_Mode or switch -gnato13 or unit SPARK.Big_Integers]
predicate_ints.ads:22:14: info: postcondition proved (CVC5: 1 VC)
predicate_ints.ads:28:24: info: implicit aspect Always_Terminates on "Equal" has been proved, subprogram will terminate
predicate_ints.ads:33:13: info: implicit aspect Always_Terminates on overriding operator "+" has been proved, subprogram will terminate
predicate_ints.ads:34:24: info: implicit aspect Always_Terminates on "Zero" has been proved, subprogram will terminate
synchronized_file_system.ads:9:20: info: class-wide postcondition is stronger than overridden one (CVC5: 1 VC)
synchronized_file_system.ads:14:20: info: class-wide precondition is weaker than overridden one (CVC5: 1 VC)
synchronized_file_system.ads:15:20: info: class-wide postcondition is stronger than overridden one (CVC5: 1 VC)
synchronized_file_system.ads:20:20: info: class-wide precondition is weaker than overridden one (CVC5: 1 VC)
synchronized_file_system.ads:21:20: info: class-wide postcondition is stronger than overridden one (CVC5: 2 VC)
synchronized_file_system.ads:26:20: info: class-wide precondition is weaker than overridden one (CVC5: 1 VC)
synchronized_file_system.ads:27:20: info: class-wide postcondition is stronger than overridden one (CVC5: 1 VC)
use_file_system.adb:3:28: info: initialization of "F" proved
use_file_system.adb:8:05: info: precondition proved (CVC5: 1 VC)
use_file_system.adb:9:05: info: precondition proved (CVC5: 1 VC)
use_file_system.adb:11:05: info: precondition proved (CVC5: 1 VC)
use_file_system.adb:12:05: info: precondition proved (CVC5: 1 VC)
use_file_system.adb:14:05: info: precondition proved (CVC5: 1 VC)
use_file_system.adb:15:05: medium: precondition might fail
fixed_mem.adb:9:55: medium: range check might fail, cannot prove lower bound for Max - Free + 1 (e.g. when Free = 1002) [reason for check: returned value must fit in the result type of the function] [possible fix: subprogram at fixed_mem.ads:8 should mention Free in a precondition]
fixed_mem.adb:12:07: info: initialization of "Free_Init" proved
fixed_mem.adb:14:17: info: add a contract to analyze it separately from calling contexts
fixed_mem.adb:14:17: info: local subprogram "Check" only analyzed in the context of calls
fixed_mem.adb:17:13: info: only expected exception raised (CVC5: 1 VC), in call inlined at fixed_mem.adb:25
fixed_mem.adb:24:20: info: overflow check proved (CVC5: 2 VC)
fixed_mem.adb:25:07: info: analyzing call to "Check" in context
fixed_mem.ads:6:14: info: postcondition proved (CVC5: 1 VC)
fixed_mem.ads:8:13: info: implicit aspect Always_Terminates on "Free_Memory" has been proved, subprogram will terminate
mem.adb:11:55: medium: range check might fail, cannot prove lower bound for Max - Free + 1 (e.g. when Free = 1002) [reason for check: returned value must fit in the result type of the function] [possible fix: subprogram at mem.ads:9 should mention Free in a precondition]
mem.adb:13:14: info: add a contract to analyze it separately from calling contexts
mem.adb:13:14: info: local subprogram "Assign" only analyzed in the context of calls
mem.adb:13:41: info: initialization of "To" proved
mem.adb:19:07: info: initialization of "Free_Init" proved
mem.adb:21:17: warning: unused assignment
mem.adb:22:07: info: analyzing call to "Assign" in context
mem.adb:24:20: info: overflow check proved (CVC5: 2 VC)
mem.adb:25:22: info: assertion proved (CVC5: 1 VC)
mem.ads:3:21: warning: no subprogram exists that can initialize abstract state "Mem.State"
mem.ads:7:14: info: postcondition proved (CVC5: 1 VC)
mem.ads:9:13: info: implicit aspect Always_Terminates on "Free_Memory" has been proved, subprogram will terminate
resources.adb:6:24: info: unrolling loop
resources.ads:9:13: info: implicit function contract might not be available on recursive calls
resources.ads:10:08: medium: implicit aspect Always_Terminates on "Sum" could be incorrect, subprogram is recursive [possible fix: annotate "Sum" with a Subprogram_Variant aspect]
resources.ads:10:32: info: index check proved (CVC5: 2 VC)
resources.ads:10:36: info: overflow check proved (CVC5: 2 VC)
resources.ads:10:46: info: range check proved (CVC5: 2 VC)
resources.ads:12:22: info: initialization of "D" proved
resources.ads:13:14: info: postcondition proved (CVC5: 1 VC)
resources.ads:17:14: info: postcondition proved (CVC5: 1 VC)
use_vectors.adb:7:07: info: initialization of "S" proved
use_vectors.adb:10:15: info: precondition proved (CVC5: 2 VC)
use_vectors.adb:11:33: info: loop invariant initialization proved (CVC5: 1 VC)
use_vectors.adb:11:33: info: loop invariant preservation proved (CVC5: 1 VC)
use_vectors.adb:11:33: info: predicate check proved (Trivial: 2 VC)
use_vectors.adb:13:13: info: loop invariant initialization proved (CVC5: 1 VC)
use_vectors.adb:13:13: info: loop invariant preservation proved (CVC5: 1 VC)
use_vectors.adb:13:36: info: precondition proved (CVC5: 4 VC)
use_vectors.adb:13:44: info: range check proved (CVC5: 4 VC)
use_vectors.ads:12:13: info: implicit aspect Always_Terminates on "Create" has been proved, subprogram will terminate
use_vectors.ads:13:14: info: postcondition proved (CVC5: 1 VC)
use_vectors.ads:14:17: info: precondition proved (CVC5: 2 VC)
use_vectors.ads:14:37: info: range check proved (CVC5: 2 VC)

infeasible_access_subp.adb:2:04: medium: contract of function might not be feasible [provers gave up before completing the proof]
infeasible_access_subp.adb:4:13: info: implicit aspect Always_Terminates on "F" has been proved, subprogram will terminate
infeasible_access_subp.adb:6:14: info: postcondition proved (CVC5: 1 VC)
infeasible_access_subp.adb:14:13: info: implicit aspect Always_Terminates on "G1" has been proved, subprogram will terminate
infeasible_access_subp.adb:14:13: warning: potentially missing contract for "G1" declared at line 14
infeasible_access_subp.adb:14:13: warning: potentially missing contract for "G2" declared at line 16
infeasible_access_subp.adb:14:13: warning: references between entities introduce a cycle in proof dependencies; (implicit) contract of mutally dependent functions might not be available on calls from contracts and assertions [cyclic-dependency]
infeasible_access_subp.adb:14:58: info: postcondition proved (CVC5: 1 VC)
infeasible_access_subp.adb:16:13: info: implicit aspect Always_Terminates on "G2" has been proved, subprogram will terminate
infeasible_access_subp.adb:16:13: warning: potentially missing contract for "G1" declared at line 14
infeasible_access_subp.adb:16:13: warning: potentially missing contract for "G2" declared at line 16
infeasible_access_subp.adb:16:13: warning: references between entities introduce a cycle in proof dependencies; (implicit) contract of mutally dependent functions might not be available on calls from contracts and assertions [cyclic-dependency]
infeasible_access_subp.adb:16:58: info: postcondition proved (CVC5: 1 VC)
infeasible_access_subp.adb:19:46: info: postcondition of source is strong enough to imply postcondition of target (CVC5: 1 VC)
infeasible_access_subp.adb:19:46: medium: call via access-to-function might not terminate [reason for check: functions should always terminate in SPARK] [possible explanation: calls via access-to-subprograms inside function taken as access might hide recursive calls]
infeasible_access_subp.adb:19:48: info: null exclusion check proved (Trivial: 1 VC)
infeasible_access_subp.adb:20:49: info: postcondition of source is strong enough to imply postcondition of target (CVC5: 1 VC)
infeasible_access_subp.adb:20:49: medium: call via access-to-function might not terminate [reason for check: functions should always terminate in SPARK] [possible explanation: calls via access-to-subprograms inside function taken as access might hide recursive calls]
infeasible_access_subp.adb:20:51: info: null exclusion check proved (Trivial: 1 VC)
infeasible_access_subp.adb:26:46: info: postcondition of source is strong enough to imply postcondition of target (CVC5: 1 VC)
infeasible_access_subp.adb:26:46: medium: call via access-to-function might not terminate [reason for check: functions should always terminate in SPARK] [possible explanation: calls via access-to-subprograms inside function taken as access might hide recursive calls]
infeasible_access_subp.adb:26:48: info: null exclusion check proved (Trivial: 1 VC)
infeasible_access_subp.adb:27:49: info: postcondition of source is strong enough to imply postcondition of target (CVC5: 1 VC)
infeasible_access_subp.adb:27:49: medium: call via access-to-function might not terminate [reason for check: functions should always terminate in SPARK] [possible explanation: calls via access-to-subprograms inside function taken as access might hide recursive calls]
infeasible_access_subp.adb:27:51: info: null exclusion check proved (Trivial: 1 VC)
test.adb:1:11: warning: subprogram "Test" has no effect
test.adb:8:07: info: function contract feasibility proved (CVC5: 1 VC)
test.adb:14:07: info: function contract feasibility proved (CVC5: 1 VC)
test.adb:22:07: medium: contract of function might not be feasible [provers gave up before completing the proof]
test.adb:25:12: info: range check proved (CVC5: 2 VC)
test.adb:29:07: medium: contract of function might not be feasible [provers reached step limit before completing the proof]

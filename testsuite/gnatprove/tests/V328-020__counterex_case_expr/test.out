case_expr.adb:14:05: info: initialization of "I" proved
case_expr.adb:22:20: high: assertion might fail (e.g. when I = 2)
case_expr.adb:31:05: info: initialization of "I" proved
case_expr.adb:37:20: high: assertion might fail (e.g. when I = 1)
case_expr.adb:46:05: info: initialization of "I" proved
case_expr.adb:53:20: high: assertion might fail (e.g. when I = 1)
case_expr.adb:64:22: info: unrolling loop [info-unrolling-inlining]
case_expr.adb:65:07: warning: initialization of an array in FOR loop is handled imprecisely [array-initialization]
case_expr.adb:65:20: info: range check proved (CVC5: 10 VC)
case_expr.adb:67:35: high: assertion might fail, cannot prove False
case_expr.ads:9:12: info: implicit aspect Always_Terminates on "Return_One" has been proved, subprogram will terminate
case_expr.ads:11:12: info: implicit aspect Always_Terminates on "Case_Expr" has been proved, subprogram will terminate
case_expr.ads:13:12: info: implicit aspect Always_Terminates on "Case_Expr_Range" has been proved, subprogram will terminate
case_expr.ads:15:12: info: implicit aspect Always_Terminates on "Case_Expr_In_Case_Expr" has been proved, subprogram will terminate
case_expr.ads:17:13: warning: subprogram "Loop_Entry_In_Case_Expr" has no effect
counterexample expected for check at case_expr.adb:22
  trace at case_expr.adb:16 --> I = 2
  trace at case_expr.adb:22 --> I = 2
  trace at case_expr.ads:11 --> N = Two
counterexample expected for check at case_expr.adb:37
  trace at case_expr.adb:33 --> I = 1
  trace at case_expr.adb:37 --> I = 1
  trace at case_expr.ads:13 --> N = One
counterexample expected for check at case_expr.adb:53
  trace at case_expr.adb:48 --> I = 1
  trace at case_expr.adb:53 --> I = 1
counterexample expected for check at case_expr.adb:67
  trace at case_expr.adb:62 --> A = (others => 1)
  trace at case_expr.adb:64 --> J = 1
  trace at case_expr.adb:65 --> A = (1 => 2, others => 1)

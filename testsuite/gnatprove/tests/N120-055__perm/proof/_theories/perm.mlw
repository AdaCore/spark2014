module Perm__index
 use import "_gnatprove_standard".Main
 use        "_gnatprove_standard".Integer
 use import "int".Int

 type index
 
 function first :int = 1
 
 function last :int = 100
 
 predicate in_range (x : int)  = 1 <= x <= 100

 (* Copy of the model of modules for static discrete types *)
 clone export "ada__model".Static_Discrete with
 type t = index, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range

end

module Perm__nat_array
 use import "_gnatprove_standard".Main
 use        Standard__natural
 use        Standard__integer
 use        Perm__index
 use        "_gnatprove_standard".Integer
 use import "int".Int
 use        "_gnatprove_standard".Array__1

 (* Copy of the model of modules for unconstrained array types *)
 clone export "ada__model".Unconstr_Array with
 type component_type = Standard__natural.natural, 
 type base_type = Standard__integer.integer, 
 function to_int = Standard__integer.to_int, 
 predicate in_range_base = Standard__integer.in_range, 
 predicate index_dynamic_property = Perm__index.dynamic_property
 
 type nat_array  = __t
 
 (* Copy of the axiom for array bitwise comparison *)
 clone export "ada__model".Array_Comparison_Axiom with
 type component_type = Standard__natural.natural, 
 function to_int = Standard__natural.to_int

end

module Perm__is_perm
  use import "_gnatprove_standard".Main
  use import int.Int
  use import Standard__natural
  use import Perm__nat_array
  use import "_gnatprove_standard".Array__1

  (* Number of occurrences of v in a *)
  function occ (v: natural) (a: nat_array) : int

  axiom occ_empty:
    forall v: natural, a: nat_array.
    last a < first a -> occ v a = 0

  axiom occ_set:
    forall e v: natural, a : nat_array, i: int.
      let b = of_array (set (to_array a) i v) (first a) (last a) in
        first a <= i <= last a -> 
          (get (to_array a) i <> e -> 
            (v <> e -> occ e b = occ e a) /\
            (v = e  -> occ e b = (occ e a) + 1)) /\
          (get (to_array a) i = e -> 
            (v <> e -> occ e b = (occ e a) - 1) /\
            (v = e  -> occ e b = occ e a))

 function is_perm "inline" (a b : nat_array) : bool =
    forall v: natural. occ v a = occ v b

 val is_perm (a : nat_array) (b : nat_array) : bool
  ensures { result = is_perm a b }

end
lcp.adb:6:21: info: cannot unroll loop (too many loop iterations)
lcp.adb:7:12: medium: overflow check might fail, cannot prove upper bound for X + L [reason for check: result of addition must fit in a 32-bits machine integer] [possible fix: loop at line 6 should mention L in a loop invariant]
lcp.adb:8:19: info: overflow check proved (CVC5: 2 VC)
lcp.adb:13:15: info: index check proved (CVC5: 2 VC)
lcp.adb:13:15: info: overflow check proved (CVC5: 2 VC)
lcp.adb:13:28: info: index check proved (CVC5: 2 VC)
lcp.adb:13:28: info: overflow check proved (CVC5: 2 VC)
lcp.adb:17:14: info: overflow check proved (CVC5: 2 VC)
lcp.ads:3:10: info: implicit aspect Always_Terminates on "LCP" has been proved, subprogram will terminate
lcp.ads:6:38: medium: postcondition might fail, cannot prove A (X + K) = A (Y + K)
lcp.ads:6:43: high: array index check might fail (e.g. when A = (1 => 0, 2 => 0) and K = 1 and X = 2) [reason for check: result of addition must be a valid index into the array]
lcp.ads:6:43: info: overflow check proved (CVC5: 2 VC)
lcp.ads:6:55: high: overflow check might fail (e.g. when K = 1 and Y = 1000000) [reason for check: result of addition must fit in a 32-bits machine integer] [possible fix: use pragma Overflow_Mode or switch -gnato13 or unit SPARK.Big_Integers]
lcp.ads:6:55: medium: array index check might fail [reason for check: result of addition must be a valid index into the array]
lcp.ads:7:19: info: overflow check proved (CVC5: 2 VC)
lcp.ads:8:29: info: overflow check proved (CVC5: 2 VC)
lcp.ads:9:32: info: index check proved (CVC5: 2 VC)
lcp.ads:9:32: info: overflow check proved (CVC5: 2 VC)
lcp.ads:9:54: info: index check proved (CVC5: 2 VC)
lcp.ads:9:54: info: overflow check proved (CVC5: 2 VC)

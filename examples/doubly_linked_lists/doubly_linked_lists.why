
type list

type cursor

type elem

logic empty_list : list

logic no_element : cursor

(************)
(* equality *)
(************)

parameter eq_cursor_ : c1 : cursor -> c2 : cursor ->
  {}
  bool
  { result = true <-> c1 = c2 }

(**********)
(* length *)
(**********)

logic length : list -> int

axiom length_is_non_negative :
  (forall li : list. length (li) >= 0)

(************)
(* is_empty *)
(************)

predicate is_empty (li : list) =
  length (li) = 0

(* following axiom is not in SPARK annotations *)
axiom empty_list_is_empty :
  is_empty (empty_list)

(************)
(* to_index *)
(************)

logic to_index : list, cursor -> int

(* following axiom is not in SPARK annotations *)
axiom to_index_injective :
  (forall li : list. forall c1,c2 : cursor. 
     (to_index (li, c1) <> 0 and to_index (li, c1) = to_index (li, c2))
     -> c1 = c2)

axiom to_index_is_non_negative :
  (forall li : list. forall c : cursor. to_index (li, c) >= 0)

axiom to_index_is_less_than_length :
  (forall li : list. forall c : cursor. to_index (li, c) <= length (li))

axiom to_index_of_no_element_is_zero :
  (forall li : list. to_index (li, no_element) = 0)

(*********)
(* first *)
(*********)

logic first : list -> cursor

axiom first_of_empty_is_no_element :
  (forall li : list. is_empty (li) -> first (li) = no_element)

axiom index_of_first_of_non_empty_is_one :
  (forall li : list. not is_empty (li) -> to_index (li, first (li)) = 1)

(********)
(* last *)
(********)

logic last : list -> cursor

axiom last_of_empty_is_no_element :
  (forall li : list. is_empty (li) -> last (li) = no_element)

axiom index_of_last_of_non_empty_is_length :
  (forall li : list. not is_empty (li) -> 
                       to_index (li, last (li)) = length (li))

(***************)
(* has_element *)
(***************)

predicate has_element (li : list, c : cursor) =
  to_index (li, c) <> 0

parameter has_element_ : li : list -> c : cursor ->
  {} bool { result = true <-> has_element (li, c) }

(***********)
(* element *)
(***********)

logic element : list, cursor -> elem

parameter element_ : li : list -> c : cursor -> 
  { has_element (li, c) } elem { result = element (li, c) }

(********)
(* next *)
(********)

parameter next_ : li : list -> c : cursor -> 
  { has_element (li, c) } 
  cursor 
  { (c = last (li) -> to_index (li, result) = 0)
    and (c <> last (li) -> to_index (li, result) = to_index (li, c) + 1) }

(*****************)
(* with_at_equal *)
(*****************)

predicate with_at_equal (li1 : list, c : cursor, e : elem, li2 : list) =
  length (li2) = length (li1)
  and (forall k : cursor.
         has_element (li1, k) -> to_index (li2, k) = to_index (li1, k))
  and (forall k : cursor.
         has_element (li1, k) and k <> c -> element (li2, k) = element (li1, k))
  and element (li2, c) = e

(*******************)
(* replace_element *)
(*******************)

parameter replace_element_ : li : list ref -> c : cursor -> e : elem ->
  { has_element (li, c) }
  unit
  reads li
  writes li
  { with_at_equal (li@, c, e, li) }

(*********************)
(* plus_any_at_equal *)
(*********************)

predicate plus_any_at_equal (li1 : list, i : int, li2 : list) =
  length (li2) = length (li1) + 1
  and (forall k : cursor.
         has_element (li1, k) and to_index (li1, k) < i 
         -> to_index (li2, k) = to_index (li1, k))
  and (forall k : cursor.
         has_element (li1, k) and to_index (li1, k) >= i 
         -> to_index (li2, k) = to_index (li1, k) + 1)
  and (forall k : cursor.
         has_element (li1, k) -> element (li2, k) = element (li1, k))
  and (forall k : cursor.
         has_element (li2, k) and to_index (li2, k) <> i
         -> has_element (li1, k))

(*****************)
(* plus_at_equal *)
(*****************)

predicate plus_at_equal (li1 : list, i : int, e : elem, li2 : list) =
  plus_any_at_equal (li1, i, li2)
  and (forall k : cursor.
         to_index (li2, k) = i -> element (li2, k) = e)

(**************************)
(* plus_num_between_equal *)
(**************************)

predicate plus_num_between_equal 
  (li1 : list, n : int, i : int, j : int, li2 : list) =
  length (li2) = length (li1) + n
  and (i <= j ->
    ((forall k : cursor.
         has_element (li1, k) and to_index (li1, k) < i 
         -> to_index (li2, k) = to_index (li1, k))
     and (forall k : cursor.
            has_element (li1, k) and to_index (li1, k) >= j
            -> to_index (li2, k) = to_index (li1, k) + n)
(*     and (forall k : cursor.
            has_element (li1, k) -> element (li2, k) = element (li1, k))
*)
     and (forall k : cursor.
            has_element (li2, k) and to_index (li2, k) < i
            -> to_index (li2, k) = to_index (li1, k))
     and (forall k : cursor.
            has_element (li2, k) and to_index (li2, k) >= j + n
            -> to_index (li2, k) = to_index (li1, k) + n)))

(**********)
(* insert *)
(**********)

parameter insert_ : li : list ref -> c : cursor -> e : elem ->
  { has_element (li, c) } (* not modeling the maximal length here *)
  unit
  reads li
  writes li
  { plus_at_equal (li@, to_index (li@, c), e, li) }

(**********)
(* append *)
(**********)

parameter append_ : li : list ref -> e : elem ->
  {} (* not modeling the maximal length here *)
  unit
  reads li
  writes li
  { plus_at_equal (li@, length (li@) + 1, e, li) }

(***********)
(* prepend *)
(***********)

parameter prepend_ : li : list ref -> e : elem ->
  {} (* not modeling the maximal length here *)
  unit
  reads li
  writes li
  { plus_at_equal (li@, 1, e, li) }

(**********)
(* delete *)
(**********)

parameter delete_ : li : list ref -> c : cursor ref ->
  { has_element (li, c) }
  unit
  reads li, c
  writes li, c
  { plus_any_at_equal (li, to_index (li@, c@), li@) 
    and not has_element (li, c) }

(*********)
(* tests *)
(*********)

(* removing an element from a list decreases its length by one *)
let test1 (li : list ref) (c : cursor ref) =
  { has_element (li, c) }
  let n = ref next_ !li !c in
  if has_element_ !li !n then
    delete_ li n
  else
    delete_ li c
  { length (li) = length (li@) - 1 }

(* take a list of 4 elements, prepend element e, remove all initial 4 elements
   and take the last element of the list, it is e *)
let test2 (li : list ref) (e : elem) =
  { length (li) = 4 }
  prepend_ li e;
  let c = ref last !li in
  delete_ li c;
  c := next_ !li (first !li);
  delete_ li c;
  c := last !li;
  delete_ li c;
  c := last !li;
  delete_ li c;
  element_ !li (last !li)
  { result = e }

(* adding elements to a list does not invalidate an existing cursor *)
let test3 (li : list ref) (c,d,f,g,h : cursor) (e : elem) =
  { to_index (li, c) = 4 and has_element (li, f) and to_index (li, h) <> 0 }
  insert_ li c e;
  append_ li e;
  if has_element_ !li d then
    insert_ li d e;
  insert_ li f e;
  if length !li > 5 then
    if eq_cursor_ g (next_ !li c) then
      insert_ li g e
    else
      insert_ li h e
  { has_element (li, c) }

(* iterate through the list and increment a counter, which should equal 
   the length of the list on exit *)
let test4 (li : list) =
  {}
  let n = ref 0 in
  let c = ref first li in
  while has_element_ li !c do
    { invariant (has_element (li, c) -> n = to_index (li, c) - 1)
                and (not has_element (li, c) -> n = length (li))
    }
    n := !n + 1;
    c := next_ li !c
  done;
  !n
  { result = length (li) }

(* unrolling of the loop in test5 *)
let test5_unroll (li : list ref) (e : elem) =
  { length (li) >= 3 }
  let c = ref first !li in
  insert_ li !c e;
  c := next_ !li !c;
  insert_ li !c e;
  c := next_ !li !c;
  insert_ li !c e;
  !c
  { length (li) = length (li@) + 3 
    and to_index (li@, result) = 3
    and to_index (li, result) = 6
    and plus_num_between_equal 
      (li@, to_index (li@, result), 1, to_index (li@, result), li) }

(* body of the loop in test5 *)
let test5_loop (li_init : list) (li : list ref) (c : cursor ref) (e : elem) =
  { has_element (li_init, c) and
    to_index (li, c) = 2 * to_index (li_init, c) - 1 and
    plus_num_between_equal 
      (li_init, to_index (li, c) - to_index (li_init, c), 
       1, to_index (li_init, c), li) }
  init:
  if has_element_ !li !c then
    (insert_ li !c e;
     c := next_ !li !c;
     assert { has_element (li, c) -> 
                to_index (li, c) = to_index (li, c@init) + 1 };
     void)
  { has_element (li, c) ->
      (has_element (li_init, c) and
       to_index (li, c) = 2 * to_index (li_init, c) - 1 and
       plus_num_between_equal
         (li_init, to_index (li, c) - to_index (li_init, c), 
          1, to_index (li_init, c), li)) }

(* exit of the loop in test5 *)
let test5_exit (li_init : list) (li : list ref) (c : cursor ref) (e : elem) =
  { has_element (li_init, c) and
    to_index (li, c) = 2 * to_index (li_init, c) - 1 and
    plus_num_between_equal 
      (li_init, to_index (li, c) - to_index (li_init, c), 
       1, to_index (li_init, c), li) }
  init:
  if has_element_ !li !c then
    (insert_ li !c e;
     c := next_ !li !c)
  { not has_element (li, c) -> length (li) = 2 * length (li_init) }

(* iterate through the list by adding element e at every position. This doubles
   the size of the list *)
let test5 (li : list ref) (e : elem) =
  { not is_empty (li) }
  let c = ref first !li in
  init:
  while has_element_ !li !c do
    { invariant 
        (has_element (li, c) -> 
           (has_element (li@init, c) and
	    to_index (li, c) = 2 * to_index (li@init, c) - 1 and
            plus_num_between_equal
              (li@init, to_index (li, c) - to_index (li@init, c), 
               1, to_index (li@init, c), li)))
        and (not has_element (li, c) -> length (li) = 2 * length (li@init))
    }
    insert_ li !c e;
    c := next_ !li !c
  done
  { length (li) = 2 * length (li@) }

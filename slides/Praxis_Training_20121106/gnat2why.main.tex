\documentclass{beamer}

\usepackage{xcolor}
\usepackage{eurosym}
\usepackage[utf8]{inputenc}
\usepackage{tikz}
\usetikzlibrary{arrows,positioning}
\usepackage{pgflibraryshapes} % for ellipse shape

%\usepackage{beamerthemesplit}

\usepackage[absolute,overlay]{textpos}
\TPGrid{15}{10}

\newcommand{\vs}{\vspace{0.5cm}}

\definecolor{mygreen}{rgb}{0,0.7,0}

\usepackage{listings}
\usepackage{color}
\lstset{
	language=Ada,
	keywordstyle=\bfseries\ttfamily\color[rgb]{0,0,1},
	identifierstyle=\ttfamily,
	commentstyle=\color[rgb]{0.133,0.545,0.133},
	stringstyle=\ttfamily\color[rgb]{0.627,0.126,0.941},
        morekeywords=[1]some,
	showstringspaces=false,
	basicstyle=\tiny,
	numberstyle=\tiny,
	numbers=left,
	stepnumber=1,
	numbersep=10pt,
	tabsize=2,
	breaklines=true,
	prebreak = \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
	breakatwhitespace=false,
	aboveskip={1.5\baselineskip},
  columns=fixed,
  extendedchars=true,
% frame=single,
% backgroundcolor=\color{lbcolor},
}

% special frames used to put source-code listings
\newenvironment{specialframe}{%
  \begin{frame}[fragile,environment=specialframe]}{\end{frame}}

\xdefinecolor{adacoreblue}{rgb}{0,0.34,0.59}
\xdefinecolor{adacoregrey}{rgb}{0.53,0.68,0.84}

\AtBeginSection[]{\frame{\frametitle{Outline}
\tableofcontents[current]}}
\AtBeginSubsection[]{\frame{\frametitle{Outline}
\tableofcontents[currentsection,currentsubsection]}}

\setbeamertemplate{footline}[page number]
\setbeamercolor{frametitle}{bg=adacoreblue!40!adacoregrey, fg=white}
\setbeamercolor{section in toc}{fg=adacoreblue}
\setbeamercolor{block title}{bg=adacoregrey, fg=white}
\setbeamertemplate{navigation symbols}{}
\setbeamercovered{transparent}
\setbeamertemplate{footline}
{%
  \hfill \insertframenumber\ / \inserttotalframenumber%
}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% types: abstract types, predefined types, records, algebraic data types
% logic: function declarations, definitions, predicates, axioms
% theories

\section{Encoding of Ada into Why3}

\begin{specialframe}\frametitle{Types - Scalar types}
   \begin{block}{Generalities}
      All entities are translated into their own module, sometimes two
   \end{block}

   \begin{block}{Discrete types}
   \begin{itemize}
      \item abstract type
      \item conversion to/from int
      \item axioms about these conversion functions
      \item constants for first/last/modulus, with definition when not dynamic
      \item \verb|of_int_| program function with precondition that argument is
         in range
      \item equality ...
   \end{itemize}
   \end{block}
   \vspace{-1em}
   \begin{block}{Floating point types}
      \begin{itemize}
         \item very similar, but conversion to/from real
      \end{itemize}
   \end{block}
\end{specialframe}

\begin{specialframe}\frametitle{Types - Record types}
   \begin{block}{Why3 model}
      \begin{itemize}
         \item why3 record type with one field for all present fields
               (even in case of variant records)
         \item program functions for access with discriminant check
      \end{itemize}
   \end{block}
\end{specialframe}

\begin{specialframe}\frametitle{Types - Array types}
   \begin{block}{Why3 record with fields:}
      \begin{itemize}
         \item map - contains the data
         \item first
         \item last
         \item offset - to allow for sliding
      \end{itemize}
   \end{block}
\end{specialframe}

\begin{specialframe}\frametitle{Constants, Variables}
   \begin{itemize}
      \item declare a logic or program (mutable) variable as required
      \item only constants get a definition
   \end{itemize}
\end{specialframe}

\begin{specialframe}\frametitle{Subprograms}

We generate three things for a subprogram, each in its own module:
   \begin{itemize}
      \item a Why3 program declaration, with pre/post/effects, but no body
      \item a Why3 program that computes the precondition, is used to get VCs
for checks in the precondition
      \item the actual translation of the Why3 program, which will get us the
VCs for the body + postcondition
   \end{itemize}
\end{specialframe}

\begin{specialframe}\frametitle{Other things that generate a module}

   \begin{block}{Array aggregates}
      We generate:
   \begin{itemize}
      \item a function with "holes" for the right hand side
      \item axiom defining the aggregate
   \end{itemize}
   \end{block}
   \begin{block}{String literals}
      We only generate the variable, no knowledge about the string for now
   \end{block}
\end{specialframe}

\begin{specialframe}\frametitle{Dispatching of entities}

Why3 files can't be mutually dependent, so we must break recursion
\vspace{-1em}

   \begin{block}{Dispatching of entities to files}
      \begin{itemize}
         \item \verb|unit__types_in_spec.mlw| for types of spec
         \item \verb|unit__types_in_body.mlw|
         \item \verb|unit__types_variables.mlw|
         \item \verb|unit__context_in_spec.mlw|
         \item \verb|unit__context_in_body.mlw|
         \item \verb|unit__package.mlw|
      \end{itemize}
   \end{block}
   \begin{block}{Dependencies}
      \begin{itemize}
         \item Each file in this list can depend on files above, for the same unit or others
         \item all calls, including recursive calls, are translated by calls to
the program declaration, not the "actual" program
      \end{itemize}
   \end{block}
\end{specialframe}

\section{gnat2why passes}

\begin{specialframe}\frametitle{Different Passes (1)}

   \begin{block}{Alfa filter}
      \begin{itemize}
         \item Compute globals for all subprograms
         \item Traverse the entire tree to find all entities, and to decide
            whether they are in Alfa or not
         \item Define lists:
            \begin{itemize}
                  \item types in alfa
                  \item objects in alfa
                  \item subprograms in alfa
            \end{itemize}
      \end{itemize}
   \end{block}
\end{specialframe}


\begin{specialframe}\frametitle{Different Passes (2) }
   \begin{block}{Translation}
      \begin{itemize}
         \item Dispatch over type of entity and call corresponding translation
            procedure:
            \begin{itemize}
                  \item \verb|Translate_Type|
                  \item \verb|Translate_Constant|
                  \item \verb|Translate_Variable|
                  \item \verb|Translate_Subprogram_Spec|
            \end{itemize}
         \item Iterate over entities to generate "VCs" (ie Why3 programs that
            will trigger VCs)
            \begin{itemize}
               \item Today, only calls \verb|Generate_VCs_For_Subprogram_Body|
            \end{itemize}
      \end{itemize}
   \end{block}
\end{specialframe}

\begin{specialframe}\frametitle{Translation of statements and expressions}
   \begin{block}{Generalities}
      \begin{itemize}
         \item there is no difference between statement and expression is Why3,
               so this simplifies things (ie. insert an assert "statement"
               inside an expression)
         \item all annotations (pre/post, assert, etc) are translated (at
least) twice to Why3, once as a program expression to get the checks, once as
annotation
      \end{itemize}

   \end{block}

   \begin{block}{loops}
      \begin{itemize}
         \item transform "assertion" invariant to hoare invariant
         \item use infinite loop + exception to allow multiple exits
      \end{itemize}
   \end{block}

\end{specialframe}

\begin{specialframe}\frametitle{Translation of statements and expressions (2) }
   \begin{block}{Conversions}
      \begin{itemize}
         \item every Ada (sub)type is translated to its own Why3 type
         \item need to insert conversions
         \item conversions go through the "Why base type"
      \end{itemize}
   \end{block}
   \begin{block}{Why base type}
      \begin{itemize}
         \item for discrete types: \verb|int|
         \item for floating point types: \verb|real|
         \item for arrays: generic array type
         \item for records types: the Why3 type of the Ada root type
      \end{itemize}
   \end{block}
\end{specialframe}

\begin{specialframe}\frametitle{Translation of statements and expressions (3) }
   \begin{block}{Arithmetic expressions}
      \begin{itemize}
         \item insert conversions to \verb|int| to allow arithmetic operators
         \item insert overflow check calls
         \item range check on conversion to Ada type
      \end{itemize}
   \end{block}
\end{specialframe}

\begin{specialframe}\frametitle{Special case - "invisible" globals}
   \begin{block}{Usually, everything is driven by entities}
      \begin{itemize}
         \item name generation
         \item dispatching to correct Why file
         \item dispatching on the kind of the Entity
      \end{itemize}
   \end{block}
   \begin{block}{reads/writes to vars that are declared in package body}
      \begin{itemize}
         \item we only have their name from ALI file
         \item that's enough to refer to it ...
         \item ... and its type
      \end{itemize}
   \end{block}
\end{specialframe}

\begin{specialframe}\frametitle{Tracability}
   \begin{block}{Labels in Why3 code}
      \begin{itemize}
         \item One can label any Why3 entity or expression with a string
         \item This label will stick to that expression through VCgen,
         simplifications, etc
      \end{itemize}
   \end{block}
   \begin{block}{We put labels in for}
      \begin{itemize}
         \item all VCs (kind of check, source location)
         \item all statements (for "Show Path")
         \item all subprograms (for "Prove Subprogram")
      \end{itemize}
   \end{block}
\end{specialframe}

\section{gnat2why Code}
\begin{specialframe}\frametitle{Code organization}
   \begin{itemize}
      \item \verb|alfa-*|       units to compute Alfa subset
      \item \verb|why-atree-*|  units to define and manipulate Why tree
      \item \verb|why-gen-*|    units to generate specific Why subtrees
      \item \verb|gnat2why-*|   units that traverse the GNAT tree and generate
         Why trees
      \item \verb|why-inter|    unit that does a lot of work "in between"
   \end{itemize}
\end{specialframe}
\end{document}

\documentclass{beamer}
\input{praxis-beamer}

\usepackage{tikz}
\usetikzlibrary{positioning,calc}

\title{SPARK 2014 Advisory Panel}
\subtitle{Teleconference 2}

% Inspired by http://tex.stackexchange.com/questions/15237
\makeatletter
\newenvironment{btHighlight}[1][]
{\begingroup\tikzset{bt@Highlight@par/.style={#1}}\begin{lrbox}{\@tempboxa}}
{\end{lrbox}\bt@HL@box[bt@Highlight@par]{\@tempboxa}\endgroup}

\newcommand\btHL[1][]{%
  \begin{btHighlight}[#1]\bgroup\aftergroup\bt@HL@endenv%
}
\def\bt@HL@endenv{%
  \end{btHighlight}%
  \egroup
}
\newcommand{\bt@HL@box}[2][]{%
  \tikz[remember picture]{%
    \pgfpathrectangle{\pgfpoint{1pt}{0pt}}{\pgfpoint{\wd #2}{\ht #2}}%
    \pgfusepath{use as bounding box}%
    \node[anchor=base west,%
          outer sep=0pt,%
          inner xsep=1pt,%
          inner ysep=0pt,%
          rounded corners=2pt,%
          minimum height=\ht\strutbox+1pt,%
          #1]%
          {%
            \raisebox{1pt}{\strut}\strut\usebox{#2}%
          };%
  }%
}
\makeatother

\date{July 17, 2013}
\begin{document}

\begin{altrantitle}
\titleprismlabela{SPARK 2014}
\titleprismlabelb{Safe and Secure programming}
\titleprismlabelc{
  \resizebox{4cm}{!}{
    \includegraphics{partnership}
  }
}
\end{altrantitle}

\begin{frame}{Introduction}

  \begin{itemize}

  \item Introductions
  \item Round-up of LRM review comments
  \item Update on Language Issues: 
    \begin{itemize}
    \item Refined\_Post
    \item Refined\_Pre
    \item Externals
    \end{itemize}
  \item Early Preview Release:
    \begin{itemize}
    \item Access
    \item Demo
    \end{itemize}
  \item Conclusion

  \end{itemize}

\end{frame}

\begin{frame}{LRM Review Comments - Access types and Allocators}

  \begin{itemize}

  \item Limited support for access types - this may be possible in the
    future as perhaps access to constants or to subprogram types. In
    the mean time possible workarounds:
   \begin{itemize}
    \item Use an indefinite container - we hope to give a SPARK
      version of indefinite containers and or provide a SPARK
      interface to the Ada Container library
   \item Make the type to contain the constants private and provide
     subprograms to read the values of the constants. The body of the
     package defining the private type will not be in SPARK
  \end{itemize}
  \item Limited support of allocators - particularly used for context
    switching.  We will consider this when we add tasking. A possible
    workaround is to use a private type as the context and mark the
    body of the package defining the type as not in SPARK
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Using a Private Type Wrapper}

  \begin{itemize}

    \item Write a SPARK compatible visible part and a non-spark private part and body
    \item Use the declared functions to get pointers and strings.
    \item Alternatively use a SPARK interface to Ada.Strings.Unbounded. 
  \end{itemize}

  \begin{pxcode}[language=SPARK,style=tinystyle,gobble=4]
    package String_Constants
    is
        subtype String_Index is Positive range 1 .. 512;
        type Ref_String is private;

        function Get_A_Ref_String (I : String_Index) return ref_String;

        function Get_A_String (S : Ref_String) return String;
    private
       pragma SPARK_Mode (Off);
       type ref_String is access String;
   end String_Constants; 
  \end{pxcode}

\end{frame}

\begin{frame}{LRM Review Comments - Global and Depends aspects}

  \begin{itemize}

  \item Global and Depends aspects: when we say that for mode out
    parameters and globals that things like array attributes,
    discriminants and tags are ignored, we mean ignored for the
    purposes of  flow analysis - they are treated as constants.  
  \item We will consider post release 1 if this model is adequate
  \item Also post release 1 we will consider whether we can provide more
  precise flow relations for composite objects which are only
  partially updated by a subprogram, but never read
  \end{itemize}

\end{frame}

\begin{frame}{LRM Review Comments - Ghost Functions}

  \begin{itemize}

  \item Ghost functions can be used in any assertion expression this
    include Pre and Post conditions.  We will make this clearer in the
    RM.
  \item It is intended that SPARK will raise an error if a Ghost
    function is used outside of an assertion expression.  
  \item It is expected that the compiler will be able to not generate
    code for Ghost functions if assertion expressions are not executed
    (Ignored).
  \item \emph {Check with AdaCore regarding omitting such functions
    from dead code statistics if they are not executed.}
 \end{itemize}

\end{frame}

\begin{frame}{LRM Review Comments - Annotations}

  \begin{itemize}

  \item SPARK 2014 aspects cannot be processed by a non SPARK aware compiler  
  \item All SPARK aspects can be expressed as pragmas which will be
    ignored by such a compiler
 \end{itemize}

\end{frame}

\begin{frame}{Refined\_Post}

  \begin{itemize}
  \item The aspect Refined\_Post is in SPARK 2014.  It facilitates
    writing a post condition in terms of the implementation of a subprogram. 
  \end{itemize}
 
\end{frame}

\begin{frame}{Refined\_Pre}

  \begin{itemize}
  \item Refined\_Pre is being postponed until after Release 1
  \item In traditional refinement techniques a precondition implies
    its refined precondition.  In principle this means that the
    refined precondition may be weaker
  \item Ada requires that the precondition is evaluated each time a
    subprogram is called
  \item This is equivalent to requiring that both the precondition and
    the refined precondition must be satisfied whenever the subprogram
    is called.  The refined precondition cannot be weaker it must be equivalent.
  \item This difference has led to much discussion and the deferral of
    the refined precondition until after release 1.
  \item There are usually workarounds: 
  \end{itemize}
 
\end{frame}

\begin{frame}{Refined\_Pre - Example 1}

  \begin{itemize}

    \item SImple case where the preconditions are given in terms of
      functions without postconditions
  \end{itemize}

  \begin{pxcode}[language=SPARK,style=tinystyle,gobble=4]
    package Stacks
    is
       type Stack is private;
 
       function Is_Empty (S : Stack) return Boolean;
       function Is_Full (S : Stack) return Boolean;

       function New_Stack return Stack
       with Post => Is_Empty (New_Stack'Result) and 
                             not Is_Full (New_Stack'Result);

       procedure Push (S : in out Stack; I : in Integer)
          with Depends => (S => S, I),
                  Pre         => not Is_Full (S);

       procedure Pop (S : in out Stack)
          with Depends => (S => S),
                  Pre         => not Is_Emptyl (S);

       function Top (S : Stack) return Integer
           with Pre => not Is_Empty;

    private
        Max_Stack : constant 100;
        type Stack_Pointer is range 0 .. Max_Stack;
        subtype Stack_Index is Stack_Pointer range 1 .. Max_Stack;
        Vector is array (Stack_Index) of Integer; 
        type Stack is record
            P : Stack_Pointer;
            V : Vector;
         end record;
    end Stacks;
          
 \end{pxcode}

\end{frame}

\begin{frame}{Refined\_Pre - Example 1 body}

  \begin{itemize}

    \item The specification (and implementation) of the functions used
      in the preconditions are given as expression functions
    \item The default Refined\_Post condition of an expression
      function is F'Result = <Expression>
   \item The expression can be in terms of the full view of type Stack.
  \end{itemize}

  \begin{pxcode}[language=SPARK,style=tinystyle,gobble=4]
    package Stacks
    is
       type Stack is private;
 
       function Is_Empty (S : Stack) return Boolean is (S.P = 0);
       function Is_Full (S : Stack) return Boolean is (S.P /= Max_Stack);

       function New_Stack return Stack is (Stack'((P => 0, V => (others => 0)));

       procedure Push (S : in out Stack; I : in Integer)
       -- Uses the precondition specified in the visible view
       -- but in terms of the refined postcondition of Is_Full
       is
       begin
          S.P := S.P + 1;
          S.V := I;
       end Push;

       procedure Pop (S : in out Stack)
       -- Uses the precondition specified in the visible view
       -- but in terms of the refined postcondition of Is_Empty
       is
       begin
            S.P := S.P - 1;
       end Pop;

       function Top (S : Stack) return Integer is (S.V (S.P));
       -- Uses the precondition specified in the visible view
       -- but in terms of the refined postcondition of Is_Empty

    end Stacks;          
 \end{pxcode}

\end{frame}

 \begin{frame}{Refined\_Pre - Example 2}

  \begin{itemize}
  \item \emph{include more complex example of work around}
  \end{itemize}
 
\end{frame}

\begin{frame}{Refined\_Pre - Feedback}

  \begin{itemize}
  \item \emph{invite feedback on the impact of no Refined\_Pre - we will email before the call to ask people to think about how they use refinement. This will allow is to gauge the priority for implementation.}
  \end{itemize}
 
\end{frame}

\begin{frame}{Externals - Overview}

  \begin{itemize}
  \item In Ada interfacing to an external device or subsystem normally
    entails using one or more volatile variables to ensure that writes
    and reads to the device are not optimised by the compiler into
    internal register reads and writes.
  \item Ada also has the concept of \emph {external readers} and \emph
    {external writers} to represent external entities reading or
    writing to the program through volatlie variables
 \item In SPARK we are specifically concerned with asynchronous
   external readers and writers - ones we essentially have no direct
   control over when they read or write and object.
  \item We use the concept of an asynchronous writer to represent an
    external entity writing to the program, an external input; and
 \item the concept of an asychronous reader to represent an external
   entity reading from the progra, an external output
 \item Unlike SPARK 2005 an external object may be both an input and
   an output
 \item A state abstraction representing one or more volatile objects
   is called an \emph {External} state abstraction.  
  \end{itemize}
 
\end{frame}

\begin{frame}{Externals - Language Definition}

  \begin{itemize}
  \item We introduce four new Boolean aspects:
    \begin{itemize}
    \item Async_Writers
    \item Async_Readers
    \item Read_Only
    \item Write_Only
    \end{itemize}
  \item These aspects may be applied to volatile object declarations
  \item Async_Writers and Async_Readers may also be applied to an
    External state abstraction
  \end{itemize}
 
\end{frame}

\begin{frame}{Externals - Phasing}

  \begin{itemize}
  \item \emph{Describe the proposed phased introduction as discussed in the LRM call (we need to validate implementation timescales first)}
  \end{itemize}
 
\end{frame}

\begin{frame}{Externals - Feedback}

  \begin{itemize}
  \item \emph{invite feedback on the proposed phasing of support for Externals}
  \end{itemize}
 
\end{frame}

\begin{frame}{Early Preview Release}

  \begin{itemize}
  \item \emph{reminder of how to request/access wavefronts}
  \end{itemize}
 
\end{frame}

\begin{frame}{Demo}

  \begin{itemize}
  \item \emph{linear search example/demo as written by Yannick for Hi-Lite}
  \end{itemize}
 
\end{frame}

\begin{frame}{Conclusion}

  \begin{itemize}

  \item Key dates: 
    \begin{itemize}
    \item News email 4 - \emph{date}
    \item Teleconference 3 - \emph{date}
    \item Preview Release Tutorial - October/November 2013
    \end{itemize}

  \item AOB

  \end{itemize}

\end{frame}

\end{document}


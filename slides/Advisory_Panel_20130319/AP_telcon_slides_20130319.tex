\documentclass{beamer}
\input{praxis-beamer}

\usepackage{tikz}
\usetikzlibrary{positioning,calc}

\title{SPARK 2014 Advisory Panel}
\subtitle{Teleconference 1}

% Inspired by http://tex.stackexchange.com/questions/15237
\makeatletter
\newenvironment{btHighlight}[1][]
{\begingroup\tikzset{bt@Highlight@par/.style={#1}}\begin{lrbox}{\@tempboxa}}
{\end{lrbox}\bt@HL@box[bt@Highlight@par]{\@tempboxa}\endgroup}

\newcommand\btHL[1][]{%
  \begin{btHighlight}[#1]\bgroup\aftergroup\bt@HL@endenv%
}
\def\bt@HL@endenv{%
  \end{btHighlight}%
  \egroup
}
\newcommand{\bt@HL@box}[2][]{%
  \tikz[remember picture]{%
    \pgfpathrectangle{\pgfpoint{1pt}{0pt}}{\pgfpoint{\wd #2}{\ht #2}}%
    \pgfusepath{use as bounding box}%
    \node[anchor=base west,%
          outer sep=0pt,%
          inner xsep=1pt,%
          inner ysep=0pt,%
          rounded corners=2pt,%
          minimum height=\ht\strutbox+1pt,%
          #1]%
          {%
            \raisebox{1pt}{\strut}\strut\usebox{#2}%
          };%
  }%
}
\makeatother

\begin{document}

\begin{altrantitle}
\titleprismlabela{SPARK 2014}
\titleprismlabelb{High Assurance by Design}
\titleprismlabelc{
  \resizebox{4cm}{!}{
    \includegraphics{partnership.pdf}
  }
}
\end{altrantitle}

\begin{frame}{Introduction}

  \begin{itemize}

  \item \emph{round-table introductions}
  \item \emph{agenda ...}

  \end{itemize}

  \end{frame}

\begin{frame}{Progress Update}

  \begin{itemize}

  \item \emph{General progress update}
  \item \emph{Highlight on a key area eg. improved flow error visualisation}

  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Progress Update - Flow Analysis}

  \lstdefinestyle{magic}{
    basicstyle=\tiny\tt,
    keywordstyle=\color{AnColour02},
    moredelim=**[is][{\btHL[fill=AnSecondaryRed!50,name=error]}]{`}{`},
    moredelim=**[is][{\btHL[fill=AnSecondaryYellow!50]}]{@}{@},
  }

  The new flow analysis allows for \structure{better error
    explanations} using program slices.

  \vskip 0.5cm

  \begin{onlyenv}<1>
  \begin{pxcode}[language=SPARK,style=magic,gobble=4]
    procedure Extra_Dep (A, B, C :     Integer;
                         X, Y    : out Integer)
      with Depends => (X => (A, B),
                       Y => (B, C));
  \end{pxcode}
  \end{onlyenv}

  \begin{onlyenv}<2->
  \begin{pxcode}[language=SPARK,style=magic,gobble=4]
    procedure Extra_Dep (A, B, C :     Integer;
                         X, Y    : out Integer)
      with Depends => (`X => (A, B)`,
                       Y => (B, C));
  \end{pxcode}
  \end{onlyenv}

  \begin{onlyenv}<1-2>
  \begin{pxcode}[language=SPARK,style=magic,gobble=4]
    procedure Extra_Dep (A, B, C :     Integer;
                         X, Y    : out Integer)
    is
    begin
       X := A + B;
       Y := B;
       if C > 0 then
          Y := 0;
       else
          X := 0;
       end if;
    end Extra_Dep;
  \end{pxcode}
  \end{onlyenv}

  \begin{onlyenv}<3>
  \begin{pxcode}[language=SPARK,style=magic,gobble=4]
    procedure Extra_Dep (A, B, C :     Integer;
                         X, Y    : out Integer)
    is
    begin
       X := A + B;
       Y := B;
       @if C > 0 then@
          Y := 0;
       else
          @X := 0;@
       end if;
    end Extra_Dep;
  \end{pxcode}
  \end{onlyenv}

  \begin{tikzpicture}[remember picture, overlay]
    \node<2-> (error_string)
      at ($(error) + (6cm, 0cm)$) {``X'' depends on ``C''};

    \draw<2->[->,black,shorten >=5pt] (error_string) -- (error);

    \node<3->[text width=7cm,anchor=west] (error_string)
      at (3cm, 1.5cm) {
        the reason shown in GPS, highlighting the indirect control
        dependency on C
      };

  \end{tikzpicture}

\end{frame}

\begin{frame}[fragile]{Progress Update - Flow Analysis}

  \lstdefinestyle{magic}{
    basicstyle=\tiny\tt,
    keywordstyle=\color{AnColour02},
    moredelim=**[is][{\btHL[fill=AnSecondaryRed!50,name=error2]}]{`}{`},
    moredelim=**[is][{\btHL[fill=AnSecondaryYellow!50]}]{@}{@},
  }

  The new flow analysis also supports a \structure{larger language
    subset}, for example early returns.

  \vskip 0.5cm

  \begin{pxcode}[language=SPARK,style=magic,gobble=4]
    procedure Output_Not_Set (A : Boolean; `X : out Integer`)
    is
    begin
       @if A then@
          @return;@
       end if;
       X := 12;
    end Output_Not_Set;
  \end{pxcode}

  \begin{tikzpicture}[remember picture, overlay]
    \node(error2_string)
      at ($(error2) + (1cm, -2cm)$) {formal parameter ``X'' might not be set};

    \draw[->,black,shorten >=5pt] (error2_string) -- (error2);

    \node[text width=7cm,anchor=west] (explanation2)
      at (2cm, -1cm) {
        the reason shown in GPS, highlighting a path where X is not set
      };

    \draw[->] (explanation2) -| (-0.4cm, 1.6cm) -- (-0.2cm, 1.6cm);

  \end{tikzpicture}

\end{frame}


\begin{frame}{LRM Review Comments}

  \begin{itemize}

  \item \emph{process - we will respond to all comments}
  \item \emph{the following slides highlight a few key themes ...}

  \end{itemize}

\end{frame}

\begin{frame}{SPARK 2014 Portability}

  \begin{itemize}
  \item SPARK 2014 will retain the property of compiler portability

  \item LRM Release 0.2 defines contracts in terms of Ada 2012 'aspects'

  \item Direct use of the new aspects requires an Ada 2012 compiler which supports them in a way consistent with the definition given in the LRM

    \begin{itemize}
    \item The GNAT implementation is one such compiler
    \item In practice, we would expect other Ada 2012 compilers to recognize the extra ascpects --- or at least ignore them
    \end{itemize}

\end{itemize}

\end{frame}

\begin{frame}{SPARK 2014 Portability cont.}

  \begin{itemize}
  \item In addition, SPARK 2014 will have a pragma version of each contract:

    \begin{itemize}
    \item Allows a SPARK 2014 program to be compiled by and executed by \emph{any} Ada 2012 implementation

    \item ''If an implementation does not recognize the name of a pragma, then it has no effect on the semantics of the program.'' [Ada RM, Sec 2.8, Rule 11]

    \item (The pragma versions of the contracts are still a 'ToDo' at this release of the document.)

    \end{itemize}

  \item \emph{Do we also want to mention the use case of using an Ada 2005 compiler with SPARK 2014?}

\end{itemize}

\end{frame}

\begin{frame}{Access Types}

  \begin{itemize}
  \item Access types are excluded from SPARK 2014 (to avoid aliasing)
  \item We have been asked about the possible use of access types for handling collections of indefinite objects
  \item Instead of this, in SPARK 2014 you can ...

    \begin{itemize}
    \item have a (possibly generic) unit My\_collection, with private type T implementing the collection, with spec in SPARK, but body in full Ada
    \item either specify the API through Pre/Post, or
    \item in future, specify a model in Why for the unit (what we currently
      do for formal containers)
    \end{itemize}

  \end{itemize}

\end{frame}

\begin{frame}{Other Topics}

  \begin{itemize}

  \item Translator/Migration to SPARK 2014
  \item Profiles
  \item Integrity Contracts

  \end{itemize}

\end{frame}

\begin{frame}{Translator/Migration to SPARK 2014}

  \begin{itemize}

  \item \emph{outline our current position - a migration guide and service but no supported tool}
  \item \emph{how do people envisage migrating to SPARK 2014 - will this meet their needs?}

  \end{itemize}

\end{frame}

\begin{frame}{Profiles - Potential Goals}

  \begin{itemize}

  \item Simplicity (of formal definition; ease of use; good practice).

  \item Bounded space and time requirements.

  \item Run-time footprint.

  \item Domain needs.

  \end{itemize}

\end{frame}

\begin{frame}{Profiles - Strict (Bounded Space and Time)}

  \begin{itemize}

  \item No recursion.

  \item All constraints on subtypes shall be statically determinable
        (i.e. no dynamic subtypes).

  \item It is not possible to complete a deferred constant by a pragma Import.

  \end{itemize}
\end{frame}

\begin{frame}{Profiles - Strict (Simplicity)}

  \begin{itemize}

  \item Public children cannot see private siblings.

  \item During package initialization, user-defined subprograms cannot be called.
        \emph{Related to modular analysis}

  \item During package initialization, no variable declared within another package
        can be read or updated. \emph{Related to modular analysis}

  \item No generics.

  \item A formal parameter cannot have a default expression/no
        default initializations for record components.

  \item No use clauses.

  \item No renaming.

  \end{itemize}
\end{frame}

\begin{frame}{Profiles - Strict (Simplicity)}

  \begin{itemize}

  \item User-defined operators are not permitted.

  \item No slices.

  \item The last statement in a function subprogram shall be a return statement
        (and no other occurrences of return statements are allowed).

  \item At most one tagged type or type extension declared in any package.

  \item No anonymous subtypes.

  \item No discriminated/variant records.

  \item No dynamic dispatching.

  \end{itemize}

\end{frame}

\begin{frame}{Integrity Contracts}

  \begin{itemize}

  \item \emph{SM to add description of integrity contracts}

  \end{itemize}

\end{frame}

\begin{frame}{Conclusion}

  \begin{itemize}

  \item Feedback - what do you want from future news emails and conferences?
  \item Key dates: next LRM release; next teleconference
  \item AOB

  \end{itemize}

\end{frame}

\end{document}


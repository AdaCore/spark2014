module Main
  use import int.Int
  use int.Abs as AbsInt
  use int.ComputerDivision
  use real.Real
  use export real.RealInfix
  use real.Abs as AbsReal
  use real.Square as SquareReal
  use real.Trigonometry
  use bool.Bool
  use floating_point.Rounding
  use floating_point.Single
  use floating_point.Double
  use import module ref.Ref

  exception Gnatprove_Exception___result_exc
  
  type t__ada_array 'a
  
  function t__ada_array___access int (t__ada_array 'a1) : 'a1
  
  function t__ada_array___update int (t__ada_array 'a1) 'a1 : (t__ada_array 'a1)
  
  function t__ada_array___attr___ATTRIBUTE_LENGTH (t__ada_array 'a1) : int
  
  function t__ada_array___attr___ATTRIBUTE_FIRST (t__ada_array 'a1) : int
  
  function t__ada_array___attr___ATTRIBUTE_LAST (t__ada_array 'a1) : int

val t__ada_array___access_ :
 i : int -> a : t__ada_array 'a ->
{ (t__ada_array___attr___ATTRIBUTE_FIRST a) <= i <= (t__ada_array___attr___ATTRIBUTE_LAST a) }'a
 { result = t__ada_array___access i a }

val t__ada_array___update_ :
 i : int -> a : t__ada_array 'a -> v : 'a ->
{ t__ada_array___attr___ATTRIBUTE_FIRST (a) <= i <= t__ada_array___attr___ATTRIBUTE_LAST (a) } t__ada_array 'a
 { result = t__ada_array___update i a v }
  
  axiom T__ada_array___accupd_eq:
    (forall a:(t__ada_array 'a1).
      (forall i:int.
        (forall v:'a1 [(t__ada_array___update i a v : (t__ada_array 'a1))].
          ((t__ada_array___access i (t__ada_array___update i a v : (t__ada_array 'a1)) : 'a1) = v))))
  
  axiom T__ada_array___accupd_neq:
    (forall a:(t__ada_array 'a1).
      (forall i:int.
        (forall j:int.
          (forall v:'a1 [(t__ada_array___access j (t__ada_array___update i a v : (t__ada_array 'a1)) : 'a1)|
            (t__ada_array___update i a v : (t__ada_array 'a1)),
            (t__ada_array___access j a : 'a1)].
            ((i <> j) ->
             ((t__ada_array___access j (t__ada_array___update i a v : (t__ada_array 'a1)) : 'a1) = (t__ada_array___access j a : 'a1)))))))
  
  axiom T__ada_array___first_update:
    (forall a:(t__ada_array 'a1).
      (forall i:int.
        (forall v:'a1.
          ((t__ada_array___attr___ATTRIBUTE_FIRST a : int) = (t__ada_array___attr___ATTRIBUTE_FIRST (t__ada_array___update i a v : (t__ada_array 'a1)) : int)))))
  
  axiom T__ada_array___last_update:
    (forall a:(t__ada_array 'a1).
      (forall i:int.
        (forall v:'a1.
          ((t__ada_array___attr___ATTRIBUTE_LAST a : int) = (t__ada_array___attr___ATTRIBUTE_LAST (t__ada_array___update i a v : (t__ada_array 'a1)) : int)))))
  
  axiom T__ada_array___length_update:
    (forall a:(t__ada_array 'a1).
      (forall i:int.
        (forall v:'a1.
          ((t__ada_array___attr___ATTRIBUTE_LENGTH a : int) = (t__ada_array___attr___ATTRIBUTE_LENGTH (t__ada_array___update i a v : (t__ada_array 'a1)) : int)))))
  
  axiom T__ada_array___length_non_zero:
    (forall a:(t__ada_array 'a1).
      ((Int.(>=) (t__ada_array___attr___ATTRIBUTE_LAST a : int) (t__ada_array___attr___ATTRIBUTE_FIRST a : int)) ->
       ((t__ada_array___attr___ATTRIBUTE_LENGTH a : int) = (Int.(+) (Int.(-) (t__ada_array___attr___ATTRIBUTE_LAST a : int) (t__ada_array___attr___ATTRIBUTE_FIRST a : int) : int) 1 : int))))
  
  axiom T__ada_array___length_zero:
    (forall a:(t__ada_array 'a1).
      ((Int.(<) (t__ada_array___attr___ATTRIBUTE_LAST a : int) (t__ada_array___attr___ATTRIBUTE_FIRST a : int)) ->
       ((t__ada_array___attr___ATTRIBUTE_LENGTH a : int) = 0)))
  
  type standard___heap_type
  
  val __HEAP : ref standard___heap_type
  
  function bool_int__eq int int : Bool.bool
  
  axiom Bool_int__eq_axiom:
    (forall x:int.
      (forall y:int.
        ((((bool_int__eq x y : Bool.bool) = Bool.True) -> (x = y)) /\
         (((bool_int__eq x y : Bool.bool) = Bool.False) -> (not (x = y))))))
  
  function bool_int__ne int int : Bool.bool
  
  axiom Bool_int__ne_axiom:
    (forall x:int.
      (forall y:int.
        ((((bool_int__ne x y : Bool.bool) = Bool.True) -> (x <> y)) /\
         (((bool_int__ne x y : Bool.bool) = Bool.False) -> (not (x <> y))))))
  
  function bool_int__lt int int : Bool.bool
  
  axiom Bool_int__lt_axiom:
    (forall x:int.
      (forall y:int.
        ((((bool_int__lt x y : Bool.bool) = Bool.True) -> (Int.(<) x y)) /\
         (((bool_int__lt x y : Bool.bool) = Bool.False) ->
          (not (Int.(<) x y))))))
  
  function bool_int__le int int : Bool.bool
  
  axiom Bool_int__le_axiom:
    (forall x:int.
      (forall y:int.
        ((((bool_int__le x y : Bool.bool) = Bool.True) -> (Int.(<=) x y)) /\
         (((bool_int__le x y : Bool.bool) = Bool.False) ->
          (not (Int.(<=) x y))))))
  
  function bool_int__gt int int : Bool.bool
  
  axiom Bool_int__gt_axiom:
    (forall x:int.
      (forall y:int.
        ((((bool_int__gt x y : Bool.bool) = Bool.True) -> (Int.(>) x y)) /\
         (((bool_int__gt x y : Bool.bool) = Bool.False) ->
          (not (Int.(>) x y))))))
  
  function bool_int__ge int int : Bool.bool
  
  axiom Bool_int__ge_axiom:
    (forall x:int.
      (forall y:int.
        ((((bool_int__ge x y : Bool.bool) = Bool.True) -> (Int.(>=) x y)) /\
         (((bool_int__ge x y : Bool.bool) = Bool.False) ->
          (not (Int.(>=) x y))))))
  
  function ___ignore 'a1 : ()
  
  function lt_int_bool int int : Bool.bool
  
  function le_int_bool int int : Bool.bool
  
  function gt_int_bool int int : Bool.bool
  
  function ge_int_bool int int : Bool.bool
  
  function eq_int_bool int int : Bool.bool
  
  function neq_int_bool int int : Bool.bool
  
  axiom Lt_int_bool_axiom:
    (forall x:int.
      (forall y:int.
        (((lt_int_bool x y : Bool.bool) = Bool.True) <-> (Int.(<) x y))))
  
  axiom Le_int_bool_axiom:
    (forall x:int.
      (forall y:int.
        (((le_int_bool x y : Bool.bool) = Bool.True) <-> (Int.(<=) x y))))
  
  axiom Gt_int_bool_axiom:
    (forall x:int.
      (forall y:int.
        (((gt_int_bool x y : Bool.bool) = Bool.True) <-> (Int.(>) x y))))
  
  axiom Ge_int_bool_axiom:
    (forall x:int.
      (forall y:int.
        (((ge_int_bool x y : Bool.bool) = Bool.True) <-> (Int.(>=) x y))))
  
  axiom Eq_int_bool_axiom:
    (forall x:int.
      (forall y:int.
        (((eq_int_bool x y : Bool.bool) = Bool.True) <-> (x = y))))
  
  axiom Neq_int_bool_axiom:
    (forall x:int.
      (forall y:int.
        (((neq_int_bool x y : Bool.bool) = Bool.True) <-> (x <> y))))
  
  function abs_int int : int
  
  axiom Abs_int_pos:
    (forall x:int. ((Int.(>=) x 0) -> ((AbsInt.abs x : int) = x)))
  
  axiom Abs_int_neg:
    (forall x:int.
      ((Int.(<=) x 0) -> ((AbsInt.abs x : int) = (Int.(-_) x : int))))
  
  function int_max int int : int
  
  function int_min int int : int
  
  axiom Int_max_is_ge:
    (forall x:int.
      (forall y:int.
        ((Int.(>=) (int_max x y : int) x) /\
         (Int.(>=) (int_max x y : int) y))))
  
  axiom Int_max_is_some:
    (forall x:int.
      (forall y:int.
        (((int_max x y : int) = x) \/ ((int_max x y : int) = y))))
  
  axiom Int_min_is_le:
    (forall x:int.
      (forall y:int.
        ((Int.(<=) (int_min x y : int) x) /\
         (Int.(<=) (int_min x y : int) y))))
  
  axiom Int_min_is_some:
    (forall x:int.
      (forall y:int.
        (((int_min x y : int) = x) \/ ((int_min x y : int) = y))))
  
  function computer_div int int : int
  
  function computer_mod int int : int
  
  function math_div int int : int
  
  function math_mod int int : int
  
  axiom Math_div_mod:
    (forall x:int.
      (forall y:int.
        ((y <> 0) ->
         (x = (Int.(+) (Int.(*) y (math_div x y : int) : int) (math_mod x y : int) : int)))))
  
  axiom Math_mod_bound:
    (forall x:int.
      (forall y:int.
        ((y <> 0) ->
         ((Int.(<=) 0 (math_mod x y : int)) /\
          (Int.(<) (math_mod x y : int) (AbsInt.abs y : int))))))
  
  axiom Computer_div_mod:
    (forall x:int.
      (forall y:int [(ComputerDivision.div x y : int),
        (ComputerDivision.mod x y : int)].
        ((y <> 0) ->
         (x = (Int.(+) (Int.(*) y (ComputerDivision.div x y : int) : int) (ComputerDivision.mod x y : int) : int)))))
  
  axiom Computer_div_bound:
    (forall x:int.
      (forall y:int.
        (((Int.(>=) x 0) /\ (Int.(>) y 0)) ->
         ((Int.(<=) 0 (ComputerDivision.div x y : int)) /\
          (Int.(<=) (ComputerDivision.div x y : int) x)))))
  
  axiom Computer_mod_bound:
    (forall x:int.
      (forall y:int.
        ((y <> 0) ->
         (Int.(<) (AbsInt.abs (ComputerDivision.mod x y : int) : int) (AbsInt.abs y : int)))))
  
  axiom Computer_mod_sign_pos:
    (forall x:int.
      (forall y:int.
        (((Int.(>=) x 0) /\ (y <> 0)) ->
         (Int.(>=) (ComputerDivision.mod x y : int) 0))))
  
  axiom Computer_mod_sign_neg:
    (forall x:int.
      (forall y:int.
        (((Int.(<=) x 0) /\ (y <> 0)) ->
         (Int.(<=) (ComputerDivision.mod x y : int) 0))))
  
  axiom Computer_rounds_toward_zero:
    (forall x:int.
      (forall y:int.
        ((y <> 0) ->
         (Int.(<=) (AbsInt.abs (Int.(*) (ComputerDivision.div x y : int) y : int) : int) (AbsInt.abs x : int)))))
  
  function bool_and Bool.bool Bool.bool : Bool.bool
  
  function bool_or Bool.bool Bool.bool : Bool.bool
  
  function bool_xor Bool.bool Bool.bool : Bool.bool
  
  function bool_not Bool.bool : Bool.bool
  
  axiom Bool_and_def:
    (forall a:Bool.bool.
      (forall b:Bool.bool.
        (((bool_and a b : Bool.bool) = Bool.True) <->
         ((a = Bool.True) /\ (b = Bool.True)))))
  
  axiom Bool_or_def:
    (forall a:Bool.bool.
      (forall b:Bool.bool.
        (((bool_or a b : Bool.bool) = Bool.True) <->
         ((a = Bool.True) \/ (b = Bool.True)))))
  
  axiom Bool_xor_def:
    (forall a:Bool.bool.
      (forall b:Bool.bool.
        (((bool_xor a b : Bool.bool) = Bool.True) <-> (a <> b))))
  
  axiom Bool_not_def:
    (forall a:Bool.bool.
      (((bool_not a : Bool.bool) = Bool.True) <-> (a = Bool.False)))
  
  function ite Bool.bool 'a1 'a1 : 'a1
  
  axiom Ite_true:
    (forall x:'a1. (forall y:'a1. ((ite Bool.True x y : 'a1) = x)))
  
  axiom Ite_false:
    (forall x:'a1. (forall y:'a1. ((ite Bool.False x y : 'a1) = y)))

  function int_of_bool (b : Bool.bool) : int =
   if b = True then 1 else 0
  
  function div_real (x : real) (y : real) : real = x /. y
  
  val computer_div_ : x:int -> y:int ->
    { y<>0 } int { result = computer_div x y }
end


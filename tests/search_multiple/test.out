------------------------------------------------------------------------
with Search;use type Search.IntArray; 
--@ line 1
--# inherit search;
package External_Search
is

  procedure Linear_Search
    (Table  : in Search.IntArray
--@ line 6
                         ;
     Value1 : in Integer;
     Value2 : in Integer;
     Found1 : out Boolean;
     Found2 : out Boolean;
     Index1 : out Integer;
     Index2 : out Integer);
  --# post (            not Found1 or else Table(Index1) = Value1
  --# ) and (           not Found2 or else Table(Index2) = Value2);

  function Check_Index
    (Table  : Search.IntArray
--@ line 17
                      ;
     Value1 : Integer;
     Value2 : Integer;
     Index1 : Integer;
     Index2 : Integer) return Boolean;
  --# pre (            Table'First <= Index1 and then Index1 <= Table'Last
  --# ) and (          Table'First <= Index2 and then Index2 <= Table'Last);
  --# return Result =>  Result             = (Table(Index1) = Value1 and then
  --#                                           Table(Index2) = Value2);
end External_Search;
with Search;use type Search.IntArray; with External_Search;
--@ line 1
--# inherit external_search, search;
--@ line 1
package Internal_Search
--@ line 1
               is



  procedure Linear_Search
    (Table  : in Search.IntArray
--@ line 6
                         ;
     Value1 : in Integer;
     Value2 : in Integer;
     Found1 : out Boolean;
     Found2 : out Boolean;
     Index1 : out Integer;
     Index2 : out Integer);
  --# post (            not Found1 or else Table(Index1) = Value1
  --# ) and (           not Found2 or else Table(Index2) = Value2);

  function Check_Index
    (Table  : Search.IntArray
--@ line 17
                      ;
     Value1 : Integer;
     Value2 : Integer;
     Index1 : Integer;
     Index2 : Integer) return Boolean;
  --# pre (            Table'First <= Index1 and then Index1 <= Table'Last
  --# ) and (          Table'First <= Index2 and then Index2 <= Table'Last);
  --# return Result =>  Result             = (Table(Index1) = Value1 and then
  --#                                           Table(Index2) = Value2);

end Internal_Search;
package Search
is
  type IntArray is array (Integer range <>) of Integer;
end Search;
package body Internal_Search
--@ line 1
                    is

  procedure Linear_Search
    (Table  : in Search.IntArray
--@ line 4
                         ;
     Value1 : in Integer;
     Value2 : in Integer;
     Found1 : out Boolean;
     Found2 : out Boolean;
     Index1 : out Integer;
     Index2 : out Integer)
  is
     Found : Natural := 0;
  begin
     Found1 := False;
     Index1 := 0;
     Found2 := False;
     Index2 := 0;

     for I in Integer range Table'Range loop
        --# assert (   (Found = 0 and not Found1 and not Found2) or else
        --#            (Found = 1 and (Found1 or Found2)) or else
        --#            (Found = 2 and Found1 and Found2)
        --# ) and (    Found1 = False or else Found2 = False
        --# ) and (    not Found1 or else Table(Index1) = Value1
        --# ) and (    not Found2 or else Table(Index2) = Value2
        --# ) and (    Found < 2);
        if not Found1 and then Table(I) = Value1 then
           Found1 := True;
           Index1 := I;
           Found := Found + 1;
           --# check      Found1 and then Index1 = I;
           --# check      Found <= 2;
        end if;
        if not Found2 and then Table(I) = Value2 then
           Found2 := True;
           Index2 := I;
           Found := Found + 1;
           --# check      Found2 and then Index2 = I;
           --# check      Found <= 2;
        end if;
        exit when Found = 2;
     end loop;
  end Linear_Search;

  function Check_Index
    (Table  : Search.IntArray
--@ line 46
                      ;
     Value1 : Integer;
     Value2 : Integer;
     Index1 : Integer;
     Index2 : Integer) return Boolean
  is
  begin
     return Table(Index1) = Value1 and then Table(Index2) = Value2;
  end Check_Index;

end Internal_Search;
------------------------------------------------------------------------
                     Total  Examiner Simp(U/R)  Checker Review False Undiscgd
Assert or Post:         14      0     14              0      0      0       0
Precondition check:      0      0      0              0      0      0       0
Check statement:         6      0      6              0      0      0       0
Runtime check:          13      0     13              0      0      0       0
Refinement VCs:          0      0      0              0      0      0       0
Inheritance VCs:         0      0      0              0      0      0       0
===============================================================================
Totals:                 33      0     33              0      0      0       0
% Totals:                       0%   100%             0%     0%     0%      0%
===================== End of Semantic Analysis Summary ========================

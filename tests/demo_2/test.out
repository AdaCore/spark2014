------------------------------------------------------------------------
package ADT_Stack
is
pragma Elaborate_Body (ADT_Stack);
--@ line 24
   Stack_Size : constant := 100;
   subtype Stack_Range is  Integer range 0 .. Stack_Size;
   subtype New_Name_1 is Stack_Range range 
--@ line 26
                        1 .. Stack_Range'Last;
--@ line 26
   type Vector is array (New_Name_1) of Integer;
   type Stack is tagged
      record
         STack_Vector  : Vector;
         STack_Top : Stack_Range;
      end record;
end ADT_Stack;
with ADT_Stack;use type ADT_Stack.Vector; 
use type ADT_Stack.Stack; 
--@ line 1
-- This specification is a implementation of a Stack ADT (Abstract Data Type)
-- An ADT defines a set of objects, with a set of operations that characterize
-- the behaviour of those object. Khown well on the name OOP.

--# inherit adt_stack;
package External_ADT_Stack
is


   function Is_Empty(S : ADT_Stack.Stack
--@ line 10
                              ) return Boolean;
   function Is_Full(S : ADT_Stack.Stack
--@ line 11
                             ) return Boolean;

   procedure Clear(S : out ADT_Stack.Stack
--@ line 13
                                );
   --# post              Is_Empty(S => 
   --# --@ line 14
   --#                             S);

   procedure Push(S : in out ADT_Stack.Stack
--@ line 16
                                  ; X : in Integer);
   --# pre              not Is_Full(S => 
   --# --@ line 17
   --#                               S);

   procedure Pop(S : in out ADT_Stack.Stack
--@ line 19
                                 ; X : out Integer);
   --# pre              not Is_Empty(S => 
   --# --@ line 20
   --#                                S);



   Stack_Size : constant := 100;
end External_ADT_Stack;
with ADT_Stack;use type ADT_Stack.Vector; 
use type ADT_Stack.Stack; 
with External_ADT_Stack;
--@ line 1
-- This specification is a implementation of a Stack ADT (Abstract Data Type)
-- An ADT defines a set of objects, with a set of operations that characterize
-- the behaviour of those object. Khown well on the name OOP.

--# inherit adt_stack, external_adt_stack;
package Internal_ADT_Stack
--@ line 6
                  is

                                 -- tagged for extension in child package

   function Is_Empty(S : ADT_Stack.Stack
--@ line 10
                              ) return Boolean;
   function Is_Full(S : ADT_Stack.Stack
--@ line 11
                             ) return Boolean;

   procedure Clear(S : out ADT_Stack.Stack
--@ line 13
                                );
   --# post              External_ADT_Stack.Is_Empty(S => 
   --# --@ line 14
   --#                             S);

   procedure Push(S : in out ADT_Stack.Stack
--@ line 16
                                  ; X : in Integer);
   --# pre              not External_ADT_Stack.Is_Full(S => 
   --# --@ line 17
   --#                               S);

   procedure Pop(S : in out ADT_Stack.Stack
--@ line 19
                                 ; X : out Integer);
   --# pre              not External_ADT_Stack.Is_Empty(S => 
   --# --@ line 20
   --#                                S);

--  full details of the type Stack
private
   Stack_Size : constant := 100;
                                                          -- derived type
                                                           --  anonymous type
--@ line 33
end Internal_ADT_Stack;
--@ line 33
     -- Not necessary to repeat the name of package,it can be generated
package body Internal_ADT_Stack
is

   function Is_Empty(S : ADT_Stack.Stack
--@ line 4
                              ) return Boolean
   is
      -- pragma Postcondition (Is_Empty'Result = (S.Stack_Top = 0));
   begin
      return S.Stack_Top = 0;
   end Is_Empty;
--@ line 9
        -- the name of subprograms can be generated if missing

   function Is_Full(S : ADT_Stack.Stack
--@ line 11
                             ) return Boolean
   is
      -- pragma Postcondition (Is_Full'Result = (S.Stack_Top = Stack_Size));
   begin
      return S.Stack_Top = ADT_Stack.Stack_Size
--@ line 15
                                     ;
   end Is_Full;

   procedure Clear(S : out ADT_Stack.Stack
--@ line 18
                                )
   is
   begin
      S.Stack_Top :=0;
      S.Stack_Vector := ADT_Stack.Vector'
--@ line 22
                        (others => 0); -- The aggregat must be qualified
   end Clear;

   procedure Push(S : in out ADT_Stack.Stack
--@ line 25
                                  ; X : in Integer)
   is
   begin
      S.Stack_Top :=S.Stack_Top + 1;
      S.Stack_Vector(S.Stack_Top) := X;
   end Push;

   procedure Pop(S : in out ADT_Stack.Stack
--@ line 32
                                 ; X : out Integer)
   is
   begin
      X := S.Stack_Vector(S.Stack_Top);
      S.Stack_Top :=S.Stack_Top - 1;
   end Pop;

end Internal_ADT_Stack;
------------------------------------------------------------------------
                     Total  Examiner Simp(U/R)  Checker Review False Undiscgd
Assert or Post:          5      4      1(   1)        0      0      0       0
Precondition check:      0      0      0              0      0      0       0
Check statement:         0      0      0              0      0      0       0
Runtime check:           6      0      5(   1)        0      0      0       1
Refinement VCs:          0      0      0              0      0      0       0
Inheritance VCs:         0      0      0              0      0      0       0
===============================================================================
Totals:                 11      4      6(   2)        0      0      0       1  <<<
% Totals:                      36%    55%(  18%)      0%     0%     0%      9% <<<
===================== End of Semantic Analysis Summary ========================

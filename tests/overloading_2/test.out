------------------------------------------------------------------------
with Overloading;
--@ line 1
--# inherit overloading;
package External_Overloading
is
--@ line 3
   function Sign (X: Integer) return Integer;
   function Sign1
--@ line 4
                 (X: Float) return Integer ;
   function Abs_Add (A, B : in Integer) return Integer;
   function Abs_Add2
--@ line 6
                    (A, B : in Float) return Float;
   procedure Abs_Eval (Eval      : in     Boolean;
                       Var_Int_1 : in out Integer;
                       Var_Int_2 : in out Integer;
                       Var_Re_1  : in out Float;
                       Var_Re_2  : in out Float;
                       Var_Out_1 :    out Integer;
                       Var_Out_2 :    out Float);
end External_Overloading;
with Overloading;with External_Overloading;
--@ line 1
--# inherit overloading, external_overloading;
--@ line 1
package Internal_Overloading
is
   function Sign (X: Integer) return Integer;
   function Sign1
--@ line 4
                 (X: Float) return Integer ;
   function Abs_Add (A, B : in Integer) return Integer;
   function Abs_Add2
--@ line 6
                    (A, B : in Float) return Float;
   procedure Abs_Eval (Eval      : in     Boolean;
                       Var_Int_1 : in out Integer;
                       Var_Int_2 : in out Integer;
                       Var_Re_1  : in out Float;
                       Var_Re_2  : in out Float;
                       Var_Out_1 :    out Integer;
                       Var_Out_2 :    out Float);
end Internal_Overloading;
package Overloading
is
end Overloading;
package body Internal_Overloading
is

   function Sign (X : Integer) return Integer
   is
      V : Integer;
   begin
      if X > 0 then
         V := 1;
      elsif X < 0 then
         V := 2;
      else
         V := 0;
      end if;
      return V;
   end Sign;

   function Sign1
--@ line 18
                 (X : Float) return Integer
   is
      V : Integer;
   begin
      if X > 0.0 then
         V := 1;
      elsif X < 0.0 then
         V := 2;
      else
         V := 0;
      end if;
      return V;
   end Sign1;

   function Abs_Add (A, B : in Integer) return Integer
   is
      V : Integer;
   begin
      if (External_Overloading.Sign
--@ line 36
               (A) = 1) and (External_Overloading.Sign
--@ line 36
                                  (B) = 1) then
         V := A + B;
      elsif (External_Overloading.Sign
--@ line 38
                  (A) = 1) and (External_Overloading.Sign
--@ line 38
                                     (B) = 2) then
         V := A - B;
      elsif (External_Overloading.Sign
--@ line 40
                  (A) = 2) and (External_Overloading.Sign
--@ line 40
                                     (B) = 1) then
         V := B - A;
      else
         V := 0;
      end if;
      return V;
   end Abs_Add;

   function Abs_Add2
--@ line 48
                    (A, B : in Float) return Float
   is
      V : Float;
   begin
      if (External_Overloading.Sign1
--@ line 52
               (A) = 1) and (External_Overloading.Sign1
--@ line 52
                                  (B) = 1) then
         V := A + B;
      elsif (External_Overloading.Sign1
--@ line 54
                  (A) = 1) and (External_Overloading.Sign1
--@ line 54
                                     (B) = 2) then
         V := A - B;
      elsif (External_Overloading.Sign1
--@ line 56
                  (A) = 2) and (External_Overloading.Sign1
--@ line 56
                                     (B) = 1) then
         V := B - A;
      else
         V := 0.0;
      end if;
      return V;
   end Abs_Add2;

   procedure Abs_Eval (Eval      : in  Boolean;
                       Var_Int_1 : in out Integer;
                       Var_Int_2 : in out Integer;
                       Var_Re_1  : in out Float;
                       Var_Re_2  : in out Float;
                       Var_Out_1 :    out Integer;
                       Var_Out_2 :    out Float)
   is
      procedure Abs_Add3
        (A, B : in Integer;
         C    : out Integer)
      is
      begin
         C := A + B;
      end Abs_Add3;
   begin
      if Eval then
         Var_Int_1 := 10;
         Var_Int_2 := -20;
         Var_Re_1  := 10.0;
         Var_Re_2  := -20.0;
         Var_Out_1 := External_Overloading.Abs_Add
--@ line 85
                              (Var_Int_1, Var_Int_2);
         Var_Out_2 := External_Overloading.Abs_Add2
--@ line 86
                              (Var_Re_1, Var_Re_2);
      else
         Abs_Add3
--@ line 88
                 (Var_Int_1, Var_Int_2, Var_Out_1);
         Var_Out_2 := 0.0;
      end if;
   end Abs_Eval;

end Internal_Overloading;
------------------------------------------------------------------------
                     Total  Examiner Simp(U/R)  Checker Review False Undiscgd
Assert or Post:         17      3     14              0      0      0       0
Precondition check:      0      0      0              0      0      0       0
Check statement:         0      0      0              0      0      0       0
Runtime check:          38      0     31              0      0      0       7
Refinement VCs:          0      0      0              0      0      0       0
Inheritance VCs:         0      0      0              0      0      0       0
===============================================================================
Totals:                 55      3     45              0      0      0       7  <<<
% Totals:                       5%    82%             0%     0%     0%     13% <<<
===================== End of Semantic Analysis Summary ========================

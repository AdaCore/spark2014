two_test.ads:5:3: sparkify: discard contract on declaration inside subprogram
two_test.ads:13:3: sparkify: discard contract on declaration inside subprogram
two_test.adb:3:3: sparkify: discard contract on definition of subprogram
two_test.adb:33:3: sparkify: discard contract on definition of subprogram
two_test.ads:5:3: sparkify: discard contract on declaration inside subprogram
two_test.ads:13:3: sparkify: discard contract on declaration inside subprogram
------------------------------------------------------------------------
with Two;use type Two.Index; 
use type Two.Table; 
--@ line 1
--# inherit two;
package External_Two
is
end External_Two;

with Two;use type Two.Index; 
use type Two.Table; 
with Two_Test;
--@ line 2
--# inherit two_test, two;
package External_Two_Test
is
  procedure Linear_Search
    (T     :     Two.Table
--@ line 6
                      ;
     Value : Integer;
     Found : out Boolean;
     I1    : out     Two.Index
--@ line 9
                          ;
     I2    : out     Two.Index
--@ line 10
                          );
  --# post              not Found or else T (I1, I2) = Value;

  function Check_Index
    (T     :     Two.Table
--@ line 14
                      ;
     Value : Integer;
     I1    :     Two.Index
--@ line 16
                      ;
     I2    :     Two.Index
--@ line 17
                      ) return Boolean;
  --# pre              T'First (1) <= I1
  --# 		       and then 
  --# --@ line 19
  --#             		                I1
  --# --@ line 19
  --#                <= 		                      T
  --# --@ line 19
  --#                    'Last
  --# 		       and then 
  --# --@ line 20
  --#             		                T
  --# --@ line 20
  --#              'First (2) <= 		                               I2
  --# 		       and then 
  --# --@ line 21
  --#             		                I2
  --# --@ line 21
  --#                <= 		                      T
  --# --@ line 21
  --#                    'Last (2);
  --# return Result =>  Result             = (T (I1, I2) = Value);
end External_Two_Test;
with Two;use type Two.Index; 
use type Two.Table; 
with External_Two;
--@ line 1
--# inherit external_two, two;
--@ line 1
package Internal_Two
--@ line 1
            is
--@ line 7
end Internal_Two;

with Two;use type Two.Index; 
use type Two.Table; 
with External_Two;
with Two_Test;with External_Two_Test;
--@ line 2
--# inherit external_two_test, external_two, two_test, two;
package Internal_Two_Test
--@ line 3
                 is

  procedure Linear_Search
    (T     :     Two.Table
--@ line 6
                      ;
     Value : Integer;
     Found : out Boolean;
     I1    : out     Two.Index
--@ line 9
                          ;
     I2    : out     Two.Index
--@ line 10
                          );
  --# post              not Found or else T (I1, I2) = Value;

  function Check_Index
    (T     :     Two.Table
--@ line 14
                      ;
     Value : Integer;
     I1    :     Two.Index
--@ line 16
                      ;
     I2    :     Two.Index
--@ line 17
                      ) return Boolean;
  --# pre              T'First (1) <= I1
  --# 		       and then 
  --# --@ line 19
  --#             		                I1
  --# --@ line 19
  --#                <= 		                      T
  --# --@ line 19
  --#                    'Last
  --# 		       and then 
  --# --@ line 20
  --#             		                T
  --# --@ line 20
  --#              'First (2) <= 		                               I2
  --# 		       and then 
  --# --@ line 21
  --#             		                I2
  --# --@ line 21
  --#                <= 		                      T
  --# --@ line 21
  --#                    'Last (2);
  --# return Result =>  Result             = (T (I1, I2) = Value);

end Internal_Two_Test;
package Two
is
pragma Elaborate_Body (Two);
--@ line 3
   type Index is range 1 .. 10;

   type Table is array (Index, Index) of Integer;
end Two;

with Two;use type Two.Index; 
use type Two.Table; 
--@ line 2
--# inherit two;
package Two_Test
is
pragma Elaborate_Body (Two_Test);
end Two_Test;
package body Internal_Two_Test
--@ line 1
                      is

  procedure Linear_Search
    (T     :     Two.Table
--@ line 4
                      ;
     Value : Integer;
     Found : out Boolean;
     I1    : out     Two.Index
--@ line 7
                          ;
     I2    : out     Two.Index
--@ line 8
                          )
  is

  begin
     Found := False;
     I1 :=     Two.Index
--@ line 13
                    'First;
     I2 :=     Two.Index
--@ line 14
                    'First;

     for J1 in Two.Index range 
--@ line 16
               T'Range (1) loop
        --# assert     Found = False;
        for J2 in Two.Index range 
--@ line 18
                  T'Range (2) loop
           --# assert     Found = False;
           if T (J1, J2) = Value then
              Found := True;
              I1 := J1;
              I2 := J2;
              exit;
           end if;
        end loop;
        if Found then
           exit;
        end if;
     end loop;
  end Linear_Search;

  function Check_Index
    (T     :     Two.Table
--@ line 34
                      ;
     Value : Integer;
     I1    :     Two.Index
--@ line 36
                      ;
     I2    :     Two.Index
--@ line 37
                      ) return Boolean
  is

  begin
     return T (I1, I2) = Value;
  end Check_Index;

end Internal_Two_Test;
------------------------------------------------------------------------
                     Total  Examiner Simp(U/R)  Checker Review False Undiscgd
Assert or Post:         10      0     10              0      0      0       0
Precondition check:      0      0      0              0      0      0       0
Check statement:         0      0      0              0      0      0       0
Runtime check:           8      0      8              0      0      0       0
Refinement VCs:          0      0      0              0      0      0       0
Inheritance VCs:         0      0      0              0      0      0       0
===============================================================================
Totals:                 18      0     18              0      0      0       0
% Totals:                       0%   100%             0%     0%     0%      0%
===================== End of Semantic Analysis Summary ========================

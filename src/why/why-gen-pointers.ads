------------------------------------------------------------------------------
--                                                                          --
--                            GNAT2WHY COMPONENTS                           --
--                                                                          --
--                      W H Y - G E N - P O I N T E R S                     --
--                                                                          --
--                                 S p e c                                  --
--                                                                          --
--                     Copyright (C) 2018-2020, AdaCore                     --
--                                                                          --
-- gnat2why is  free  software;  you can redistribute  it and/or  modify it --
-- under terms of the  GNU General Public License as published  by the Free --
-- Software  Foundation;  either version 3,  or (at your option)  any later --
-- version.  gnat2why is distributed  in the hope that  it will be  useful, --
-- but WITHOUT ANY WARRANTY; without even the implied warranty of  MERCHAN- --
-- TABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public --
-- License for  more details.  You should have  received  a copy of the GNU --
-- General  Public License  distributed with  gnat2why;  see file COPYING3. --
-- If not,  go to  http://www.gnu.org/licenses  for a complete  copy of the --
-- license.                                                                 --
--                                                                          --
-- gnat2why is maintained by AdaCore (http://www.adacore.com)               --
--                                                                          --
------------------------------------------------------------------------------

with Gnat2Why.Util;          use Gnat2Why.Util;
with SPARK_Atree;            use SPARK_Atree;
with SPARK_Atree.Entities;   use SPARK_Atree.Entities;
with SPARK_Util.Subprograms; use SPARK_Util.Subprograms;
with SPARK_Util.Types;       use SPARK_Util.Types;
with Types;                  use Types;
with Why.Gen.Binders;        use Why.Gen.Binders;
with Why.Ids;                use Why.Ids;
with Why.Sinfo;              use Why.Sinfo;

package Why.Gen.Pointers is
   --  This package encapsulates the encoding of access types into Why.

   procedure Declare_Rep_Pointer_Compl_If_Needed
     (P : W_Section_Id; E : Entity_Id)
   with
     Pre => Is_Access_Type (E) and then Designates_Incomplete_Type (E);
   --  Declare a new module for completion of access types designating
   --  incomplete types.

   procedure Declare_Ada_Pointer (P : W_Section_Id; E : Entity_Id)
   with Pre => Is_Access_Type (E);
   --  Emit all necessary Why3 declarations to support Ada pointers.
   --  @param P the Why section to insert the declaration
   --  @param E the type entity to translate

   procedure Create_Rep_Pointer_Theory_If_Needed
     (P : W_Section_Id;
      E : Entity_Id);
   --  Similar to Create_Rep_Record_Theory_If_Needed but handles objects of
   --  access type. It declares a pointer type as a why record with three
   --  fields: pointer_address, is_null_pointer, and pointer_address.
   --  It also defines the needed functions to manipulate this type.

   function Move_Param_Item
     (Typ : Entity_Id) return Item_Type
   with Pre => Is_Deep (Typ) and then Is_Composite_Type (Typ);
   --  Create an item for the parameter of the __move function for deep
   --  composite types.

   function New_Ada_Pointer_Update
     (Ada_Node : Node_Id;
      Domain   : EW_Domain;
      Name     : W_Expr_Id;
      Value    : W_Expr_Id)
      return W_Expr_Id;
   --  Generate a Why3 expression that corresponds to the update to an Ada
   --  pointer (the pointed value). Emit all necessary checks.
   --  Note that this function does not generate an assignment, instead it
   --  returns a functional update. It will look like
   --    { name with Pointer_Value = value }
   --  The assignment, if required, needs to be generated by the caller.

   function New_Pointer_Address_Access
     (E     : Entity_Id;
      Name  : W_Expr_Id;
      Local : Boolean := False)
      return W_Expr_Id;
   --  Return an access to the Pointer_Address field of the pointer why record.
   --  @param E the Ada type entity
   --  @param Name name of the pointer to access
   --  @param Local whether we want the local or the global access

   function New_Pointer_Is_Null_Access
     (E     : Entity_Id;
      Name  : W_Expr_Id;
      Local : Boolean := False)
      return W_Expr_Id;
   --  Return an access to the Is_Null field of the pointer why record.
   --  @param E the Ada type entity
   --  @param Name name of the pointer to access
   --  @param Local whether we want the local or the global access

   function New_Pointer_Is_Moved_Access
     (E     : Entity_Id;
      Name  : W_Expr_Id;
      Local : Boolean := False)
      return W_Expr_Id;
   --  Return an access to the Is_Moved field of the pointer why record.
   --  @param E the Ada type entity
   --  @param Name name of the pointer to access
   --  @param Local whether we want the local or the global access

   function New_Pointer_Is_Moved_Update
     (E      : Entity_Id;
      Name   : W_Expr_Id;
      Value  : W_Expr_Id;
      Domain : EW_Domain;
      Local  : Boolean := False)
      return W_Expr_Id;
   --  Return an update of the Is_Moved field of the pointer why record Name
   --  with value Value.

   function New_Pointer_Value_Access
     (Ada_Node : Node_Id;
      E        : Entity_Id;
      Name     : W_Expr_Id;
      Domain   : EW_Domain;
      Local    : Boolean := False)
      return W_Expr_Id;
   --  Return an access to the Pointer_Value field of the pointer why record.
   --  @param E the Ada type entity
   --  @param Name name of the pointer to access
   --  @param Local whether we want the local or the global access

   function Repr_Pointer_Type (E : Entity_Id) return Entity_Id
     with Pre => Has_Access_Type (E);
   --  Return the first pointer type defined with the same designated type.

   function Root_Pointer_Type (E : Entity_Id) return Entity_Id
     with Pre => Has_Access_Type (E);
   --  Return the representative of the root of E

   function Pointer_From_Split_Form
     (I           : Item_Type;
      Ref_Allowed : Boolean)
      return W_Expr_Id
     with Pre => I.Kind = Pointer;
   --  Reconstructs a complete pointer from an item in split form.

   function Pointer_From_Split_Form
     (Ada_Node : Node_Id := Empty;
      A        : W_Expr_Array;
      Ty       : Entity_Id;
      Local    : Boolean := False)
      return W_Expr_Id;
   --  Reconstructs a complete pointer of type Ty from an array of expressions
   --  representing a split form. A should contain first the value, then the
   --  address, is_null and is_moved.

   function Prepare_Args_For_Access_Subtype_Check
     (Check_Ty : Entity_Id;
      Expr     : W_Expr_Id)
      return W_Expr_Array;
   --  Given a pointer type, compute the argument array that can be used
   --  together with its subtype check predicate of program function. The
   --  last argument is actually the given expression itself.

   function Insert_Pointer_Subtype_Check
     (Ada_Node : Node_Id;
      Check_Ty : Entity_Id;
      Expr     : W_Prog_Id)
      return W_Prog_Id;
   --  Insert a check that an expression is in the range of a pointer subtype
   --  @param Ada_Node used to locate the check
   --  @param Check_Ty pointer type
   --  @param Expr why expression. Expr should be of type
   --     EW_Abstract (Root_Pointer_Type (Check_Ty))

   ---------------
   -- Borrowers --
   ---------------

   procedure Declare_Pledge_Function
     (File    : W_Section_Id;
      E       : Entity_Id;
      Binders : Binder_Array);
   --  Clone the pledge module for E and emit a function returning the pledge
   --  for the result of a traversal function.

   procedure Declare_Pledge_Ref (File : W_Section_Id; E : Entity_Id);
   --  Clone the pledge module for E and emit a global reference for the pledge

   function Get_Borrowed_Entity (E : Entity_Id) return Entity_Id;
   --  Get the borrowed entity

   function Get_Borrowed_Expr (E : Entity_Id) return Node_Id
   with Pre  => Ekind (E) /= E_Function,
        Post => Nkind (Get_Borrowed_Expr'Result) in N_Subexpr;
   --  Get the initial borrowed expression

   function Get_Borrowed_Typ (E : Entity_Id) return Entity_Id
   with Post => Is_Type (Get_Borrowed_Typ'Result);
   --  Get the type of the borrower of initially borrowed expression

   function Get_Pledge_Id (E : Entity_Id) return W_Identifier_Id;
   --  Get the identifier of the pledge reference

   function New_Pledge_For_Call
     (E    : Entity_Id;
      Args : W_Expr_Array) return W_Expr_Id;
   --  Construct the pledge of a call to a traversal function E with
   --  parameters Args.

   function New_Pledge_Call
     (E            : Entity_Id;
      Borrowed_Arg : W_Expr_Id;
      Brower_Arg   : W_Expr_Id;
      Ref_Allowed  : Boolean) return W_Expr_Id;
   --  Construct a call to the pledge of a borrower E

   function New_Pledge_Call
     (E            : Entity_Id;
      Args         : W_Expr_Array;
      Borrowed_Arg : W_Expr_Id;
      Brower_Arg   : W_Expr_Id) return W_Expr_Id;
   --  Construct a call to the pledge of a call to a traversal function E with
   --  parameters Args.

   function New_Pledge_Def
     (E           : Entity_Id;
      Name        : W_Term_Id;
      Borrowed_Id : W_Identifier_Id;
      Brower_Id   : W_Identifier_Id;
      Def         : W_Term_Id) return W_Pred_Id;
   --  Construct an equality between a pledge object Name and its definition
   --  Def, Borrowed_Id and Brower_Id being the variables used in Def.

   function New_Pledge_Update
     (E           : Entity_Id;
      Borrowed_Id : W_Identifier_Id;
      Brower_Id   : W_Identifier_Id;
      Def         : W_Term_Id) return W_Prog_Id;
   --  Construct an update of the pledge of E

   function Result_Pledge_Id (E : Entity_Id) return W_Identifier_Id with
     Pre => Is_Borrowing_Traversal_Function (E);
   --  E is a traversal function, create an identifier for references to the
   --  pledge of E in its postcondition.

end Why.Gen.Pointers;

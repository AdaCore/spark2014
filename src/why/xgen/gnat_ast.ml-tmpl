(* -*- mode: tuareg -*- *)
(* This package is automatically generated by xtree. Do not edit manually. *)

[@@@warning "-42"]

(* TODO Use appropriate OCaml integer type *)
type uint = Uint of string
type ureal = Ureal of { numerator : uint ; denominator : uint; base : int; negative : bool }

(* GNAT *)

type source_ptr =
  | No_location
  | Source_ptr of { filename: string; line: int }

(* GNATCOLL.Symbols *)
type symbol = No_symbol | Symbol of string
type symbol_set = symbol list
type string_sets_set = symbol list

type why_node_set = unit

_@Declare_OCaml_Why_Sinfo_Types@_

type 'a nonempty = { elt0: 'a; elts: 'a list }

let list_of_nonempty n = n.elt0 :: n.elts

_@Declare_OCaml_Tags@_

_@Declare_OCaml_Why_Node_Type@_

and 'a why_node_oid = 'a why_node option
and 'a why_node_olist = 'a why_node list
and 'a why_node_id = 'a why_node
and 'a why_node_list = 'a why_node nonempty

_@Declare_OCaml_Opaque_Ids@_

type file = { theory_declarations: theory_declaration_olist }

_@Declare_OCaml_Coercions@_

module From_json = struct

  type t = [
    | `Null
    | `Bool of bool
    | `Int of int
    | `Intlit of string
    | `Float of float
    | `String of string
    | `Assoc of (string * t) list
    | `List of t list
    | `Tuple of t list
    | `Variant of string * t option
  ]

  type 'a from_json = t -> 'a

  exception Unexpected_Json of string * t

  let unexpected_json type_str json =
    raise (Unexpected_Json (type_str, json))

  let boolean_from_json : bool from_json = function
    | `Bool b -> b
    | json -> unexpected_json "bool" json

  let int_from_json : int from_json = function
    | `Int i -> i
    | json -> unexpected_json "int" json

  let uint_from_json : uint from_json = function
    | `String s -> Uint s
    | json -> unexpected_json "uint" json

  let ureal_from_json : ureal from_json = function
    | `List [numerator; denominator; base; negative] ->
      Ureal {
        numerator = uint_from_json numerator;
        denominator = uint_from_json denominator;
        base = int_from_json base;
        negative = boolean_from_json negative;
      }
    | json ->
      unexpected_json "ureal" json

  let source_ptr_from_json : source_ptr from_json = function
    | `Null -> No_location
    | `List [`String filename; `Int line] ->
      Source_ptr {filename; line}
    | json -> unexpected_json "source_ptr" json

  let why_node_set_from_json : why_node_set from_json = function
    | `String "<Why_Node_Set>" -> ()
    | json -> unexpected_json "why_node_set" json

  let symbol_from_json : symbol from_json = function
    | `String "" -> No_symbol
    | `String s -> Symbol s
    | json -> unexpected_json "symbol" json

  let symbol_set_from_json : symbol_set from_json = function
    | `List l -> List.map symbol_from_json l
    | json -> unexpected_json "symbol_set" json

  let string_sets_set_from_json : string_sets_set from_json = function
    | `List l -> List.map symbol_from_json l
    | json -> unexpected_json "string_sets_set" json

  _@Declare_OCaml_Why_Sinfo_Types_From_Json@_
  _@Declare_OCaml_Why_Node_From_Json@_

  and why_node_id_from_json : 'a . (any_node_tag why_node -> 'a why_node) -> 'a why_node_id from_json =
    fun coerce json ->
    coerce (why_node_from_json json)

  and why_node_oid_from_json : 'a . (any_node_tag why_node -> 'a why_node) -> 'a why_node_oid from_json =
    fun coerce json ->
    match json with
    | `Null ->
      None
    | json ->
      Some (coerce (why_node_from_json json))

  and why_node_list_from_json : 'a . (any_node_tag why_node -> 'a why_node) -> 'a why_node_list from_json =
    fun coerce json ->
    match json with
    | `List (elt0 :: elts) ->
      let elt0 = coerce (why_node_from_json elt0) in
      let elts =
        List.map coerce
          (List.map why_node_from_json elts) in
      {elt0; elts}
    | json ->
      unexpected_json "why_node_list" json

  and why_node_olist_from_json : 'a . (any_node_tag why_node -> 'a why_node) -> 'a why_node_olist from_json =
    fun coerce json ->
    match json with
    | `Null ->
      []
    | `List l ->
      List.map coerce
        (List.map why_node_from_json l)
    | json ->
      unexpected_json "why_node_olist_from_json" json

  _@Declare_OCaml_Opaque_Ids_From_Json@_

  let file_from_json : file from_json = function
    | `Assoc fields when
        List.length fields = 1 && List.mem_assoc "theory_declarations" fields  ->
      let ast_json = List.assoc "theory_declarations" fields in
      let theory_declarations = theory_declaration_opaque_olist_from_json ast_json in
      { theory_declarations }
    | json -> unexpected_json "file_from_json" json
end

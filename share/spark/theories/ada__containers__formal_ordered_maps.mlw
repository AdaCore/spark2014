module Ada__containers__formal_ordered_maps__witness
  use import real.Real
  use "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__key_type
  use "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__olt

  function witness Ada__containers__formal_ordered_maps__key_type.base_type : real

  axiom olt_witness :
    (forall k1  k2 : Ada__containers__formal_ordered_maps__key_type.base_type [Ada__containers__formal_ordered_maps__olt.olt k1 k2].
	Real.(<) (witness k1) (witness k2) <-> Ada__containers__formal_ordered_maps__olt.olt k1 k2 = True)
end

module Ada__containers__formal_ordered_maps__map
  use import int.Int
  use import "_gnatprove_standard".Main
  use Ada__containers__hash_type
  use Ada__containers__count_type

  type __split_discrs = {rec__capacity : Ada__containers__count_type.count_type}

  type __split_fields = { rec__main__ : __private }

  type map = { __split_discrs : __split_discrs; __split_fields : __split_fields }

  predicate map_inv "inline" (l : map) =
     l = { __split_discrs = { rec__capacity = l.__split_discrs.rec__capacity }; __split_fields = { rec__main__ = l.__split_fields.rec__main__ } }

   function capacity  (co : map) : int =
          Ada__containers__count_type.to_rep (rec__capacity (__split_discrs co))

  function bool_eq map map : bool
  function user_eq map map : bool
end

module Ada__containers__formal_ordered_maps__length
  use import int.Int
  use import "_gnatprove_standard".Main
  use Ada__containers__count_type
  use import Ada__containers__formal_ordered_maps__map

  function length__logic map : int

  function length_ "inline" (co : map) : int = length__logic co

  axiom length_range:
    forall co:map [length__logic co]. 0 <= length_ co <= capacity co

  val length (co : map) : int
     ensures { result = length__logic co }
end

module Ada__containers__formal_ordered_maps__cursor
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__key_type
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length

  type __split_fields = { rec__main__ : __private }

  type cursor = { __split_fields : __split_fields }

  function dummy : cursor

  function position map cursor : int

  function position_inv map int : cursor

  axiom position_gte_zero:
    forall co:map, cu:cursor [position co cu].
        length_ co >= position co cu >= 0

  axiom position_eq1:
   forall co:map, i :int [position co (position_inv co i)]. 0 < i <= length_ co ->
              position co (position_inv co i) = i

  axiom position_eq2:
    forall co:map, cu:cursor [position co cu].
          position co cu > 0 -> position_inv co (position co cu) = cu

  function bool_eq "inline" (c1:cursor) (c2:cursor) : bool = c1 = c2
  function user_eq cursor cursor : bool
end

module Ada__containers__formal_ordered_maps__no_element
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__cursor

  function no_element : cursor

  axiom position_no_element:
    forall co:map [position co no_element]. position co no_element = 0
end

module Ada__containers__formal_ordered_maps__empty_map
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length

  function empty_map : map

  axiom Empty_is_empty: length_ empty_map = 0
end

module Ada__containers__formal_ordered_maps__is_empty
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length

  function is_empty__logic map : bool

  axiom is_empty:
    forall co:map [is_empty__logic (co)].
          is_empty__logic (co) = True <-> length_ co = 0

  val is_empty (co:map) : bool
     ensures  { result = is_empty__logic co }
end

module Ada__containers__formal_ordered_maps__key
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__key_type
  use import Ada__containers__formal_ordered_maps__witness
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__cursor

  function key__logic map cursor : Ada__containers__formal_ordered_maps__key_type.base_type

  axiom range__key:
    forall co:map, cu:cursor. Ada__containers__formal_ordered_maps__key_type.valid (key__logic co cu)

  axiom ordered:
    forall s:map, cu1 cu2:cursor [key__logic s cu2, key__logic s cu1].
       position s cu1 > 0 -> position s cu2 > 0 ->
         (position s cu1 > position s cu2 <-> Real.(>) (witness (key__logic s cu1)) (witness (key__logic s cu2)))

  val key (co:map) (cu:cursor) : Ada__containers__formal_ordered_maps__key_type.base_type
     requires { position co cu > 0 }
     ensures  { result = key__logic co cu }
end

module Ada__containers__formal_ordered_maps__element
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__element_type
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__cursor

  function element__logic map cursor : Ada__containers__formal_ordered_maps__element_type.base_type

  axiom range__element:
    forall co:map, cu:cursor. Ada__containers__formal_ordered_maps__element_type.valid (element__logic co cu)

  val element (co:map) (cu:cursor) : Ada__containers__formal_ordered_maps__element_type.base_type
     requires { position co cu > 0 }
     ensures  { result = element__logic co cu }
end

module Ada__containers__formal_ordered_maps__previous
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__no_element

  function previous__logic map cursor : cursor

  axiom previous_in:
    forall co:map, cu:cursor [previous__logic co cu].
	(position co cu > 1 \/ position co (previous__logic co cu) > 0) ->
	position co (previous__logic co cu) = position co cu - 1

  axiom previous_ext:
    forall co:map, cu:cursor [previous__logic co cu].
        (position co cu = 1 \/ cu = no_element) -> previous__logic co cu = no_element

  val previous (co:map) (cu:cursor) : cursor
     requires { cu = no_element \/ position co cu > 0 }
     ensures  { result = previous__logic co cu }
end

module Ada__containers__formal_ordered_maps__previous__2
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__no_element
  use import Ada__containers__formal_ordered_maps__previous

  val previous__2 (co:map) (cu:ref cursor) : unit
     requires { !cu = no_element \/ position co !cu > 0 }
     writes     { cu }
     reads      { cu }
     ensures  { !cu = previous__logic co (old !cu) }
end

module Ada__containers__formal_ordered_maps__next
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__no_element

  function next__logic map cursor : cursor

  axiom next_in:
    forall co:map, cu:cursor [next__logic co cu].
	(length_ co > position co cu > 0 \/ position co (next__logic co cu) > 0) ->
	position co (next__logic co cu) = position co cu + 1

  axiom next_ext:
    forall co:map, cu:cursor [next__logic co cu].
        (position co cu = length_ co \/ cu = no_element) -> next__logic co cu = no_element

  val next (co:map) (cu:cursor) : cursor
     requires { cu = no_element \/ position co cu > 0 }
     ensures  { result = next__logic co cu }
end

module Ada__containers__formal_ordered_maps__next__2
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__no_element
  use import Ada__containers__formal_ordered_maps__next

  val next__2 (co:map) (cu:ref cursor) : unit
     requires { !cu = no_element \/ position co !cu > 0 }
     writes     { cu }
     reads      { cu }
     ensures  { !cu = next__logic co (old !cu) }
end

module Ada__containers__formal_ordered_maps__last
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__no_element

  function last__logic map : cursor

  axiom last_empty:
    forall co:map [last__logic co]. length_ co = 0 <-> last__logic co = no_element

  axiom last_gen:
    forall co:map [last__logic co]. length_ co = position co (last__logic co)

  val last (co:map) : cursor
     ensures  { result = last__logic co }
end

module Ada__containers__formal_ordered_maps__first
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__no_element

  function first__logic map : cursor

  axiom first_empty:
    forall co:map [first__logic co]. length_ co = 0 <-> first__logic co = no_element

  axiom first_gen:
    forall co:map [first__logic co]. length_ co > 0 -> position co (first__logic co) = 1

  val first (co:map) : cursor
     ensures  { result = first__logic co }
end

module Ada__containers__formal_ordered_maps__first_key
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__key_type
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__first
  use import Ada__containers__formal_ordered_maps__key

  function first_key__logic (co:map) : Ada__containers__formal_ordered_maps__key_type.base_type = key__logic co (first__logic co)

  val first_key (co:map) : Ada__containers__formal_ordered_maps__key_type.base_type
     requires { length_ co > 0 }
     ensures  { result = key__logic co (first__logic co) }
end

module Ada__containers__formal_ordered_maps__last_key
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__key_type
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__last
  use import Ada__containers__formal_ordered_maps__key

  function last_key__logic (co:map) : Ada__containers__formal_ordered_maps__key_type.base_type = key__logic co (last__logic co)

  val last_key (co:map) : Ada__containers__formal_ordered_maps__key_type.base_type
     requires { length_ co > 0 }
     ensures  { result = key__logic co (last__logic co) }
end

module Ada__containers__formal_ordered_maps__first_element
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__element_type
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__first
  use import Ada__containers__formal_ordered_maps__element

  function first_element__logic (co:map) : Ada__containers__formal_ordered_maps__element_type.base_type = element__logic co (first__logic co)

  val first_element (co:map) : Ada__containers__formal_ordered_maps__element_type.base_type
     requires { length_ co > 0 }
     ensures  { result = element__logic co (first__logic co) }
end

module Ada__containers__formal_ordered_maps__last_element
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__element_type
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__last
  use import Ada__containers__formal_ordered_maps__element

  function last_element__logic (co:map) : Ada__containers__formal_ordered_maps__element_type.base_type = element__logic co (last__logic co)

  val last_element (co:map) : Ada__containers__formal_ordered_maps__element_type.base_type
     requires { length_ co > 0 }
     ensures  { result = element__logic co (last__logic co) }
end

module Ada__containers__formal_ordered_maps__find
  use import int.Int
  use import "_gnatprove_standard".Main
  use  "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__key_type
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__witness
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__no_element
  use import Ada__containers__formal_ordered_maps__key

  function find_ map real : cursor

  predicate find__ (co : map) (i : real) (cu : cursor) =
    (cu = (no_element  : cursor) /\
      (forall cun:cursor.
        position co cun >  0 ->
         witness (key__logic co cun) <> i)) \/
     (position co cu > 0 /\
      witness (key__logic co cu) = i)

  axiom Find_find_val:
    (forall co:map.
      (forall i:real.
        ((find__ co i (find_ co i)) /\
         ((length_ co = 0) -> (find_ co i = no_element )))))

  function find__logic "inline" (co : map) (e:Ada__containers__formal_ordered_maps__key_type.base_type) : cursor =
  find_ co (witness e)

  val find (co:map) (e:Ada__containers__formal_ordered_maps__key_type.base_type)  : cursor
     ensures  { result = find__logic co e }
end

module Ada__containers__formal_ordered_maps__element__2
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__element_type
  use import Ada__containers__formal_ordered_maps__witness
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__element
  use import Ada__containers__formal_ordered_maps__find

  function element__2__logic "inline" (co:map) (k:Ada__containers__formal_ordered_maps__key_type.base_type) : Ada__containers__formal_ordered_maps__element_type.base_type =
element__logic co (find_ co (witness k))

  val element__2 (co:map) (k:Ada__containers__formal_ordered_maps__key_type.base_type) : Ada__containers__formal_ordered_maps__element_type.base_type
     requires { position co (find_ co (witness k)) > 0 }
     ensures  { result = element__2__logic co k }
end

module Ada__containers__formal_ordered_maps__ceiling
  use import int.Int
  use import "_gnatprove_standard".Main
  use  "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__key_type
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__witness
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__no_element
  use import Ada__containers__formal_ordered_maps__last
  use import Ada__containers__formal_ordered_maps__key

  function ceiling_ map real : cursor

  predicate is_ceiling (s : map) (i : real) (cu : cursor) =
     (cu = no_element  /\
       (length_ s = 0 \/ length_ s > 0 /\
        Real.(>) i (witness (key__logic s (last__logic s))))) \/
      (position s cu > 0 /\
       Real.(<=) i (witness (key__logic s cu)) /\
	(forall cun : cursor [key__logic s cun]. 0 < position s cun < position s cu
	 -> Real.(>) i (witness (key__logic s cun))))

  axiom ceiling_is_ceiling:
    forall s:map.
      forall i:real [(ceiling_ s i : cursor)].
        is_ceiling s i (ceiling_ s i : cursor)

  function ceiling__logic  "inline" (co:map) (e:Ada__containers__formal_ordered_maps__key_type.base_type) : cursor =
 ceiling_ co (witness e)

  val ceiling (co:map) (e:Ada__containers__formal_ordered_maps__key_type.base_type) :cursor
     ensures { result = ceiling_ co (witness e) }
end

module Ada__containers__formal_ordered_maps__floor
  use import int.Int
  use import "_gnatprove_standard".Main
  use  "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__key_type
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__witness
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__no_element
  use import Ada__containers__formal_ordered_maps__first
  use import Ada__containers__formal_ordered_maps__key

  function floor_ map real : cursor

  predicate is_floor (s : map) (i : real) (cu : cursor) =
     (cu = no_element  /\
       (length_ s = 0 \/ length_ s > 0 /\
         Real.(<) i (witness (key__logic s (first__logic s))))) \/
      (position s cu > 0 /\
       Real.(>=) i (witness (key__logic s cu)) /\
	(forall cun : cursor. position s cu < position s cun
	 ->  Real.(<) i (witness (key__logic s cun))))

  axiom floor_is_floor:
    (forall s:map.
      (forall i:real [(floor_ s i : cursor)].
        (is_floor s i (floor_ s i : cursor))))

  function floor__logic  "inline" (co:map) (e:Ada__containers__formal_ordered_maps__key_type.base_type) : cursor =
 floor_ co (witness e)

  val floor (co:map) (e:Ada__containers__formal_ordered_maps__key_type.base_type) :cursor
     ensures { result = floor_ co (witness e) }
end

module Ada__containers__formal_ordered_maps__first_to_previous
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_maps__witness
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__no_element
  use import Ada__containers__formal_ordered_maps__key
  use import Ada__containers__formal_ordered_maps__element
  use import Ada__containers__formal_ordered_maps__find

  function first_to_previous__logic map cursor : map

  axiom first_to_previous_no_element:
    forall co:map [first_to_previous__logic co no_element]. first_to_previous__logic co no_element = co

  axiom first_to_previous_length_:
    forall co:map, cu:cursor [first_to_previous__logic co cu].
	position co cu > 0 -> length_ (first_to_previous__logic co cu) = position co cu - 1

  axiom first_to_previous_position_in:
    forall co:map, cu cun:cursor [position (first_to_previous__logic co cu) cun | first_to_previous__logic co cu, position co cun].
	(position (first_to_previous__logic co cu) cun > 0 \/ position co cun < position co cu) ->
	position (first_to_previous__logic co cu) cun = position co cun

  axiom first_to_previous_position_ext:
    forall co:map, cu cun:cursor [position (first_to_previous__logic co cu) cun].
	position co cun >= position co cu > 0 ->
	position (first_to_previous__logic co cu) cun = 0

  axiom first_to_previous_key:
    forall co:map, cu cun:cursor [key__logic (first_to_previous__logic co cu) cun | first_to_previous__logic co cu, key__logic co cun].
	(position (first_to_previous__logic co cu) cun > 0 \/ 0 < position co cun < position co cu) ->
	key__logic (first_to_previous__logic co cu) cun = key__logic co cun

  axiom first_to_previous_element:
    forall co:map, cu cun:cursor [element__logic (first_to_previous__logic co cu) cun | first_to_previous__logic co cu, element__logic co cun].
	(position (first_to_previous__logic co cu) cun > 0 \/ 0 < position co cun < position co cu) ->
	element__logic (first_to_previous__logic co cu) cun = element__logic co cun

  axiom first_to_previous_find :
    forall co:map, cu:cursor, w:real [find_ co w, first_to_previous__logic co cu|
     find_ (first_to_previous__logic co cu) w].
     ((position co cu > position co (find_ co w) > 0 \/
      position (first_to_previous__logic co cu) (find_ (first_to_previous__logic co cu) w) > 0) ->
      find_ co w = find_ (first_to_previous__logic co cu) w) /\
      (position co (find_ co w) >= position co cu -> find_ (first_to_previous__logic co cu) w = no_element)

  axiom first_to_previous_find_elt :
    forall co:map, cu:cursor, w:real [key__logic co cu, find_ co w, first_to_previous__logic co cu|
     key__logic co cu, find_ (first_to_previous__logic co cu) w].
     (Real.(>) (witness (key__logic co cu)) w  ->
      find_ co w = find_ (first_to_previous__logic co cu) w) /\
     (Real.(<=) (witness (key__logic co cu)) w  ->
      find_ (first_to_previous__logic co cu) w = no_element)

  val first_to_previous (co:map) (cu:cursor) : map
     requires { cu = no_element \/ position co cu > 0 }
     ensures  { result = first_to_previous__logic co cu /\ map_inv result}
end

module Ada__containers__formal_ordered_maps__current_to_last
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_maps__witness
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__empty_map
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__no_element
  use import Ada__containers__formal_ordered_maps__key
  use import Ada__containers__formal_ordered_maps__element
  use import Ada__containers__formal_ordered_maps__find

  function current_to_last__logic map cursor : map

  axiom current_to_last_no_element:
    forall co:map [current_to_last__logic co no_element]. current_to_last__logic co no_element = empty_map

  axiom current_to_last_length_:
    forall co:map, cu:cursor [length_ (current_to_last__logic co cu) ].
	position co cu > 0 -> length_ (current_to_last__logic co cu) = (length_ co) - (position co cu) + 1

  axiom current_to_last_position_in:
    forall co:map, cu cun:cursor [position (current_to_last__logic co cu) cun | current_to_last__logic co cu, position co cun].
	(position (current_to_last__logic co cu) cun > 0 \/ position co cun >= position co cu > 0) ->
	position (current_to_last__logic co cu) cun = (position co cun) - (position co cu) + 1

  axiom current_to_last_position_ext:
    forall co:map, cu cun:cursor [position (current_to_last__logic co cu) cun].
	position co cun < position co cu -> position (current_to_last__logic co cu) cun = 0

  axiom current_to_last_key:
    forall co:map, cu cun:cursor [key__logic (current_to_last__logic co cu) cun | current_to_last__logic co cu, key__logic co cun].
	(position (current_to_last__logic co cu) cun > 0 \/ 0 < position co cu <= position co cun) ->
	key__logic (current_to_last__logic co cu) cun = key__logic co cun

  axiom current_to_last_element:
    forall co:map, cu cun:cursor [element__logic (current_to_last__logic co cu) cun | current_to_last__logic co cu, element__logic co cun].
	(position (current_to_last__logic co cu) cun > 0 \/ 0 < position co cu <= position co cun) ->
	element__logic (current_to_last__logic co cu) cun = element__logic co cun

  axiom current_to_last_find :
    forall co:map, cu:cursor, w:real [find_ (current_to_last__logic co cu) w| current_to_last__logic co cu,
     find_ co w].
     ((0 < position co cu <= position co (find_ co w) \/
      position (current_to_last__logic co cu) (find_ (current_to_last__logic co cu) w) > 0) ->
      find_ co w = find_ (current_to_last__logic co cu) w) /\
      (position co (find_ co w) < position co cu -> find_ (current_to_last__logic co cu) w = no_element)

  axiom current_to_last_find_elt :
    forall co:map, cu:cursor, w:real [key__logic co cu, find_ co w, current_to_last__logic co cu|
     key__logic co cu, find_ (current_to_last__logic co cu) w].
     (Real.(<=) (witness (key__logic co cu)) w  ->
      find_ co w = find_ (current_to_last__logic co cu) w) /\
     (Real.(>) (witness (key__logic co cu)) w  ->
      find_ (current_to_last__logic co cu) w = no_element)

  val current_to_last (co:map) (cu:cursor) : map
     requires { cu = no_element \/ position co cu > 0 }
     ensures  { result = current_to_last__logic co cu /\ map_inv result }
end

module Ada__containers__formal_ordered_maps__replace
  use import int.Int
  use import "_gnatprove_standard".Main
  use  "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__key_type
  use "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__element_type
  use "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__oeq
  use import Ada__containers__formal_ordered_maps__witness
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__empty_map
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__no_element
  use import Ada__containers__formal_ordered_maps__key
  use import Ada__containers__formal_ordered_maps__element
  use import Ada__containers__formal_ordered_maps__find

  predicate replace (co1:map) (k:Ada__containers__formal_ordered_maps__key_type.base_type) (e:Ada__containers__formal_ordered_maps__element_type.base_type) (co2:map) =
    (position co1 (find_ co1 (witness k)) > 0 /\
      length_ co1 = length_ co2 /\
       Ada__containers__formal_ordered_maps__oeq.oeq (element__logic co2 (find_ co1 (witness k))) e /\
        (forall cun:cursor [position co2 cun | position co1 cun]. position co2 cun = position co1 cun) /\
         (forall cun:cursor [key__logic co2 cun | key__logic co1 cun].
           position co1 cun > 0 /\ not cun = find_ co1 (witness k) ->
            key__logic co2 cun = key__logic co1 cun) /\
         (forall cun:cursor [element__logic co2 cun | element__logic co1 cun].
           position co1 cun > 0 /\ not cun = find_ co1 (witness k) ->
            element__logic co2 cun = element__logic co1 cun) /\
          (forall w:real [find_ co1 w | find_ co2 w]. find_ co1 w = find_ co2 w)) /\
     capacity co1 = capacity co2

  val replace (co:ref Ada__containers__formal_ordered_maps__map.__split_fields) (cap : Ada__containers__formal_ordered_maps__map.__split_discrs) (k:Ada__containers__formal_ordered_maps__key_type.base_type) (e:Ada__containers__formal_ordered_maps__element_type.base_type) : unit
     requires { let rec_co = {Ada__containers__formal_ordered_maps__map.__split_fields = !co;
                              Ada__containers__formal_ordered_maps__map.__split_discrs = cap}  in
                   find_ rec_co (witness k) <> no_element }
     writes { co }
     reads { co }
     ensures { let rec_co = {Ada__containers__formal_ordered_maps__map.__split_fields = !co;
                              Ada__containers__formal_ordered_maps__map.__split_discrs = cap}  in
               let old_co = {Ada__containers__formal_ordered_maps__map.__split_fields = old !co;
                              Ada__containers__formal_ordered_maps__map.__split_discrs = cap}  in
                   replace old_co k e rec_co }
end

module Ada__containers__formal_ordered_maps__replace_element
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__key_type
  use "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__element_type
  use "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__oeq
  use import Ada__containers__formal_ordered_maps__witness
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__no_element
  use import Ada__containers__formal_ordered_maps__key
  use import Ada__containers__formal_ordered_maps__element
  use import Ada__containers__formal_ordered_maps__find

  predicate replace_element map cursor Ada__containers__formal_ordered_maps__element_type.base_type map

  axiom replace_element_length_:
    forall co1 co2:map, cu:cursor, e:Ada__containers__formal_ordered_maps__element_type.base_type
      [replace_element co1 cu e co2].
      replace_element co1 cu e co2 -> length_ co1 = length_ co2

  axiom replace_element_capacity:
    forall co1 co2:map, cu:cursor, e:Ada__containers__formal_ordered_maps__element_type.base_type
      [replace_element co1 cu e co2, capacity co1|replace_element co1 cu e co2, capacity co2].
      replace_element co1 cu e co2 -> capacity co1 = capacity co2

  axiom replace_element_position:
    forall co1 co2:map, cu cun:cursor, e:Ada__containers__formal_ordered_maps__element_type.base_type
      [replace_element co1 cu e co2, position co2 cun
     | replace_element co1 cu e co2, position co1 cun].
      replace_element co1 cu e co2 -> position co2 cun = position co1 cun

  axiom replace_element_key:
    forall co1 co2:map, cu cun:cursor, e:Ada__containers__formal_ordered_maps__element_type.base_type
      [replace_element co1 cu e co2, key__logic co2 cun
     | replace_element co1 cu e co2, key__logic co1 cun].
      replace_element co1 cu e co2 -> position co1 cun > 0 ->
        key__logic co2 cun = key__logic co1 cun

  axiom replace_element_element_in:
    forall co1 co2:map, cu:cursor, e:Ada__containers__formal_ordered_maps__element_type.base_type
      [replace_element co1 cu e co2].
      replace_element co1 cu e co2 -> Ada__containers__formal_ordered_maps__oeq.oeq (element__logic co2 cu) e

  axiom replace_element_element_ext:
    forall co1 co2:map, cu cun:cursor, e:Ada__containers__formal_ordered_maps__element_type.base_type
      [replace_element co1 cu e co2, element__logic co2 cun
     | replace_element co1 cu e co2, element__logic co1 cun].
      replace_element co1 cu e co2 -> cu <> cun -> position co1 cun > 0 ->
        element__logic co2 cun = element__logic co1 cun

  axiom replace_element_find:
    forall co1 co2:map, cu:cursor, w:real, e:Ada__containers__formal_ordered_maps__element_type.base_type
      [replace_element co1 cu e co2, find_ co2 w
     | replace_element co1 cu e co2, find_ co1 w].
       replace_element co1 cu e co2 -> find_ co1 w = find_ co2 w

  val replace_element (co:ref Ada__containers__formal_ordered_maps__map.__split_fields) (cap : Ada__containers__formal_ordered_maps__map.__split_discrs) (cu:cursor) (e:Ada__containers__formal_ordered_maps__element_type.base_type) : unit
     requires { let rec_co = {Ada__containers__formal_ordered_maps__map.__split_fields = !co;
                              Ada__containers__formal_ordered_maps__map.__split_discrs = cap}  in
                   position rec_co cu > 0 }
     writes     { co }
     reads      { co }
     ensures { let rec_co = {Ada__containers__formal_ordered_maps__map.__split_fields = !co;
                              Ada__containers__formal_ordered_maps__map.__split_discrs = cap}  in
               let old_co = {Ada__containers__formal_ordered_maps__map.__split_fields = old !co;
                              Ada__containers__formal_ordered_maps__map.__split_discrs = cap}  in
                   replace_element old_co cu e rec_co }
end

module Ada__containers__formal_ordered_maps__insert
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__key_type
  use "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__element_type
  use "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__oeq
  use import Ada__containers__formal_ordered_maps__witness
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__no_element
  use import Ada__containers__formal_ordered_maps__last
  use import Ada__containers__formal_ordered_maps__key
  use import Ada__containers__formal_ordered_maps__element
  use import Ada__containers__formal_ordered_maps__find
  use import Ada__containers__formal_ordered_maps__ceiling

  predicate insert map Ada__containers__formal_ordered_maps__key_type.base_type  Ada__containers__formal_ordered_maps__element_type.base_type map

  axiom insert_length_:
    forall co1 co2:map,  k:Ada__containers__formal_ordered_maps__key_type.base_type, e:Ada__containers__formal_ordered_maps__element_type.base_type
      [insert co1 k e co2].
      insert co1 k e co2 -> length_ co1 + 1 = length_ co2 /\ find_ co1 (witness k) = no_element /\ Ada__containers__formal_ordered_maps__oeq.oeq (element__logic co2 (find_ co2 (witness k))) e

  axiom insert_capacity:
    forall co1 co2:map,  k:Ada__containers__formal_ordered_maps__key_type.base_type, e:Ada__containers__formal_ordered_maps__element_type.base_type
      [insert co1 k e co2, capacity co1|insert co1 k e co2, capacity co2].
      insert co1 k e co2 -> capacity co1 = capacity co2

  axiom insert_new:
    forall co1 co2:map,  k:Ada__containers__formal_ordered_maps__key_type.base_type, e:Ada__containers__formal_ordered_maps__element_type.base_type [insert co1 k e co2].
      insert co1 k e co2 -> (ceiling_ co1 (witness k) <> no_element ->
      position co2 (find_ co2 (witness k)) = position co1 (ceiling_ co1 (witness k))) /\ (ceiling_ co1 (witness k) = no_element ->
      find_ co2 (witness k) = last__logic co2)

  axiom insert_position_before:
    forall co1 co2:map, cun:cursor,  k:Ada__containers__formal_ordered_maps__key_type.base_type, e:Ada__containers__formal_ordered_maps__element_type.base_type
      [insert co1 k e co2,  position co1 cun
     | insert co1 k e co2,  position co2 cun].
    let i = position co2 (find_ co2 (witness k)) in
      insert co1 k e co2 ->
      (i > position co1 cun > 0 \/ position co2 cun < i) ->
        position co1 cun = position co2 cun

  axiom insert_position_after:
    forall co1 co2:map, cun:cursor,  k:Ada__containers__formal_ordered_maps__key_type.base_type, e:Ada__containers__formal_ordered_maps__element_type.base_type
      [insert co1 k e co2,  position co1 cun
     | insert co1 k e co2,  position co2 cun].
    let i = position co2 (find_ co2 (witness k)) in
      insert co1 k e co2 ->
      (position co1 cun >= i \/ position co2 cun > i) ->
        position co1 cun + 1 = position co2 cun

  axiom insert_key:
    forall co1 co2:map, cun:cursor,  k:Ada__containers__formal_ordered_maps__key_type.base_type, e:Ada__containers__formal_ordered_maps__element_type.base_type
      [insert co1 k e co2,  key__logic co1 cun
     | insert co1 k e co2,  key__logic co2 cun].
      insert co1 k e co2 ->
      (position co1 cun > 0 \/ position co2 cun > 0 /\ find_ co2 (witness k) <> cun) ->
        key__logic co1 cun = key__logic co2 cun

  axiom insert_element:
    forall co1 co2:map, cun:cursor,  k:Ada__containers__formal_ordered_maps__key_type.base_type, e:Ada__containers__formal_ordered_maps__element_type.base_type
      [insert co1 k e co2,  element__logic co1 cun
     | insert co1 k e co2,  element__logic co2 cun].
      insert co1 k e co2 ->
      (position co1 cun > 0 \/ position co2 cun > 0 /\ find_ co2 (witness k) <> cun) ->
        element__logic co1 cun = element__logic co2 cun

  axiom insert_find :
    forall co1:map, co2:map, w:real,  k:Ada__containers__formal_ordered_maps__key_type.base_type, e:Ada__containers__formal_ordered_maps__element_type.base_type
     [insert co1 k e co2, find_ co1 w| insert co1 k e co2, find_ co2 w].
      insert co1 k e co2 -> not witness k = w -> find_ co1 w = find_ co2 w

  val insert (co:ref Ada__containers__formal_ordered_maps__map.__split_fields) (cap : Ada__containers__formal_ordered_maps__map.__split_discrs) (k:Ada__containers__formal_ordered_maps__key_type.base_type) (e:Ada__containers__formal_ordered_maps__element_type.base_type)  (p:ref cursor) (inserted : ref bool) : unit
     requires { let rec_co = {Ada__containers__formal_ordered_maps__map.__split_fields = !co;
                              Ada__containers__formal_ordered_maps__map.__split_discrs = cap}  in
                   length_ rec_co < capacity rec_co }
     writes     { co, p, inserted }
     reads      { co }
     ensures { let rec_co = {Ada__containers__formal_ordered_maps__map.__split_fields = !co;
                              Ada__containers__formal_ordered_maps__map.__split_discrs = cap}  in
               let old_co = {Ada__containers__formal_ordered_maps__map.__split_fields = old !co;
                              Ada__containers__formal_ordered_maps__map.__split_discrs = cap}  in
                   (!inserted = True <-> find_ old_co (witness k) = no_element) /\ !p = find_ rec_co (witness k) /\
                          if !inserted = True then (insert old_co k e rec_co)
                                                                 else (!co = old !co) }
end

module Ada__containers__formal_ordered_maps__insert__2
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__key_type
  use import Ada__containers__formal_ordered_maps__witness
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__no_element
  use import Ada__containers__formal_ordered_maps__insert
  use import Ada__containers__formal_ordered_maps__find

  val insert__2 (co:ref Ada__containers__formal_ordered_maps__map.__split_fields) (cap : Ada__containers__formal_ordered_maps__map.__split_discrs)  (k:Ada__containers__formal_ordered_maps__key_type.base_type) (e:Ada__containers__formal_ordered_maps__element_type.base_type) : unit
     requires { let rec_co = {Ada__containers__formal_ordered_maps__map.__split_fields = !co;
                              Ada__containers__formal_ordered_maps__map.__split_discrs = cap}  in
                   length_ rec_co < capacity rec_co /\ find_ rec_co (witness k) = no_element }
     writes     { co }
     reads      { co }
     ensures { let rec_co = {Ada__containers__formal_ordered_maps__map.__split_fields = !co;
                              Ada__containers__formal_ordered_maps__map.__split_discrs = cap}  in
               let old_co = {Ada__containers__formal_ordered_maps__map.__split_fields = old !co;
                              Ada__containers__formal_ordered_maps__map.__split_discrs = cap}  in
                   insert old_co k e rec_co }
end

module Ada__containers__formal_ordered_maps__delete
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__key_type
  use import Ada__containers__formal_ordered_maps__witness
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__no_element
  use import Ada__containers__formal_ordered_maps__next
  use import Ada__containers__formal_ordered_maps__key
  use import Ada__containers__formal_ordered_maps__element
  use import Ada__containers__formal_ordered_maps__find

  predicate delete map cursor map

  axiom delete_capacity:
    forall co1 co2:map, cu:cursor
      [delete co1 cu co2, capacity co1|delete co1 cu co2, capacity co2].
      delete co1 cu co2 -> capacity co1 = capacity co2

  axiom delete_length_:
    forall co1 co2:map, cu:cursor
      [delete co1 cu co2].
      delete co1 cu co2 -> length_ co1 = length_ co2 + 1

  axiom delete_position_before:
    forall co1 co2:map, cu cun:cursor
      [delete co1 cu co2,  position co1 cun
     | delete co1 cu co2,  position co2 cun].
      delete co1 cu co2 ->
      (position co1 cu > position co1 cun \/ 0 < position co2 cun < position co1 cu) ->
        position co1 cun = position co2 cun

  axiom delete_position_after:
    forall co1 co2:map, cu cun:cursor
      [delete co1 cu co2,  position co1 cun | delete co1 cu co2,  position co2 cun].
      delete co1 cu co2 ->
      (position co1 cun > position co1 cu \/ position co2 cun >= position co1 cu) ->
        position co1 cun = position co2 cun + 1

  axiom delete_position_range:
    forall co1 co2:map, cu:cursor [delete co1 cu co2].
      delete co1 cu co2 -> position co2 cu = 0 /\ 0 < position co1 cu /\ find_ co2 (witness (key__logic co1 cu)) = no_element

  axiom delete_position_next:
    forall co1 co2:map, cu:cursor [delete co1 cu co2].
      delete co1 cu co2 -> position co1 (next__logic co1 cu) >= 0

  axiom delete_key:
    forall co1 co2:map, cu cun:cursor
      [delete co1 cu co2,  key__logic co1 cun
     | delete co1 cu co2,  key__logic co2 cun].
      delete co1 cu co2 ->
      0 < position co2 cun ->
        key__logic co1 cun = key__logic co2 cun

  axiom delete_element:
    forall co1 co2:map, cu cun:cursor
      [delete co1 cu co2,  element__logic co1 cun
     | delete co1 cu co2,  element__logic co2 cun].
      delete co1 cu co2 ->
      0 < position co2 cun ->
        element__logic co1 cun = element__logic co2 cun

  axiom delete_find :
    forall co1:map, co2:map, cu:cursor, w:real [delete co1 cu co2,
     find_ co1 w| delete co1 cu co2, find_ co2 w].
     delete co1 cu co2 -> not witness (key__logic co1 cu) = w -> find_ co1 w = find_ co2 w

  val delete (co:ref Ada__containers__formal_ordered_maps__map.__split_fields) (cap : Ada__containers__formal_ordered_maps__map.__split_discrs) (e : Ada__containers__formal_ordered_maps__key_type.base_type) : unit
     requires { let rec_co = {Ada__containers__formal_ordered_maps__map.__split_fields = !co;
                              Ada__containers__formal_ordered_maps__map.__split_discrs = cap}  in
                   find_ rec_co (witness e) <> no_element }
     writes     { co }
     reads      { co }
     ensures { let rec_co = {Ada__containers__formal_ordered_maps__map.__split_fields = !co;
                              Ada__containers__formal_ordered_maps__map.__split_discrs = cap}  in
               let old_co = {Ada__containers__formal_ordered_maps__map.__split_fields = old !co;
                              Ada__containers__formal_ordered_maps__map.__split_discrs = cap}  in
                   delete old_co (find_ old_co (witness e)) rec_co }
end

module Ada__containers__formal_ordered_maps__delete__2
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__no_element
  use import Ada__containers__formal_ordered_maps__delete

  val delete__2 (co:ref Ada__containers__formal_ordered_maps__map.__split_fields) (cap : Ada__containers__formal_ordered_maps__map.__split_discrs) (cu:ref cursor) : unit
     requires { let rec_co = {Ada__containers__formal_ordered_maps__map.__split_fields = !co;
                              Ada__containers__formal_ordered_maps__map.__split_discrs = cap}  in
                   position rec_co !cu > 0 }
     writes     { co, cu }
     reads      { co }
     ensures { let rec_co = {Ada__containers__formal_ordered_maps__map.__split_fields = !co;
                              Ada__containers__formal_ordered_maps__map.__split_discrs = cap}  in
               let old_co = {Ada__containers__formal_ordered_maps__map.__split_fields = old !co;
                              Ada__containers__formal_ordered_maps__map.__split_discrs = cap}  in
                   delete old_co (old !cu) rec_co /\ !cu = no_element}
 end

module Ada__containers__formal_ordered_maps__delete_first
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__no_element
  use import Ada__containers__formal_ordered_maps__first
  use import Ada__containers__formal_ordered_maps__delete

  val delete__first (co:ref Ada__containers__formal_ordered_maps__map.__split_fields) (cap : Ada__containers__formal_ordered_maps__map.__split_discrs) : unit
     writes     { co }
     reads      { co }
     ensures { let rec_co = {Ada__containers__formal_ordered_maps__map.__split_fields = !co;
                              Ada__containers__formal_ordered_maps__map.__split_discrs = cap}  in
               let old_co = {Ada__containers__formal_ordered_maps__map.__split_fields = old !co;
                              Ada__containers__formal_ordered_maps__map.__split_discrs = cap}  in
                   if length_ old_co = 0 then !co = (old !co) else delete old_co (first__logic old_co) rec_co }
 end

module Ada__containers__formal_ordered_maps__delete_last
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__no_element
  use import Ada__containers__formal_ordered_maps__last
  use import Ada__containers__formal_ordered_maps__delete

  val delete__last (co:ref Ada__containers__formal_ordered_maps__map.__split_fields) (cap : Ada__containers__formal_ordered_maps__map.__split_discrs) : unit
     writes     { co }
     reads      { co }
     ensures { let rec_co = {Ada__containers__formal_ordered_maps__map.__split_fields = !co;
                              Ada__containers__formal_ordered_maps__map.__split_discrs = cap}  in
               let old_co = {Ada__containers__formal_ordered_maps__map.__split_fields = old !co;
                              Ada__containers__formal_ordered_maps__map.__split_discrs = cap}  in
                   if length_ old_co = 0 then !co = (old !co) else delete old_co (last__logic old_co) rec_co }
 end

module Ada__containers__formal_ordered_maps__include
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__key_type
  use import Ada__containers__formal_ordered_maps__witness
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__no_element
  use import Ada__containers__formal_ordered_maps__replace
  use import Ada__containers__formal_ordered_maps__insert
  use import Ada__containers__formal_ordered_maps__find

  val include (co:ref Ada__containers__formal_ordered_maps__map.__split_fields) (cap : Ada__containers__formal_ordered_maps__map.__split_discrs) (k :Ada__containers__formal_ordered_maps__key_type.base_type) (e :Ada__containers__formal_ordered_maps__element_type.base_type) : unit
     requires {  let rec_co = {Ada__containers__formal_ordered_maps__map.__split_fields = !co;
                              Ada__containers__formal_ordered_maps__map.__split_discrs = cap}  in
                   length_ rec_co  < capacity rec_co}
     writes     { co }
     reads      { co }
     ensures { let rec_co = {Ada__containers__formal_ordered_maps__map.__split_fields = !co;
                              Ada__containers__formal_ordered_maps__map.__split_discrs = cap}  in
               let old_co = {Ada__containers__formal_ordered_maps__map.__split_fields = old !co;
                              Ada__containers__formal_ordered_maps__map.__split_discrs = cap}  in
                   if find_ old_co (witness k) <> no_element then replace old_co k e rec_co
                         else insert old_co k e rec_co  }
end

module Ada__containers__formal_ordered_maps__exclude
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__key_type
  use import Ada__containers__formal_ordered_maps__witness
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__no_element
  use import Ada__containers__formal_ordered_maps__delete
  use import Ada__containers__formal_ordered_maps__find

  val exclude (co:ref Ada__containers__formal_ordered_maps__map.__split_fields) (cap : Ada__containers__formal_ordered_maps__map.__split_discrs) (e :Ada__containers__formal_ordered_maps__key_type.base_type) : unit
     writes     { co }
     reads      { co }
     ensures { let rec_co = {Ada__containers__formal_ordered_maps__map.__split_fields = !co;
                              Ada__containers__formal_ordered_maps__map.__split_discrs = cap}  in
               let old_co = {Ada__containers__formal_ordered_maps__map.__split_fields = old !co;
                              Ada__containers__formal_ordered_maps__map.__split_discrs = cap}  in
                   if find_ old_co (witness e) = no_element then  old !co = !co
                         else delete old_co (find_ old_co (witness e)) rec_co  }
end

module Ada__containers__formal_ordered_maps__has_element
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__cursor

  function has_element__logic map cursor : bool

  axiom has_element_pos:
    forall co:map, cu:cursor [has_element__logic co cu].
    has_element__logic co cu = True -> 0 < position co cu

  axiom has_element_neg:
    forall co:map, cu:cursor [has_element__logic co cu].
    has_element__logic co cu <> True -> position co cu = 0

  val has_element (co:map) (cu:cursor) : bool
     ensures { has_element__logic co cu = result }
end

module Ada__containers__formal_ordered_maps__contains
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__key_type
  use import Ada__containers__formal_ordered_maps__witness
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__find

  function contains__logic map Ada__containers__formal_ordered_maps__key_type.base_type : bool

  axiom contains_c:
  forall co : map, e : Ada__containers__formal_ordered_maps__key_type.base_type [contains__logic co e].
    contains__logic co e = True <-> 0 < position co (find_ co (witness e))

  val contains (co:map) (e:Ada__containers__formal_ordered_maps__key_type.base_type) : bool
     ensures { contains__logic co e = result }
end

module Ada__containers__formal_ordered_maps__strict_equal
  use import int.Int
  use import "_gnatprove_standard".Main
  use  "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__key_type
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__key
  use import Ada__containers__formal_ordered_maps__element

  function strict_equal__logic map map : bool

  axiom strict_equal__def:
    forall co1 co2 : map [strict_equal__logic co1 co2].
    ((forall cu:cursor [position co1 cu | position co2 cu].
       position co1 cu > 0 <-> position co2 cu > 0) /\
     (forall cu:cursor [key__logic co1 cu | key__logic co2 cu]. position co1 cu > 0 ->
        key__logic co1 cu = key__logic co2 cu) /\
     (forall cu:cursor [element__logic co1 cu | element__logic co2 cu]. position co1 cu > 0 ->
        element__logic co1 cu = element__logic co2 cu)) <->  strict_equal__logic co1 co2 = True

  axiom strict_equal__position:
    forall co1 co2 : map [strict_equal__logic co1 co2].
    strict_equal__logic co1 co2 = True -> (forall cu:cursor [position co1 cu | position co2 cu].
       position co1 cu = position co2 cu)

  axiom strict_equal_length_:
    forall co1 co2 : map [strict_equal__logic co1 co2].
     strict_equal__logic co1 co2 = True -> length_ co1 = length_ co2

    val strict_equal (co1:map) (co2:map) : bool
     ensures  { result  = strict_equal__logic co1 co2 }
end

module Ada__containers__formal_ordered_maps__Oeq__2
  use import int.Int
  use  "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__key_type
  use  "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__element_type
  use "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__oeq
  use import Ada__containers__formal_ordered_maps__witness
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__no_element
  use import Ada__containers__formal_ordered_maps__key
  use import Ada__containers__formal_ordered_maps__element
  use import Ada__containers__formal_ordered_maps__find

  function oeq__2__logic map map : bool

  axiom oeq__2_length_:
   forall co1 co2 : map [oeq__2__logic co1 co2].
   oeq__2__logic co1 co2 = True -> length_ co1 = length_ co2

  axiom oeq__2_element:
   forall co1 co2 : map [oeq__2__logic co1 co2]. oeq__2__logic co1 co2 = True ->
   forall cu1:cursor [key__logic co1 cu1]. position co1 cu1 > 0 ->
	let cu2 = find_ co2 (witness (key__logic co1 cu1)) in
          position co2 cu2 > 0 /\
          Ada__containers__formal_ordered_maps__oeq.oeq (element__logic co2 cu2) (element__logic co1 cu1) = True

  axiom oeq__2_inv:
   forall co1 co2 : map [oeq__2__logic co1 co2]. oeq__2__logic co1 co2 <> True ->
   (length_ co1 <> length_ co2 \/
   exists e : real. position co1 (find_ co1 e) > 0 /\
         (find_ co2 e = no_element \/ position co2 (find_ co2 e) > 0 /\
          Ada__containers__formal_ordered_maps__oeq.oeq (element__logic co2 (find_ co2 e)) (element__logic co1 (find_ co1 e)) <> True))

  axiom oeq__2_sym :
  forall e1 e2 : map [oeq__2__logic e1 e2].
	oeq__2__logic e1 e2 = True -> oeq__2__logic e2 e1 = True

  axiom oeq__2_trans :
  forall e1 e2 e3 : map [oeq__2__logic e1 e2, oeq__2__logic e1 e3 | oeq__2__logic e1 e2, oeq__2__logic e2 e3].
	oeq__2__logic e1 e2 = True -> oeq__2__logic e2 e3 = True -> oeq__2__logic e1 e3 = True

  val oeq__2 (co1:map) (co2:map) : bool
     ensures  { result  = oeq__2__logic co1 co2 }
end

module Ada__containers__formal_ordered_maps__overlap
  use import int.Int
  use import "_gnatprove_standard".Main
  use  "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__key_type
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__no_element
  use import Ada__containers__formal_ordered_maps__find

  function overlap__logic map map : bool

  axiom overlap__def :
    forall s1:map, s2:map [overlap__logic s1 s2].
     overlap__logic s1 s2 <> True <->
      (forall i:real [find_ s1 i| find_ s2 i].
        find_ s1 i = no_element \/ find_ s2 i = no_element)

  val overlap (co1 co2:map) : bool
     ensures { result = overlap__logic co1 co2 }
end

module Ada__containers__formal_ordered_maps__capacity
  use import int.Int
  use import "_gnatprove_standard".Main
  use Ada__containers__count_type
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length

  function capacity__logic (co : map) : int = Ada__containers__count_type.to_rep (rec__capacity (__split_discrs co))

  val capacity (co : map) : int
    ensures { result = Ada__containers__count_type.to_rep (rec__capacity (__split_discrs co)) }
end

module Ada__containers__formal_ordered_maps__reserve_capacity
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_maps__map

  val reserve_capacity (co:ref Ada__containers__formal_ordered_maps__map.__split_fields) (cap : Ada__containers__formal_ordered_maps__map.__split_discrs) (c : int) : unit
    requires { Ada__containers__count_type.to_rep cap.rec__capacity >= c }
    ensures { !co = old !co }
end

module Ada__containers__formal_ordered_maps__equivalent_keys
  use "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__key_type
  use "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__olt
  use import Ada__containers__formal_ordered_maps__witness
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__key

  function equivalent_keys__logic (e1:Ada__containers__formal_ordered_maps__key_type.base_type)  (e2:Ada__containers__formal_ordered_maps__key_type.base_type) : bool =
  not (Ada__containers__formal_ordered_maps__olt.olt e1 e2) && not (Ada__containers__formal_ordered_maps__olt.olt e2 e1)

 val equivalent_keys (e1:Ada__containers__formal_ordered_maps__key_type.base_type) (e2:Ada__containers__formal_ordered_maps__key_type.base_type) : bool
	ensures {  result = equivalent_keys__logic  e1 e2 }
end

module Ada__containers__formal_ordered_maps__clear
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length

  val clear (co:ref Ada__containers__formal_ordered_maps__map.__split_fields) (cap : Ada__containers__formal_ordered_maps__map.__split_discrs) : unit
     writes     { co }
     ensures { let rec_co = {Ada__containers__formal_ordered_maps__map.__split_fields = !co;
                              Ada__containers__formal_ordered_maps__map.__split_discrs = cap}  in
                   length_ rec_co = 0 }
end

module Ada__containers__formal_ordered_maps__assign
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__Oeq__2

  val assign (target:ref Ada__containers__formal_ordered_maps__map.__split_fields) (cap : Ada__containers__formal_ordered_maps__map.__split_discrs) (source:map) : unit
     requires { Ada__containers__count_type.to_rep (cap.rec__capacity) >= length_ source }
     writes     { target }
     reads      { target }
     ensures { let rec_t = {Ada__containers__formal_ordered_maps__map.__split_fields = !target;
                              Ada__containers__formal_ordered_maps__map.__split_discrs = cap}  in
                   oeq__2__logic rec_t source = True }
end

module Ada__containers__formal_ordered_maps__move
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__Oeq__2

  val move (target:ref Ada__containers__formal_ordered_maps__map.__split_fields) (t_cap : Ada__containers__formal_ordered_maps__map.__split_discrs) (source:ref Ada__containers__formal_ordered_maps__map.__split_fields) (s_cap : Ada__containers__formal_ordered_maps__map.__split_discrs) : unit
     requires { let rec_s = {Ada__containers__formal_ordered_maps__map.__split_fields = !source;
                              Ada__containers__formal_ordered_maps__map.__split_discrs = s_cap}  in
                   Ada__containers__count_type.to_rep (t_cap.rec__capacity) >= length_ rec_s }
     writes     { target, source }
     reads      { target, source }
     ensures { let rec_s = {Ada__containers__formal_ordered_maps__map.__split_fields = !source;
                              Ada__containers__formal_ordered_maps__map.__split_discrs = s_cap}  in
               let rec_t = {Ada__containers__formal_ordered_maps__map.__split_fields = !target;
                              Ada__containers__formal_ordered_maps__map.__split_discrs = t_cap}  in
               let old_s = {Ada__containers__formal_ordered_maps__map.__split_fields = old !source;
                              Ada__containers__formal_ordered_maps__map.__split_discrs = s_cap}  in
                   oeq__2__logic rec_t old_s = True /\ length_ rec_s = 0 }
end

module Ada__containers__formal_ordered_maps__copy
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__strict_equal

  function copy__logic map int : map

  axiom copy__def:
    forall co : map, cap : int [copy__logic co cap].
       strict_equal__logic co (copy__logic co cap) = True /\
       (cap = 0 -> capacity co = capacity (copy__logic co cap)) /\
       (cap >= capacity co ->  capacity (copy__logic co cap) = cap)

  val copy (co: map) (cap:int) : map
     requires { cap = 0 \/ cap >= capacity co}
     ensures { result = copy__logic co cap /\ map_inv result }
end

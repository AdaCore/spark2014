module Ada__containers__formal_ordered_maps__witness
  use import real.Real
  use "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__key_type
  use "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__olt

  function witness Ada__containers__formal_ordered_maps__key_type.base_type : real

  axiom olt_witness :
    (forall k1  k2 : Ada__containers__formal_ordered_maps__key_type.base_type [Ada__containers__formal_ordered_maps__olt.olt k1 k2].
	Real.(<) (witness k1) (witness k2) <-> Ada__containers__formal_ordered_maps__olt.olt k1 k2 = True)
end

module Ada__containers__formal_ordered_maps__map
  use import int.Int
  use import "_gnatprove_standard".Main
  use Ada__containers__hash_type
  use Ada__containers__count_type

  type map

  function rec__capacity map : Ada__containers__count_type.count_type

   function capacity  (co : map) : int =
          Ada__containers__count_type.to_int (rec__capacity co)

  function to_base "inline" (co : map) : map = co

  function of_base "inline" (co : map) : map = co
end

module Ada__containers__formal_ordered_maps__length
  use import int.Int
  use import "_gnatprove_standard".Main
  use Ada__containers__count_type
  use import Ada__containers__formal_ordered_maps__map

  function length map : Ada__containers__count_type.count_type

  function length_ "inline" (co : map) : int =
    Ada__containers__count_type.to_int (length co)

  axiom length_range:
    forall co:map [length co]. 0 <= length_ co <= capacity co

  val length (co : map) :  Ada__containers__count_type.count_type
     ensures { result = length co }
end

module Ada__containers__formal_ordered_maps__cursor
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__key_type
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length

  type cursor

  function position map cursor : int

  function position_inv map int : cursor

  axiom position_gte_zero:
    forall co:map, cu:cursor [position co cu].
        length_ co >= position co cu >= 0

  axiom position_eq1:
   forall co:map, i :int [position co (position_inv co i)]. 0 < i <= length_ co -> 
              position co (position_inv co i) = i

  axiom position_eq2:
    forall co:map, cu:cursor [position co cu].
          position co cu > 0 -> position_inv co (position co cu) = cu
end

module Ada__containers__formal_ordered_maps__no_element
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__cursor

  function no_element : cursor

  axiom position_no_element:
    forall co:map [position co no_element]. position co no_element = 0
end

module Ada__containers__formal_ordered_maps__empty_map
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length

  function empty_map : map

  axiom Empty_is_empty: length_ empty_map = 0
end

module Ada__containers__formal_ordered_maps__is_empty
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length

  function is_empty map : bool

  axiom is_empty:
    forall co:map [is_empty (co)]. 
          is_empty (co) = True <-> length_ co = 0

  val is_empty (co:map) : bool
     ensures  { result = is_empty co }
end

module Ada__containers__formal_ordered_maps__key
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__key_type
  use import Ada__containers__formal_ordered_maps__witness
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__cursor

  function key map cursor : Ada__containers__formal_ordered_maps__key_type.key_type

  axiom ordered:
    forall s:map, cu1 cu2:cursor [key s cu2, key s cu1].
       position s cu1 > 0 -> position s cu2 > 0 ->
         (position s cu1 > position s cu2 <-> Real.(>) (witness (Ada__containers__formal_ordered_maps__key_type.to_base (key s cu1))) (witness (Ada__containers__formal_ordered_maps__key_type.to_base (key s cu2))))

  val key (co:map) (cu:cursor) : Ada__containers__formal_ordered_maps__key_type.key_type
     requires { position co cu > 0 }
     ensures  { result = key co cu }
end

module Ada__containers__formal_ordered_maps__element
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__element_type
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__cursor

  function element map cursor : Ada__containers__formal_ordered_maps__element_type.element_type

  val element (co:map) (cu:cursor) : Ada__containers__formal_ordered_maps__element_type.element_type
     requires { position co cu > 0 }
     ensures  { result = element co cu }
end

module Ada__containers__formal_ordered_maps__previous
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__no_element

  function previous map cursor : cursor

  axiom previous_in:
    forall co:map, cu:cursor [previous co cu].
	(position co cu > 1 \/ position co (previous co cu) > 0) ->
	position co (previous co cu) = position co cu - 1

  axiom previous_ext:
    forall co:map, cu:cursor [previous co cu].
        (position co cu = 1 \/ cu = no_element) -> previous co cu = no_element

  val previous (co:map) (cu:cursor) : cursor
     requires { cu = no_element \/ position co cu > 0 }
     ensures  { result = previous co cu }
end

module Ada__containers__formal_ordered_maps__previous__2
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__no_element
  use import Ada__containers__formal_ordered_maps__previous

  val previous__2 (co:map) (cu:ref cursor) : unit
     requires { !cu = no_element \/ position co !cu > 0 }
     writes     { cu }
     reads      { cu }
     ensures  { !cu = previous co (old !cu) }
end

module Ada__containers__formal_ordered_maps__next
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__no_element

  function next map cursor : cursor

  axiom next_in:
    forall co:map, cu:cursor [next co cu].
	(length_ co > position co cu > 0 \/ position co (next co cu) > 0) ->
	position co (next co cu) = position co cu + 1

  axiom next_ext:
    forall co:map, cu:cursor [next co cu].
        (position co cu = length_ co \/ cu = no_element) -> next co cu = no_element

  val next (co:map) (cu:cursor) : cursor
     requires { cu = no_element \/ position co cu > 0 }
     ensures  { result = next co cu }
end

module Ada__containers__formal_ordered_maps__next__2
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__no_element
  use import Ada__containers__formal_ordered_maps__next

  val next__2 (co:map) (cu:ref cursor) : unit
     requires { !cu = no_element \/ position co !cu > 0 }
     writes     { cu }
     reads      { cu }
     ensures  { !cu = next co (old !cu) }
end

module Ada__containers__formal_ordered_maps__last
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__no_element

  function last map : cursor

  axiom last_empty:
    forall co:map [last co]. length_ co = 0 <-> last co = no_element

  axiom last_gen:
    forall co:map [last co]. length_ co = position co (last co)

  val last (co:map) : cursor
     ensures  { result = last co }
end

module Ada__containers__formal_ordered_maps__first
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__no_element

  function first map : cursor

  axiom first_empty:
    forall co:map [first co]. length_ co = 0 <-> first co = no_element

  axiom first_gen:
    forall co:map [first co]. length_ co > 0 -> position co (first co) = 1

  val first (co:map) : cursor
     ensures  { result = first co }
end

module Ada__containers__formal_ordered_maps__first_key
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__key_type
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__first
  use import Ada__containers__formal_ordered_maps__key

  function first_key (co:map) : Ada__containers__formal_ordered_maps__key_type.key_type = key co (first co)

  val first_key (co:map) : Ada__containers__formal_ordered_maps__key_type.key_type
     requires { length_ co > 0 }
     ensures  { result = key co (first co) }
end

module Ada__containers__formal_ordered_maps__last_key
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__key_type
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__last
  use import Ada__containers__formal_ordered_maps__key

  function last_key (co:map) : Ada__containers__formal_ordered_maps__key_type.key_type = key co (last co)

  val last_key (co:map) : Ada__containers__formal_ordered_maps__key_type.key_type
     requires { length_ co > 0 }
     ensures  { result = key co (last co) }
end

module Ada__containers__formal_ordered_maps__first_element
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__element_type
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__first
  use import Ada__containers__formal_ordered_maps__element

  function first_element (co:map) : Ada__containers__formal_ordered_maps__element_type.element_type = element co (first co)

  val first_element (co:map) : Ada__containers__formal_ordered_maps__element_type.element_type
     requires { length_ co > 0 }
     ensures  { result = element co (first co) }
end

module Ada__containers__formal_ordered_maps__last_element
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__element_type
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__last
  use import Ada__containers__formal_ordered_maps__element

  function last_element (co:map) : Ada__containers__formal_ordered_maps__element_type.element_type = element co (last co)

  val last_element (co:map) : Ada__containers__formal_ordered_maps__element_type.element_type
     requires { length_ co > 0 }
     ensures  { result = element co (last co) }
end

module Ada__containers__formal_ordered_maps__find
  use import int.Int
  use import "_gnatprove_standard".Main
  use  "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__key_type
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__witness
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__no_element
  use import Ada__containers__formal_ordered_maps__key

  function find_ map real : cursor
  
  predicate find__ (co : map) (i : real) (cu : cursor) =
    (cu = (no_element  : cursor) /\
      (forall cun:cursor.
        position co cun >  0 ->
         witness (Ada__containers__formal_ordered_maps__key_type.to_base (key co cun)) <> i)) \/
     (position co cu > 0 /\
      witness (Ada__containers__formal_ordered_maps__key_type.to_base (key co cu)) = i)
  
  axiom Find_find_val:
    (forall co:map.
      (forall i:real.
        ((find__ co i (find_ co i)) /\
         ((length_ co = 0) -> (find_ co i = no_element )))))

  function find "inline" (co : map) (e:Ada__containers__formal_ordered_maps__key_type.base_type) : cursor =
  find_ co (witness e)

  val find (co:map) (e:Ada__containers__formal_ordered_maps__key_type.base_type)  : cursor
     ensures  { result = find co e }
end

module Ada__containers__formal_ordered_maps__element__2
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__element_type
  use import Ada__containers__formal_ordered_maps__witness
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__element
  use import Ada__containers__formal_ordered_maps__find

  function element__2 "inline" (co:map) (k:Ada__containers__formal_ordered_maps__key_type.base_type) : Ada__containers__formal_ordered_maps__element_type.element_type =
element co (find_ co (witness k))

  val element__2 (co:map) (k:Ada__containers__formal_ordered_maps__key_type.base_type) : Ada__containers__formal_ordered_maps__element_type.element_type
     requires { position co (find_ co (witness k)) > 0 }
     ensures  { result = element__2 co k }
end

module Ada__containers__formal_ordered_maps__ceiling
  use import int.Int
  use import "_gnatprove_standard".Main
  use  "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__key_type
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__witness
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__no_element
  use import Ada__containers__formal_ordered_maps__last
  use import Ada__containers__formal_ordered_maps__key
  
  function ceiling_ map real : cursor
  
  predicate is_ceiling (s : map) (i : real) (cu : cursor) =
     (cu = no_element  /\
       (length_ s = 0 \/ length_ s > 0 /\
        Real.(>) i (witness (Ada__containers__formal_ordered_maps__key_type.to_base (key s (last s)))))) \/
      (position s cu > 0 /\
       Real.(<=) i (witness (Ada__containers__formal_ordered_maps__key_type.to_base (key s cu))) /\
	(forall cun : cursor [key s cun]. 0 < position s cun < position s cu
	 -> Real.(>) i (witness (Ada__containers__formal_ordered_maps__key_type.to_base (key s cun)))))
  
  axiom ceiling_is_ceiling:
    forall s:map.
      forall i:real [(ceiling_ s i : cursor)].
        is_ceiling s i (ceiling_ s i : cursor)

  function ceiling  "inline" (co:map) (e:Ada__containers__formal_ordered_maps__key_type.base_type) : cursor =
 ceiling_ co (witness e)

  val ceiling (co:map) (e:Ada__containers__formal_ordered_maps__key_type.base_type) :cursor
     ensures { result = ceiling_ co (witness e) }
end

module Ada__containers__formal_ordered_maps__floor
  use import int.Int
  use import "_gnatprove_standard".Main
  use  "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__key_type
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__witness
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__no_element
  use import Ada__containers__formal_ordered_maps__first
  use import Ada__containers__formal_ordered_maps__key
  
  function floor_ map real : cursor
  
  predicate is_floor (s : map) (i : real) (cu : cursor) =
     (cu = no_element  /\
       (length_ s = 0 \/ length_ s > 0 /\
         Real.(<) i (witness (Ada__containers__formal_ordered_maps__key_type.to_base (key s (first s)))))) \/
      (position s cu > 0 /\
       Real.(>=) i (witness (Ada__containers__formal_ordered_maps__key_type.to_base (key s cu))) /\
	(forall cun : cursor. position s cu < position s cun
	 ->  Real.(<) i (witness (Ada__containers__formal_ordered_maps__key_type.to_base (key s cun)))))
  
  axiom floor_is_floor:
    (forall s:map.
      (forall i:real [(floor_ s i : cursor)].
        (is_floor s i (floor_ s i : cursor))))

  function floor  "inline" (co:map) (e:Ada__containers__formal_ordered_maps__key_type.base_type) : cursor =
 floor_ co (witness e)

  val floor (co:map) (e:Ada__containers__formal_ordered_maps__key_type.base_type) :cursor
     ensures { result = floor_ co (witness e) }
end

module Ada__containers__formal_ordered_maps__left
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_maps__witness
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__no_element
  use import Ada__containers__formal_ordered_maps__key
  use import Ada__containers__formal_ordered_maps__element
  use import Ada__containers__formal_ordered_maps__find

  function left map cursor : map

  axiom left_no_element:
    forall co:map [left co no_element]. left co no_element = co

  axiom left_length_:
    forall co:map, cu:cursor [left co cu].
	position co cu > 0 -> length_ (left co cu) = position co cu - 1

  axiom left_position_in:
    forall co:map, cu cun:cursor [position (left co cu) cun | left co cu, position co cun].
	(position (left co cu) cun > 0 \/ position co cun < position co cu) ->
	position (left co cu) cun = position co cun

  axiom left_position_ext:
    forall co:map, cu cun:cursor [position (left co cu) cun].
	position co cun >= position co cu > 0 ->
	position (left co cu) cun = 0

  axiom left_key:
    forall co:map, cu cun:cursor [key (left co cu) cun | left co cu, key co cun].
	(position (left co cu) cun > 0 \/ 0 < position co cun < position co cu) ->
	key (left co cu) cun = key co cun

  axiom left_element:
    forall co:map, cu cun:cursor [element (left co cu) cun | left co cu, element co cun].
	(position (left co cu) cun > 0 \/ 0 < position co cun < position co cu) ->
	element (left co cu) cun = element co cun

  axiom left_find :
    forall co:map, cu:cursor, w:real [find_ co w, left co cu|
     find_ (left co cu) w].
     ((position co cu > position co (find_ co w) > 0 \/
      position (left co cu) (find_ (left co cu) w) > 0) ->
      find_ co w = find_ (left co cu) w) /\
      (position co (find_ co w) >= position co cu -> find_ (left co cu) w = no_element)

  axiom left_find_elt :
    forall co:map, cu:cursor, w:real [key co cu, find_ co w, left co cu|
     key co cu, find_ (left co cu) w].
     (Real.(>) (witness (Ada__containers__formal_ordered_maps__key_type.to_base (key co cu))) w  ->
      find_ co w = find_ (left co cu) w) /\
     (Real.(<=) (witness (Ada__containers__formal_ordered_maps__key_type.to_base (key co cu))) w  ->
      find_ (left co cu) w = no_element) 
     
  val left (co:map) (cu:cursor) : map
     requires { cu = no_element \/ position co cu > 0 }
     ensures  { result = left co cu }
end

module Ada__containers__formal_ordered_maps__right
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_maps__witness
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__empty_map
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__no_element
  use import Ada__containers__formal_ordered_maps__key
  use import Ada__containers__formal_ordered_maps__element
  use import Ada__containers__formal_ordered_maps__find

  function right map cursor : map

  axiom right_no_element:
    forall co:map [right co no_element]. right co no_element = empty_map

  axiom right_length_:
    forall co:map, cu:cursor [length_ (right co cu) ].
	position co cu > 0 -> length_ (right co cu) = (length_ co) - (position co cu) + 1

  axiom right_position_in:
    forall co:map, cu cun:cursor [position (right co cu) cun | right co cu, position co cun].
	(position (right co cu) cun > 0 \/ position co cun >= position co cu > 0) ->
	position (right co cu) cun = (position co cun) - (position co cu) + 1

  axiom right_position_ext:
    forall co:map, cu cun:cursor [position (right co cu) cun].
	position co cun < position co cu -> position (right co cu) cun = 0

  axiom right_key:
    forall co:map, cu cun:cursor [key (right co cu) cun | right co cu, key co cun].
	(position (right co cu) cun > 0 \/ 0 < position co cu <= position co cun) ->
	key (right co cu) cun = key co cun

  axiom right_element:
    forall co:map, cu cun:cursor [element (right co cu) cun | right co cu, element co cun].
	(position (right co cu) cun > 0 \/ 0 < position co cu <= position co cun) ->
	element (right co cu) cun = element co cun

  axiom right_find :
    forall co:map, cu:cursor, w:real [find_ (right co cu) w| right co cu,
     find_ co w].
     ((0 < position co cu <= position co (find_ co w) \/
      position (right co cu) (find_ (right co cu) w) > 0) ->
      find_ co w = find_ (right co cu) w) /\
      (position co (find_ co w) < position co cu -> find_ (right co cu) w = no_element)

  axiom right_find_elt :
    forall co:map, cu:cursor, w:real [key co cu, find_ co w, right co cu|
     key co cu, find_ (right co cu) w].
     (Real.(<=) (witness (Ada__containers__formal_ordered_maps__key_type.to_base (key co cu))) w  ->
      find_ co w = find_ (right co cu) w) /\
     (Real.(>) (witness (Ada__containers__formal_ordered_maps__key_type.to_base (key co cu))) w  ->
      find_ (right co cu) w = no_element) 

  val right (co:map) (cu:cursor) : map
     requires { cu = no_element \/ position co cu > 0 }
     ensures  { result = right co cu }
end

module Ada__containers__formal_ordered_maps__replace
  use import int.Int
  use import "_gnatprove_standard".Main
  use  "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__key_type
  use "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__element_type
  use import Ada__containers__formal_ordered_maps__witness
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__empty_map
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__no_element
  use import Ada__containers__formal_ordered_maps__key
  use import Ada__containers__formal_ordered_maps__element
  use import Ada__containers__formal_ordered_maps__find 

  predicate replace (co1:map) (k:Ada__containers__formal_ordered_maps__key_type.base_type) (e:Ada__containers__formal_ordered_maps__element_type.base_type) (co2:map) =
    (position co1 (find_ co1 (witness k)) > 0 /\
      length_ co1 = length_ co2 /\
       Ada__containers__formal_ordered_maps__key_type.to_base (key co2 (find_ co1 (witness k))) = k /\
       Ada__containers__formal_ordered_maps__element_type.to_base (element co2 (find_ co1 (witness k))) = e /\
        (forall cun:cursor [position co2 cun | position co1 cun]. position co2 cun = position co1 cun) /\
         (forall cun:cursor [key co2 cun | key co1 cun].
           position co1 cun > 0 /\ not cun = find_ co1 (witness k) ->
            key co2 cun = key co1 cun) /\
         (forall cun:cursor [element co2 cun | element co1 cun].
           position co1 cun > 0 /\ not cun = find_ co1 (witness k) ->
            element co2 cun = element co1 cun) /\
          (forall w:real [find_ co1 w | find_ co2 w]. find_ co1 w = find_ co2 w)) /\
     capacity co1 = capacity co2 

  val replace (co :ref map) (k:Ada__containers__formal_ordered_maps__key_type.base_type) (e:Ada__containers__formal_ordered_maps__element_type.base_type) : unit
     requires { find_ !co (witness k) <> no_element }
     writes { co }
     reads { co }
     ensures { replace (old !co) k e !co }
end

module Ada__containers__formal_ordered_maps__replace_element
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__key_type
  use "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__element_type
  use import Ada__containers__formal_ordered_maps__witness
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__no_element
  use import Ada__containers__formal_ordered_maps__key
  use import Ada__containers__formal_ordered_maps__element
  use import Ada__containers__formal_ordered_maps__find

  predicate replace_element map cursor Ada__containers__formal_ordered_maps__element_type.base_type map

  axiom replace_element_length_:
    forall co1 co2:map, cu:cursor, e:Ada__containers__formal_ordered_maps__element_type.base_type
      [replace_element co1 cu e co2].
      replace_element co1 cu e co2 -> length_ co1 = length_ co2

  axiom replace_element_capacity:
    forall co1 co2:map, cu:cursor, e:Ada__containers__formal_ordered_maps__element_type.base_type
      [replace_element co1 cu e co2, capacity co1|replace_element co1 cu e co2, capacity co2].
      replace_element co1 cu e co2 -> capacity co1 = capacity co2

  axiom replace_element_position:
    forall co1 co2:map, cu cun:cursor, e:Ada__containers__formal_ordered_maps__element_type.base_type
      [replace_element co1 cu e co2, position co2 cun
     | replace_element co1 cu e co2, position co1 cun].
      replace_element co1 cu e co2 -> position co2 cun = position co1 cun

  axiom replace_element_key:
    forall co1 co2:map, cu cun:cursor, e:Ada__containers__formal_ordered_maps__element_type.base_type
      [replace_element co1 cu e co2, key co2 cun
     | replace_element co1 cu e co2, key co1 cun].
      replace_element co1 cu e co2 -> position co1 cun > 0 ->
        key co2 cun = key co1 cun

  axiom replace_element_element_in:
    forall co1 co2:map, cu:cursor, e:Ada__containers__formal_ordered_maps__element_type.base_type
      [replace_element co1 cu e co2].
      replace_element co1 cu e co2 -> Ada__containers__formal_ordered_maps__element_type.to_base (element co2 cu) = e

  axiom replace_element_element_ext:
    forall co1 co2:map, cu cun:cursor, e:Ada__containers__formal_ordered_maps__element_type.base_type
      [replace_element co1 cu e co2, element co2 cun
     | replace_element co1 cu e co2, element co1 cun].
      replace_element co1 cu e co2 -> cu <> cun -> position co1 cun > 0 ->
        element co2 cun = element co1 cun

  axiom replace_element_find:
    forall co1 co2:map, cu:cursor, w:real, e:Ada__containers__formal_ordered_maps__element_type.base_type
      [replace_element co1 cu e co2, find_ co2 w
     | replace_element co1 cu e co2, find_ co1 w].
       replace_element co1 cu e co2 -> find_ co1 w = find_ co2 w

  val replace_element (co:ref map) (cu:cursor) (e:Ada__containers__formal_ordered_maps__element_type.base_type) : unit
     requires { position !co cu > 0 }
     writes     { co }
     reads      { co }
     ensures { replace_element (old !co) cu e !co }
end

module Ada__containers__formal_ordered_maps__insert
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__key_type
  use "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__element_type
  use import Ada__containers__formal_ordered_maps__witness
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__no_element
  use import Ada__containers__formal_ordered_maps__last
  use import Ada__containers__formal_ordered_maps__key
  use import Ada__containers__formal_ordered_maps__element
  use import Ada__containers__formal_ordered_maps__find
  use import Ada__containers__formal_ordered_maps__ceiling

  predicate insert map Ada__containers__formal_ordered_maps__key_type.base_type  Ada__containers__formal_ordered_maps__element_type.base_type map

  axiom insert_length_:
    forall co1 co2:map,  k:Ada__containers__formal_ordered_maps__key_type.base_type, e:Ada__containers__formal_ordered_maps__element_type.base_type
      [insert co1 k e co2].
      insert co1 k e co2 -> length_ co1 + 1 = length_ co2 /\ find_ co1 (witness k) = no_element /\ Ada__containers__formal_ordered_maps__key_type.to_base (key co2 (find_ co2 (witness k))) = k /\ Ada__containers__formal_ordered_maps__element_type.to_base (element co2 (find_ co2 (witness k))) = e

  axiom insert_capacity:
    forall co1 co2:map,  k:Ada__containers__formal_ordered_maps__key_type.base_type, e:Ada__containers__formal_ordered_maps__element_type.base_type
      [insert co1 k e co2, capacity co1|insert co1 k e co2, capacity co2].
      insert co1 k e co2 -> capacity co1 = capacity co2

  axiom insert_new:
    forall co1 co2:map,  k:Ada__containers__formal_ordered_maps__key_type.base_type, e:Ada__containers__formal_ordered_maps__element_type.base_type [insert co1 k e co2].
      insert co1 k e co2 -> (ceiling_ co1 (witness k) <> no_element ->
      position co2 (find_ co2 (witness k)) = position co1 (ceiling_ co1 (witness k))) /\ (ceiling_ co1 (witness k) = no_element ->
      find_ co2 (witness k) = last co2)

  axiom insert_position_before:
    forall co1 co2:map, cun:cursor,  k:Ada__containers__formal_ordered_maps__key_type.base_type, e:Ada__containers__formal_ordered_maps__element_type.base_type
      [insert co1 k e co2,  position co1 cun
     | insert co1 k e co2,  position co2 cun].
    let i = position co2 (find_ co2 (witness k)) in
      insert co1 k e co2 ->
      (i > position co1 cun > 0 \/ position co2 cun < i) ->
        position co1 cun = position co2 cun

  axiom insert_position_after:
    forall co1 co2:map, cun:cursor,  k:Ada__containers__formal_ordered_maps__key_type.base_type, e:Ada__containers__formal_ordered_maps__element_type.base_type
      [insert co1 k e co2,  position co1 cun
     | insert co1 k e co2,  position co2 cun].
    let i = position co2 (find_ co2 (witness k)) in
      insert co1 k e co2 ->
      (position co1 cun >= i \/ position co2 cun > i) ->
        position co1 cun + 1 = position co2 cun

  axiom insert_key:
    forall co1 co2:map, cun:cursor,  k:Ada__containers__formal_ordered_maps__key_type.base_type, e:Ada__containers__formal_ordered_maps__element_type.base_type
      [insert co1 k e co2,  key co1 cun
     | insert co1 k e co2,  key co2 cun].
      insert co1 k e co2 ->
      (position co1 cun > 0 \/ position co2 cun > 0 /\ find_ co2 (witness k) <> cun) ->
        key co1 cun = key co2 cun

  axiom insert_element:
    forall co1 co2:map, cun:cursor,  k:Ada__containers__formal_ordered_maps__key_type.base_type, e:Ada__containers__formal_ordered_maps__element_type.base_type
      [insert co1 k e co2,  element co1 cun
     | insert co1 k e co2,  element co2 cun].
      insert co1 k e co2 ->
      (position co1 cun > 0 \/ position co2 cun > 0 /\ find_ co2 (witness k) <> cun) ->
        element co1 cun = element co2 cun

  axiom insert_find :
    forall co1:map, co2:map, w:real,  k:Ada__containers__formal_ordered_maps__key_type.base_type, e:Ada__containers__formal_ordered_maps__element_type.base_type
     [insert co1 k e co2, find_ co1 w| insert co1 k e co2, find_ co2 w].
      insert co1 k e co2 -> not witness k = w -> find_ co1 w = find_ co2 w

  val insert (co:ref map) (k:Ada__containers__formal_ordered_maps__key_type.base_type) (e:Ada__containers__formal_ordered_maps__element_type.base_type)  (p:ref cursor) (inserted : ref bool) : unit
     requires { length_ !co < capacity !co }
     writes     { co, p, inserted }
     reads      { co }
     ensures { (!inserted = True <-> find_(old  !co) (witness k) = no_element) /\ !p = find_ !co (witness k) /\
                          if !inserted = True then (insert (old !co) k e !co)
                                                                 else (!co = old !co) }
end

module Ada__containers__formal_ordered_maps__insert__2
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__key_type
  use import Ada__containers__formal_ordered_maps__witness
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__no_element
  use import Ada__containers__formal_ordered_maps__insert
  use import Ada__containers__formal_ordered_maps__find

  val insert__2 (co:ref map)  (k:Ada__containers__formal_ordered_maps__key_type.base_type) (e:Ada__containers__formal_ordered_maps__element_type.base_type) : unit
     requires { length_ !co < capacity !co /\ find_ !co (witness k) = no_element }
     writes     { co }
     reads      { co }
     ensures { insert (old !co) k e !co }
end

module Ada__containers__formal_ordered_maps__delete
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__key_type
  use import Ada__containers__formal_ordered_maps__witness
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__no_element
  use import Ada__containers__formal_ordered_maps__next
  use import Ada__containers__formal_ordered_maps__key
  use import Ada__containers__formal_ordered_maps__element
  use import Ada__containers__formal_ordered_maps__find

  predicate delete map cursor map

  axiom delete_capacity:
    forall co1 co2:map, cu:cursor
      [delete co1 cu co2, capacity co1|delete co1 cu co2, capacity co2].
      delete co1 cu co2 -> capacity co1 = capacity co2

  axiom delete_length_:
    forall co1 co2:map, cu:cursor
      [delete co1 cu co2].
      delete co1 cu co2 -> length_ co1 = length_ co2 + 1

  axiom delete_position_before:
    forall co1 co2:map, cu cun:cursor
      [delete co1 cu co2,  position co1 cun
     | delete co1 cu co2,  position co2 cun].
      delete co1 cu co2 ->
      (position co1 cu > position co1 cun \/ 0 < position co2 cun < position co1 cu) ->
        position co1 cun = position co2 cun

  axiom delete_position_after:
    forall co1 co2:map, cu cun:cursor
      [delete co1 cu co2,  position co1 cun | delete co1 cu co2,  position co2 cun].
      delete co1 cu co2 ->
      (position co1 cun > position co1 cu \/ position co2 cun >= position co1 cu) ->
        position co1 cun = position co2 cun + 1

  axiom delete_position_range:
    forall co1 co2:map, cu:cursor [delete co1 cu co2].
      delete co1 cu co2 -> position co2 cu = 0 /\ 0 < position co1 cu /\ find_ co2 (witness (Ada__containers__formal_ordered_maps__key_type.to_base (key co1 cu))) = no_element

  axiom delete_position_next:
    forall co1 co2:map, cu:cursor [delete co1 cu co2].
      delete co1 cu co2 -> position co1 (next co1 cu) >= 0

  axiom delete_key:
    forall co1 co2:map, cu cun:cursor
      [delete co1 cu co2,  key co1 cun
     | delete co1 cu co2,  key co2 cun].
      delete co1 cu co2 ->
      0 < position co2 cun ->
        key co1 cun = key co2 cun  

  axiom delete_element:
    forall co1 co2:map, cu cun:cursor
      [delete co1 cu co2,  element co1 cun
     | delete co1 cu co2,  element co2 cun].
      delete co1 cu co2 ->
      0 < position co2 cun ->
        element co1 cun = element co2 cun  

  axiom delete_find :
    forall co1:map, co2:map, cu:cursor, w:real [delete co1 cu co2,
     find_ co1 w| delete co1 cu co2, find_ co2 w].
     delete co1 cu co2 -> not witness (Ada__containers__formal_ordered_maps__key_type.to_base (key co1 cu)) = w -> find_ co1 w = find_ co2 w

  val delete (co:ref map) (e : Ada__containers__formal_ordered_maps__key_type.base_type) : unit
     requires { find_ !co (witness e) <> no_element }
     writes     { co }
     reads      { co }
     ensures { delete (old !co) (find_ (old !co) (witness e)) !co }
end

module Ada__containers__formal_ordered_maps__delete__2
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__no_element
  use import Ada__containers__formal_ordered_maps__delete

  val delete__2 (co:ref map) (cu:ref cursor) : unit
     requires { position !co !cu > 0 }
     writes     { co, cu }
     reads      { co }
     ensures { delete (old !co) (old !cu) !co /\ !cu = no_element}
 end

module Ada__containers__formal_ordered_maps__delete_first
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__no_element
  use import Ada__containers__formal_ordered_maps__first
  use import Ada__containers__formal_ordered_maps__delete

  val delete__first (co:ref map) : unit
     writes     { co }
     reads      { co }
     ensures { if length_ (old !co) = 0 then !co = (old !co) else delete (old !co) (first (old !co)) !co }
 end

module Ada__containers__formal_ordered_maps__delete_last
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__no_element
  use import Ada__containers__formal_ordered_maps__last
  use import Ada__containers__formal_ordered_maps__delete

  val delete__last (co:ref map) : unit
     writes     { co }
     reads      { co }
     ensures { if length_ (old !co) = 0 then !co = (old !co) else delete (old !co) (last (old !co)) !co }
 end

module Ada__containers__formal_ordered_maps__include
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__key_type
  use import Ada__containers__formal_ordered_maps__witness
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__no_element
  use import Ada__containers__formal_ordered_maps__replace
  use import Ada__containers__formal_ordered_maps__insert
  use import Ada__containers__formal_ordered_maps__find

  val include (co:ref map) (k :Ada__containers__formal_ordered_maps__key_type.base_type) (e :Ada__containers__formal_ordered_maps__element_type.base_type) : unit
     requires {  length_ !co  < capacity !co}
     writes     { co }
     reads      { co }
     ensures { if find_ (old !co) (witness k) <> no_element then replace (old !co) k e !co
                         else insert (old !co) k e !co  }
end

module Ada__containers__formal_ordered_maps__exclude
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__key_type
  use import Ada__containers__formal_ordered_maps__witness
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__no_element
  use import Ada__containers__formal_ordered_maps__delete
  use import Ada__containers__formal_ordered_maps__find

  val exclude (co:ref map) (e :Ada__containers__formal_ordered_maps__key_type.base_type) : unit
     writes     { co }
     reads      { co }
     ensures { if find_ (old !co) (witness e) = no_element then  old !co = !co
                         else delete (old !co) (find_ (old !co) (witness e)) !co  }
end

module Ada__containers__formal_ordered_maps__has_element
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__cursor

  function has_element map cursor : bool

  axiom has_element_pos:
    forall co:map, cu:cursor [has_element co cu].
    has_element co cu = True -> 0 < position co cu

  axiom has_element_neg:
    forall co:map, cu:cursor [has_element co cu].
    has_element co cu <> True -> position co cu = 0

  val has_element (co:map) (cu:cursor) : bool
     ensures { has_element co cu = result }
end

module Ada__containers__formal_ordered_maps__contains
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__key_type
  use import Ada__containers__formal_ordered_maps__witness
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__find

  function contains map Ada__containers__formal_ordered_maps__key_type.base_type : bool

  axiom contains_c:
  forall co : map, e : Ada__containers__formal_ordered_maps__key_type.base_type [contains co e].
    contains co e = True <-> 0 < position co (find_ co (witness e))

  val contains (co:map) (e:Ada__containers__formal_ordered_maps__key_type.base_type) : bool
     ensures { contains co e = result }
end

module Ada__containers__formal_ordered_maps__strict_equal
  use import int.Int
  use import "_gnatprove_standard".Main
  use  "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__key_type
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__key
  use import Ada__containers__formal_ordered_maps__element

  function strict_equal map map : bool

  axiom strict_equal__def:
    forall co1 co2 : map [strict_equal co1 co2].
    ((forall cu:cursor [position co1 cu | position co2 cu].
       position co1 cu = position co2 cu) /\
     (forall cu:cursor [key co1 cu | key co2 cu]. position co1 cu > 0 ->
        Ada__containers__formal_ordered_maps__key_type.to_base (key co1 cu) = Ada__containers__formal_ordered_maps__key_type.to_base (key co2 cu)) /\
     (forall cu:cursor [element co1 cu | element co2 cu]. position co1 cu > 0 ->
        Ada__containers__formal_ordered_maps__element_type.to_base (element co1 cu) = Ada__containers__formal_ordered_maps__element_type.to_base (element co2 cu))) <->  strict_equal co1 co2 = True

  axiom strict_equal_length_:
    forall co1 co2 : map [strict_equal co1 co2].
     strict_equal co1 co2 = True -> length_ co1 = length_ co2

    val strict_equal (co1:map) (co2:map) : bool
     ensures  { result  = strict_equal co1 co2 }
end

module Ada__containers__formal_ordered_maps__Oeq__2
  use import int.Int
  use  "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__key_type
  use  "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__element_type
  use "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__oeq
  use import Ada__containers__formal_ordered_maps__witness
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__no_element
  use import Ada__containers__formal_ordered_maps__key
  use import Ada__containers__formal_ordered_maps__element
  use import Ada__containers__formal_ordered_maps__find

  function oeq__2 map map : bool

  axiom oeq__2_length_:
   forall co1 co2 : map [oeq__2 co1 co2].
   oeq__2 co1 co2 = True -> length_ co1 = length_ co2

  axiom oeq__2_element:
   forall co1 co2 : map [oeq__2 co1 co2]. oeq__2 co1 co2 = True ->
   forall cu1:cursor [key co1 cu1]. position co1 cu1 > 0 ->
	let cu2 = find_ co2 (witness (Ada__containers__formal_ordered_maps__key_type.to_base (key co1 cu1))) in
          Ada__containers__formal_ordered_maps__oeq.oeq (Ada__containers__formal_ordered_maps__element_type.to_base (element co2 cu2)) (Ada__containers__formal_ordered_maps__element_type.to_base (element co1 cu1)) = True

  axiom oeq__2_inv:
   forall co1 co2 : map [oeq__2 co1 co2]. oeq__2 co1 co2 <> True ->
   (length_ co1 <> length_ co2 \/
   exists e : real. position co1 (find_ co1 e) > 0 /\
         (find_ co2 e = no_element \/ position co2 (find_ co2 e) > 0 /\ 
          Ada__containers__formal_ordered_maps__oeq.oeq (Ada__containers__formal_ordered_maps__element_type.to_base (element co2 (find_ co2 e))) (Ada__containers__formal_ordered_maps__element_type.to_base (element co1 (find_ co1 e))) <> True))

  axiom oeq__2_sym :
  forall e1 e2 : map [oeq__2 e1 e2].
	oeq__2 e1 e2 = True -> oeq__2 e2 e1 = True

  axiom oeq__2_trans :
  forall e1 e2 e3 : map [oeq__2 e1 e2, oeq__2 e1 e3 | oeq__2 e1 e2, oeq__2 e2 e3].
	oeq__2 e1 e2 = True -> oeq__2 e2 e3 = True -> oeq__2 e1 e3 = True

  val oeq__2 (co1:map) (co2:map) : bool
     ensures  { result  = oeq__2 co1 co2 }
end

module Ada__containers__formal_ordered_maps__overlap
  use import int.Int
  use import "_gnatprove_standard".Main
  use  "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__key_type
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__no_element
  use import Ada__containers__formal_ordered_maps__find

  function overlap map map : bool  

  axiom overlap__def :
    forall s1:map, s2:map [overlap s1 s2].
     overlap s1 s2 <> True <->
      (forall i:real [find_ s1 i| find_ s2 i].
        find_ s1 i = no_element \/ find_ s2 i = no_element)

  val overlap (co1 co2:map) : bool
     ensures { result = overlap co1 co2 }
end

module Ada__containers__formal_ordered_maps__capacity
  use import int.Int
  use import "_gnatprove_standard".Main
  use Ada__containers__count_type
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length

  function capacity (co : map) : Ada__containers__count_type.count_type = rec__capacity co

  val capacity (co : map) : Ada__containers__count_type.count_type
    ensures { result = rec__capacity co }
end

module Ada__containers__formal_ordered_maps__reserve_capacity
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_maps__map

  val reserve_capacity (co : ref map) (c :  int) : unit
    requires { capacity !co >= c }
    ensures { !co = old !co }
end

module Ada__containers__formal_ordered_maps__equivalent_keys
  use "ada__containers__formal_ordered_maps__args".Ada__containers__formal_ordered_maps__key_type
  use import Ada__containers__formal_ordered_maps__witness
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__cursor
  use import Ada__containers__formal_ordered_maps__key

  function equivalent_keys (co1:map) (e1:Ada__containers__formal_ordered_maps__key_type.base_type) (co2:map) (e2:Ada__containers__formal_ordered_maps__key_type.base_type) : bool =
  if witness e1 = witness e2 then True else False

 val equivalent_keys__2  (co1:map) (e1:Ada__containers__formal_ordered_maps__key_type.base_type) (co2:map) (e2:Ada__containers__formal_ordered_maps__key_type.base_type) : bool
	ensures {  result = equivalent_keys co1 e1 co2 e2 }
end

module Ada__containers__formal_ordered_maps__clear
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  
  val clear (co:ref map) : unit
     writes     { co }
     ensures { length_ !co = 0 /\ capacity !co = capacity (old !co) }
end

module Ada__containers__formal_ordered_maps__assign
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__Oeq__2

  val assign (target:ref map) (source:map) : unit
     requires { capacity !target >= length_ source }
     writes     { target }
     reads      { target }
     ensures { oeq__2 !target source = True }
end

module Ada__containers__formal_ordered_maps__move
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__Oeq__2

  val move (target:ref map) (source:ref map) : unit
     requires { capacity !target >= length_ !source }
     writes     { target, source }
     reads      { target, source }
     ensures { oeq__2 !target (old !source) = True /\ length_ !source = 0 }
end

module Ada__containers__formal_ordered_maps__copy
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_maps__map
  use import Ada__containers__formal_ordered_maps__length
  use import Ada__containers__formal_ordered_maps__strict_equal

  predicate cap_is_max map map int

 axiom cap_is_max_def:
   forall co1 co2:map, max:int 
                  [cap_is_max co1 co2 max].
   if capacity co1 > max then capacity co2 = capacity co1 else capacity co2 = max

  function copy map int : map

  val copy (co: map) (cap:int) : map
     ensures { strict_equal co (result) = True /\ 
                      cap_is_max co result cap /\ result = copy co cap }
end

(* This file is generated by Why3's Coq-realize driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require bool.Bool.
Require map.Map.

(* Why3 goal *)
Definition t : Type.
exact Z.
Defined.

(* Why3 goal *)
Definition le: t -> t -> Prop.
exact Z.le.
Defined.

(* Why3 goal *)
Definition lt: t -> t -> Prop.
exact Z.lt.
Defined.

(* Why3 goal *)
Definition gt: t -> t -> Prop.
exact Z.gt.
Defined.

(* Why3 goal *)
Definition add: t -> t -> t.
intros x y; exact (x + y)%Z.
Defined.

(* Why3 goal *)
Definition sub: t -> t -> t.
intros x y; exact (x - y)%Z.
Defined.

(* Why3 goal *)
Definition one: t.
exact (1)%Z.
Defined.

(* Why3 assumption *)
Definition map (a:Type) := (map.Map.map t a).

Definition eq_bool {ty:Type} {ty_WT:WhyType ty} (x : ty) (y : ty) : bool.
destruct (why_decidable_eq x y) as [H|H].
exact true.
exact false.
Defined.

Fixpoint array_eq {ty:Type} {ty_WT:WhyType ty} (a : map.Map.map t ty)
  (af : t) (b : map.Map.map t ty) (bf : t) (h : nat) : bool :=
  match h with
  | O => eq_bool (map.Map.get a af) (map.Map.get b bf)
  | S (n) => andb (eq_bool (map.Map.get a af) (map.Map.get b bf)) (array_eq a (af + 1)%Z b (bf + 1)%Z n)
  end.

Lemma array_eq_def: 
forall {a:Type} {a_WT:WhyType a},
forall (a1:(map.Map.map t a)),
 forall (af:t),
  forall (b:(map.Map.map t a)),
   forall (bf:t),
    forall (h:nat),
      array_eq a1 af b bf h = true <->
      (forall (i:t), 
        (af <= i <= af + Z.of_nat h)%Z ->
            map.Map.get a1 i = map.Map.get b ((bf - af) + i))%Z.
intros a a_WT a1 af b bf h.
generalize af bf; clear af bf.
induction h; intros af bf; split.
 - simpl; unfold eq_bool.
   destruct (why_decidable_eq (Map.get a1 af) (Map.get b bf)) as [Heq | _];
   [intros _|intro Hwrong; contradict Hwrong; auto].
   intros i [Hil Hir].
   rewrite <- Zplus_0_r_reverse in Hir.
   apply (Z.le_antisymm _ _ Hir) in Hil.
   rewrite Hil.
   rewrite Heq.
   rewrite Z.sub_simpl_r.
   auto.
 - simpl; intro Helmt.
   rewrite (Helmt af) by omega.
   rewrite Z.sub_simpl_r.
   unfold eq_bool;
   destruct (why_decidable_eq (Map.get b bf) (Map.get b bf)) as [_ | Hwrong];
   [| contradict Hwrong]; auto.
 - unfold array_eq; fold array_eq; unfold eq_bool; unfold andb.
   destruct (why_decidable_eq (Map.get a1 af) (Map.get b bf)) as [Heq | _];
   [intro Helmt | intro Hwrong; contradict Hwrong; auto].
   intros i [Hil Hir].
   rewrite <- NPeano.Nat.add_1_r in Hir.
   rewrite Nat2Z.inj_add in Hir; simpl in Hir.
   rewrite <- (Zminus_plus_simpl_r bf af 1%Z).
   destruct (Z_le_lt_eq_dec _ _ Hil) as [Haf | Haf].
   * apply IHh; try omega; auto.
   * rewrite <- Haf.
     rewrite Zminus_plus_simpl_r.
     rewrite Z.sub_simpl_r; auto.
 - unfold array_eq; fold array_eq; unfold eq_bool; unfold andb.
   intro Helmt.
   rewrite (Helmt af) by omega.
   rewrite Z.sub_simpl_r.
   destruct (why_decidable_eq (Map.get b bf) (Map.get b bf)) as [_ | Hwrong];
   [| contradict Hwrong]; auto.
   apply IHh.
   intros i [Hil Hir].
   rewrite Zminus_plus_simpl_r.
   apply Helmt.
   rewrite <- NPeano.Nat.add_1_r.
   rewrite Nat2Z.inj_add; simpl.
   split; omega.
Qed.

(* Why3 goal *)
Definition bool_eq: forall {a:Type} {a_WT:WhyType a}, (map.Map.map t a) ->
  t -> t -> (map.Map.map t a) -> t -> t -> bool.
intros ty ty_WT a af al b bf bl.
destruct (Z_gt_le_dec af al) as [Ha|Ha].
exact (Zlt_bool bl bf).
destruct (Z_eq_dec (al - af)%Z (bl - bf)%Z) as [He|He]; [|exact false].
exact (array_eq a af b bf (Z.to_nat (al - af)%Z)).
Defined.

(* Why3 goal *)
Lemma T__ada_array___equal_def :
forall {a:Type} {a_WT:WhyType a},
forall (a1:(map.Map.map t a)),
 forall (af:t),
  forall (al:t),
   forall (b:(map.Map.map t a)),
    forall (bf:t),
     forall (bl:t),
      (((((le af al) /\ ((add (sub al af) one) = (add (sub bl bf) one)))
         \/ ((~ (le af al)) /\ (gt bf bl)))
        /\ forall (i:t),
            ((le af i) /\ (le i al)) ->
            ((map.Map.get a1 i) = (map.Map.get b (add (sub bf af) i)))) ->
       ((bool_eq a1 af al b bf bl) = true))
      /\ (((bool_eq a1 af al b bf bl) = true) ->
          ((((le af al) -> ((add (sub al af) one) = (add (sub bl bf) one)))
            /\ ((~ (le af al)) -> (gt bf bl)))
           /\ forall (i:t),
               ((le af i) /\ (le i al)) ->
               ((map.Map.get a1 i) = (map.Map.get b (add (sub bf af) i))))).
intros a a_WT a1 af al b bf bl.
unfold le; unfold gt; unfold add; unfold one; unfold sub; unfold bool_eq.
split.
 - intros [[[Ha Heq_lgth1] | [Ha_emp Hb_emp]] Helmt].
   * case (Z_gt_le_dec af al) as [Hwrong | _]; [contradiction |].
     case (Z.eq_dec (al - af) (bl - bf)) as [Heq_lgth | Hwrong].
     + clear Heq_lgth1.
       apply array_eq_def.
       apply Zle_minus_le_0 in Ha.
       apply Z2Nat.id in Ha.
       rewrite Ha.
       intros i [Hil Hir].
       apply Helmt; split; omega.
     + contradict Hwrong.
       apply Zeq_plus_swap in Heq_lgth1.
       rewrite Heq_lgth1; ring.
   * case (Z_gt_le_dec af al) as [_ | Hwrong]; [| contradiction].
     apply Zlt_is_lt_bool; omega.
 - case (Z_gt_le_dec af al) as [Ha | Ha].
   * intro Hb; split; [split | ].
     + intro Hwrong; contradict Hwrong; omega.
     + intros _; apply Zlt_is_lt_bool in Hb; omega.
     + intros i Hwrong; contradict Hwrong; omega.
   * case (Z.eq_dec (al - af) (bl - bf)) as [Heq_lgth | _];
     [|intro Hwrong; contradict Hwrong; auto].
     split; [split | ].
     + intros _; rewrite Heq_lgth; auto.
     + intro Hwrong; contradiction.
     + apply Zle_minus_le_0 in Ha.
       apply Z2Nat.id in Ha.
       rewrite <- (Zplus_minus af al).
       rewrite <- Ha.
       apply array_eq_def; auto.
Qed.

(* Why3 goal *)
Definition slide: forall {a:Type} {a_WT:WhyType a}, (map.Map.map t a) -> t ->
  t -> (map.Map.map t a).
intros ty ty_WT (a) of nf.
destruct (Z.eq_dec of nf) as [_ | _].
exact (Map._map_constr _ _ a).
exact (Map._map_constr _ _ (fun x => a (x - nf + of)%Z)).
Defined.

(* Why3 goal *)
Lemma slide_eq :
forall {a:Type} {a_WT:WhyType a},
forall (a1:(map.Map.map t a)),
 forall (first:t), ((slide a1 first first) = a1).
intros a a_WT (a1) first.
unfold slide; simpl.
destruct (Z.eq_dec first first) as [_ | Hwrong];
[| contradict Hwrong]; auto.
Qed.

(* Why3 goal *)
Lemma slide_def :
forall {a:Type} {a_WT:WhyType a},
forall (a1:(map.Map.map t a)),
 forall (old_first:t),
  forall (new_first:t),
   forall (i:t),
    ((map.Map.get (slide a1 old_first new_first) i) = (map.Map.get a1
                                                        (sub i
                                                          (sub new_first
                                                            old_first)))).
intros a a_WT (a1) old_first new_first i.
unfold Map.get; unfold slide; unfold sub; simpl.
destruct (Z.eq_dec old_first new_first) as [Ha | _].
 - rewrite Ha.
   rewrite Zminus_diag.
   rewrite <- Zminus_0_l_reverse.
   auto.
 - rewrite Z.sub_sub_distr.
   auto.
Qed.

(* Why3 goal *)
Definition concat: forall {a:Type} {a_WT:WhyType a}, (map.Map.map t a) ->
  t -> t -> (map.Map.map t a) -> t -> t -> (map.Map.map t a).
intros a a_WT (a1) af al (b) bf bl.
exact (Map._map_constr _ _
       (fun x => if Zle_bool x al then a1 x else b ((x - al) + (bf - 1))%Z)).
Defined.

(* Why3 goal *)
Lemma concat_def :
forall {a:Type} {a_WT:WhyType a},
forall (a1:(map.Map.map t a)) (b:(map.Map.map t a)),
 forall (a_first:t) (a_last:t) (b_first:t) (b_last:t),
  forall (i:t),
   (((le a_first i) /\ (le i a_last)) ->
    ((map.Map.get (concat a1 a_first a_last b b_first b_last) i) = (map.Map.get a1
                                                                    i)))
   /\ ((gt i a_last) ->
       ((map.Map.get (concat a1 a_first a_last b b_first b_last) i) = 
       (map.Map.get b (add (sub i a_last) (sub b_first one))))).
intros a a_WT (a1) (b) a_first a_last b_first b_last i.
unfold Map.get; unfold concat; unfold sub; unfold add; unfold one;
unfold le; unfold gt; simpl.
split.
 - intros [_ Hi].
   apply Zle_imp_le_bool in Hi; rewrite Hi; auto.
 - intro Hi.
   apply Zgt_not_le in Hi.
   rewrite <- Z.leb_nle in Hi.
   rewrite Hi; auto.
Qed.

Parameter to_rep : forall {a:Type} {a_WT:WhyType a}, a -> Z.

Fixpoint comp_rec {ty:Type} {ty_WT:WhyType ty} (a : map.Map.map t ty)
  (af : t) (ha : nat) (b : map.Map.map t ty) (bf : t) (hb : nat) : Z :=
  if Zlt_bool (to_rep (map.Map.get a af)) (to_rep (map.Map.get b bf)) then (-1)%Z
  else if Zgt_bool (to_rep (map.Map.get a af)) (to_rep (map.Map.get b bf)) then 1%Z
  else 
    match (ha, hb) with
    | (O, O)           => 0%Z
    | (O, S (nb))      => (-1)%Z
    | (S (na), O)      => 1%Z 
    | (S (na), S (nb)) => comp_rec a (af + 1)%Z na b (bf + 1)%Z nb 
end.

(* Why3 goal *)
Definition compare: forall {a:Type} {a_WT:WhyType a}, (map.Map.map t a) ->
  t -> t -> (map.Map.map t a) -> t -> t -> Z.
intros a a_WT a1 af al b bf bl.
destruct (Z_gt_le_dec af al) as [Ha|Ha];
destruct (Z_gt_le_dec bf bl) as [Hb|Hb].
exact 0%Z.
exact (-1)%Z.
exact 1%Z.
exact (comp_rec a1 af (Z.to_nat (al - af))%Z b bf (Z.to_nat (bl - bf)%Z)).
Defined.

Parameter to_bool : forall {a:Type} {a_WT:WhyType a}, a -> bool.

Parameter of_bool : forall {a:Type} {a_WT:WhyType a}, bool -> a.

(* Why3 goal *)
Definition xorb: forall {a:Type} {a_WT:WhyType a}, (map.Map.map t a) -> t ->
  t -> (map.Map.map t a) -> t -> t -> (map.Map.map t a).
intros a a_WT (a1) af al (b) bf bl.
exact (Map._map_constr _ _
       (fun x => of_bool (xorb (to_bool (a1 x)) (to_bool (b x))))).
Defined.

(* Why3 goal *)
Definition andb: forall {a:Type} {a_WT:WhyType a}, (map.Map.map t a) -> t ->
  t -> (map.Map.map t a) -> t -> t -> (map.Map.map t a).
intros a a_WT (a1) af al (b) bf bl.
exact (Map._map_constr _ _
       (fun x => of_bool (andb (to_bool (a1 x)) (to_bool (b x))))).
Defined.

(* Why3 goal *)
Definition orb: forall {a:Type} {a_WT:WhyType a}, (map.Map.map t a) -> t ->
  t -> (map.Map.map t a) -> t -> t -> (map.Map.map t a).
intros a a_WT (a1) af al (b) bf bl.
exact (Map._map_constr _ _
       (fun x => of_bool (orb (to_bool (a1 x)) (to_bool (b x))))).
Defined.

(* Why3 goal *)
Definition notb: forall {a:Type} {a_WT:WhyType a}, (map.Map.map t a) -> t ->
  t -> (map.Map.map t a).
intros a a_WT (a1) af al.
exact (Map._map_constr _ _
       (fun x => of_bool (negb (to_bool (a1 x))))).
Defined.

(* Why3 goal *)
Definition singleton: forall {a:Type} {a_WT:WhyType a}, a -> t ->
  (map.Map.map t a).
intros a a_WT e i.
exact (map.Map.const e).
Defined.

(* Why3 goal *)
Lemma singleton_def :
forall {a:Type} {a_WT:WhyType a},
forall (v:a), forall (i:t), ((map.Map.get (singleton v i) i) = v).
intros a a_WT v i.
apply map.Map.Const.
Qed.


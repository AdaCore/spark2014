module Ada__containers__formal_hashed_maps__witness
  use                 "_gnatprove_standard".BV8
  use                 "_gnatprove_standard".BV16
  use                 "_gnatprove_standard".BV32
  use                 "_gnatprove_standard".BV64
  use "ada__containers__formal_hashed_maps__args".Ada__containers__formal_hashed_maps__key_type
  use "ada__containers__formal_hashed_maps__args".Ada__containers__formal_hashed_maps__equivalent_keys

  function witness Ada__containers__formal_hashed_maps__key_type.base_type : real

  axiom eq_witness :
    (forall k1 k2 : Ada__containers__formal_hashed_maps__key_type.base_type [Ada__containers__formal_hashed_maps__equivalent_keys.equivalent_keys k1 k2].
	witness k1 = witness k2 <-> Ada__containers__formal_hashed_maps__equivalent_keys.equivalent_keys k1 k2 = True)
end

module Ada__containers__formal_hashed_maps__map__rep
  use import int.Int
  use import "_gnatprove_standard".Main
  use Ada__containers__hash_type
  use Ada__containers__count_type
  use Ada__containers__count_type__rep

  type __split_discrs = { rec__ada__containers__formal_hashed_maps__map__capacity : Ada__containers__count_type.count_type;
                          rec__ada__containers__formal_hashed_maps__map__modulus : Ada__containers__hash_type.hash_type }

  type __split_discrs__ref = { mutable __split_discrs__content : __split_discrs }
  val __split_discrs__havoc (x : __split_discrs__ref) : unit
     writes { x }

  type __split_fields = { rec__ada__containers__formal_hashed_maps__map : __private }

  type __split_fields__ref = { mutable __split_fields__content : __split_fields }
  val __split_fields__havoc (x : __split_fields__ref) : unit
     writes { x }

  type __rep = { __split_discrs : __split_discrs; __split_fields : __split_fields }

  function bool_eq __rep __rep : bool
  function user_eq __rep __rep : bool
  function to_base (x : __rep) : __rep = x
  function of_base (x : __rep) : __rep = x
end

module Ada__containers__formal_hashed_maps__map
  use export Ada__containers__formal_hashed_maps__map__rep
  type map = __rep

  type map__ref = { mutable map__content : map }
  val map__havoc (x : map__ref) : unit
     writes { x }

  predicate map_inv "inline" (l : map) =
     l = { __split_discrs = { rec__ada__containers__formal_hashed_maps__map__capacity = l.__split_discrs.rec__ada__containers__formal_hashed_maps__map__capacity; rec__ada__containers__formal_hashed_maps__map__modulus = l.__split_discrs.rec__ada__containers__formal_hashed_maps__map__modulus }; __split_fields = { rec__ada__containers__formal_hashed_maps__map = l.__split_fields.rec__ada__containers__formal_hashed_maps__map } }

   function capacity  (co : map) : int =
          Ada__containers__count_type__rep.to_rep (rec__ada__containers__formal_hashed_maps__map__capacity (__split_discrs co))

end

module Ada__containers__formal_hashed_maps__length
  use import int.Int
  use import "_gnatprove_standard".Main
  use Ada__containers__count_type
  use import Ada__containers__formal_hashed_maps__map

  function length__logic map : int

  function length_ "inline" (co : map) : int =
    length__logic co

  axiom length_range:
    forall co:map [length__logic co]. 0 <= length_ co <= capacity co

  val length (co : map) : int
     ensures { result = length__logic co }
end

module Ada__containers__formal_hashed_maps__cursor
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_hashed_maps__args".Ada__containers__formal_hashed_maps__key_type
  use import Ada__containers__formal_hashed_maps__map
  use import Ada__containers__formal_hashed_maps__length

  type __split_fields = { rec__main__ : __private }

  type __split_fields__ref = { mutable __split_fields__content : __split_fields }
  val __split_fields__havoc (x : __split_fields__ref) : unit
     writes { x }

  type cursor = { __split_fields : __split_fields }

  type cursor__ref = { mutable cursor__content : cursor }
  val cursor__havoc (x : cursor__ref) : unit
     writes { x }

  function dummy : cursor

  function position map cursor : int

  function position_inv map int : cursor

  axiom position_gte_zero:
    forall co:map, cu:cursor [position co cu].
        length_ co >= position co cu >= 0

  axiom position_eq1:
   forall co:map, i :int [position co (position_inv co i)]. 0 < i <= length_ co ->
              position co (position_inv co i) = i

  axiom position_eq2:
    forall co:map, cu:cursor [position co cu].
          position co cu > 0 -> position_inv co (position co cu) = cu

  function bool_eq "inline" (c1:cursor) (c2:cursor) : bool = c1 = c2
  function user_eq cursor cursor : bool
end

module Ada__containers__formal_hashed_maps__no_element
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_hashed_maps__map
  use import Ada__containers__formal_hashed_maps__length
  use import Ada__containers__formal_hashed_maps__cursor

  function no_element : cursor

  axiom position_no_element:
    forall co:map [position co no_element]. position co no_element = 0
end

module Ada__containers__formal_hashed_maps__empty_map
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_hashed_maps__map
  use import Ada__containers__formal_hashed_maps__length

  function empty_map : map

  axiom Empty_is_empty: length_ empty_map = 0
end

module Ada__containers__formal_hashed_maps__is_empty
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_hashed_maps__map
  use import Ada__containers__formal_hashed_maps__length

  function is_empty__logic map : bool

  axiom is_empty:
    forall co:map [is_empty__logic (co)].
          is_empty__logic (co) = True <-> length_ co = 0

  val is_empty (co:map) : bool
     ensures  { result = is_empty__logic co }
end

module Ada__containers__formal_hashed_maps__key
  use import int.Int
  use import "_gnatprove_standard".Main
  use                 "_gnatprove_standard".BV8
  use                 "_gnatprove_standard".BV16
  use                 "_gnatprove_standard".BV32
  use                 "_gnatprove_standard".BV64
  use "ada__containers__formal_hashed_maps__args".Ada__containers__formal_hashed_maps__key_type
  use import Ada__containers__formal_hashed_maps__map
  use import Ada__containers__formal_hashed_maps__length
  use import Ada__containers__formal_hashed_maps__cursor

  function key__logic map cursor : Ada__containers__formal_hashed_maps__key_type.base_type

  axiom key__range:
    forall co:map, cu:cursor. Ada__containers__formal_hashed_maps__key_type.valid (key__logic co cu)

  val key (co:map) (cu:cursor) : Ada__containers__formal_hashed_maps__key_type.base_type
     requires { position co cu > 0 }
     ensures  { result = key__logic co cu }
end

module Ada__containers__formal_hashed_maps__element
  use import int.Int
  use import "_gnatprove_standard".Main
  use                 "_gnatprove_standard".BV8
  use                 "_gnatprove_standard".BV16
  use                 "_gnatprove_standard".BV32
  use                 "_gnatprove_standard".BV64
  use "ada__containers__formal_hashed_maps__args".Ada__containers__formal_hashed_maps__element_type
  use import Ada__containers__formal_hashed_maps__map
  use import Ada__containers__formal_hashed_maps__cursor

  function element__logic map cursor : Ada__containers__formal_hashed_maps__element_type.base_type

  axiom element__range:
    forall co:map, cu:cursor. Ada__containers__formal_hashed_maps__element_type.valid (element__logic co cu)

  val element (co:map) (cu:cursor) : Ada__containers__formal_hashed_maps__element_type.base_type
     requires { position co cu > 0 }
     ensures  { result = element__logic co cu }
end

module Ada__containers__formal_hashed_maps__next
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_hashed_maps__map
  use import Ada__containers__formal_hashed_maps__length
  use import Ada__containers__formal_hashed_maps__cursor
  use import Ada__containers__formal_hashed_maps__no_element

  function next__logic map cursor : cursor

  axiom next_in:
    forall co:map, cu:cursor [next__logic co cu].
	(length_ co > position co cu > 0 \/ position co (next__logic co cu) > 0) ->
	position co (next__logic co cu) = position co cu + 1

  axiom next_ext:
    forall co:map, cu:cursor [next__logic co cu].
        (position co cu = length_ co \/ cu = no_element) -> next__logic co cu = no_element

  val next (co:map) (cu:cursor) : cursor
     requires { cu = no_element \/ position co cu > 0 }
     ensures  { result = next__logic co cu }
end

module Ada__containers__formal_hashed_maps__next__2
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_hashed_maps__map
  use import Ada__containers__formal_hashed_maps__length
  use import Ada__containers__formal_hashed_maps__cursor
  use import Ada__containers__formal_hashed_maps__no_element
  use import Ada__containers__formal_hashed_maps__next

  val next__2 (co:map) (cu:cursor__ref) : unit
     requires { cu.cursor__content = no_element \/ position co cu.cursor__content > 0 }
     writes     { cu }
     reads      { cu }
     ensures  { cu.cursor__content = next__logic co (old cu.cursor__content) }
end

module Ada__containers__formal_hashed_maps__first
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_hashed_maps__map
  use import Ada__containers__formal_hashed_maps__length
  use import Ada__containers__formal_hashed_maps__cursor
  use import Ada__containers__formal_hashed_maps__no_element

  function first__logic map : cursor

  axiom first_empty:
    forall co:map [first__logic co]. length_ co = 0 <-> first__logic co = no_element

  axiom first_gen:
    forall co:map [first__logic co]. length_ co > 0 -> position co (first__logic co) = 1

  val first (co:map) : cursor
     ensures  { result = first__logic co }
end

module Ada__containers__formal_hashed_maps__find
  use import int.Int
  use import "_gnatprove_standard".Main
  use                 "_gnatprove_standard".BV8
  use                 "_gnatprove_standard".BV16
  use                 "_gnatprove_standard".BV32
  use                 "_gnatprove_standard".BV64
  use  "ada__containers__formal_hashed_maps__args".Ada__containers__formal_hashed_maps__key_type
  use import Ada__containers__formal_hashed_maps__map
  use import Ada__containers__formal_hashed_maps__witness
  use import Ada__containers__formal_hashed_maps__length
  use import Ada__containers__formal_hashed_maps__cursor
  use import Ada__containers__formal_hashed_maps__no_element
  use import Ada__containers__formal_hashed_maps__key

  function find_ map real : cursor

  predicate find__ (co : map) (i : real) (cu : cursor) =
    (((cu = (no_element  : cursor)) /\
      (forall cun:cursor.
        ((position co cun > 0) ->
         ((witness (key__logic co cun)) <> i)))) \/
     ((position co cu > 0) /\
      (((witness (key__logic co cu)) = i) /\
       (forall cun:cursor.
         ((position co cun > 0) ->
          ((cu <> cun) ->
           ((witness (key__logic co cun)) <> i)))))))

  axiom Find_find_val:
    (forall co:map.
      (forall i:real.
        ((find__ co i (find_ co i)) /\
         ((length_ co = 0) -> (find_ co i = no_element )))))

  function find__logic "inline" (co : map) (e:Ada__containers__formal_hashed_maps__key_type.base_type) : cursor =
  find_ co (witness e)

  val find (co:map) (e:Ada__containers__formal_hashed_maps__key_type.base_type)  : cursor
     ensures  { result = find__logic co e }
end

module Ada__containers__formal_hashed_maps__element__2
  use import int.Int
  use import "_gnatprove_standard".Main
  use                 "_gnatprove_standard".BV8
  use                 "_gnatprove_standard".BV16
  use                 "_gnatprove_standard".BV32
  use                 "_gnatprove_standard".BV64
  use "ada__containers__formal_hashed_maps__args".Ada__containers__formal_hashed_maps__element_type
  use import Ada__containers__formal_hashed_maps__witness
  use import Ada__containers__formal_hashed_maps__map
  use import Ada__containers__formal_hashed_maps__cursor
  use import Ada__containers__formal_hashed_maps__element
  use import Ada__containers__formal_hashed_maps__find

  function element__2__logic "inline" (co:map) (k:Ada__containers__formal_hashed_maps__key_type.base_type) : Ada__containers__formal_hashed_maps__element_type.base_type =
element__logic co (find_ co (witness k))

  val element__2 (co:map) (k:Ada__containers__formal_hashed_maps__key_type.base_type) : Ada__containers__formal_hashed_maps__element_type.base_type
     requires { position co (find_ co (witness k)) > 0 }
     ensures  { result = element__2__logic co k }
end

module Ada__containers__formal_hashed_maps__first_to_previous
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_hashed_maps__map
  use import Ada__containers__formal_hashed_maps__length
  use import Ada__containers__formal_hashed_maps__cursor
  use import Ada__containers__formal_hashed_maps__no_element
  use import Ada__containers__formal_hashed_maps__key
  use import Ada__containers__formal_hashed_maps__element
  use import Ada__containers__formal_hashed_maps__find

  function first_to_previous__logic map cursor : map

  axiom first_to_previous_no_element:
    forall co:map [first_to_previous__logic co no_element]. first_to_previous__logic co no_element = co

  axiom first_to_previous_length_:
    forall co:map, cu:cursor [first_to_previous__logic co cu].
	position co cu > 0 -> length_ (first_to_previous__logic co cu) = position co cu - 1

  axiom first_to_previous_position_in:
    forall co:map, cu cun:cursor [position (first_to_previous__logic co cu) cun | first_to_previous__logic co cu, position co cun].
	(position (first_to_previous__logic co cu) cun > 0 \/ position co cun < position co cu) ->
	position (first_to_previous__logic co cu) cun = position co cun

  axiom first_to_previous_position_ext:
    forall co:map, cu cun:cursor [position (first_to_previous__logic co cu) cun].
	position co cun >= position co cu > 0 ->
	position (first_to_previous__logic co cu) cun = 0

  axiom first_to_previous_key:
    forall co:map, cu cun:cursor [key__logic (first_to_previous__logic co cu) cun | first_to_previous__logic co cu, key__logic co cun].
	(position (first_to_previous__logic co cu) cun > 0 \/ 0 < position co cun < position co cu) ->
	key__logic (first_to_previous__logic co cu) cun = key__logic co cun

  axiom first_to_previous_element:
    forall co:map, cu cun:cursor [element__logic (first_to_previous__logic co cu) cun | first_to_previous__logic co cu, element__logic co cun].
	(position (first_to_previous__logic co cu) cun > 0 \/ 0 < position co cun < position co cu) ->
	element__logic (first_to_previous__logic co cu) cun = element__logic co cun

  axiom first_to_previous_find :
    forall co:map, cu:cursor, w:real [find_ co w, first_to_previous__logic co cu|
     find_ (first_to_previous__logic co cu) w].
     ((position co cu > position co (find_ co w) > 0 \/
      position (first_to_previous__logic co cu) (find_ (first_to_previous__logic co cu) w) > 0) ->
      find_ co w = find_ (first_to_previous__logic co cu) w) /\
      (position co (find_ co w) >= position co cu -> find_ (first_to_previous__logic co cu) w = no_element)

  val first_to_previous (co:map) (cu:cursor) : map
     requires { cu = no_element \/ position co cu > 0 }
     ensures  { result = first_to_previous__logic co cu /\ map_inv result }
end

module Ada__containers__formal_hashed_maps__current_to_last
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_hashed_maps__map
  use import Ada__containers__formal_hashed_maps__length
  use import Ada__containers__formal_hashed_maps__empty_map
  use import Ada__containers__formal_hashed_maps__cursor
  use import Ada__containers__formal_hashed_maps__no_element
  use import Ada__containers__formal_hashed_maps__key
  use import Ada__containers__formal_hashed_maps__element
  use import Ada__containers__formal_hashed_maps__find

  function current_to_last__logic map cursor : map

  axiom current_to_last_no_element:
    forall co:map [current_to_last__logic co no_element]. current_to_last__logic co no_element = empty_map

  axiom current_to_last_length_:
    forall co:map, cu:cursor [length_ (current_to_last__logic co cu) ].
	position co cu > 0 -> length_ (current_to_last__logic co cu) = (length_ co) - (position co cu) + 1

  axiom current_to_last_position_in:
    forall co:map, cu cun:cursor [position (current_to_last__logic co cu) cun | current_to_last__logic co cu, position co cun].
	(position (current_to_last__logic co cu) cun > 0 \/ position co cun >= position co cu > 0) ->
	position (current_to_last__logic co cu) cun = (position co cun) - (position co cu) + 1

  axiom current_to_last_position_ext:
    forall co:map, cu cun:cursor [position (current_to_last__logic co cu) cun].
	position co cun < position co cu -> position (current_to_last__logic co cu) cun = 0

  axiom current_to_last_key:
    forall co:map, cu cun:cursor [key__logic (current_to_last__logic co cu) cun | current_to_last__logic co cu, key__logic co cun].
	(position (current_to_last__logic co cu) cun > 0 \/ 0 < position co cu <= position co cun) ->
	key__logic (current_to_last__logic co cu) cun = key__logic co cun

  axiom current_to_last_element:
    forall co:map, cu cun:cursor [element__logic (current_to_last__logic co cu) cun | current_to_last__logic co cu, element__logic co cun].
	(position (current_to_last__logic co cu) cun > 0 \/ 0 < position co cu <= position co cun) ->
	element__logic (current_to_last__logic co cu) cun = element__logic co cun

  axiom current_to_last_find :
    forall co:map, cu:cursor, w:real [find_ (current_to_last__logic co cu) w| current_to_last__logic co cu,
     find_ co w].
     ((0 < position co cu <= position co (find_ co w) \/
      position (current_to_last__logic co cu) (find_ (current_to_last__logic co cu) w) > 0) ->
      find_ co w = find_ (current_to_last__logic co cu) w) /\
      (position co (find_ co w) < position co cu -> find_ (current_to_last__logic co cu) w = no_element)

  val current_to_last (co:map) (cu:cursor) : map
     requires { cu = no_element \/ position co cu > 0 }
     ensures  { result = current_to_last__logic co cu /\ map_inv result }
end

module Ada__containers__formal_hashed_maps__replace
  use import int.Int
  use import "_gnatprove_standard".Main
  use                 "_gnatprove_standard".BV8
  use                 "_gnatprove_standard".BV16
  use                 "_gnatprove_standard".BV32
  use                 "_gnatprove_standard".BV64
  use  "ada__containers__formal_hashed_maps__args".Ada__containers__formal_hashed_maps__key_type
  use "ada__containers__formal_hashed_maps__args".Ada__containers__formal_hashed_maps__oeq
  use import Ada__containers__formal_hashed_maps__witness
  use import Ada__containers__formal_hashed_maps__map
  use import Ada__containers__formal_hashed_maps__length
  use import Ada__containers__formal_hashed_maps__empty_map
  use import Ada__containers__formal_hashed_maps__cursor
  use import Ada__containers__formal_hashed_maps__no_element
  use import Ada__containers__formal_hashed_maps__key
  use import Ada__containers__formal_hashed_maps__find
  use import Ada__containers__formal_hashed_maps__element

  predicate replace (co1:map) (k:Ada__containers__formal_hashed_maps__key_type.base_type) (e:Ada__containers__formal_hashed_maps__element_type.base_type) (co2:map) =
    (position co1 (find_ co1 (witness k)) > 0 /\
      length_ co1 = length_ co2 /\
       Ada__containers__formal_hashed_maps__oeq.oeq (element__logic co2 (find_ co1 (witness k))) e /\
        (forall cun:cursor [position co2 cun | position co1 cun]. position co2 cun = position co1 cun) /\
         (forall cun:cursor [key__logic co2 cun | key__logic co1 cun].
           position co1 cun > 0 /\ not cun = find_ co1 (witness k) ->
            key__logic co2 cun = key__logic co1 cun) /\
         (forall cun:cursor [element__logic co2 cun | element__logic co1 cun].
           position co1 cun > 0 /\ not cun = find_ co1 (witness k) ->
            element__logic co2 cun = element__logic co1 cun) /\
          (forall w:real [find_ co1 w | find_ co2 w]. find_ co1 w = find_ co2 w)) /\
     capacity co1 = capacity co2

  val replace (co:Ada__containers__formal_hashed_maps__map.__split_fields__ref) (cap : Ada__containers__formal_hashed_maps__map.__split_discrs) (k:Ada__containers__formal_hashed_maps__key_type.base_type) (e:Ada__containers__formal_hashed_maps__element_type.base_type) : unit
     requires { let rec_co = {Ada__containers__formal_hashed_maps__map.__split_fields = co.Ada__containers__formal_hashed_maps__map.__split_fields__content;
                              Ada__containers__formal_hashed_maps__map.__split_discrs = cap}  in
                   find_ rec_co (witness k) <> no_element }
     writes { co }
     reads { co }
     ensures { let rec_co = {Ada__containers__formal_hashed_maps__map.__split_fields = co.Ada__containers__formal_hashed_maps__map.__split_fields__content;
                              Ada__containers__formal_hashed_maps__map.__split_discrs = cap}  in
               let old_co = {Ada__containers__formal_hashed_maps__map.__split_fields = old co.Ada__containers__formal_hashed_maps__map.__split_fields__content;
                              Ada__containers__formal_hashed_maps__map.__split_discrs = cap}  in
                   replace old_co k e rec_co }
end

module Ada__containers__formal_hashed_maps__replace_element
  use import int.Int
  use import "_gnatprove_standard".Main
  use                 "_gnatprove_standard".BV8
  use                 "_gnatprove_standard".BV16
  use                 "_gnatprove_standard".BV32
  use                 "_gnatprove_standard".BV64
  use "ada__containers__formal_hashed_maps__args".Ada__containers__formal_hashed_maps__key_type
  use "ada__containers__formal_hashed_maps__args".Ada__containers__formal_hashed_maps__oeq
  use import Ada__containers__formal_hashed_maps__map
  use import Ada__containers__formal_hashed_maps__length
  use import Ada__containers__formal_hashed_maps__cursor
  use import Ada__containers__formal_hashed_maps__no_element
  use import Ada__containers__formal_hashed_maps__key
  use import Ada__containers__formal_hashed_maps__element
  use import Ada__containers__formal_hashed_maps__find

  predicate replace_element map cursor Ada__containers__formal_hashed_maps__element_type.base_type map

  axiom replace_element_length_:
    forall co1 co2:map, cu:cursor, e:Ada__containers__formal_hashed_maps__element_type.base_type
      [replace_element co1 cu e co2].
      replace_element co1 cu e co2 -> length_ co1 = length_ co2

  axiom replace_element_capacity:
    forall co1 co2:map, cu:cursor, e:Ada__containers__formal_hashed_maps__element_type.base_type
      [replace_element co1 cu e co2, capacity co1|replace_element co1 cu e co2, capacity co2].
      replace_element co1 cu e co2 -> capacity co1 = capacity co2

  axiom replace_element_position:
    forall co1 co2:map, cu cun:cursor, e:Ada__containers__formal_hashed_maps__element_type.base_type
      [replace_element co1 cu e co2, position co2 cun
     | replace_element co1 cu e co2, position co1 cun].
      replace_element co1 cu e co2 -> position co2 cun = position co1 cun

  axiom replace_element_key:
    forall co1 co2:map, cu cun:cursor, e:Ada__containers__formal_hashed_maps__element_type.base_type
      [replace_element co1 cu e co2, key__logic co2 cun
     | replace_element co1 cu e co2, key__logic co1 cun].
      replace_element co1 cu e co2 -> position co1 cun > 0 ->
        key__logic co2 cun = key__logic co1 cun

  axiom replace_element_element_in:
    forall co1 co2:map, cu:cursor, e:Ada__containers__formal_hashed_maps__element_type.base_type
      [replace_element co1 cu e co2].
      replace_element co1 cu e co2 -> Ada__containers__formal_hashed_maps__oeq.oeq (element__logic co2 cu) e

  axiom replace_element_element_ext:
    forall co1 co2:map, cu cun:cursor, e:Ada__containers__formal_hashed_maps__element_type.base_type
      [replace_element co1 cu e co2, element__logic co2 cun
     | replace_element co1 cu e co2, element__logic co1 cun].
      replace_element co1 cu e co2 -> cu <> cun -> position co1 cun > 0 ->
        element__logic co2 cun = element__logic co1 cun

  axiom replace_element_find:
    forall co1 co2:map, cu:cursor, w:real, e:Ada__containers__formal_hashed_maps__element_type.base_type
      [replace_element co1 cu e co2, find_ co2 w
     | replace_element co1 cu e co2, find_ co1 w].
       replace_element co1 cu e co2 -> find_ co1 w = find_ co2 w

  val replace_element (co:Ada__containers__formal_hashed_maps__map.__split_fields__ref) (cap : Ada__containers__formal_hashed_maps__map.__split_discrs) (cu:cursor) (e:Ada__containers__formal_hashed_maps__element_type.base_type) : unit
     requires { let rec_co = {Ada__containers__formal_hashed_maps__map.__split_fields = co.Ada__containers__formal_hashed_maps__map.__split_fields__content;
                              Ada__containers__formal_hashed_maps__map.__split_discrs = cap}  in
                   position rec_co cu > 0 }
     writes     { co }
     reads      { co }
     ensures { let rec_co = {Ada__containers__formal_hashed_maps__map.__split_fields = co.Ada__containers__formal_hashed_maps__map.__split_fields__content;
                              Ada__containers__formal_hashed_maps__map.__split_discrs = cap}  in
               let old_co = {Ada__containers__formal_hashed_maps__map.__split_fields = old co.Ada__containers__formal_hashed_maps__map.__split_fields__content;
                              Ada__containers__formal_hashed_maps__map.__split_discrs = cap}  in
                   replace_element old_co cu e rec_co }
end

module Ada__containers__formal_hashed_maps__insert
  use import int.Int
  use import "_gnatprove_standard".Main
  use                 "_gnatprove_standard".BV8
  use                 "_gnatprove_standard".BV16
  use                 "_gnatprove_standard".BV32
  use                 "_gnatprove_standard".BV64
  use "ada__containers__formal_hashed_maps__args".Ada__containers__formal_hashed_maps__key_type
  use "ada__containers__formal_hashed_maps__args".Ada__containers__formal_hashed_maps__element_type
  use "ada__containers__formal_hashed_maps__args".Ada__containers__formal_hashed_maps__oeq
  use import Ada__containers__formal_hashed_maps__witness
  use import Ada__containers__formal_hashed_maps__map
  use import Ada__containers__formal_hashed_maps__length
  use import Ada__containers__formal_hashed_maps__cursor
  use import Ada__containers__formal_hashed_maps__no_element
  use import Ada__containers__formal_hashed_maps__key
  use import Ada__containers__formal_hashed_maps__element
  use import Ada__containers__formal_hashed_maps__find

  predicate insert map Ada__containers__formal_hashed_maps__key_type.base_type  Ada__containers__formal_hashed_maps__element_type.base_type map

  axiom insert_length_:
    forall co1 co2:map,  k:Ada__containers__formal_hashed_maps__key_type.base_type, e:Ada__containers__formal_hashed_maps__element_type.base_type
      [insert co1 k e co2].
      insert co1 k e co2 -> length_ co1 + 1 = length_ co2 /\ find_ co1 (witness k) = no_element /\ Ada__containers__formal_hashed_maps__oeq.oeq (element__logic co2 (find_ co2 (witness k))) e

  axiom insert_capacity:
    forall co1 co2:map,  k:Ada__containers__formal_hashed_maps__key_type.base_type, e:Ada__containers__formal_hashed_maps__element_type.base_type
      [insert co1 k e co2, capacity co1|insert co1 k e co2, capacity co2].
      insert co1 k e co2 -> capacity co1 = capacity co2

  axiom insert_new:
    forall co1 co2:map,  k:Ada__containers__formal_hashed_maps__key_type.base_type, e:Ada__containers__formal_hashed_maps__element_type.base_type [insert co1 k e co2].
      insert co1 k e co2 ->
      position co2 (find_ co2 (witness k)) > 0

  axiom insert_position_before:
    forall co1 co2:map, cun:cursor,  k:Ada__containers__formal_hashed_maps__key_type.base_type, e:Ada__containers__formal_hashed_maps__element_type.base_type
      [insert co1 k e co2,  position co1 cun
     | insert co1 k e co2,  position co2 cun].
    let i = position co2 (find_ co2 (witness k)) in
      insert co1 k e co2 ->
      (i > position co1 cun > 0 \/ position co2 cun < i) ->
        position co1 cun = position co2 cun

  axiom insert_position_after:
    forall co1 co2:map, cun:cursor,  k:Ada__containers__formal_hashed_maps__key_type.base_type, e:Ada__containers__formal_hashed_maps__element_type.base_type
      [insert co1 k e co2,  position co1 cun
     | insert co1 k e co2,  position co2 cun].
    let i = position co2 (find_ co2 (witness k)) in
      insert co1 k e co2 ->
      (position co1 cun >= i \/ position co2 cun > i) ->
        position co1 cun + 1 = position co2 cun

  axiom insert_key:
    forall co1 co2:map, cun:cursor,  k:Ada__containers__formal_hashed_maps__key_type.base_type, e:Ada__containers__formal_hashed_maps__element_type.base_type
      [insert co1 k e co2,  key__logic co1 cun
     | insert co1 k e co2,  key__logic co2 cun].
      insert co1 k e co2 ->
      (position co1 cun > 0 \/ position co2 cun > 0 /\ find_ co2 (witness k) <> cun) ->
        key__logic co1 cun = key__logic co2 cun

  axiom insert_element:
    forall co1 co2:map, cun:cursor,  k:Ada__containers__formal_hashed_maps__key_type.base_type, e:Ada__containers__formal_hashed_maps__element_type.base_type
      [insert co1 k e co2,  element__logic co1 cun
     | insert co1 k e co2,  element__logic co2 cun].
      insert co1 k e co2 ->
      (position co1 cun > 0 \/ position co2 cun > 0 /\ find_ co2 (witness k) <> cun) ->
        element__logic co1 cun = element__logic co2 cun

  axiom insert_find :
    forall co1:map, co2:map, w:real,  k:Ada__containers__formal_hashed_maps__key_type.base_type, e:Ada__containers__formal_hashed_maps__element_type.base_type
     [insert co1 k e co2, find_ co1 w| insert co1 k e co2, find_ co2 w].
      insert co1 k e co2 -> not witness k = w -> find_ co1 w = find_ co2 w

  val insert (co:Ada__containers__formal_hashed_maps__map.__split_fields__ref) (cap : Ada__containers__formal_hashed_maps__map.__split_discrs) (k:Ada__containers__formal_hashed_maps__key_type.base_type) (e:Ada__containers__formal_hashed_maps__element_type.base_type)  (p:cursor__ref) (inserted : bool__ref) : unit
     requires { let rec_co = {Ada__containers__formal_hashed_maps__map.__split_fields = co.Ada__containers__formal_hashed_maps__map.__split_fields__content;
                              Ada__containers__formal_hashed_maps__map.__split_discrs = cap}  in
                   length_ rec_co < capacity rec_co }
     writes     { co, p, inserted }
     reads      { co }
     ensures { let rec_co = {Ada__containers__formal_hashed_maps__map.__split_fields = co.Ada__containers__formal_hashed_maps__map.__split_fields__content;
                              Ada__containers__formal_hashed_maps__map.__split_discrs = cap}  in
               let old_co = {Ada__containers__formal_hashed_maps__map.__split_fields = old co.Ada__containers__formal_hashed_maps__map.__split_fields__content;
                              Ada__containers__formal_hashed_maps__map.__split_discrs = cap}  in
                   (inserted.bool__content = True <-> find_ old_co (witness k) = no_element) /\ p.cursor__content = find_ rec_co (witness k) /\
                          if inserted.bool__content = True then (insert old_co k e rec_co)
                                                                 else (co.Ada__containers__formal_hashed_maps__map.__split_fields__content = old co.Ada__containers__formal_hashed_maps__map.__split_fields__content) }
end

module Ada__containers__formal_hashed_maps__insert__2
  use import int.Int
  use import "_gnatprove_standard".Main
  use                 "_gnatprove_standard".BV8
  use                 "_gnatprove_standard".BV16
  use                 "_gnatprove_standard".BV32
  use                 "_gnatprove_standard".BV64
  use "ada__containers__formal_hashed_maps__args".Ada__containers__formal_hashed_maps__key_type
  use import Ada__containers__formal_hashed_maps__witness
  use import Ada__containers__formal_hashed_maps__map
  use import Ada__containers__formal_hashed_maps__length
  use import Ada__containers__formal_hashed_maps__cursor
  use import Ada__containers__formal_hashed_maps__no_element
  use import Ada__containers__formal_hashed_maps__insert
  use import Ada__containers__formal_hashed_maps__find

  val insert__2 (co:Ada__containers__formal_hashed_maps__map.__split_fields__ref) (cap : Ada__containers__formal_hashed_maps__map.__split_discrs)  (k:Ada__containers__formal_hashed_maps__key_type.base_type) (e:Ada__containers__formal_hashed_maps__element_type.base_type) : unit
     requires { let rec_co = {Ada__containers__formal_hashed_maps__map.__split_fields = co.Ada__containers__formal_hashed_maps__map.__split_fields__content;
                              Ada__containers__formal_hashed_maps__map.__split_discrs = cap}  in
                   length_ rec_co < capacity rec_co /\ find_ rec_co (witness k) = no_element }
     writes     { co }
     reads      { co }
     ensures { let rec_co = {Ada__containers__formal_hashed_maps__map.__split_fields = co.Ada__containers__formal_hashed_maps__map.__split_fields__content;
                              Ada__containers__formal_hashed_maps__map.__split_discrs = cap}  in
               let old_co = {Ada__containers__formal_hashed_maps__map.__split_fields = old co.Ada__containers__formal_hashed_maps__map.__split_fields__content;
                              Ada__containers__formal_hashed_maps__map.__split_discrs = cap}  in
                   insert old_co k e rec_co }
end

module Ada__containers__formal_hashed_maps__delete
  use import int.Int
  use import "_gnatprove_standard".Main
  use                 "_gnatprove_standard".BV8
  use                 "_gnatprove_standard".BV16
  use                 "_gnatprove_standard".BV32
  use                 "_gnatprove_standard".BV64
  use "ada__containers__formal_hashed_maps__args".Ada__containers__formal_hashed_maps__key_type
  use import Ada__containers__formal_hashed_maps__witness
  use import Ada__containers__formal_hashed_maps__map
  use import Ada__containers__formal_hashed_maps__length
  use import Ada__containers__formal_hashed_maps__cursor
  use import Ada__containers__formal_hashed_maps__no_element
  use import Ada__containers__formal_hashed_maps__next
  use import Ada__containers__formal_hashed_maps__key
  use import Ada__containers__formal_hashed_maps__element
  use import Ada__containers__formal_hashed_maps__find

  predicate delete map cursor map

  axiom delete_capacity:
    forall co1 co2:map, cu:cursor
      [delete co1 cu co2, capacity co1|delete co1 cu co2, capacity co2].
      delete co1 cu co2 -> capacity co1 = capacity co2

  axiom delete_length_:
    forall co1 co2:map, cu:cursor
      [delete co1 cu co2].
      delete co1 cu co2 -> length_ co1 = length_ co2 + 1

  axiom delete_position_before:
    forall co1 co2:map, cu cun:cursor
      [delete co1 cu co2,  position co1 cun
     | delete co1 cu co2,  position co2 cun].
      delete co1 cu co2 ->
      (position co1 cu > position co1 cun \/ 0 < position co2 cun < position co1 cu) ->
        position co1 cun = position co2 cun

  axiom delete_position_after:
    forall co1 co2:map, cu cun:cursor
      [delete co1 cu co2,  position co1 cun | delete co1 cu co2,  position co2 cun].
      delete co1 cu co2 ->
      (position co1 cun > position co1 cu \/ position co2 cun >= position co1 cu) ->
        position co1 cun = position co2 cun + 1

  axiom delete_position_range:
    forall co1 co2:map, cu:cursor [delete co1 cu co2].
      delete co1 cu co2 -> position co2 cu = 0 /\ 0 < position co1 cu /\ find_ co2 (witness (key__logic co1 cu)) = no_element

  axiom delete_position_next:
    forall co1 co2:map, cu:cursor [delete co1 cu co2].
      delete co1 cu co2 -> position co1 (next__logic co1 cu) >= 0

  axiom delete_key:
    forall co1 co2:map, cu cun:cursor
      [delete co1 cu co2,  key__logic co1 cun
     | delete co1 cu co2,  key__logic co2 cun].
      delete co1 cu co2 ->
      0 < position co2 cun ->
        key__logic co1 cun = key__logic co2 cun

  axiom delete_element:
    forall co1 co2:map, cu cun:cursor
      [delete co1 cu co2,  element__logic co1 cun
     | delete co1 cu co2,  element__logic co2 cun].
      delete co1 cu co2 ->
      0 < position co2 cun ->
        element__logic co1 cun = element__logic co2 cun

  axiom delete_find :
    forall co1:map, co2:map, cu:cursor, w:real [delete co1 cu co2,
     find_ co1 w| delete co1 cu co2, find_ co2 w].
     delete co1 cu co2 -> not witness (key__logic co1 cu) = w -> find_ co1 w = find_ co2 w

  val delete (co:Ada__containers__formal_hashed_maps__map.__split_fields__ref) (cap : Ada__containers__formal_hashed_maps__map.__split_discrs) (e : Ada__containers__formal_hashed_maps__key_type.base_type) : unit
     requires { let rec_co = {Ada__containers__formal_hashed_maps__map.__split_fields = co.Ada__containers__formal_hashed_maps__map.__split_fields__content;
                              Ada__containers__formal_hashed_maps__map.__split_discrs = cap}  in
                   find_ rec_co (witness e) <> no_element }
     writes     { co }
     reads      { co }
     ensures { let rec_co = {Ada__containers__formal_hashed_maps__map.__split_fields = co.Ada__containers__formal_hashed_maps__map.__split_fields__content;
                              Ada__containers__formal_hashed_maps__map.__split_discrs = cap}  in
               let old_co = {Ada__containers__formal_hashed_maps__map.__split_fields = old co.Ada__containers__formal_hashed_maps__map.__split_fields__content;
                              Ada__containers__formal_hashed_maps__map.__split_discrs = cap}  in
                   delete old_co (find_ old_co (witness e)) rec_co }
end

module Ada__containers__formal_hashed_maps__delete__2
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_hashed_maps__map
  use import Ada__containers__formal_hashed_maps__length
  use import Ada__containers__formal_hashed_maps__cursor
  use import Ada__containers__formal_hashed_maps__no_element
  use import Ada__containers__formal_hashed_maps__delete

  val delete__2 (co:Ada__containers__formal_hashed_maps__map.__split_fields__ref) (cap : Ada__containers__formal_hashed_maps__map.__split_discrs) (cu:cursor__ref) : unit
     requires { let rec_co = {Ada__containers__formal_hashed_maps__map.__split_fields = co.Ada__containers__formal_hashed_maps__map.__split_fields__content;
                              Ada__containers__formal_hashed_maps__map.__split_discrs = cap}  in
                   position rec_co cu.cursor__content > 0 }
     writes     { co, cu }
     reads      { co }
     ensures { let rec_co = {Ada__containers__formal_hashed_maps__map.__split_fields = co.Ada__containers__formal_hashed_maps__map.__split_fields__content;
                              Ada__containers__formal_hashed_maps__map.__split_discrs = cap}  in
               let old_co = {Ada__containers__formal_hashed_maps__map.__split_fields = old co.Ada__containers__formal_hashed_maps__map.__split_fields__content;
                              Ada__containers__formal_hashed_maps__map.__split_discrs = cap}  in
                   delete old_co (old cu.cursor__content) rec_co /\ cu.cursor__content = no_element}
 end

module Ada__containers__formal_hashed_maps__include
  use import int.Int
  use import "_gnatprove_standard".Main
  use                 "_gnatprove_standard".BV8
  use                 "_gnatprove_standard".BV16
  use                 "_gnatprove_standard".BV32
  use                 "_gnatprove_standard".BV64
  use "ada__containers__formal_hashed_maps__args".Ada__containers__formal_hashed_maps__key_type
  use import Ada__containers__formal_hashed_maps__witness
  use import Ada__containers__formal_hashed_maps__map
  use import Ada__containers__formal_hashed_maps__length
  use import Ada__containers__formal_hashed_maps__cursor
  use import Ada__containers__formal_hashed_maps__no_element
  use import Ada__containers__formal_hashed_maps__replace
  use import Ada__containers__formal_hashed_maps__insert
  use import Ada__containers__formal_hashed_maps__find

  val include (co:Ada__containers__formal_hashed_maps__map.__split_fields__ref) (cap : Ada__containers__formal_hashed_maps__map.__split_discrs) (k :Ada__containers__formal_hashed_maps__key_type.base_type) (e :Ada__containers__formal_hashed_maps__element_type.base_type) : unit
     requires {  let rec_co = {Ada__containers__formal_hashed_maps__map.__split_fields = co.Ada__containers__formal_hashed_maps__map.__split_fields__content;
                              Ada__containers__formal_hashed_maps__map.__split_discrs = cap}  in
                   length_ rec_co  < capacity rec_co}
     writes     { co }
     reads      { co }
     ensures { let rec_co = {Ada__containers__formal_hashed_maps__map.__split_fields = co.Ada__containers__formal_hashed_maps__map.__split_fields__content;
                              Ada__containers__formal_hashed_maps__map.__split_discrs = cap}  in
               let old_co = {Ada__containers__formal_hashed_maps__map.__split_fields = old co.Ada__containers__formal_hashed_maps__map.__split_fields__content;
                              Ada__containers__formal_hashed_maps__map.__split_discrs = cap}  in
                   if find_ old_co (witness k) <> no_element then replace old_co k e rec_co
                         else insert old_co k e rec_co  }
end

module Ada__containers__formal_hashed_maps__exclude
  use import int.Int
  use import "_gnatprove_standard".Main
  use                 "_gnatprove_standard".BV8
  use                 "_gnatprove_standard".BV16
  use                 "_gnatprove_standard".BV32
  use                 "_gnatprove_standard".BV64
  use "ada__containers__formal_hashed_maps__args".Ada__containers__formal_hashed_maps__key_type
  use import Ada__containers__formal_hashed_maps__witness
  use import Ada__containers__formal_hashed_maps__map
  use import Ada__containers__formal_hashed_maps__length
  use import Ada__containers__formal_hashed_maps__cursor
  use import Ada__containers__formal_hashed_maps__no_element
  use import Ada__containers__formal_hashed_maps__delete
  use import Ada__containers__formal_hashed_maps__find

  val exclude (co:Ada__containers__formal_hashed_maps__map.__split_fields__ref) (cap : Ada__containers__formal_hashed_maps__map.__split_discrs) (k :Ada__containers__formal_hashed_maps__key_type.base_type) : unit
     writes     { co }
     reads      { co }
     ensures { let rec_co = {Ada__containers__formal_hashed_maps__map.__split_fields = co.Ada__containers__formal_hashed_maps__map.__split_fields__content;
                              Ada__containers__formal_hashed_maps__map.__split_discrs = cap}  in
               let old_co = {Ada__containers__formal_hashed_maps__map.__split_fields = old co.Ada__containers__formal_hashed_maps__map.__split_fields__content;
                              Ada__containers__formal_hashed_maps__map.__split_discrs = cap}  in
                   if find_ old_co (witness k) = no_element then  old co.Ada__containers__formal_hashed_maps__map.__split_fields__content = co.Ada__containers__formal_hashed_maps__map.__split_fields__content
                         else delete old_co (find_ old_co (witness k)) rec_co  }
end

module Ada__containers__formal_hashed_maps__has_element
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_hashed_maps__map
  use import Ada__containers__formal_hashed_maps__length
  use import Ada__containers__formal_hashed_maps__cursor

  function has_element map cursor : bool

  axiom has_element_pos:
    forall co:map, cu:cursor [has_element co cu].
    has_element co cu = True -> 0 < position co cu

  axiom has_element_neg:
    forall co:map, cu:cursor [has_element co cu].
    has_element co cu <> True -> position co cu = 0

  val has_element (co:map) (cu:cursor) : bool
     ensures { has_element co cu = result }
end

module Ada__containers__formal_hashed_maps__contains
  use import int.Int
  use import "_gnatprove_standard".Main
  use                 "_gnatprove_standard".BV8
  use                 "_gnatprove_standard".BV16
  use                 "_gnatprove_standard".BV32
  use                 "_gnatprove_standard".BV64
  use "ada__containers__formal_hashed_maps__args".Ada__containers__formal_hashed_maps__key_type
  use import Ada__containers__formal_hashed_maps__witness
  use import Ada__containers__formal_hashed_maps__map
  use import Ada__containers__formal_hashed_maps__length
  use import Ada__containers__formal_hashed_maps__cursor
  use import Ada__containers__formal_hashed_maps__find

  function contains__logic map Ada__containers__formal_hashed_maps__key_type.base_type : bool

  axiom contains_c:
  forall co : map, e : Ada__containers__formal_hashed_maps__key_type.base_type [contains__logic co e].
    contains__logic co e = True <-> 0 < position co (find_ co (witness e))

  val contains (co:map) (e:Ada__containers__formal_hashed_maps__key_type.base_type) : bool
     ensures { contains__logic co e = result }
end

module Ada__containers__formal_hashed_maps__strict_equal
  use import int.Int
  use import "_gnatprove_standard".Main
  use                 "_gnatprove_standard".BV8
  use                 "_gnatprove_standard".BV16
  use                 "_gnatprove_standard".BV32
  use                 "_gnatprove_standard".BV64
  use  "ada__containers__formal_hashed_maps__args".Ada__containers__formal_hashed_maps__key_type
  use import Ada__containers__formal_hashed_maps__map
  use import Ada__containers__formal_hashed_maps__length
  use import Ada__containers__formal_hashed_maps__cursor
  use import Ada__containers__formal_hashed_maps__key
  use import Ada__containers__formal_hashed_maps__element

  function strict_equal__logic map map : bool

  axiom strict_equal__def:
    forall co1 co2 : map [strict_equal__logic co1 co2].
    ((forall cu:cursor [position co1 cu | position co2 cu].
       position co1 cu = position co2 cu) /\
     (forall cu:cursor [key__logic co1 cu | key__logic co2 cu]. position co1 cu > 0 ->
        key__logic co1 cu = key__logic co2 cu) /\
     (forall cu:cursor [element__logic co1 cu | element__logic co2 cu]. position co1 cu > 0 ->
        element__logic co1 cu = element__logic co2 cu)) <->  strict_equal__logic co1 co2 = True

  axiom strict_equal_length_:
    forall co1 co2 : map [strict_equal__logic co1 co2].
     strict_equal__logic co1 co2 = True -> length_ co1 = length_ co2

    val strict_equal (co1:map) (co2:map) : bool
     ensures  { result  = strict_equal__logic co1 co2 }
end

module Ada__containers__formal_hashed_maps__Oeq__2
  use import int.Int
  use                 "_gnatprove_standard".BV8
  use                 "_gnatprove_standard".BV16
  use                 "_gnatprove_standard".BV32
  use                 "_gnatprove_standard".BV64
  use  "ada__containers__formal_hashed_maps__args".Ada__containers__formal_hashed_maps__key_type
  use "ada__containers__formal_hashed_maps__args".Ada__containers__formal_hashed_maps__oeq
  use import Ada__containers__formal_hashed_maps__witness
  use import Ada__containers__formal_hashed_maps__map
  use import Ada__containers__formal_hashed_maps__length
  use import Ada__containers__formal_hashed_maps__cursor
  use import Ada__containers__formal_hashed_maps__no_element
  use import Ada__containers__formal_hashed_maps__key
  use import Ada__containers__formal_hashed_maps__element
  use import Ada__containers__formal_hashed_maps__find

  function oeq__2__logic map map : bool

  axiom oeq__2_length_:
   forall co1 co2 : map [oeq__2__logic co1 co2].
   oeq__2__logic co1 co2 = True -> length_ co1 = length_ co2

  axiom oeq__2_key:
   forall co1 co2 : map [oeq__2__logic co1 co2]. oeq__2__logic co1 co2 = True ->
   forall cu1:cursor [key__logic co1 cu1]. position co1 cu1 > 0 ->
	let cu2 = find_ co2 (witness (key__logic co1 cu1)) in
          position co2 cu2 > 0 /\
          Ada__containers__formal_hashed_maps__oeq.oeq (element__logic co2 cu2) (element__logic co1 cu1) = True

  axiom oeq__2_inv:
   forall co1 co2 : map [oeq__2__logic co1 co2]. oeq__2__logic co1 co2 <> True ->
   (length_ co1 <> length_ co2 \/
   exists e : real. position co1 (find_ co1 e) > 0 /\
         (find_ co2 e = no_element \/ position co2 (find_ co2 e) > 0 /\
          Ada__containers__formal_hashed_maps__oeq.oeq (element__logic co2 (find_ co2 e)) (element__logic co1 (find_ co1 e)) <> True))

  axiom oeq__2_sym :
  forall e1 e2 : map [oeq__2__logic e1 e2].
	oeq__2__logic e1 e2 = True -> oeq__2__logic e2 e1 = True

  axiom oeq__2_trans :
  forall e1 e2 e3 : map [oeq__2__logic e1 e2, oeq__2__logic e1 e3 | oeq__2__logic e1 e2, oeq__2__logic e2 e3].
	oeq__2__logic e1 e2 = True -> oeq__2__logic e2 e3 = True -> oeq__2__logic e1 e3 = True

  val oeq__2 (co1:map) (co2:map) : bool
     ensures  { result  = oeq__2__logic co1 co2 }
end

module Ada__containers__formal_hashed_maps__overlap
  use import int.Int
  use import "_gnatprove_standard".Main
  use                 "_gnatprove_standard".BV8
  use                 "_gnatprove_standard".BV16
  use                 "_gnatprove_standard".BV32
  use                 "_gnatprove_standard".BV64
  use  "ada__containers__formal_hashed_maps__args".Ada__containers__formal_hashed_maps__key_type
  use import Ada__containers__formal_hashed_maps__map
  use import Ada__containers__formal_hashed_maps__length
  use import Ada__containers__formal_hashed_maps__cursor
  use import Ada__containers__formal_hashed_maps__no_element
  use import Ada__containers__formal_hashed_maps__find

  function overlap__logic map map : bool

  axiom overlap__def :
    forall s1:map, s2:map [overlap__logic s1 s2].
     overlap__logic s1 s2 <> True <->
      (forall i:real [find_ s1 i| find_ s2 i].
        find_ s1 i = no_element \/ find_ s2 i = no_element)

  val overlap (co1 co2:map) : bool
     ensures { result = overlap__logic co1 co2 }
end

module Ada__containers__formal_hashed_maps__capacity
  use import int.Int
  use import "_gnatprove_standard".Main
  use Ada__containers__count_type
  use import Ada__containers__formal_hashed_maps__map
  use import Ada__containers__formal_hashed_maps__length

  function capacity__logic (co : map) : Ada__containers__count_type.count_type = rec__ada__containers__formal_hashed_maps__map__capacity (__split_discrs co)

  val capacity (co : map) : Ada__containers__count_type.count_type
    ensures { result = rec__ada__containers__formal_hashed_maps__map__capacity (__split_discrs co) }
end

module Ada__containers__formal_hashed_maps__reserve_capacity
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_hashed_maps__map
  use Ada__containers__count_type__rep

  val reserve_capacity (co:Ada__containers__formal_hashed_maps__map.__split_fields__ref) (cap : Ada__containers__formal_hashed_maps__map.__split_discrs) (c : int) : unit
    requires { Ada__containers__count_type__rep.to_rep cap.rec__ada__containers__formal_hashed_maps__map__capacity >= c }
    ensures { co.Ada__containers__formal_hashed_maps__map.__split_fields__content = old co.Ada__containers__formal_hashed_maps__map.__split_fields__content }
end

module Ada__containers__formal_hashed_maps__default_modulus
  use Ada__containers__hash_type

 function default_modulus__logic (cap : int): Ada__containers__hash_type.rep_type

 val default_modulus  (cap:int) : Ada__containers__hash_type.rep_type
     ensures { result = default_modulus__logic cap }

end

module Ada__containers__formal_hashed_maps__equivalent_keys__2
  use                 "_gnatprove_standard".BV8
  use                 "_gnatprove_standard".BV16
  use                 "_gnatprove_standard".BV32
  use                 "_gnatprove_standard".BV64
  use "ada__containers__formal_hashed_maps__args".Ada__containers__formal_hashed_maps__key_type
  use "ada__containers__formal_hashed_maps__args".Ada__containers__formal_hashed_maps__equivalent_keys
  use import Ada__containers__formal_hashed_maps__map
  use import Ada__containers__formal_hashed_maps__cursor
  use import Ada__containers__formal_hashed_maps__key

  function equivalent_keys__2__logic (co1:map) (cu1:cursor) (co2:map) (cu2:cursor) : bool =
  Ada__containers__formal_hashed_maps__equivalent_keys.equivalent_keys (key__logic co1 cu1)  (key__logic co2 cu2)

 val equivalent_keys__2  (co1:map) (cu1:cursor) (co2:map) (cu2:cursor) : bool
	ensures { result =
  Ada__containers__formal_hashed_maps__equivalent_keys.equivalent_keys (key__logic co1 cu1) (key__logic co2 cu2)  }
end

module Ada__containers__formal_hashed_maps__equivalent_keys__3
  use                 "_gnatprove_standard".BV8
  use                 "_gnatprove_standard".BV16
  use                 "_gnatprove_standard".BV32
  use                 "_gnatprove_standard".BV64
  use "ada__containers__formal_hashed_maps__args".Ada__containers__formal_hashed_maps__key_type
  use "ada__containers__formal_hashed_maps__args".Ada__containers__formal_hashed_maps__equivalent_keys
  use import Ada__containers__formal_hashed_maps__map
  use import Ada__containers__formal_hashed_maps__cursor
  use import Ada__containers__formal_hashed_maps__key

  function equivalent_keys__3__logic (co1:map) (cu1:cursor) (e2 : Ada__containers__formal_hashed_maps__key_type.base_type) : bool =
  Ada__containers__formal_hashed_maps__equivalent_keys.equivalent_keys (key__logic co1 cu1)  e2

 val equivalent_keys__3  (co1:map) (cu1:cursor) (e2 : Ada__containers__formal_hashed_maps__key_type.base_type) : bool
	ensures { result =
  Ada__containers__formal_hashed_maps__equivalent_keys.equivalent_keys (key__logic co1 cu1)  e2  }
end

module Ada__containers__formal_hashed_maps__equivalent_keys__4
  use                 "_gnatprove_standard".BV8
  use                 "_gnatprove_standard".BV16
  use                 "_gnatprove_standard".BV32
  use                 "_gnatprove_standard".BV64
  use "ada__containers__formal_hashed_maps__args".Ada__containers__formal_hashed_maps__key_type
  use "ada__containers__formal_hashed_maps__args".Ada__containers__formal_hashed_maps__equivalent_keys
  use import Ada__containers__formal_hashed_maps__map
  use import Ada__containers__formal_hashed_maps__cursor
  use import Ada__containers__formal_hashed_maps__key

  function equivalent_keys__4__logic (e1 : Ada__containers__formal_hashed_maps__key_type.base_type) (co2:map) (cu2:cursor) : bool =
  Ada__containers__formal_hashed_maps__equivalent_keys.equivalent_keys e1 (key__logic co2 cu2)

 val equivalent_keys__4  (e1 : Ada__containers__formal_hashed_maps__key_type.base_type) (co2:map) (cu2:cursor) : bool
	ensures { result =
  Ada__containers__formal_hashed_maps__equivalent_keys.equivalent_keys e1 (key__logic co2 cu2)  }
end

module Ada__containers__formal_hashed_maps__clear
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_hashed_maps__map
  use import Ada__containers__formal_hashed_maps__length

  val clear (co:Ada__containers__formal_hashed_maps__map.__split_fields__ref) (cap : Ada__containers__formal_hashed_maps__map.__split_discrs) : unit
     writes     { co }
     ensures { let rec_co = {Ada__containers__formal_hashed_maps__map.__split_fields = co.Ada__containers__formal_hashed_maps__map.__split_fields__content;
                              Ada__containers__formal_hashed_maps__map.__split_discrs = cap}  in
               let old_co = {Ada__containers__formal_hashed_maps__map.__split_fields = old co.Ada__containers__formal_hashed_maps__map.__split_fields__content;
                              Ada__containers__formal_hashed_maps__map.__split_discrs = cap}  in
                   length_ rec_co = 0 /\ capacity rec_co = capacity old_co }
end

module Ada__containers__formal_hashed_maps__assign
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_hashed_maps__map
  use import Ada__containers__formal_hashed_maps__length
  use import Ada__containers__formal_hashed_maps__Oeq__2

  val assign (target:Ada__containers__formal_hashed_maps__map.__split_fields__ref) (cap : Ada__containers__formal_hashed_maps__map.__split_discrs) (source:map) : unit
     requires { let rec_t = {Ada__containers__formal_hashed_maps__map.__split_fields = target.Ada__containers__formal_hashed_maps__map.__split_fields__content;
                              Ada__containers__formal_hashed_maps__map.__split_discrs = cap}  in
                   capacity rec_t >= length_ source }
     writes     { target }
     reads      { target }
     ensures { let rec_t = {Ada__containers__formal_hashed_maps__map.__split_fields = target.Ada__containers__formal_hashed_maps__map.__split_fields__content;
                              Ada__containers__formal_hashed_maps__map.__split_discrs = cap}  in
                   oeq__2__logic rec_t source = True }
end

module Ada__containers__formal_hashed_maps__move
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_hashed_maps__map
  use import Ada__containers__formal_hashed_maps__length
  use import Ada__containers__formal_hashed_maps__Oeq__2

  val move (target:Ada__containers__formal_hashed_maps__map.__split_fields__ref) (t_cap : Ada__containers__formal_hashed_maps__map.__split_discrs) (source:Ada__containers__formal_hashed_maps__map.__split_fields__ref) (s_cap : Ada__containers__formal_hashed_maps__map.__split_discrs) : unit
     requires { let rec_t = {Ada__containers__formal_hashed_maps__map.__split_fields = target.Ada__containers__formal_hashed_maps__map.__split_fields__content;
                              Ada__containers__formal_hashed_maps__map.__split_discrs = t_cap}  in
               let rec_s = {Ada__containers__formal_hashed_maps__map.__split_fields = source.Ada__containers__formal_hashed_maps__map.__split_fields__content;
                              Ada__containers__formal_hashed_maps__map.__split_discrs = s_cap}  in
                 capacity rec_t >= length_ rec_s }
     writes     { target, source }
     reads      { target, source }
     ensures { let rec_t = {Ada__containers__formal_hashed_maps__map.__split_fields = target.Ada__containers__formal_hashed_maps__map.__split_fields__content;
                              Ada__containers__formal_hashed_maps__map.__split_discrs = t_cap}  in
               let rec_s = {Ada__containers__formal_hashed_maps__map.__split_fields = source.Ada__containers__formal_hashed_maps__map.__split_fields__content;
                              Ada__containers__formal_hashed_maps__map.__split_discrs = s_cap}  in
               let old_s = {Ada__containers__formal_hashed_maps__map.__split_fields = old source.Ada__containers__formal_hashed_maps__map.__split_fields__content;
                              Ada__containers__formal_hashed_maps__map.__split_discrs = s_cap}  in
                   oeq__2__logic rec_t old_s = True /\ length_ rec_s = 0 }
end

module Ada__containers__formal_hashed_maps__copy
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_hashed_maps__map
  use import Ada__containers__formal_hashed_maps__length
  use import Ada__containers__formal_hashed_maps__strict_equal

  function copy__logic map int : map

  axiom copy__def:
    forall co : map, cap : int [copy__logic co cap].
       strict_equal__logic co (copy__logic co cap) = True /\
       (cap = 0 -> capacity co = capacity (copy__logic co cap)) /\
       (cap >= capacity co ->  capacity (copy__logic co cap) = cap)

  val copy (co: map) (cap:int) : map
     requires { cap = 0 \/ cap >= capacity co}
     ensures { result = copy__logic co cap /\ map_inv result }
end

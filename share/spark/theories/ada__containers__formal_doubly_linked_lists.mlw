module Ada__containers__formal_doubly_linked_lists__list
  use import int.Int
  use import "_gnatprove_standard".Main
  use Ada__containers__count_type

  type __split_discrs = {rec__capacity : Ada__containers__count_type.count_type}

  type __split_fields = { rec__main__ : __private }

  type list = { __split_discrs : __split_discrs; __split_fields : __split_fields }

  predicate list_inv "inline" (l : list) =
     l = { __split_discrs = { rec__capacity = l.__split_discrs.rec__capacity }; __split_fields = { rec__main__ = l.__split_fields.rec__main__ } }
 
   function capacity  (co : list) : int =
          Ada__containers__count_type.to_rep (rec__capacity (__split_discrs (co)))

  function bool_eq list list : bool
  function user_eq list list : bool
end

module Ada__containers__formal_doubly_linked_lists__length
  use import int.Int
  use import "_gnatprove_standard".Main
  use Ada__containers__count_type
  use import Ada__containers__formal_doubly_linked_lists__list

  function length__logic list : int

  function length_ "inline" (co : list) : int =
    length__logic co

  axiom length_range:
    forall co:list [length__logic co]. 0 <= length_ co <= capacity co

  val length (co : list) : int
     ensures { result = length__logic co }
end

module Ada__containers__formal_doubly_linked_lists__cursor
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_doubly_linked_lists__args".Ada__containers__formal_doubly_linked_lists__element_type
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length

  type __split_fields = { rec__main__ : __private }

  type cursor = { __split_fields : __split_fields }

  function dummy : cursor

  function position list cursor : int

  function position_inv list int : cursor

  axiom position_gte_zero:
    forall co:list, cu:cursor [position co cu].
        length_ co >= position co cu >= 0

  axiom position_eq1:
   forall co:list, i :int [position co (position_inv co i)]. 0 < i <= length_ co ->
              position co (position_inv co i) = i

  axiom position_eq2:
    forall co:list, cu:cursor [position co cu].
          position co cu > 0 -> position_inv co (position co cu) = cu

  function bool_eq "inline" (c1:cursor) (c2:cursor) : bool = c1 = c2
  function user_eq cursor cursor : bool
end

module Ada__containers__formal_doubly_linked_lists__no_element
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor

  function no_element : cursor

  axiom position_no_element:
    forall co:list [position co no_element]. position co no_element = 0
end

module Ada__containers__formal_doubly_linked_lists__empty_list
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length

  function empty_list : list

  axiom Empty_is_empty: length_ empty_list = 0
end

module Ada__containers__formal_doubly_linked_lists__is_empty
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length

  function is_empty__logic list : bool

  axiom is_empty:
    forall co:list [is_empty__logic (co)].
          is_empty__logic (co) = True <-> length_ co = 0

  val is_empty (co:list) : bool
     ensures  { result = is_empty__logic co }
end

module Ada__containers__formal_doubly_linked_lists__previous
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__no_element

  function previous__logic list cursor : cursor

  axiom previous_in:
    forall co:list, cu:cursor [previous__logic co cu].
	(position co cu > 1 \/ position co (previous__logic co cu) > 0) ->
	position co (previous__logic co cu) = position co cu - 1

  axiom previous_ext:
    forall co:list, cu:cursor [previous__logic co cu].
        (position co cu = 1 \/ cu = no_element) -> previous__logic co cu = no_element

  val previous (co:list) (cu:cursor) : cursor
     requires { cu = no_element \/ position co cu > 0 }
     ensures  { result = previous__logic co cu }
end

module Ada__containers__formal_doubly_linked_lists__previous__2
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__no_element
  use import Ada__containers__formal_doubly_linked_lists__previous

  val previous__2 (co:list) (cu:ref cursor) : unit
     requires { !cu = no_element \/ position co !cu > 0 }
     writes     { cu }
     reads      { cu }
     ensures  { !cu = previous__logic co (old !cu) }
end

module Ada__containers__formal_doubly_linked_lists__next
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__no_element

  function next__logic list cursor : cursor

  axiom next_in:
    forall co:list, cu:cursor [next__logic co cu].
	(length_ co > position co cu > 0 \/ position co (next__logic co cu) > 0) ->
	position co (next__logic co cu) = position co cu + 1

  axiom next_ext:
    forall co:list, cu:cursor [next__logic co cu].
        (position co cu = length_ co \/ cu = no_element) -> next__logic co cu = no_element

  val next (co:list) (cu:cursor) : cursor
     requires { cu = no_element \/ position co cu > 0 }
     ensures  { result = next__logic co cu }
end

module Ada__containers__formal_doubly_linked_lists__next__2
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__no_element
  use import Ada__containers__formal_doubly_linked_lists__next

  val next__2 (co:list) (cu:ref cursor) : unit
     requires { !cu = no_element \/ position co !cu > 0 }
     writes     { cu }
     reads      { cu }
     ensures  { !cu = next__logic co (old !cu) }
end

module Ada__containers__formal_doubly_linked_lists__last
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__no_element

  function last__logic list : cursor

  axiom last_empty:
    forall co:list [last__logic co]. length_ co = 0 <-> last__logic co = no_element

  axiom last_gen:
    forall co:list [last__logic co]. length_ co = position co (last__logic co)

  val last (co:list) : cursor
     ensures  { result = last__logic co }
end

module Ada__containers__formal_doubly_linked_lists__first
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__no_element

  function first__logic list : cursor

  axiom first_empty:
    forall co:list [first__logic co]. length_ co = 0 <-> first__logic co = no_element

  axiom first_gen:
    forall co:list [first__logic co]. length_ co > 0 -> position co (first__logic co) = 1

  val first (co:list) : cursor
     ensures  { result = first__logic co }
end

module Ada__containers__formal_doubly_linked_lists__element
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_doubly_linked_lists__args".Ada__containers__formal_doubly_linked_lists__element_type
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor

  function element__logic list cursor : Ada__containers__formal_doubly_linked_lists__element_type.base_type

  axiom element_range:
    forall l : list, cu : cursor. Ada__containers__formal_doubly_linked_lists__element_type.valid (element__logic l cu)

  val element (co:list) (cu:cursor) : Ada__containers__formal_doubly_linked_lists__element_type.base_type
     requires { position co cu > 0 }
     ensures  { result = element__logic co cu }
end

module Ada__containers__formal_doubly_linked_lists__first_element
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_doubly_linked_lists__args".Ada__containers__formal_doubly_linked_lists__element_type
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__first
  use import Ada__containers__formal_doubly_linked_lists__element

  function first_element__logic (co:list) : Ada__containers__formal_doubly_linked_lists__element_type.base_type
= element__logic co (first__logic co)

  val first_element (co:list) : Ada__containers__formal_doubly_linked_lists__element_type.base_type
     requires { length_ co > 0 }
     ensures  { result = element__logic co (first__logic co) }
end

module Ada__containers__formal_doubly_linked_lists__last_element
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_doubly_linked_lists__args".Ada__containers__formal_doubly_linked_lists__element_type
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__last
  use import Ada__containers__formal_doubly_linked_lists__element

  function last_element__logic (co:list) : Ada__containers__formal_doubly_linked_lists__element_type.base_type
= element__logic co (last__logic co)

  val last_element (co:list) : Ada__containers__formal_doubly_linked_lists__element_type.base_type
     requires { length_ co > 0 }
     ensures  { result = element__logic co (last__logic co) }
end

module Ada__containers__formal_doubly_linked_lists__first_to_previous
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__no_element
  use import Ada__containers__formal_doubly_linked_lists__element

  function first_to_previous__logic list cursor : list

  axiom first_to_previous_no_element:
    forall co:list [first_to_previous__logic co no_element]. first_to_previous__logic co no_element = co

  axiom first_to_previous_length_:
    forall co:list, cu:cursor [first_to_previous__logic co cu].
	position co cu > 0 -> length_ (first_to_previous__logic co cu) = position co cu - 1

  axiom first_to_previous_position_in:
    forall co:list, cu cun:cursor [position (first_to_previous__logic co cu) cun | first_to_previous__logic co cu, position co cun].
	(position (first_to_previous__logic co cu) cun > 0 \/ position co cun < position co cu) ->
	position (first_to_previous__logic co cu) cun = position co cun

  axiom first_to_previous_position_ext:
    forall co:list, cu cun:cursor [position (first_to_previous__logic co cu) cun].
	position co cun >= position co cu > 0 ->
	position (first_to_previous__logic co cu) cun = 0

  axiom first_to_previous_element:
    forall co:list, cu cun:cursor [element__logic (first_to_previous__logic co cu) cun | first_to_previous__logic co cu, element__logic co cun].
	(position (first_to_previous__logic co cu) cun > 0 \/ 0 < position co cun < position co cu) ->
	element__logic (first_to_previous__logic co cu) cun = element__logic co cun

  val first_to_previous (co:list) (cu:cursor) : list
     requires { cu = no_element \/ position co cu > 0 }
     ensures  { result = first_to_previous__logic co cu /\ list_inv result }
end

module Ada__containers__formal_doubly_linked_lists__current_to_last
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__empty_list
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__no_element
  use import Ada__containers__formal_doubly_linked_lists__element

  function current_to_last__logic list cursor : list

  axiom current_to_last_no_element:
    forall co:list [current_to_last__logic co no_element]. current_to_last__logic co no_element = empty_list

  axiom current_to_last_length_:
    forall co:list, cu:cursor [length_ (current_to_last__logic co cu) ].
	position co cu > 0 -> length_ (current_to_last__logic co cu) = (length_ co) - (position co cu) + 1

  axiom current_to_last_position_in:
    forall co:list, cu cun:cursor [position (current_to_last__logic co cu) cun | current_to_last__logic co cu, position co cun].
	(position (current_to_last__logic co cu) cun > 0 \/ position co cun >= position co cu > 0) ->
	position (current_to_last__logic co cu) cun = (position co cun) - (position co cu) + 1

  axiom current_to_last_position_ext:
    forall co:list, cu cun:cursor [position (current_to_last__logic co cu) cun].
	position co cun < position co cu -> position (current_to_last__logic co cu) cun = 0

  axiom current_to_last_element:
    forall co:list, cu cun:cursor [element__logic (current_to_last__logic co cu) cun | current_to_last__logic co cu, element__logic co cun].
	(position (current_to_last__logic co cu) cun > 0 \/ 0 < position co cu <= position co cun) ->
	element__logic (current_to_last__logic co cu) cun = element__logic co cun

  val current_to_last (co:list) (cu:cursor) : list
     requires { cu = no_element \/ position co cu > 0 }
     ensures  { result = current_to_last__logic co cu /\ list_inv result }
end

module Ada__containers__formal_doubly_linked_lists__find
  use import int.Int
  use import "_gnatprove_standard".Main
  use  "ada__containers__formal_doubly_linked_lists__args".Ada__containers__formal_doubly_linked_lists__element_type
  use  "ada__containers__formal_doubly_linked_lists__args".Ada__containers__formal_doubly_linked_lists__oeq
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__no_element
  use import Ada__containers__formal_doubly_linked_lists__element
  use import Ada__containers__formal_doubly_linked_lists__current_to_last

  function findfirst list Ada__containers__formal_doubly_linked_lists__element_type.base_type : cursor

  axiom find_range:
    forall co:list, e:Ada__containers__formal_doubly_linked_lists__element_type.base_type [findfirst co e].
	findfirst co e = no_element \/ position co (findfirst co e) > 0

  axiom find_not:
    forall co:list, e:Ada__containers__formal_doubly_linked_lists__element_type.base_type, cu : cursor [findfirst co e, element__logic co cu].
	findfirst co e = no_element -> position co cu > 0 ->
	Ada__containers__formal_doubly_linked_lists__oeq.oeq (element__logic co cu) e = False

  axiom find_yes:
    forall co:list, e:Ada__containers__formal_doubly_linked_lists__element_type.base_type, cu : cursor [findfirst co e, element__logic co cu].
	0 < position co cu < position co (findfirst co e) ->
	Ada__containers__formal_doubly_linked_lists__oeq.oeq (element__logic co cu) e = False

  axiom find_element:
    forall co:list, e:Ada__containers__formal_doubly_linked_lists__element_type.base_type [findfirst co e].
	0 < position co (findfirst co e) ->
	Ada__containers__formal_doubly_linked_lists__oeq.oeq (element__logic co (findfirst co e)) e = True

  function find__logic (l : list) (e : Ada__containers__formal_doubly_linked_lists__element_type.base_type) (cu : cursor) : cursor =
    if cu = no_element then (findfirst l e) else (findfirst (current_to_last__logic l cu) e)

  val find (co:list) (e:Ada__containers__formal_doubly_linked_lists__element_type.base_type) (cu:cursor) : cursor
     requires { cu = no_element \/ position co cu > 0 }
     ensures  { result = find__logic co e cu }
end

module Ada__containers__formal_doubly_linked_lists__first_to_current
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__empty_list
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__no_element
  use import Ada__containers__formal_doubly_linked_lists__element

  function first_to_current__logic list cursor : list

  axiom first_to_current_no_element:
    forall co:list [first_to_current__logic co no_element]. first_to_current__logic co no_element = empty_list

  axiom first_to_current_length_:
    forall co:list, cu:cursor [first_to_current__logic co cu].
	position co cu > 0 -> length_ (first_to_current__logic co cu) = position co cu

  axiom first_to_current_position_in:
    forall co:list, cu cun:cursor [position (first_to_current__logic co cu) cun | first_to_current__logic co cu, position co cun].
	(position (first_to_current__logic co cu) cun > 0 \/ position co cun <= position co cu) ->
	position (first_to_current__logic co cu) cun = position co cun

  axiom first_to_current_position_ext:
    forall co:list, cu cun:cursor [position (first_to_current__logic co cu) cun].
	position co cun > position co cu > 0 ->
	position (first_to_current__logic co cu) cun = 0

  axiom first_to_current_element:
    forall co:list, cu cun:cursor [element__logic (first_to_current__logic co cu) cun | first_to_current__logic co cu, element__logic co cun].
	(position (first_to_current__logic co cu) cun > 0 \/ 0 < position co cun <= position co cu) ->
	element__logic (first_to_current__logic co cu) cun = element__logic co cun
end

module Ada__containers__formal_doubly_linked_lists__reverse_find
  use import int.Int
  use import "_gnatprove_standard".Main
  use  "ada__containers__formal_doubly_linked_lists__args".Ada__containers__formal_doubly_linked_lists__element_type
  use "ada__containers__formal_doubly_linked_lists__args".Ada__containers__formal_doubly_linked_lists__oeq
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__no_element
  use import Ada__containers__formal_doubly_linked_lists__element
  use import Ada__containers__formal_doubly_linked_lists__first_to_current

  function findlast list Ada__containers__formal_doubly_linked_lists__element_type.base_type : cursor

  axiom rev_find_range:
    forall co:list, e:Ada__containers__formal_doubly_linked_lists__element_type.base_type [findlast co e].
	findlast co e = no_element \/ position co (findlast co e) > 0

  axiom rev_find_not:
    forall co:list, e:Ada__containers__formal_doubly_linked_lists__element_type.base_type, cu : cursor [findlast co e, element__logic co cu].
	findlast co e = no_element -> position co cu > 0 ->
	Ada__containers__formal_doubly_linked_lists__oeq.oeq (element__logic co cu) e = False

  axiom rev_find_yes:
    forall co:list, e:Ada__containers__formal_doubly_linked_lists__element_type.base_type, cu : cursor [findlast co e, element__logic co cu].
	position co (findlast co e) < position co cu <= length_ co ->
	Ada__containers__formal_doubly_linked_lists__oeq.oeq (element__logic co cu) e = False

  axiom rev_find_element:
    forall co:list, e:Ada__containers__formal_doubly_linked_lists__element_type.base_type [findlast co e].
	0 < position co (findlast co e) ->
	Ada__containers__formal_doubly_linked_lists__oeq.oeq (element__logic co (findlast co e)) e = True

  function reverse_find__logic (l : list) (e : Ada__containers__formal_doubly_linked_lists__element_type.base_type) (cu : cursor) : cursor =
    if cu = no_element then (findlast l e) else (findlast (first_to_current__logic l cu) e)

  val reverse_find (co:list) (e:Ada__containers__formal_doubly_linked_lists__element_type.base_type) (cu:cursor) : cursor
     requires { cu = no_element \/ position co cu > 0 }
     ensures  { result = reverse_find__logic co e cu }
end

module Ada__containers__formal_doubly_linked_lists__strict_equal
  use import int.Int
  use import "_gnatprove_standard".Main
  use  "ada__containers__formal_doubly_linked_lists__args".Ada__containers__formal_doubly_linked_lists__element_type
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__element

  function strict_equal__logic list list : bool

  axiom strict_equal__def:
    forall co1 co2 : list [strict_equal__logic co1 co2].
    ((forall cu:cursor [position co1 cu | position co2 cu].
       position co1 cu = position co2 cu) /\
     (forall cu:cursor [element__logic co1 cu | element__logic co2 cu]. position co1 cu > 0 ->
        element__logic co1 cu = element__logic co2 cu)) <->  strict_equal__logic co1 co2 = True

  axiom strict_equal_length_:
    forall co1 co2 : list [strict_equal__logic co1 co2].
     strict_equal__logic co1 co2 = True -> length_ co1 = length_ co2

    val strict_equal (co1:list) (co2:list) : bool
     ensures  { result  = strict_equal__logic co1 co2 }
end

module Ada__containers__formal_doubly_linked_lists__Oeq__2
  use import int.Int
  use  "ada__containers__formal_doubly_linked_lists__args".Ada__containers__formal_doubly_linked_lists__element_type
  use "ada__containers__formal_doubly_linked_lists__args".Ada__containers__formal_doubly_linked_lists__oeq
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__element

  function oeq__2__logic list list : bool

  axiom oeq__2_length_:
   forall co1 co2 : list [oeq__2__logic co1 co2].
   oeq__2__logic co1 co2 = True -> length_ co1 = length_ co2

  axiom oeq__2_element:
   forall co1 co2 : list [oeq__2__logic co1 co2]. oeq__2__logic co1 co2 = True ->
   forall cu1 : cursor [element__logic co1 cu1]. position co1 cu1 > 0 ->
	exists cu2 : cursor. position co2 cu2 = position co1 cu1 /\
          Ada__containers__formal_doubly_linked_lists__oeq.oeq (element__logic co2 cu2) (element__logic co1 cu1) = True

  axiom oeq__2_inv:
   forall co1 co2 : list [oeq__2__logic co1 co2]. oeq__2__logic co1 co2 <> True ->
   (length_ co1 <> length_ co2 \/
   exists i : int. 0<i<=length_ co1 /\ Ada__containers__formal_doubly_linked_lists__oeq.oeq (element__logic co1 (position_inv co1 i))
       (element__logic co2 (position_inv co2 i))=False)

  axiom oeq__2_sym :
  forall e1 e2 : list [oeq__2__logic e1 e2].
	oeq__2__logic e1 e2 = True -> oeq__2__logic e2 e1 = True

  axiom oeq__2_trans :
  forall e1 e2 e3 : list [oeq__2__logic e1 e2, oeq__2__logic e1 e3 | oeq__2__logic e1 e2, oeq__2__logic e2 e3].
	oeq__2__logic e1 e2 = True -> oeq__2__logic e2 e3 = True -> oeq__2__logic e1 e3 = True

  val oeq__2 (co1:list) (co2:list) : bool
     ensures  { result  = oeq__2__logic co1 co2 }
end

module Ada__containers__formal_doubly_linked_lists__replace_element
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_doubly_linked_lists__args".Ada__containers__formal_doubly_linked_lists__element_type
  use "ada__containers__formal_doubly_linked_lists__args".Ada__containers__formal_doubly_linked_lists__oeq
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__element

  predicate replace_element list cursor Ada__containers__formal_doubly_linked_lists__element_type.base_type list

  axiom replace_element_length_:
    forall co1 co2:list, cu:cursor, e:Ada__containers__formal_doubly_linked_lists__element_type.base_type
      [replace_element co1 cu e co2].
      replace_element co1 cu e co2 -> length_ co1 = length_ co2

  axiom replace_element_capacity:
    forall co1 co2:list, cu:cursor, e:Ada__containers__formal_doubly_linked_lists__element_type.base_type
      [replace_element co1 cu e co2, capacity co1|replace_element co1 cu e co2, capacity co2].
      replace_element co1 cu e co2 -> capacity co1 = capacity co2

  axiom replace_element_position_ext:
    forall co1 co2:list, cu cun:cursor, e:Ada__containers__formal_doubly_linked_lists__element_type.base_type
      [replace_element co1 cu e co2, position co2 cun
     | replace_element co1 cu e co2, position co1 cun].
      replace_element co1 cu e co2 -> position co2 cun = position co1 cun

  axiom replace_element_position_in:
    forall co1 co2:list, cu:cursor, e:Ada__containers__formal_doubly_linked_lists__element_type.base_type
      [replace_element co1 cu e co2].
      replace_element co1 cu e co2 -> position co2 cu > 0

  axiom replace_element_element_in:
    forall co1 co2:list, cu:cursor, e:Ada__containers__formal_doubly_linked_lists__element_type.base_type
      [replace_element co1 cu e co2].
      replace_element co1 cu e co2 -> Ada__containers__formal_doubly_linked_lists__oeq.oeq (element__logic co2 cu) e

  axiom replace_element_element_ext:
    forall co1 co2:list, cu cun:cursor, e:Ada__containers__formal_doubly_linked_lists__element_type.base_type
      [replace_element co1 cu e co2, element__logic co2 cun
     | replace_element co1 cu e co2, element__logic co1 cun].
      replace_element co1 cu e co2 -> cu <> cun -> position co1 cun > 0 ->
        element__logic co2 cun = element__logic co1 cun

  val replace_element (co:ref Ada__containers__formal_doubly_linked_lists__list.__split_fields) (cap : Ada__containers__formal_doubly_linked_lists__list.__split_discrs) (cu:cursor) (e:Ada__containers__formal_doubly_linked_lists__element_type.base_type) : unit
     requires { let rec_co = {Ada__containers__formal_doubly_linked_lists__list.__split_fields = !co;
                              Ada__containers__formal_doubly_linked_lists__list.__split_discrs = cap}  in
                   position rec_co cu > 0 }
     writes     { co }
     reads      { co }
     ensures { let rec_co = {Ada__containers__formal_doubly_linked_lists__list.__split_fields = !co;
                             Ada__containers__formal_doubly_linked_lists__list.__split_discrs = cap}  in
               let old_co = {Ada__containers__formal_doubly_linked_lists__list.__split_fields = (old !co);
                             Ada__containers__formal_doubly_linked_lists__list.__split_discrs = cap}  in
                  replace_element old_co cu e rec_co }
end

module Ada__containers__formal_doubly_linked_lists__reverse_elements
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__element

  predicate reverse_elements list list

  axiom reverse_elements_length_:
    forall co1 co2:list
      [reverse_elements co1 co2].
      reverse_elements co1 co2 -> length_ co1 = length_ co2

  axiom reverse_elements_capacity:
    forall co1 co2:list
      [reverse_elements co1 co2, capacity co1|reverse_elements co1 co2, capacity co2].
      reverse_elements co1 co2 -> capacity co1 = capacity co2

  axiom reverse_elements_position:
    forall co1 co2:list, cun:cursor
      [reverse_elements co1 co2, position co2 cun
     | reverse_elements co1 co2, position co1 cun].
      reverse_elements co1 co2 -> position co2 cun = (length_ co1) - (position co1 cun) + 1

  axiom reverse_elements_element:
    forall co1 co2:list, cun:cursor
      [reverse_elements co1 co2, element__logic co2 cun
     | reverse_elements co1 co2, element__logic co1 cun].
      reverse_elements co1 co2 -> position co1 cun > 0 ->
        element__logic co2 cun = element__logic co1 cun

  val reverse_elements (co:ref Ada__containers__formal_doubly_linked_lists__list.__split_fields) (cap : Ada__containers__formal_doubly_linked_lists__list.__split_discrs) : unit
     writes     { co }
     ensures { let rec_co = {Ada__containers__formal_doubly_linked_lists__list.__split_fields = !co;
                             Ada__containers__formal_doubly_linked_lists__list.__split_discrs = cap}  in
               let old_co = {Ada__containers__formal_doubly_linked_lists__list.__split_fields = (old !co);
                             Ada__containers__formal_doubly_linked_lists__list.__split_discrs = cap}  in
                  reverse_elements rec_co old_co }
end

module Ada__containers__formal_doubly_linked_lists__insert
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_doubly_linked_lists__args".Ada__containers__formal_doubly_linked_lists__element_type
  use "ada__containers__formal_doubly_linked_lists__args".Ada__containers__formal_doubly_linked_lists__oeq
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__no_element
  use import Ada__containers__formal_doubly_linked_lists__previous
  use import Ada__containers__formal_doubly_linked_lists__last
  use import Ada__containers__formal_doubly_linked_lists__element

  predicate insert list cursor Ada__containers__formal_doubly_linked_lists__element_type.base_type list

  axiom insert_range:
    forall co1 co2:list, cu:cursor, e:Ada__containers__formal_doubly_linked_lists__element_type.base_type [insert co1 cu e co2].
      insert co1 cu e co2 -> cu = no_element \/ position co1 cu > 0

  axiom insert_length_:
    forall co1 co2:list, cu:cursor, e:Ada__containers__formal_doubly_linked_lists__element_type.base_type
      [insert co1 cu e co2].
      insert co1 cu e co2 -> length_ co1 + 1 = length_ co2

  axiom insert_capacity:
    forall co1 co2:list, cu:cursor, e:Ada__containers__formal_doubly_linked_lists__element_type.base_type
      [insert co1 cu e co2, capacity co1|insert co1 cu e co2, capacity co2].
      insert co1 cu e co2 -> capacity co1 = capacity co2

  axiom insert_new:
    forall co1 co2:list, cu:cursor, e:Ada__containers__formal_doubly_linked_lists__element_type.base_type [insert co1 cu e co2].
      insert co1 cu e co2 -> position co1 cu > 0 ->
      (position co1 (previous__logic co2 cu) = 0 /\ Ada__containers__formal_doubly_linked_lists__oeq.oeq (element__logic co2 (previous__logic co2 cu)) e)

  axiom insert_new_no_element:
    forall co1 co2:list, e:Ada__containers__formal_doubly_linked_lists__element_type.base_type [insert co1 no_element e co2].
      insert co1 no_element e co2 ->
        position co1 (last__logic co2) = 0 /\ Ada__containers__formal_doubly_linked_lists__oeq.oeq (element__logic co2 (last__logic co2)) e

  axiom insert_position_before:
    forall co1 co2:list, cu cun:cursor, e:Ada__containers__formal_doubly_linked_lists__element_type.base_type
      [insert co1 cu e co2,  position co1 cun
     | insert co1 cu e co2,  position co2 cun].
      insert co1 cu e co2 -> position co1 cu > 0 ->
      (position co1 cu > position co1 cun > 0 \/ position co2 cun < position co1 cu) ->
        position co1 cun = position co2 cun

  axiom insert_position_after:
    forall co1 co2:list, cu cun:cursor, e:Ada__containers__formal_doubly_linked_lists__element_type.base_type
      [insert co1 cu e co2,  position co1 cun
     | insert co1 cu e co2,  position co2 cun].
      insert co1 cu e co2 -> position co1 cu > 0 ->
      (position co1 cun >= position co1 cu \/ position co2 cun > position co1 cu) ->
        position co1 cun + 1 = position co2 cun

  axiom insert_position_no_element:
    forall co1 co2:list, cun:cursor, e:Ada__containers__formal_doubly_linked_lists__element_type.base_type
      [insert co1 no_element e co2,  position co1 cun
     | insert co1 no_element e co2,  position co2 cun].
      insert co1 no_element e co2 -> (position co1 cun > 0 \/ position co2 cun < length_ co2) ->
        position co1 cun = position co2 cun

  axiom insert_element:
    forall co1 co2:list, cu cun:cursor, e:Ada__containers__formal_doubly_linked_lists__element_type.base_type
      [insert co1 cu e co2,  element__logic co1 cun
     | insert co1 cu e co2,  element__logic co2 cun].
      insert co1 cu e co2 -> position co1 cu > 0 ->
      position co1 cun > 0 ->
        element__logic co1 cun = element__logic co2 cun

  axiom insert_element_no_element:
    forall co1 co2:list, cun:cursor, e:Ada__containers__formal_doubly_linked_lists__element_type.base_type
      [insert co1 no_element e co2,  element__logic co1 cun
     | insert co1 no_element e co2,  element__logic co2 cun].
      insert co1 no_element e co2 ->
      (position co1 cun > 0 \/ 0 < position co2 cun < length_ co2) ->
        element__logic co1 cun = element__logic co2 cun

  predicate insert_mult list cursor Ada__containers__formal_doubly_linked_lists__element_type.base_type int list

  axiom insert_mult_0 :
    forall li1 li2 : list, cu : cursor, e : Ada__containers__formal_doubly_linked_lists__element_type.base_type [insert_mult li1 cu e 0 li2].
	insert_mult li1 cu e 0 li2 -> li1 = li2

  axiom insert_mult_1 :
    forall li1 li2 : list, cu : cursor, e : Ada__containers__formal_doubly_linked_lists__element_type.base_type [insert_mult li1 cu e 1 li2].
	insert_mult li1 cu e 1 li2 -> insert li1 cu e li2

  axiom insert_mult_n :
    forall li1 li2 : list, cu : cursor, e : Ada__containers__formal_doubly_linked_lists__element_type.base_type, c : int [insert_mult li1 cu e c li2].
	insert_mult li1 cu e c li2 -> c > 1 ->
	 exists nl : list [insert li1 cu e nl].
    		(insert li1 cu e nl /\ insert_mult nl cu e (c - 1) li2)

  val insert (co:ref Ada__containers__formal_doubly_linked_lists__list.__split_fields) (cap : Ada__containers__formal_doubly_linked_lists__list.__split_discrs) (cu:cursor) (e:Ada__containers__formal_doubly_linked_lists__element_type.base_type)
                                             (c : int) : unit
     requires { let rec_co = {Ada__containers__formal_doubly_linked_lists__list.__split_fields = !co;
                             Ada__containers__formal_doubly_linked_lists__list.__split_discrs = cap}  in
               length_ rec_co + c <= capacity rec_co
                         /\ (position rec_co cu > 0 \/ cu = no_element) }
     writes     { co }
     reads      { co }
     ensures { let rec_co = {Ada__containers__formal_doubly_linked_lists__list.__split_fields = !co;
                             Ada__containers__formal_doubly_linked_lists__list.__split_discrs = cap}  in
               let old_co = {Ada__containers__formal_doubly_linked_lists__list.__split_fields = (old !co);
                             Ada__containers__formal_doubly_linked_lists__list.__split_discrs = cap}  in
                  insert_mult old_co cu e c rec_co }
end

module Ada__containers__formal_doubly_linked_lists__insert__2
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_doubly_linked_lists__args".Ada__containers__formal_doubly_linked_lists__element_type
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__no_element
  use import Ada__containers__formal_doubly_linked_lists__first
  use import Ada__containers__formal_doubly_linked_lists__insert

  predicate first_inserted (co1:list) (cu:cursor) (co2:list) (p:cursor) =
	    cu = no_element /\ length_ co1 > 0 /\ position co2 p = length_ co2 \/
             length_ co1 = 0 /\ p = first__logic co2 \/
             position co1 cu > 0 /\ position co2 p = position co1 cu

  val insert__2 (co:ref Ada__containers__formal_doubly_linked_lists__list.__split_fields) (cap : Ada__containers__formal_doubly_linked_lists__list.__split_discrs) (cu:cursor) (e:Ada__containers__formal_doubly_linked_lists__element_type.base_type) (p:ref cursor)
                                             (c : int) : unit
     requires { let rec_co = {Ada__containers__formal_doubly_linked_lists__list.__split_fields = !co;
                             Ada__containers__formal_doubly_linked_lists__list.__split_discrs = cap}  in
                   length_ rec_co + c <= capacity rec_co
                         /\ (position rec_co cu > 0 \/ cu = no_element) }
     writes     { co, p }
     reads      { co }
     ensures { let rec_co = {Ada__containers__formal_doubly_linked_lists__list.__split_fields = !co;
                             Ada__containers__formal_doubly_linked_lists__list.__split_discrs = cap}  in
               let old_co = {Ada__containers__formal_doubly_linked_lists__list.__split_fields = (old !co);
                             Ada__containers__formal_doubly_linked_lists__list.__split_discrs = cap}  in
                  insert_mult old_co cu e c rec_co /\
            first_inserted old_co cu rec_co !p }
end

module Ada__containers__formal_doubly_linked_lists__insert__3
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_doubly_linked_lists__args".Ada__containers__formal_doubly_linked_lists__element_type
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__no_element
  use import Ada__containers__formal_doubly_linked_lists__insert
  use import Ada__containers__formal_doubly_linked_lists__insert__2

  predicate insert_3_mult list cursor int list

  axiom insert_3_mult_0 :
    forall li1 li2 : list, cu : cursor [insert_3_mult li1 cu 0 li2].
	insert_3_mult li1 cu 0 li2 -> li1 = li2

  axiom insert_3_mult_1 :
    forall li1 li2 : list, cu : cursor [insert_3_mult li1 cu 1 li2].
	insert_3_mult li1 cu 1 li2 ->
        exists e : Ada__containers__formal_doubly_linked_lists__element_type.base_type.
         Ada__containers__formal_doubly_linked_lists__element_type.valid e /\ insert li1 cu e li2

  axiom insert_3_mult_n :
    forall li1 li2 : list, cu : cursor, c : int [insert_3_mult li1 cu c li2].
	insert_3_mult li1 cu c li2 -> c > 1 ->
	 exists nl : list , e : Ada__containers__formal_doubly_linked_lists__element_type.base_type [insert li1 cu e nl].
         Ada__containers__formal_doubly_linked_lists__element_type.valid e /\
    		(insert li1 cu e nl /\ insert_3_mult nl cu (c - 1) li2)

  val insert__3 (co:ref Ada__containers__formal_doubly_linked_lists__list.__split_fields) (cap : Ada__containers__formal_doubly_linked_lists__list.__split_discrs) (cu:cursor) (p:ref cursor)
                                             (c : int) : unit
     requires { let rec_co = {Ada__containers__formal_doubly_linked_lists__list.__split_fields = !co;
                             Ada__containers__formal_doubly_linked_lists__list.__split_discrs = cap}  in
                   length_ rec_co + c <= capacity rec_co
                         /\ (position rec_co cu > 0 \/ cu = no_element) }
     writes     { co, p }
     reads      { co }
     ensures { let rec_co = {Ada__containers__formal_doubly_linked_lists__list.__split_fields = !co;
                             Ada__containers__formal_doubly_linked_lists__list.__split_discrs = cap}  in
               let old_co = {Ada__containers__formal_doubly_linked_lists__list.__split_fields = (old !co);
                             Ada__containers__formal_doubly_linked_lists__list.__split_discrs = cap}  in
                  insert_3_mult old_co cu c rec_co /\
            first_inserted old_co cu rec_co !p }
end

module Ada__containers__formal_doubly_linked_lists__prepend
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_doubly_linked_lists__args".Ada__containers__formal_doubly_linked_lists__element_type
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__first
  use import Ada__containers__formal_doubly_linked_lists__insert

  val prepend (co:ref Ada__containers__formal_doubly_linked_lists__list.__split_fields) (cap : Ada__containers__formal_doubly_linked_lists__list.__split_discrs) (e:Ada__containers__formal_doubly_linked_lists__element_type.base_type)
                                             (c : int) : unit
     requires { let rec_co = {Ada__containers__formal_doubly_linked_lists__list.__split_fields = !co;
                             Ada__containers__formal_doubly_linked_lists__list.__split_discrs = cap}  in
                   length_ rec_co + c <= capacity rec_co }
     writes     { co }
     reads      { co }
     ensures { let rec_co = {Ada__containers__formal_doubly_linked_lists__list.__split_fields = !co;
                             Ada__containers__formal_doubly_linked_lists__list.__split_discrs = cap}  in
               let old_co = {Ada__containers__formal_doubly_linked_lists__list.__split_fields = (old !co);
                             Ada__containers__formal_doubly_linked_lists__list.__split_discrs = cap}  in
               insert_mult old_co (first__logic old_co) e c rec_co }
end

module Ada__containers__formal_doubly_linked_lists__append
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_doubly_linked_lists__args".Ada__containers__formal_doubly_linked_lists__element_type
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__no_element
  use import Ada__containers__formal_doubly_linked_lists__insert

   val append (co:ref Ada__containers__formal_doubly_linked_lists__list.__split_fields) (cap : Ada__containers__formal_doubly_linked_lists__list.__split_discrs) (e:Ada__containers__formal_doubly_linked_lists__element_type.base_type)
                                             (c : int) : unit
     requires { let rec_co = {Ada__containers__formal_doubly_linked_lists__list.__split_fields = !co;
                             Ada__containers__formal_doubly_linked_lists__list.__split_discrs = cap}  in
                   length_ rec_co + c <= capacity rec_co }
     writes     { co }
     reads      { co }
     ensures { let rec_co = {Ada__containers__formal_doubly_linked_lists__list.__split_fields = !co;
                             Ada__containers__formal_doubly_linked_lists__list.__split_discrs = cap}  in
               let old_co = {Ada__containers__formal_doubly_linked_lists__list.__split_fields = (old !co);
                             Ada__containers__formal_doubly_linked_lists__list.__split_discrs = cap}  in
               insert_mult old_co no_element e c rec_co }
end

module Ada__containers__formal_doubly_linked_lists__delete
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__no_element
  use import Ada__containers__formal_doubly_linked_lists__next
  use import Ada__containers__formal_doubly_linked_lists__element

  predicate delete list cursor list

  axiom delete_capacity:
    forall co1 co2:list, cu:cursor
      [delete co1 cu co2, capacity co1|delete co1 cu co2, capacity co2].
      delete co1 cu co2 -> capacity co1 = capacity co2

  axiom delete_length_:
    forall co1 co2:list, cu:cursor
      [delete co1 cu co2].
      delete co1 cu co2 -> length_ co1 = length_ co2 + 1

  axiom delete_position_before:
    forall co1 co2:list, cu cun:cursor
      [delete co1 cu co2,  position co1 cun
     | delete co1 cu co2,  position co2 cun].
      delete co1 cu co2 ->
      (position co1 cu > position co1 cun \/ 0 < position co2 cun < position co1 cu) ->
        position co1 cun = position co2 cun

  axiom delete_position_after:
    forall co1 co2:list, cu cun:cursor
      [delete co1 cu co2,  position co1 cun | delete co1 cu co2,  position co2 cun].
      delete co1 cu co2 ->
      (position co1 cun > position co1 cu \/ position co2 cun >= position co1 cu) ->
        position co1 cun = position co2 cun + 1

  axiom delete_position_range:
    forall co1 co2:list, cu:cursor [delete co1 cu co2].
      delete co1 cu co2 -> position co2 cu = 0 /\ 0 < position co1 cu

  axiom delete_position_next:
    forall co1 co2:list, cu:cursor [delete co1 cu co2].
      delete co1 cu co2 -> position co1 (next__logic co1 cu) >= 0

  axiom delete_element:
    forall co1 co2:list, cu cun:cursor
      [delete co1 cu co2,  element__logic co1 cun
     | delete co1 cu co2,  element__logic co2 cun].
      delete co1 cu co2 ->
      0 < position co2 cun ->
        element__logic co1 cun = element__logic co2 cun

  predicate delete_mult list cursor int list

  axiom delete_mult_0 :
    forall li1 li2 : list, cu : cursor [delete_mult li1 cu 0 li2].
	delete_mult li1 cu 0 li2 -> li1 = li2

  axiom delete_mult_1 :
    forall li1 li2 : list, cu : cursor [delete_mult li1 cu 1 li2].
	delete_mult li1 cu 1 li2 -> delete li1 cu li2

  axiom delete_mult_n :
    forall li1 li2 : list, cu : cursor, c : int [delete_mult li1 cu c li2].
	delete_mult li1 cu c li2 -> c > 1 ->
	 exists nl : list [delete li1 cu nl].
    		(delete li1 cu nl /\
                  (position li1 cu = length_ li1 \/
                    position li1 cu < length_ li1 /\ delete_mult nl (next__logic li1 cu) (c - 1) li2))

  val delete (co:ref Ada__containers__formal_doubly_linked_lists__list.__split_fields) (cap : Ada__containers__formal_doubly_linked_lists__list.__split_discrs) (cu:ref cursor) (c : int) : unit
     requires {  let rec_co = {Ada__containers__formal_doubly_linked_lists__list.__split_fields = !co;
                             Ada__containers__formal_doubly_linked_lists__list.__split_discrs = cap}  in
                   position rec_co !cu > 0 }
     writes     { co, cu }
     reads      { co }
     ensures { let rec_co = {Ada__containers__formal_doubly_linked_lists__list.__split_fields = !co;
                             Ada__containers__formal_doubly_linked_lists__list.__split_discrs = cap}  in
               let old_co = {Ada__containers__formal_doubly_linked_lists__list.__split_fields = old !co;
                             Ada__containers__formal_doubly_linked_lists__list.__split_discrs = cap}  in
                   delete_mult old_co (old !cu) c rec_co /\ !cu = no_element }
end

module Ada__containers__formal_doubly_linked_lists__delete_first
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__first
  use import Ada__containers__formal_doubly_linked_lists__delete

  val delete_first (co:ref Ada__containers__formal_doubly_linked_lists__list.__split_fields) (cap : Ada__containers__formal_doubly_linked_lists__list.__split_discrs) (c : int) : unit
     writes     { co }
     reads      { co }
     ensures { let rec_co = {Ada__containers__formal_doubly_linked_lists__list.__split_fields = !co;
                             Ada__containers__formal_doubly_linked_lists__list.__split_discrs = cap}  in
               let old_co = {Ada__containers__formal_doubly_linked_lists__list.__split_fields = old !co;
                             Ada__containers__formal_doubly_linked_lists__list.__split_discrs = cap}  in
               (if length_ old_co > 0 then delete_mult old_co (first__logic old_co) c rec_co else rec_co = old_co)  }
end

module Ada__containers__formal_doubly_linked_lists__delete_last
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__last
  use import Ada__containers__formal_doubly_linked_lists__delete

  val delete_last (co:ref Ada__containers__formal_doubly_linked_lists__list.__split_fields) (cap : Ada__containers__formal_doubly_linked_lists__list.__split_discrs) (c : int) : unit
     writes     { co }
     reads      { co }
     ensures { let rec_co = {Ada__containers__formal_doubly_linked_lists__list.__split_fields = !co;
                             Ada__containers__formal_doubly_linked_lists__list.__split_discrs = cap}  in
               let old_co = {Ada__containers__formal_doubly_linked_lists__list.__split_fields = old !co;
                             Ada__containers__formal_doubly_linked_lists__list.__split_discrs = cap}  in
               (if length_ old_co > 0 then delete_mult old_co (last__logic old_co) c rec_co else rec_co = old_co) }
end

module Ada__containers__formal_doubly_linked_lists__swap_links
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__element

  predicate swap_links list cursor cursor list

  axiom swap_links_elements:
    forall co1 co2 : list, cu cu1 cu2 : cursor
             [swap_links co1 cu1 cu2 co2, element__logic co1 cu |
               swap_links co1 cu1 cu2 co2, element__logic co2 cu].
    swap_links co1 cu1 cu2 co2 -> position co1 cu > 0 ->
    element__logic co1 cu = element__logic co2 cu

  axiom swap_links_length_:
    forall co1 co2 : list, cu1 cu2 : cursor
             [swap_links co1 cu1 cu2 co2, length_ co1].
    swap_links co1 cu1 cu2 co2 -> length_ co1 = length_ co2

  axiom swap_links_capacity:
    forall co1 co2 : list, cu1 cu2 : cursor
             [swap_links co1 cu1 cu2 co2, capacity co1
             | swap_links co1 cu1 cu2 co2, capacity co2].
    swap_links co1 cu1 cu2 co2 -> capacity co1 = capacity co2

  axiom swap_links_position_ext:
    forall co1 co2 : list, cu cu1 cu2 : cursor
             [swap_links co1 cu1 cu2 co2, position co1 cu |
               swap_links co1 cu1 cu2 co2, position co2 cu].
    swap_links co1 cu1 cu2 co2 ->
     cu <> cu1 -> cu <> cu2 -> position co1 cu = position co2 cu

  axiom swap_links_position_in:
    forall co1 co2 : list, cu1 cu2 : cursor
             [swap_links co1 cu1 cu2 co2].
    swap_links co1 cu1 cu2 co2 ->
     position co1 cu1 = position co2 cu2 /\
     position co1 cu2 = position co2 cu1 /\
     position co1 cu1 > 0 /\ position co1 cu2 > 0

  val swap_links (co:ref Ada__containers__formal_doubly_linked_lists__list.__split_fields) (cap : Ada__containers__formal_doubly_linked_lists__list.__split_discrs) (cu1 cu2 : cursor) : unit
    requires { let rec_co = {Ada__containers__formal_doubly_linked_lists__list.__split_fields = !co;
                             Ada__containers__formal_doubly_linked_lists__list.__split_discrs = cap}  in
                  position rec_co cu1 > 0 /\ position rec_co cu2 > 0 }
     writes     { co }
     ensures { let rec_co = {Ada__containers__formal_doubly_linked_lists__list.__split_fields = !co;
                             Ada__containers__formal_doubly_linked_lists__list.__split_discrs = cap}  in
               let old_co = {Ada__containers__formal_doubly_linked_lists__list.__split_fields = old !co;
                             Ada__containers__formal_doubly_linked_lists__list.__split_discrs = cap}  in
               (cu1 = cu2 /\ rec_co = old_co) \/
                         (cu1 <> cu2 /\ swap_links old_co cu1 cu2 rec_co) }
end

module Ada__containers__formal_doubly_linked_lists__swap
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__element

  predicate swap list cursor cursor list

  axiom swap_position:
    forall co1 co2 : list, cu cu1 cu2 : cursor
             [swap co1 cu1 cu2 co2, position co1 cu |
               swap co1 cu1 cu2 co2, position co2 cu].
    swap co1 cu1 cu2 co2 -> position co1 cu = position co2 cu

  axiom swap_length_:
    forall co1 co2 : list, cu1 cu2 : cursor
             [swap co1 cu1 cu2 co2].
    swap co1 cu1 cu2 co2 -> length_ co1 = length_ co2

  axiom swap_capacity:
    forall co1 co2 : list, cu1 cu2 : cursor
             [swap co1 cu1 cu2 co2, capacity co1
             | swap co1 cu1 cu2 co2, capacity co2].
    swap co1 cu1 cu2 co2 -> capacity co1 = capacity co2

  axiom swap_element_ext:
    forall co1 co2 : list, cu cu1 cu2 : cursor
             [swap co1 cu1 cu2 co2, element__logic co1 cu |
               swap co1 cu1 cu2 co2, element__logic co2 cu].
    swap co1 cu1 cu2 co2 -> position co1 cu > 0 ->
     cu <> cu1 -> cu <> cu2 -> element__logic co1 cu = element__logic co2 cu

  axiom swap_element_in:
    forall co1 co2 : list, cu1 cu2 : cursor
             [swap co1 cu1 cu2 co2].
    swap co1 cu1 cu2 co2 ->
     element__logic co1 cu1 = element__logic co2 cu2 /\
     element__logic co1 cu2 = element__logic co2 cu1 /\
     position co1 cu1 > 0 /\ position co1 cu2 > 0

  val swap (co:ref Ada__containers__formal_doubly_linked_lists__list.__split_fields) (cap : Ada__containers__formal_doubly_linked_lists__list.__split_discrs) (cu1 cu2 : cursor) : unit
    requires { let rec_co = {Ada__containers__formal_doubly_linked_lists__list.__split_fields = !co;
                             Ada__containers__formal_doubly_linked_lists__list.__split_discrs = cap}  in
                  position rec_co cu1 > 0 /\ position rec_co cu2 > 0 }
     writes     { co }
     ensures { let rec_co = {Ada__containers__formal_doubly_linked_lists__list.__split_fields = !co;
                             Ada__containers__formal_doubly_linked_lists__list.__split_discrs = cap}  in
               let old_co = {Ada__containers__formal_doubly_linked_lists__list.__split_fields = old !co;
                             Ada__containers__formal_doubly_linked_lists__list.__split_discrs = cap}  in
               (cu1 = cu2 /\ rec_co = old_co) \/
                         (cu1 <> cu2 /\ swap old_co cu1 cu2 rec_co) }
end

module Ada__containers__formal_doubly_linked_lists__splice
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__no_element
  use import Ada__containers__formal_doubly_linked_lists__next
  use import Ada__containers__formal_doubly_linked_lists__previous
  use import Ada__containers__formal_doubly_linked_lists__first_to_current
  use import Ada__containers__formal_doubly_linked_lists__current_to_last
  use import Ada__containers__formal_doubly_linked_lists__first_to_previous
  use import Ada__containers__formal_doubly_linked_lists__Oeq__2
  use import Ada__containers__formal_doubly_linked_lists__strict_equal

  val splice (target:ref Ada__containers__formal_doubly_linked_lists__list.__split_fields) (t_cap : Ada__containers__formal_doubly_linked_lists__list.__split_discrs) (cu:cursor) (source:ref Ada__containers__formal_doubly_linked_lists__list.__split_fields) (s_cap : Ada__containers__formal_doubly_linked_lists__list.__split_discrs) : unit
     requires { let rec_t = {Ada__containers__formal_doubly_linked_lists__list.__split_fields = !target;
                             Ada__containers__formal_doubly_linked_lists__list.__split_discrs = t_cap}  in
                let rec_s = {Ada__containers__formal_doubly_linked_lists__list.__split_fields = !source;
                             Ada__containers__formal_doubly_linked_lists__list.__split_discrs = s_cap}  in
                  capacity rec_t >= (length_ rec_t) + (length_ rec_s) /\ (position rec_t cu > 0 \/ cu = no_element)}
     writes     { target, source }
     reads      { target, source }
     ensures {  let rec_t = {Ada__containers__formal_doubly_linked_lists__list.__split_fields = !target;
                             Ada__containers__formal_doubly_linked_lists__list.__split_discrs = t_cap}  in
                let rec_s = {Ada__containers__formal_doubly_linked_lists__list.__split_fields = !source;
                             Ada__containers__formal_doubly_linked_lists__list.__split_discrs = s_cap}  in
                let old_t = {Ada__containers__formal_doubly_linked_lists__list.__split_fields = old !target;
                             Ada__containers__formal_doubly_linked_lists__list.__split_discrs = t_cap}  in
                let old_s = {Ada__containers__formal_doubly_linked_lists__list.__split_fields = old !source;
                             Ada__containers__formal_doubly_linked_lists__list.__split_discrs = s_cap}  in
                  length_ rec_t = (length_ old_t) + (length_ old_s) /\
                         length_ rec_s = 0 /\ strict_equal__logic (current_to_last__logic rec_t cu) (current_to_last__logic old_t cu) = True /\
                         strict_equal__logic (first_to_previous__logic old_t cu) (first_to_current__logic rec_t (previous__logic old_t cu)) = True /\
                         oeq__2__logic old_s (current_to_last__logic (first_to_previous__logic rec_t cu) (next__logic rec_t (previous__logic old_t cu))) = True }
end

module Ada__containers__formal_doubly_linked_lists__splice__2
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_doubly_linked_lists__args".Ada__containers__formal_doubly_linked_lists__element_type
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__no_element
  use import Ada__containers__formal_doubly_linked_lists__element
  use import Ada__containers__formal_doubly_linked_lists__insert
  use import Ada__containers__formal_doubly_linked_lists__insert__2
  use import Ada__containers__formal_doubly_linked_lists__delete

  val splice__2  (target:ref Ada__containers__formal_doubly_linked_lists__list.__split_fields) (t_cap : Ada__containers__formal_doubly_linked_lists__list.__split_discrs) (cu:cursor) (source:ref Ada__containers__formal_doubly_linked_lists__list.__split_fields) (s_cap : Ada__containers__formal_doubly_linked_lists__list.__split_discrs) (p:ref cursor) : unit
     requires { let rec_t = {Ada__containers__formal_doubly_linked_lists__list.__split_fields = !target;
                             Ada__containers__formal_doubly_linked_lists__list.__split_discrs = t_cap}  in
                let rec_s = {Ada__containers__formal_doubly_linked_lists__list.__split_fields = !source;
                             Ada__containers__formal_doubly_linked_lists__list.__split_discrs = s_cap}  in
                  capacity rec_t >= (length_ rec_t) + (length_ rec_s)
                           /\ (position rec_t cu > 0 \/ cu = no_element)
                           /\ position rec_s !p > 0}
     writes     { target, source, p }
     reads      { target, source, p }
     ensures {  let rec_t = {Ada__containers__formal_doubly_linked_lists__list.__split_fields = !target;
                             Ada__containers__formal_doubly_linked_lists__list.__split_discrs = t_cap}  in
                let rec_s = {Ada__containers__formal_doubly_linked_lists__list.__split_fields = !source;
                             Ada__containers__formal_doubly_linked_lists__list.__split_discrs = s_cap}  in
                let old_t = {Ada__containers__formal_doubly_linked_lists__list.__split_fields = old !target;
                             Ada__containers__formal_doubly_linked_lists__list.__split_discrs = t_cap}  in
                let old_s = {Ada__containers__formal_doubly_linked_lists__list.__split_fields = old !source;
                             Ada__containers__formal_doubly_linked_lists__list.__split_discrs = s_cap}  in
                  insert old_t cu (element__logic old_s (old !p)) rec_t /\
                         delete old_s (old !p) rec_s /\
                        first_inserted old_t cu rec_t !p }
end

module Ada__containers__formal_doubly_linked_lists__splice__3
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_doubly_linked_lists__args".Ada__containers__formal_doubly_linked_lists__element_type
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__no_element
  use import Ada__containers__formal_doubly_linked_lists__element
  use import Ada__containers__formal_doubly_linked_lists__insert
  use import Ada__containers__formal_doubly_linked_lists__delete

  val splice__3 (co:ref Ada__containers__formal_doubly_linked_lists__list.__split_fields) (cap : Ada__containers__formal_doubly_linked_lists__list.__split_discrs) (before:cursor) (p:cursor) : unit
     requires { let rec_co = {Ada__containers__formal_doubly_linked_lists__list.__split_fields = !co;
                             Ada__containers__formal_doubly_linked_lists__list.__split_discrs = cap}  in
                  capacity rec_co >= 2*(length_ rec_co)
                           /\ (position rec_co before > 0 \/ before = no_element) }
     writes     { co }
     reads      { co }
     ensures { let rec_co = {Ada__containers__formal_doubly_linked_lists__list.__split_fields = !co;
                             Ada__containers__formal_doubly_linked_lists__list.__split_discrs = cap}  in
               let old_co = {Ada__containers__formal_doubly_linked_lists__list.__split_fields = old !co;
                             Ada__containers__formal_doubly_linked_lists__list.__split_discrs = cap}  in
                  exists interm : list.
                       delete old_co p  interm /\
                       insert interm before (element__logic old_co p) rec_co }
end

module Ada__containers__formal_doubly_linked_lists__has_element
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor

  function has_element__logic list cursor : bool

  axiom has_element_pos:
    forall co:list, cu:cursor [has_element__logic co cu].
    has_element__logic co cu = True -> 0 < position co cu

  axiom has_element_neg:
    forall co:list, cu:cursor [has_element__logic co cu].
    has_element__logic co cu <> True -> position co cu = 0

  val has_element (co:list) (cu:cursor) : bool
     ensures { has_element__logic co cu = result }
end

module Ada__containers__formal_doubly_linked_lists__contains
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_doubly_linked_lists__args".Ada__containers__formal_doubly_linked_lists__element_type
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__find

  function contains__logic list Ada__containers__formal_doubly_linked_lists__element_type.base_type : bool

  axiom contains_c:
  forall co : list, e : Ada__containers__formal_doubly_linked_lists__element_type.base_type [contains__logic co e].
    contains__logic co e = True <-> 0 < position co (findfirst co e)

  val contains (co:list) (e:Ada__containers__formal_doubly_linked_lists__element_type.base_type) : bool
     ensures { contains__logic co e = result }
end

module Ada__containers__formal_doubly_linked_lists__clear
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length

  val clear (co:ref Ada__containers__formal_doubly_linked_lists__list.__split_fields) (cap : Ada__containers__formal_doubly_linked_lists__list.__split_discrs) : unit
     writes     { co }
     ensures { let rec_co = {Ada__containers__formal_doubly_linked_lists__list.__split_fields = !co;
                             Ada__containers__formal_doubly_linked_lists__list.__split_discrs = cap}  in
                 length_ rec_co = 0 }
end

module Ada__containers__formal_doubly_linked_lists__assign
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__Oeq__2

  val assign (target:ref Ada__containers__formal_doubly_linked_lists__list.__split_fields) (cap : Ada__containers__formal_doubly_linked_lists__list.__split_discrs) (source:list) : unit
     requires { let rec_t = {Ada__containers__formal_doubly_linked_lists__list.__split_fields = !target;
                             Ada__containers__formal_doubly_linked_lists__list.__split_discrs = cap}  in
                 capacity rec_t >= length_ source }
     writes     { target }
     reads      { target }
     ensures { let rec_t = {Ada__containers__formal_doubly_linked_lists__list.__split_fields = !target;
                             Ada__containers__formal_doubly_linked_lists__list.__split_discrs = cap}  in
                 oeq__2__logic rec_t source = True }
end

module Ada__containers__formal_doubly_linked_lists__move
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__Oeq__2

  val move (target:ref Ada__containers__formal_doubly_linked_lists__list.__split_fields) (t_cap : Ada__containers__formal_doubly_linked_lists__list.__split_discrs) (source:ref Ada__containers__formal_doubly_linked_lists__list.__split_fields) (s_cap : Ada__containers__formal_doubly_linked_lists__list.__split_discrs) : unit
     requires { let rec_t = {Ada__containers__formal_doubly_linked_lists__list.__split_fields = !target;
                             Ada__containers__formal_doubly_linked_lists__list.__split_discrs = t_cap}  in
                let rec_s = {Ada__containers__formal_doubly_linked_lists__list.__split_fields = !source;
                             Ada__containers__formal_doubly_linked_lists__list.__split_discrs = s_cap}  in
                  capacity rec_t >= length_ rec_s }
     writes     { target, source }
     reads      { source }
     ensures { let rec_t = {Ada__containers__formal_doubly_linked_lists__list.__split_fields = !target;
                             Ada__containers__formal_doubly_linked_lists__list.__split_discrs = t_cap}  in
               let rec_s = {Ada__containers__formal_doubly_linked_lists__list.__split_fields = !source;
                             Ada__containers__formal_doubly_linked_lists__list.__split_discrs = s_cap}  in
               let old_s = {Ada__containers__formal_doubly_linked_lists__list.__split_fields = old !source;
                             Ada__containers__formal_doubly_linked_lists__list.__split_discrs = s_cap}  in
                  oeq__2__logic rec_t old_s = True /\ length_ rec_s = 0 }
end

module Ada__containers__formal_doubly_linked_lists__copy
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__strict_equal

  function copy__logic list int : list

  axiom copy__def:
    forall co : list, cap : int [copy__logic co cap].
       strict_equal__logic co (copy__logic co cap) = True /\
       (cap = 0 -> capacity co = capacity (copy__logic co cap)) /\
       (cap >= capacity co ->  capacity (copy__logic co cap) = cap)

  val copy (co: list) (cap:int) : list
     requires { cap = 0 \/ cap >= capacity co}
     ensures { result = copy__logic co cap /\ list_inv result }
end

module Ada__containers__formal_doubly_linked_lists__list
  use import int.Int
  use import "_gnatprove_standard".Main
  use "a-contai__types_in_spec".Ada__containers__count_type

  type list

  function rec__capacity list : Ada__containers__count_type.count_type

   function capacity  (co : list) : int =
          Ada__containers__count_type.to_int (rec__capacity co)

  function to_base "inline" (co : list) : list = co

  function of_base "inline" (co : list) : list = co
end

module Ada__containers__formal_doubly_linked_lists__length
  use import int.Int
  use import "_gnatprove_standard".Main
  use "a-contai__types_in_spec".Ada__containers__count_type
  use import Ada__containers__formal_doubly_linked_lists__list

  function length list : Ada__containers__count_type.count_type

  function length_ "inline" (co : list) : int =
    Ada__containers__count_type.to_int (length co)

  axiom length_range:
    forall co:list [length co]. 0 <= length_ co <= capacity co

  val length (co : list) :  Ada__containers__count_type.count_type
     ensures { result = length co }
end

module Ada__containers__formal_doubly_linked_lists__cursor
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_doubly_linked_lists__args".Ada__containers__formal_doubly_linked_lists__element_type
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length

  type cursor

  function position list cursor : int

  function position_inv list int : cursor

  axiom position_gte_zero:
    forall co:list, cu:cursor [position co cu].
        length_ co >= position co cu >= 0

  axiom position_eq1:
   forall co:list, i :int [position co (position_inv co i)]. 0 < i <= length_ co -> 
              position co (position_inv co i) = i

  axiom position_eq2:
    forall co:list, cu:cursor [position co cu].
          position co cu > 0 -> position_inv co (position co cu) = cu
end

module Ada__containers__formal_doubly_linked_lists__no_element
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor

  function no_element : cursor

  axiom position_no_element:
    forall co:list [position co no_element]. position co no_element = 0
end

module Ada__containers__formal_doubly_linked_lists__empty_list
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length

  function empty_list : list

  axiom Empty_is_empty: length_ empty_list = 0
end

module Ada__containers__formal_doubly_linked_lists__is_empty
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length

  function is_empty list : bool

  axiom is_empty:
    forall co:list [is_empty (co)]. 
          is_empty (co) = True <-> length_ co = 0

  val is_empty (co:list) : bool
     ensures  { result = is_empty co }
end

module Ada__containers__formal_doubly_linked_lists__previous
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__no_element

  function previous list cursor : cursor

  axiom previous_in:
    forall co:list, cu:cursor [previous co cu].
	(position co cu > 1 \/ position co (previous co cu) > 0) ->
	position co (previous co cu) = position co cu - 1

  axiom previous_ext:
    forall co:list, cu:cursor [previous co cu].
        (position co cu = 1 \/ cu = no_element) -> previous co cu = no_element

  val previous (co:list) (cu:cursor) : cursor
     requires { cu = no_element \/ position co cu > 0 }
     ensures  { result = previous co cu }
end

module Ada__containers__formal_doubly_linked_lists__previous__2
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__no_element
  use import Ada__containers__formal_doubly_linked_lists__previous

  val previous__2 (co:list) (cu:ref cursor) : unit
     requires { !cu = no_element \/ position co !cu > 0 }
     writes     { cu }
     reads      { cu }
     ensures  { !cu = previous co (old !cu) }
end

module Ada__containers__formal_doubly_linked_lists__next
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__no_element

  function next list cursor : cursor

  axiom next_in:
    forall co:list, cu:cursor [next co cu].
	(length_ co > position co cu > 0 \/ position co (next co cu) > 0) ->
	position co (next co cu) = position co cu + 1

  axiom next_ext:
    forall co:list, cu:cursor [next co cu].
        (position co cu = length_ co \/ cu = no_element) -> next co cu = no_element

  val next (co:list) (cu:cursor) : cursor
     requires { cu = no_element \/ position co cu > 0 }
     ensures  { result = next co cu }
end

module Ada__containers__formal_doubly_linked_lists__next__2
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__no_element
  use import Ada__containers__formal_doubly_linked_lists__next

  val next__2 (co:list) (cu:ref cursor) : unit
     requires { !cu = no_element \/ position co !cu > 0 }
     writes     { cu }
     reads      { cu }
     ensures  { !cu = next co (old !cu) }
end

module Ada__containers__formal_doubly_linked_lists__last
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__no_element

  function last list : cursor

  axiom last_empty:
    forall co:list [last co]. length_ co = 0 <-> last co = no_element

  axiom last_gen:
    forall co:list [last co]. length_ co = position co (last co)

  val last (co:list) : cursor
     ensures  { result = last co }
end

module Ada__containers__formal_doubly_linked_lists__first
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__no_element

  function first list : cursor

  axiom first_empty:
    forall co:list [first co]. length_ co = 0 <-> first co = no_element

  axiom first_gen:
    forall co:list [first co]. length_ co > 0 -> position co (first co) = 1

  val first (co:list) : cursor
     ensures  { result = first co }
end

module Ada__containers__formal_doubly_linked_lists__element
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_doubly_linked_lists__args".Ada__containers__formal_doubly_linked_lists__element_type
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor

  function element list cursor : Ada__containers__formal_doubly_linked_lists__element_type.element_type

  val element (co:list) (cu:cursor) : Ada__containers__formal_doubly_linked_lists__element_type.element_type
     requires { position co cu > 0 }
     ensures  { result = element co cu }
end

module Ada__containers__formal_doubly_linked_lists__first_element
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_doubly_linked_lists__args".Ada__containers__formal_doubly_linked_lists__element_type
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__first
  use import Ada__containers__formal_doubly_linked_lists__element

  function first_element (co:list) : Ada__containers__formal_doubly_linked_lists__element_type.element_type
= element co (first co)

  val first_element (co:list) : Ada__containers__formal_doubly_linked_lists__element_type.element_type
     requires { length_ co > 0 }
     ensures  { result = element co (first co) }
end

module Ada__containers__formal_doubly_linked_lists__last_element
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_doubly_linked_lists__args".Ada__containers__formal_doubly_linked_lists__element_type
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__last
  use import Ada__containers__formal_doubly_linked_lists__element

  function last_element (co:list) : Ada__containers__formal_doubly_linked_lists__element_type.element_type
= element co (last co)

  val last_element (co:list) : Ada__containers__formal_doubly_linked_lists__element_type.element_type
     requires { length_ co > 0 }
     ensures  { result = element co (last co) }
end

module Ada__containers__formal_doubly_linked_lists__left
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__no_element
  use import Ada__containers__formal_doubly_linked_lists__element

  function left list cursor : list

  axiom left_no_element:
    forall co:list [left co no_element]. left co no_element = co

  axiom left_length_:
    forall co:list, cu:cursor [left co cu].
	position co cu > 0 -> length_ (left co cu) = position co cu - 1

  axiom left_position_in:
    forall co:list, cu cun:cursor [position (left co cu) cun | left co cu, position co cun].
	(position (left co cu) cun > 0 \/ position co cun < position co cu) ->
	position (left co cu) cun = position co cun

  axiom left_position_ext:
    forall co:list, cu cun:cursor [position (left co cu) cun].
	position co cun >= position co cu > 0 ->
	position (left co cu) cun = 0

  axiom left_element:
    forall co:list, cu cun:cursor [element (left co cu) cun | left co cu, element co cun].
	(position (left co cu) cun > 0 \/ 0 < position co cun < position co cu) ->
	element (left co cu) cun = element co cun

  val left (co:list) (cu:cursor) : list
     requires { cu = no_element \/ position co cu > 0 }
     ensures  { result = left co cu }
end

module Ada__containers__formal_doubly_linked_lists__right
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__empty_list
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__no_element
  use import Ada__containers__formal_doubly_linked_lists__element

  function right list cursor : list

  axiom right_no_element:
    forall co:list [right co no_element]. right co no_element = empty_list

  axiom right_length_:
    forall co:list, cu:cursor [length_ (right co cu) ].
	position co cu > 0 -> length_ (right co cu) = (length_ co) - (position co cu) + 1

  axiom right_position_in:
    forall co:list, cu cun:cursor [position (right co cu) cun | right co cu, position co cun].
	(position (right co cu) cun > 0 \/ position co cun >= position co cu > 0) ->
	position (right co cu) cun = (position co cun) - (position co cu) + 1

  axiom right_position_ext:
    forall co:list, cu cun:cursor [position (right co cu) cun].
	position co cun < position co cu -> position (right co cu) cun = 0

  axiom right_element:
    forall co:list, cu cun:cursor [element (right co cu) cun | right co cu, element co cun].
	(position (right co cu) cun > 0 \/ 0 < position co cu <= position co cun) ->
	element (right co cu) cun = element co cun

  val right (co:list) (cu:cursor) : list
     requires { cu = no_element \/ position co cu > 0 }
     ensures  { result = right co cu }
end

module Ada__containers__formal_doubly_linked_lists__find
  use import int.Int
  use import "_gnatprove_standard".Main
  use  "ada__containers__formal_doubly_linked_lists__args".Ada__containers__formal_doubly_linked_lists__element_type
  use  "ada__containers__formal_doubly_linked_lists__args".Ada__containers__formal_doubly_linked_lists__oeq
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__no_element
  use import Ada__containers__formal_doubly_linked_lists__element
  use import Ada__containers__formal_doubly_linked_lists__right

  function findfirst list Ada__containers__formal_doubly_linked_lists__element_type.base_type : cursor

  axiom find_range:
    forall co:list, e:Ada__containers__formal_doubly_linked_lists__element_type.base_type [findfirst co e].
	findfirst co e = no_element \/ position co (findfirst co e) > 0

  axiom find_not:
    forall co:list, e:Ada__containers__formal_doubly_linked_lists__element_type.base_type, cu : cursor [findfirst co e, element co cu].
	findfirst co e = no_element -> position co cu > 0 ->
	Ada__containers__formal_doubly_linked_lists__oeq.oeq (Ada__containers__formal_doubly_linked_lists__element_type.to_base (element co cu)) e = False

  axiom find_yes:
    forall co:list, e:Ada__containers__formal_doubly_linked_lists__element_type.base_type, cu : cursor [findfirst co e, element co cu].
	0 < position co cu < position co (findfirst co e) ->
	Ada__containers__formal_doubly_linked_lists__oeq.oeq (Ada__containers__formal_doubly_linked_lists__element_type.to_base (element co cu)) e = False

  axiom find_element:
    forall co:list, e:Ada__containers__formal_doubly_linked_lists__element_type.base_type [findfirst co e].
	0 < position co (findfirst co e) ->
	Ada__containers__formal_doubly_linked_lists__oeq.oeq (Ada__containers__formal_doubly_linked_lists__element_type.to_base (element co (findfirst co e))) e = True

  function find (l : list) (e : Ada__containers__formal_doubly_linked_lists__element_type.base_type) (cu : cursor) : cursor =
    if cu = no_element then (findfirst l e) else (findfirst (right l cu) e)

  val find (co:list) (e:Ada__containers__formal_doubly_linked_lists__element_type.base_type) (cu:cursor) : cursor
     requires { cu = no_element \/ position co cu > 0 }
     ensures  { result = find co e cu }
end

module Ada__containers__formal_doubly_linked_lists__inleft
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__empty_list
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__no_element
  use import Ada__containers__formal_doubly_linked_lists__element

  function inleft list cursor : list

  axiom inleft_no_element:
    forall co:list [inleft co no_element]. inleft co no_element = empty_list

  axiom inleft_length_:
    forall co:list, cu:cursor [inleft co cu].
	position co cu > 0 -> length_ (inleft co cu) = position co cu

  axiom inleft_position_in:
    forall co:list, cu cun:cursor [position (inleft co cu) cun | inleft co cu, position co cun].
	(position (inleft co cu) cun > 0 \/ position co cun <= position co cu) ->
	position (inleft co cu) cun = position co cun

  axiom inleft_position_ext:
    forall co:list, cu cun:cursor [position (inleft co cu) cun].
	position co cun > position co cu > 0 ->
	position (inleft co cu) cun = 0

  axiom inleft_element:
    forall co:list, cu cun:cursor [element (inleft co cu) cun | inleft co cu, element co cun].
	(position (inleft co cu) cun > 0 \/ 0 < position co cun <= position co cu) ->
	element (inleft co cu) cun = element co cun
end

module Ada__containers__formal_doubly_linked_lists__reverse_find
  use import int.Int
  use import "_gnatprove_standard".Main
  use  "ada__containers__formal_doubly_linked_lists__args".Ada__containers__formal_doubly_linked_lists__element_type
  use "ada__containers__formal_doubly_linked_lists__args".Ada__containers__formal_doubly_linked_lists__oeq
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__no_element
  use import Ada__containers__formal_doubly_linked_lists__element
  use import Ada__containers__formal_doubly_linked_lists__inleft

  function findlast list Ada__containers__formal_doubly_linked_lists__element_type.base_type : cursor

  axiom rev_find_range:
    forall co:list, e:Ada__containers__formal_doubly_linked_lists__element_type.base_type [findlast co e].
	findlast co e = no_element \/ position co (findlast co e) > 0

  axiom rev_find_not:
    forall co:list, e:Ada__containers__formal_doubly_linked_lists__element_type.base_type, cu : cursor [findlast co e, element co cu].
	findlast co e = no_element -> position co cu > 0 ->
	Ada__containers__formal_doubly_linked_lists__oeq.oeq (Ada__containers__formal_doubly_linked_lists__element_type.to_base (element co cu)) e = False

  axiom rev_find_yes:
    forall co:list, e:Ada__containers__formal_doubly_linked_lists__element_type.base_type, cu : cursor [findlast co e, element co cu].
	position co (findlast co e) < position co cu <= length_ co ->
	Ada__containers__formal_doubly_linked_lists__oeq.oeq (Ada__containers__formal_doubly_linked_lists__element_type.to_base (element co cu)) e = False

  axiom rev_find_element:
    forall co:list, e:Ada__containers__formal_doubly_linked_lists__element_type.base_type [findlast co e].
	0 < position co (findlast co e) ->
	Ada__containers__formal_doubly_linked_lists__oeq.oeq (Ada__containers__formal_doubly_linked_lists__element_type.to_base (element co (findlast co e))) e = True

  function reverse_find (l : list) (e : Ada__containers__formal_doubly_linked_lists__element_type.base_type) (cu : cursor) : cursor =
    if cu = no_element then (findlast l e) else (findlast (inleft l cu) e)

  val reverse_find (co:list) (e:Ada__containers__formal_doubly_linked_lists__element_type.base_type) (cu:cursor) : cursor
     requires { cu = no_element \/ position co cu > 0 }
     ensures  { result = reverse_find co e cu }
end

module Ada__containers__formal_doubly_linked_lists__strict_equal
  use import int.Int
  use import "_gnatprove_standard".Main
  use  "ada__containers__formal_doubly_linked_lists__args".Ada__containers__formal_doubly_linked_lists__element_type
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__element

  function strict_equal list list : bool

  axiom strict_equal__def:
    forall co1 co2 : list [strict_equal co1 co2].
    ((forall cu:cursor [position co1 cu | position co2 cu].
       position co1 cu = position co2 cu) /\
     (forall cu:cursor [element co1 cu | element co2 cu]. position co1 cu > 0 ->
        Ada__containers__formal_doubly_linked_lists__element_type.to_base (element co1 cu) = Ada__containers__formal_doubly_linked_lists__element_type.to_base (element co2 cu))) <->  strict_equal co1 co2 = True

  lemma strict_equal_length_:
    forall co1 co2 : list [strict_equal co1 co2].
     strict_equal co1 co2 = True -> length_ co1 = length_ co2

    val strict_equal (co1:list) (co2:list) : bool
     ensures  { result  = strict_equal co1 co2 }
end

module Ada__containers__formal_doubly_linked_lists__Oeq__2
  use import int.Int
  use  "ada__containers__formal_doubly_linked_lists__args".Ada__containers__formal_doubly_linked_lists__element_type
  use "ada__containers__formal_doubly_linked_lists__args".Ada__containers__formal_doubly_linked_lists__oeq
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__element

  function oeq__2 list list : bool

  axiom oeq__2_length_:
   forall co1 co2 : list [oeq__2 co1 co2].
   oeq__2 co1 co2 = True -> length_ co1 = length_ co2

  axiom oeq__2_element:
   forall co1 co2 : list [oeq__2 co1 co2]. oeq__2 co1 co2 = True ->
   forall cu1 : cursor [element co1 cu1]. position co1 cu1 > 0 ->
	exists cu2 : cursor. position co2 cu2 = position co1 cu1 /\ 
          Ada__containers__formal_doubly_linked_lists__oeq.oeq (Ada__containers__formal_doubly_linked_lists__element_type.to_base (element co2 cu2)) (Ada__containers__formal_doubly_linked_lists__element_type.to_base (element co1 cu1)) = True

  axiom oeq__2_inv:
   forall co1 co2 : list [oeq__2 co1 co2]. oeq__2 co1 co2 <> True ->
   (length_ co1 <> length_ co2 \/
   exists i : int. 0<i<=length_ co1 /\ Ada__containers__formal_doubly_linked_lists__oeq.oeq (Ada__containers__formal_doubly_linked_lists__element_type.to_base (element co1 (position_inv co1 i)))
       (Ada__containers__formal_doubly_linked_lists__element_type.to_base (element co2 (position_inv co2 i)))=False)

  lemma oeq__2_sym :
  forall e1 e2 : list [oeq__2 e1 e2].
	oeq__2 e1 e2 = True -> oeq__2 e2 e1 = True

  lemma oeq__2_trans :
  forall e1 e2 e3 : list [oeq__2 e1 e2, oeq__2 e1 e3 | oeq__2 e1 e2, oeq__2 e2 e3].
	oeq__2 e1 e2 = True -> oeq__2 e2 e3 = True -> oeq__2 e1 e3 = True

  val oeq__2 (co1:list) (co2:list) : bool
     ensures  { result  = oeq__2 co1 co2 }
end

module Ada__containers__formal_doubly_linked_lists__replace_element
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_doubly_linked_lists__args".Ada__containers__formal_doubly_linked_lists__element_type
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__element

  predicate replace_element list cursor Ada__containers__formal_doubly_linked_lists__element_type.base_type list

  axiom replace_element_length_:
    forall co1 co2:list, cu:cursor, e:Ada__containers__formal_doubly_linked_lists__element_type.base_type
      [replace_element co1 cu e co2].
      replace_element co1 cu e co2 -> length_ co1 = length_ co2

  axiom replace_element_capacity:
    forall co1 co2:list, cu:cursor, e:Ada__containers__formal_doubly_linked_lists__element_type.base_type
      [replace_element co1 cu e co2, capacity co1|replace_element co1 cu e co2, capacity co2].
      replace_element co1 cu e co2 -> capacity co1 = capacity co2

  axiom replace_element_position_ext:
    forall co1 co2:list, cu cun:cursor, e:Ada__containers__formal_doubly_linked_lists__element_type.base_type
      [replace_element co1 cu e co2, position co2 cun
     | replace_element co1 cu e co2, position co1 cun].
      replace_element co1 cu e co2 -> position co2 cun = position co1 cun

  axiom replace_element_position_in:
    forall co1 co2:list, cu:cursor, e:Ada__containers__formal_doubly_linked_lists__element_type.base_type
      [replace_element co1 cu e co2].
      replace_element co1 cu e co2 -> position co2 cu > 0

  axiom replace_element_element_in:
    forall co1 co2:list, cu:cursor, e:Ada__containers__formal_doubly_linked_lists__element_type.base_type
      [replace_element co1 cu e co2].
      replace_element co1 cu e co2 -> Ada__containers__formal_doubly_linked_lists__element_type.to_base (element co2 cu) = e

  axiom replace_element_element_ext:
    forall co1 co2:list, cu cun:cursor, e:Ada__containers__formal_doubly_linked_lists__element_type.base_type
      [replace_element co1 cu e co2, element co2 cun
     | replace_element co1 cu e co2, element co1 cun].
      replace_element co1 cu e co2 -> cu <> cun -> position co1 cun > 0 ->
        element co2 cun = element co1 cun

  val replace_element (co:ref list) (cu:cursor) (e:Ada__containers__formal_doubly_linked_lists__element_type.base_type) : unit
     requires { position !co cu > 0 }
     writes     { co }
     reads      { co }
     ensures { replace_element (old !co) cu e !co }
end

module Ada__containers__formal_doubly_linked_lists__reverse_elements
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__element

  predicate reverse_elements list list

  axiom reverse_elements_length_:
    forall co1 co2:list
      [reverse_elements co1 co2].
      reverse_elements co1 co2 -> length_ co1 = length_ co2

  axiom reverse_elements_capacity:
    forall co1 co2:list
      [reverse_elements co1 co2, capacity co1|reverse_elements co1 co2, capacity co2].
      reverse_elements co1 co2 -> capacity co1 = capacity co2

  axiom reverse_elements_position:
    forall co1 co2:list, cun:cursor
      [reverse_elements co1 co2, position co2 cun
     | reverse_elements co1 co2, position co1 cun].
      reverse_elements co1 co2 -> position co2 cun = (length_ co1) - (position co1 cun) + 1

  axiom reverse_elements_element:
    forall co1 co2:list, cun:cursor
      [reverse_elements co1 co2, element co2 cun
     | reverse_elements co1 co2, element co1 cun].
      reverse_elements co1 co2 -> position co1 cun > 0 ->
        element co2 cun = element co1 cun

  val reverse_elements (co:ref list) : unit
     writes     { co }
     ensures { reverse_elements !co (old !co) }
end

module Ada__containers__formal_doubly_linked_lists__insert
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_doubly_linked_lists__args".Ada__containers__formal_doubly_linked_lists__element_type
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__no_element
  use import Ada__containers__formal_doubly_linked_lists__previous
  use import Ada__containers__formal_doubly_linked_lists__last
  use import Ada__containers__formal_doubly_linked_lists__element

  predicate insert list cursor Ada__containers__formal_doubly_linked_lists__element_type.base_type list

  axiom insert_range:
    forall co1 co2:list, cu:cursor, e:Ada__containers__formal_doubly_linked_lists__element_type.base_type [insert co1 cu e co2].
      insert co1 cu e co2 -> cu = no_element \/ position co1 cu > 0

  axiom insert_length_:
    forall co1 co2:list, cu:cursor, e:Ada__containers__formal_doubly_linked_lists__element_type.base_type
      [insert co1 cu e co2].
      insert co1 cu e co2 -> length_ co1 + 1 = length_ co2

  axiom insert_capacity:
    forall co1 co2:list, cu:cursor, e:Ada__containers__formal_doubly_linked_lists__element_type.base_type
      [insert co1 cu e co2, capacity co1|insert co1 cu e co2, capacity co2].
      insert co1 cu e co2 -> capacity co1 = capacity co2

  axiom insert_new:
    forall co1 co2:list, cu:cursor, e:Ada__containers__formal_doubly_linked_lists__element_type.base_type [insert co1 cu e co2].
      insert co1 cu e co2 -> position co1 cu > 0 ->
      (position co1 (previous co2 cu) = 0 /\ Ada__containers__formal_doubly_linked_lists__element_type.to_base (element co2 (previous co2 cu)) = e)

  axiom insert_new_no_element:
    forall co1 co2:list, e:Ada__containers__formal_doubly_linked_lists__element_type.base_type [insert co1 no_element e co2].
      insert co1 no_element e co2 ->
        position co1 (last co2) = 0 /\ Ada__containers__formal_doubly_linked_lists__element_type.to_base (element co2 (last co2)) = e

  axiom insert_position_before:
    forall co1 co2:list, cu cun:cursor, e:Ada__containers__formal_doubly_linked_lists__element_type.base_type
      [insert co1 cu e co2,  position co1 cun
     | insert co1 cu e co2,  position co2 cun].
      insert co1 cu e co2 -> position co1 cu > 0 ->
      (position co1 cu > position co1 cun > 0 \/ position co2 cun < position co1 cu) ->
        position co1 cun = position co2 cun

  axiom insert_position_after:
    forall co1 co2:list, cu cun:cursor, e:Ada__containers__formal_doubly_linked_lists__element_type.base_type
      [insert co1 cu e co2,  position co1 cun
     | insert co1 cu e co2,  position co2 cun].
      insert co1 cu e co2 -> position co1 cu > 0 ->
      (position co1 cun >= position co1 cu \/ position co2 cun > position co1 cu) ->
        position co1 cun + 1 = position co2 cun

  axiom insert_position_no_element:
    forall co1 co2:list, cun:cursor, e:Ada__containers__formal_doubly_linked_lists__element_type.base_type
      [insert co1 no_element e co2,  position co1 cun
     | insert co1 no_element e co2,  position co2 cun].
      insert co1 no_element e co2 -> (position co1 cun > 0 \/ position co2 cun < length_ co2) ->
        position co1 cun = position co2 cun

  axiom insert_element:
    forall co1 co2:list, cu cun:cursor, e:Ada__containers__formal_doubly_linked_lists__element_type.base_type
      [insert co1 cu e co2,  element co1 cun
     | insert co1 cu e co2,  element co2 cun].
      insert co1 cu e co2 -> position co1 cu > 0 ->
      position co1 cun > 0 ->
        element co1 cun = element co2 cun

  axiom insert_element_no_element:
    forall co1 co2:list, cun:cursor, e:Ada__containers__formal_doubly_linked_lists__element_type.base_type
      [insert co1 no_element e co2,  element co1 cun
     | insert co1 no_element e co2,  element co2 cun].
      insert co1 no_element e co2 ->
      (position co1 cun > 0 \/ 0 < position co2 cun < length_ co2) ->
        element co1 cun = element co2 cun

  predicate insert_mult list cursor Ada__containers__formal_doubly_linked_lists__element_type.base_type int list

  axiom insert_mult_0 :
    forall li1 li2 : list, cu : cursor, e : Ada__containers__formal_doubly_linked_lists__element_type.base_type [insert_mult li1 cu e 0 li2].
	insert_mult li1 cu e 0 li2 -> li1 = li2

  axiom insert_mult_1 :
    forall li1 li2 : list, cu : cursor, e : Ada__containers__formal_doubly_linked_lists__element_type.base_type [insert_mult li1 cu e 1 li2].
	insert_mult li1 cu e 1 li2 -> insert li1 cu e li2

  axiom insert_mult_n :
    forall li1 li2 : list, cu : cursor, e : Ada__containers__formal_doubly_linked_lists__element_type.base_type, c : int [insert_mult li1 cu e c li2].
	insert_mult li1 cu e c li2 -> c > 1 ->
	 exists nl : list [insert li1 cu e nl].
    		(insert li1 cu e nl /\ insert_mult nl cu e (c - 1) li2)

  val insert (co:ref list) (cu:cursor) (e:Ada__containers__formal_doubly_linked_lists__element_type.base_type) 
                                             (c : int) : unit
     requires { length_ !co + c <= capacity !co
                         /\ (position !co cu > 0 \/ cu = no_element) }
     writes     { co }
     reads      { co }
     ensures { insert_mult (old !co) cu e c !co }
end

module Ada__containers__formal_doubly_linked_lists__insert__2
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_doubly_linked_lists__args".Ada__containers__formal_doubly_linked_lists__element_type
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__no_element
  use import Ada__containers__formal_doubly_linked_lists__first
  use import Ada__containers__formal_doubly_linked_lists__insert

  predicate first_inserted (co1:list) (cu:cursor) (co2:list) (p:cursor) =
	    cu = no_element /\ length_ co1 > 0 /\ position co2 p = length_ co2 \/
             length_ co1 = 0 /\ p = first co2 \/
             position co1 cu > 0 /\ position co2 p = position co1 cu

  val insert__2 (co:ref list) (cu:cursor) (e:Ada__containers__formal_doubly_linked_lists__element_type.base_type) (p:ref cursor)
                                             (c : int) : unit
     requires { length_ !co + c <= capacity !co
                         /\ (position !co cu > 0 \/ cu = no_element) }
     writes     { co, p }
     reads      { co }
     ensures { insert_mult (old !co) cu e c !co /\
            first_inserted (old !co) cu !co !p }
end

module Ada__containers__formal_doubly_linked_lists__insert__3
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_doubly_linked_lists__args".Ada__containers__formal_doubly_linked_lists__element_type
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__no_element
  use import Ada__containers__formal_doubly_linked_lists__insert
  use import Ada__containers__formal_doubly_linked_lists__insert__2

  predicate insert_3_mult list cursor int list

  axiom insert_3_mult_0 :
    forall li1 li2 : list, cu : cursor [insert_3_mult li1 cu 0 li2].
	insert_3_mult li1 cu 0 li2 -> li1 = li2

  axiom insert_3_mult_1 :
    forall li1 li2 : list, cu : cursor [insert_3_mult li1 cu 1 li2].
	insert_3_mult li1 cu 1 li2 -> 
        exists e : Ada__containers__formal_doubly_linked_lists__element_type.base_type.
         Ada__containers__formal_doubly_linked_lists__element_type.valid e /\ insert li1 cu e li2

  axiom insert_3_mult_n :
    forall li1 li2 : list, cu : cursor, c : int [insert_3_mult li1 cu c li2].
	insert_3_mult li1 cu c li2 -> c > 1 ->
	 exists nl : list , e : Ada__containers__formal_doubly_linked_lists__element_type.base_type [insert li1 cu e nl].
         Ada__containers__formal_doubly_linked_lists__element_type.valid e /\
    		(insert li1 cu e nl /\ insert_3_mult nl cu (c - 1) li2) 

  val insert__3 (co:ref list) (cu:cursor)  (p:ref cursor)
                                             (c : int) : unit
     requires { length_ !co + c <= capacity !co
                         /\ (position !co cu > 0 \/ cu = no_element) }
     writes     { co, p }
     reads      { co }
     ensures { insert_3_mult (old !co) cu c !co /\
            first_inserted (old !co) cu !co !p }
end

module Ada__containers__formal_doubly_linked_lists__prepend
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_doubly_linked_lists__args".Ada__containers__formal_doubly_linked_lists__element_type
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__first
  use import Ada__containers__formal_doubly_linked_lists__insert

  val prepend (co:ref list) (e:Ada__containers__formal_doubly_linked_lists__element_type.base_type) 
                                             (c : int) : unit
     requires { length_ !co + c <= capacity !co }
     writes     { co }
     reads      { co }
     ensures { insert_mult (old !co) (first (old !co)) e c !co }
end

module Ada__containers__formal_doubly_linked_lists__append
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_doubly_linked_lists__args".Ada__containers__formal_doubly_linked_lists__element_type
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__no_element
  use import Ada__containers__formal_doubly_linked_lists__insert

   val append (co:ref list) (e:Ada__containers__formal_doubly_linked_lists__element_type.base_type) 
                                             (c : int) : unit
     requires { length_ !co + c <= capacity !co }
     writes     { co }
     reads      { co }
     ensures { insert_mult (old !co) no_element e
                             c !co }
end

module Ada__containers__formal_doubly_linked_lists__delete
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__no_element
  use import Ada__containers__formal_doubly_linked_lists__next
  use import Ada__containers__formal_doubly_linked_lists__element

  predicate delete list cursor list

  axiom delete_capacity:
    forall co1 co2:list, cu:cursor
      [delete co1 cu co2, capacity co1|delete co1 cu co2, capacity co2].
      delete co1 cu co2 -> capacity co1 = capacity co2

  axiom delete_length_:
    forall co1 co2:list, cu:cursor
      [delete co1 cu co2].
      delete co1 cu co2 -> length_ co1 = length_ co2 + 1

  axiom delete_position_before:
    forall co1 co2:list, cu cun:cursor
      [delete co1 cu co2,  position co1 cun
     | delete co1 cu co2,  position co2 cun].
      delete co1 cu co2 ->
      (position co1 cu > position co1 cun \/ 0 < position co2 cun < position co1 cu) ->
        position co1 cun = position co2 cun

  axiom delete_position_after:
    forall co1 co2:list, cu cun:cursor
      [delete co1 cu co2,  position co1 cun | delete co1 cu co2,  position co2 cun].
      delete co1 cu co2 ->
      (position co1 cun > position co1 cu \/ position co2 cun >= position co1 cu) ->
        position co1 cun = position co2 cun + 1

  axiom delete_position_range:
    forall co1 co2:list, cu:cursor [delete co1 cu co2].
      delete co1 cu co2 -> position co2 cu = 0 /\ 0 < position co1 cu

  axiom delete_position_next:
    forall co1 co2:list, cu:cursor [delete co1 cu co2].
      delete co1 cu co2 -> position co1 (next co1 cu) >= 0

  axiom delete_element:
    forall co1 co2:list, cu cun:cursor
      [delete co1 cu co2,  element co1 cun
     | delete co1 cu co2,  element co2 cun].
      delete co1 cu co2 ->
      0 < position co2 cun ->
        element co1 cun = element co2 cun

  predicate delete_mult list cursor int list

  axiom delete_mult_0 :
    forall li1 li2 : list, cu : cursor [delete_mult li1 cu 0 li2].
	delete_mult li1 cu 0 li2 -> li1 = li2

  axiom delete_mult_1 :
    forall li1 li2 : list, cu : cursor [delete_mult li1 cu 1 li2].
	delete_mult li1 cu 1 li2 -> delete li1 cu li2

  axiom delete_mult_n :
    forall li1 li2 : list, cu : cursor, c : int [delete_mult li1 cu c li2].
	delete_mult li1 cu c li2 -> c > 1 ->
	 exists nl : list [delete li1 cu nl].
    		(delete li1 cu nl /\
                  (position li1 cu = length_ li1 \/
                    position li1 cu < length_ li1 /\ delete_mult nl (next li1 cu) (c - 1) li2))

  val delete (co:ref list) (cu:ref cursor) (c : int) : unit
     requires { position !co !cu > 0 }
     writes     { co, cu }
     reads      { co }
     ensures { delete_mult (old !co) (old !cu) c !co /\ !cu = no_element}
end

module Ada__containers__formal_doubly_linked_lists__delete_first
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__first
  use import Ada__containers__formal_doubly_linked_lists__delete

  val delete_first (co:ref list)  (c : int) : unit
     writes     { co }
     reads      { co }
     ensures { if length_ !co > 0 then delete_mult (old !co) (first (old !co)) c !co else !co = (old !co) }
end

module Ada__containers__formal_doubly_linked_lists__delete_last
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__last
  use import Ada__containers__formal_doubly_linked_lists__delete

  val delete_last (co:ref list) (c : int) : unit
     writes     { co }
     reads      { co }
     ensures { if length_ !co > 0 then delete_mult (old !co) (last (old !co)) c !co else !co = (old !co) }
end

module Ada__containers__formal_doubly_linked_lists__swap_links
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__element

  predicate swap_links list cursor cursor list

  axiom swap_links_elements:
    forall co1 co2 : list, cu cu1 cu2 : cursor 
             [swap_links co1 cu1 cu2 co2, element co1 cu | 
               swap_links co1 cu1 cu2 co2, element co2 cu].
    swap_links co1 cu1 cu2 co2 -> position co1 cu > 0 ->
    element co1 cu = element co2 cu

  axiom swap_links_length_:
    forall co1 co2 : list, cu1 cu2 : cursor 
             [swap_links co1 cu1 cu2 co2, length_ co1].
    swap_links co1 cu1 cu2 co2 -> length_ co1 = length_ co2

  axiom swap_links_capacity:
    forall co1 co2 : list, cu1 cu2 : cursor 
             [swap_links co1 cu1 cu2 co2, capacity co1
             | swap_links co1 cu1 cu2 co2, capacity co2].
    swap_links co1 cu1 cu2 co2 -> capacity co1 = capacity co2

  axiom swap_links_position_ext:
    forall co1 co2 : list, cu cu1 cu2 : cursor 
             [swap_links co1 cu1 cu2 co2, position co1 cu | 
               swap_links co1 cu1 cu2 co2, position co2 cu].
    swap_links co1 cu1 cu2 co2 -> 
     cu <> cu1 -> cu <> cu2 -> position co1 cu = position co2 cu

  axiom swap_links_position_in:
    forall co1 co2 : list, cu1 cu2 : cursor 
             [swap_links co1 cu1 cu2 co2].
    swap_links co1 cu1 cu2 co2 -> 
     position co1 cu1 = position co2 cu2 /\
     position co1 cu2 = position co2 cu1 /\
     position co1 cu1 > 0 /\ position co1 cu2 > 0
  
  val swap_links (co:ref list) (cu1 cu2 : cursor) : unit
    requires { position !co cu1 > 0 /\ position !co cu2 > 0 }
     writes     { co }
     ensures { (cu1 = cu2 /\ !co = old !co) \/
                         (cu1 <> cu2 /\ swap_links (old !co) cu1 cu2 !co) }
end

module Ada__containers__formal_doubly_linked_lists__swap
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__element

  predicate swap list cursor cursor list

  axiom swap_position:
    forall co1 co2 : list, cu cu1 cu2 : cursor 
             [swap co1 cu1 cu2 co2, position co1 cu | 
               swap co1 cu1 cu2 co2, position co2 cu].
    swap co1 cu1 cu2 co2 -> position co1 cu = position co2 cu

  axiom swap_length_:
    forall co1 co2 : list, cu1 cu2 : cursor 
             [swap co1 cu1 cu2 co2, length_ co1].
    swap co1 cu1 cu2 co2 -> length_ co1 = length_ co2

  axiom swap_capacity:
    forall co1 co2 : list, cu1 cu2 : cursor 
             [swap co1 cu1 cu2 co2, capacity co1
             | swap co1 cu1 cu2 co2, capacity co2].
    swap co1 cu1 cu2 co2 -> capacity co1 = capacity co2

  axiom swap_element_ext:
    forall co1 co2 : list, cu cu1 cu2 : cursor 
             [swap co1 cu1 cu2 co2, element co1 cu | 
               swap co1 cu1 cu2 co2, element co2 cu].
    swap co1 cu1 cu2 co2 -> position co1 cu > 0 ->
     cu <> cu1 -> cu <> cu2 -> element co1 cu = element co2 cu

  axiom swap_element_in:
    forall co1 co2 : list, cu1 cu2 : cursor 
             [swap co1 cu1 cu2 co2].
    swap co1 cu1 cu2 co2 -> 
     element co1 cu1 = element co2 cu2 /\
     element co1 cu2 = element co2 cu1 /\
     position co1 cu1 > 0 /\ position co1 cu2 > 0
  
  val swap (co:ref list) (cu1 cu2 : cursor) : unit
    requires { position !co cu1 > 0 /\ position !co cu2 > 0 }
     writes     { co }
     ensures { (cu1 = cu2 /\ !co = old !co) \/
                         (cu1 <> cu2 /\ swap (old !co) cu1 cu2 !co) }
end

module Ada__containers__formal_doubly_linked_lists__splice
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__no_element
  use import Ada__containers__formal_doubly_linked_lists__next
  use import Ada__containers__formal_doubly_linked_lists__previous
  use import Ada__containers__formal_doubly_linked_lists__inleft
  use import Ada__containers__formal_doubly_linked_lists__right
  use import Ada__containers__formal_doubly_linked_lists__left
  use import Ada__containers__formal_doubly_linked_lists__Oeq__2
  use import Ada__containers__formal_doubly_linked_lists__strict_equal

  val splice (target:ref list) (cu:cursor) (source:ref list) : unit
     requires { capacity !target >= (length_ !target) + (length_ !source) 
                           /\ (position !target cu > 0 \/ cu = no_element)}
     writes     { target, source }
     reads      { target, source }
     ensures {length_ !target = (length_ (old !target)) + (length_ (old !source)) /\
                         length_ !source = 0 /\ strict_equal (right !target cu) (right (old !target) cu) = True /\
                         strict_equal (left (old !target) cu) (inleft !target (previous (old !target) cu)) = True /\
                         oeq__2 (old !source) (right (left !target cu) (next !target (previous (old !target) cu))) = True }
end

module Ada__containers__formal_doubly_linked_lists__splice__2
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_doubly_linked_lists__args".Ada__containers__formal_doubly_linked_lists__element_type
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__no_element
  use import Ada__containers__formal_doubly_linked_lists__element
  use import Ada__containers__formal_doubly_linked_lists__insert
  use import Ada__containers__formal_doubly_linked_lists__insert__2
  use import Ada__containers__formal_doubly_linked_lists__delete
  
  val splice__2 (target:ref list) (cu:cursor) (source:ref list)
                                (p:ref cursor) : unit
     requires { capacity !target >= (length_ !target) + (length_ !source)
                           /\ (position !target cu > 0 \/ cu = no_element)
                           /\ position !source !p > 0}
     writes     { target, source, p }
     reads      { target, source, p }
     ensures { insert (old !target) cu (Ada__containers__formal_doubly_linked_lists__element_type.to_base (element (old !source) (old !p))) !target /\
                         delete (old !source) (old !p) !source /\ 
                        first_inserted (old !target) cu !target !p  }
end

module Ada__containers__formal_doubly_linked_lists__splice__3
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_doubly_linked_lists__args".Ada__containers__formal_doubly_linked_lists__element_type
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__no_element
  use import Ada__containers__formal_doubly_linked_lists__element
  use import Ada__containers__formal_doubly_linked_lists__insert
  use import Ada__containers__formal_doubly_linked_lists__delete

  val splice__3 (co:ref list) (before:cursor) (p:cursor) : unit
     requires { capacity !co >= 2*(length_ !co)
                           /\ (position !co before > 0 \/ before = no_element) }
     writes     { co }
     reads      { co }
     ensures { exists interm : list. 
                       delete (old !co) p  interm /\
                       insert interm before (Ada__containers__formal_doubly_linked_lists__element_type.to_base (element (old !co) p)) !co }
end

module Ada__containers__formal_doubly_linked_lists__has_element
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor

  function has_element list cursor : bool

  axiom has_element_pos:
    forall co:list, cu:cursor [has_element co cu].
    has_element co cu = True -> 0 < position co cu

  axiom has_element_neg:
    forall co:list, cu:cursor [has_element co cu].
    has_element co cu <> True -> position co cu = 0

  val has_element (co:list) (cu:cursor) : bool
     ensures { has_element co cu = result }
end

module Ada__containers__formal_doubly_linked_lists__contains
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_doubly_linked_lists__args".Ada__containers__formal_doubly_linked_lists__element_type
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__cursor
  use import Ada__containers__formal_doubly_linked_lists__find

  function contains list Ada__containers__formal_doubly_linked_lists__element_type.base_type : bool

  axiom contains_c:
  forall co : list, e : Ada__containers__formal_doubly_linked_lists__element_type.base_type [contains co e].
    contains co e = True <-> 0 < position co (findfirst co e)

  val contains (co:list) (e:Ada__containers__formal_doubly_linked_lists__element_type.base_type) : bool
     ensures { contains co e = result }
end

module Ada__containers__formal_doubly_linked_lists__clear
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  
  val clear (co:ref list) : unit
     writes     { co }
     ensures { length_ !co = 0 /\ capacity !co = capacity (old !co) }
end

module Ada__containers__formal_doubly_linked_lists__assign
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__Oeq__2

  val assign (target:ref list) (source:list) : unit
     requires { capacity !target >= length_ source }
     writes     { target }
     reads      { target }
     ensures { oeq__2 !target source = True }
end

module Ada__containers__formal_doubly_linked_lists__move
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__Oeq__2

  val move (target:ref list) (source:ref list) : unit
     requires { capacity !target >= length_ !source }
     writes     { target, source }
     reads      { target, source }
     ensures { oeq__2 !target (old !source) = True /\ length_ !source = 0 }
end

module Ada__containers__formal_doubly_linked_lists__copy
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_doubly_linked_lists__list
  use import Ada__containers__formal_doubly_linked_lists__length
  use import Ada__containers__formal_doubly_linked_lists__strict_equal

  predicate cap_is_max list list int

 axiom cap_is_max_def:
   forall co1 co2:list, max:int 
                  [cap_is_max co1 co2 max, capacity co1 | cap_is_max co1 co2 max, capacity co2].
   if capacity co1 > max then capacity co2 = capacity co1 else capacity co2 = max

  function copy list int : list

  val copy (co: list) (cap:int) : list
     ensures { strict_equal co (result) = True /\ 
                      cap_is_max co result cap /\ result = copy co cap }
end
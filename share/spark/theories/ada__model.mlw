module Discrete_Base
  (* The module that is used as basis for all discrete types. It contains the
    whole discrete theory, except the coerce_axiom which differs between
    modular and non-modular types, and range-related functions and axioms which
    differ between "static" and "dynamic" discrete types. *)

  use import int.Int
  use import "_gnatprove_standard".Main
  use        "_gnatprove_standard".Integer

  use export "ada__model_th".Discrete_Base_Theory

  type t "bounded_type"

  function attr__ATTRIBUTE_IMAGE int : __image

  predicate attr__ATTRIBUTE_VALUE__pre_check (x : __image)

  function attr__ATTRIBUTE_VALUE __image : int

  val attr__ATTRIBUTE_VALUE_ (x : __image) : int
    requires { attr__ATTRIBUTE_VALUE__pre_check x }
    ensures { true }

  function to_int "bounded_type" t : int

  function of_int "bounded_type" int : t

  val of_int (x : int) : t
    requires { true }
    ensures { to_int(result) = x }

  function user_eq  (x : t) (y : t) : bool

  axiom inversion_axiom "bounded_type" :
    forall x : t [to_int x].
    of_int (to_int (x)) = x

  function dummy : t
end

module Static_Discrete_Base
  (* The module that is used as basis for all "static" discrete types.
     It contains the whole discrete theory, except the coerce_axiom which
     differs between modular and non-modular types. "Static" here means that
     Why only sees a static version of the type, with constants for the bounds,
     even though this might correspond to dynamic types in Ada. *)

  use import int.Int

  clone export Discrete_Base

  function first : int

  function last : int

  val check_not_last (n : int) : int
    requires { n <> last }
    ensures { result = n }

  val check_not_first (n : int) : int
    requires { n <> first }
    ensures { result = n }

  predicate in_range "bounded_type" (x : int) =
    ( first <= x <= last )

  val range_check_ (n : int) : int
    requires { in_range n }
    ensures { result = n }

  axiom range_axiom "bounded_type" :
    forall x : t. in_range (to_int x)
end

module Static_Discrete
  use import int.Int
  clone export Static_Discrete_Base

  axiom coerce_axiom "bounded_type" :
    forall x  : int [to_int (of_int x)].
      in_range x -> to_int (of_int x) = x
end

module Static_Modular
  clone export Static_Discrete_Base

  function attr__ATTRIBUTE_MODULUS : int

  axiom coerce_axiom "bounded_type" :
    forall x  : int [to_int (of_int x)].
      to_int (of_int x) = Integer.math_mod x attr__ATTRIBUTE_MODULUS
end

module Dynamic_Discrete_Base
  (* The module that is used as basis for all "dynamic" discrete types.
     It contains the whole discrete theory, except the coerce_axiom which
     differs between modular and non-modular types. "Dynamic" here means that
     Why sees a dynamic version of the type, with references for the bounds,
     which correspond to some cases of dynamic types in Ada. *)

  use import int.Int
  use import ref.Ref
  clone export Discrete_Base

  (* left uninterpreted, used for unconstrained arrays based on this index range *)
  predicate in_range "bounded_type" (x : int)

  val first : ref int

  val last : ref int
end

module Dynamic_Discrete
  use import int.Int
  clone export Dynamic_Discrete_Base
end

module Dynamic_Modular
  clone export Dynamic_Discrete_Base

  function attr__ATTRIBUTE_MODULUS : int

  axiom coerce_axiom "bounded_type" :
    forall x  : int [to_int (of_int x)].
      to_int (of_int x) = Integer.math_mod x attr__ATTRIBUTE_MODULUS
end

module Floating_Point_Base
  (* The module that is used as basis for all floating-point types. *)

  use import "_gnatprove_standard".Main
  use        "_gnatprove_standard".Floating
  use import real.RealInfix
  use export "ada__model_th".Floating_Point_Theory

  type t

  (* This module will be cloned and round_real_tmp possibly replaced.
     We keep round_real to denote the resulting rounding function. *)

  function round_real_tmp real : real
  function round_real (x : real) : real = round_real_tmp (x)

  function to_real t : real

  function of_real real : t

  val of_real (x : real) : t
    requires { true }
    ensures  { to_real (result) = x }

  function user_eq  (x : t) (y : t) : bool

  axiom inversion_axiom :
    forall x : t [to_real x].
      of_real ( to_real(x) ) = x

  function attr__ATTRIBUTE_IMAGE real : __image

  predicate attr__ATTRIBUTE_VALUE__pre_check (x : __image)

  function attr__ATTRIBUTE_VALUE __image : real

  val attr__ATTRIBUTE_VALUE_ (x : __image) : real
    requires { attr__ATTRIBUTE_VALUE__pre_check x }
    ensures { true }

 function dummy :t
end

module Static_Floating_Point
  (* The module that is used as basis for all "static" floating-point types. *)

  use import real.RealInfix
  clone export Floating_Point_Base

  function first  : real

  function last  : real

  (* The first and last value of the floating-point type are exactly
     represented. So round_real is the identity on such values. *)

  axiom representable_first :
    round_real first = first

  axiom representable_last :
    round_real last = last

  predicate in_range  (x : real) =
   ( first <=. x <=. last )

  val range_check_ (n : real)  :real
    requires { in_range n }
    ensures { result = n }

  axiom range_axiom :
    forall x  : t.  in_range (to_real x)

  axiom coerce_axiom :
    forall x  : real [to_real (of_real x) | in_range x, of_real x].
      in_range x -> to_real (of_real x) = x
end

module Dynamic_Floating_Point
  (* The module that is used as basis for all "dynamic" floating-point types. *)

  use import ref.Ref
  clone export Floating_Point_Base

  val first : ref real

  val last  : ref real
end

(* The following modules are templates for unconstrained and constrained array
types. Only the one for one dimension is commented, the others are very similar *)

(* ??? TBD Index types of arrays are treated in a special way, but there is no
reason for that: something similar could be the basis for all
scalar types. To be done. *)

module Index_Type
  (* This is the module for an index type of an unconstrained array. first
  and last are always in the base type, but when first <= last, then they are
  actually in the index subtype. *)

  use import int.Int

  (* These are filled in for every instance of an index type *)
  type base

  function to_int base : int
  predicate in_range_base int
  predicate in_range int

  (* the index type itself *)
  type t

  (* first and last of an index *)
  function first t : base

  function last t : base

  (* constructing and deconstructing the index *)
  function mk int int : t

  axiom range_axiom_first :
    forall a : t [first a].
      to_int (first a) <= to_int (last a) ->
        in_range (to_int (first a))

  axiom range_axiom_last :
    forall a : t [last a].
      to_int (first a) <= to_int (last a) ->
        in_range (to_int (last a))

  axiom mk_def :
    forall f l : int [mk f l].
      in_range_base f ->
      in_range_base l ->
      ((f <= l -> (in_range f /\ in_range l))
        /\
        to_int (first (mk f l)) = f /\
        to_int (last (mk f l)) = l)

  (* The range check that is required by conversion to an unconstrained array.
     See RM 3.6.2(4-6) and 4.6(38) *)
  predicate range_check (low : int) (high : int) =
    in_range_base low /\ in_range_base high /\
       (high >= low -> (in_range low /\ in_range high))

end

module Array_Comparison_Axiom
  use import int.Int
  use "_gnatprove_standard".Array__1

  (* These declarations have to be filled in by gnat2why for each
  discrete 1 dimension array type *)
  type component_type

   function to_int component_type : int

   axiom compare_def :
    forall a b : Array__1.map component_type.
    forall a_first a_last b_first b_last : int [Array__1.compare a a_first a_last b b_first b_last].
      (Array__1.compare a a_first a_last b b_first b_last = 0 <->
          Array__1.bool_eq a a_first a_last b b_first b_last = True) /\
      (Array__1.compare a a_first a_last b b_first b_last < 0 <->
         exists i j : int. i <= a_last /\ j < b_last /\ 
             (Array__1.bool_eq a a_first  i b b_first j = True /\
             (i = a_last \/
                   i < a_last /\
                       to_int (Array__1.get a (i + 1)) < to_int (Array__1.get b (j + 1))))) /\
      (Array__1.compare a a_first a_last b b_first b_last > 0 <->
         exists i j : int. i <= b_last /\ j < a_last /\ 
             (Array__1.bool_eq a a_first j b b_first i = True /\
             (i = b_last \/ i < b_last /\
                       to_int (Array__1.get a (j + 1)) > to_int (Array__1.get b (i + 1)))))

end

module Unconstr_Array
  (* The module to be cloned for an unconstrained array of dimension 1 *)

  use import int.Int
  use "_gnatprove_standard".Array__1

  (* These declarations have to be filled in by gnat2why for each
  unconstrained array type *)
  type component_type

  type base_type
  function to_int base_type : int
  predicate in_range_base int
  predicate in_range int

  clone Index_Type as I1 with
    type      base          = base_type,
    function  to_int        = to_int,
    predicate in_range_base = in_range_base,
    predicate in_range      = in_range

  type __split = Array__1.map component_type

  (* An unconstrained array comes with its bounds *)
  type __t =
    { elts : __split; rt : I1.t }

  function to_array (a : __t) : __split = a.elts

  function of_array (a : __split) (f l : int) : __t =
    { elts = a; rt = I1.mk f l }

  function first (a : __t) : int = to_int (I1.first a.rt)
  function last (a : __t) : int = to_int (I1.last a.rt)
  function length (a : __t) : int =
    if first a <= last a then
      last a - first a + 1 else 0

  predicate range_check (f1 l1 : int) =
    I1.range_check f1 l1

  function bool_eq (x : __t) (y : __t) : bool =
    Array__1.bool_eq
      x.elts (to_int (I1.first x.rt)) (to_int (I1.last x.rt))
      y.elts (to_int (I1.first y.rt)) (to_int (I1.last y.rt))

  function user_eq (x : __t) (y : __t) : bool

  function dummy : __t
end

module Unconstr_Array_2
  (* The module to be cloned for an unconstrained array of dimension 1 *)

  use import int.Int
  use "_gnatprove_standard".Array__2

  type component_type

  type base_type
  function to_int base_type : int
  predicate in_range_base int
  predicate in_range int

  type base_type_2
  function to_int_2 base_type_2 : int
  predicate in_range_base_2 int
  predicate in_range_2 int

  clone Index_Type as I1 with
    type      base          = base_type,
    function  to_int        = to_int,
    predicate in_range_base = in_range_base,
    predicate in_range      = in_range

  clone Index_Type as I2 with
    type      base          = base_type_2,
    function  to_int        = to_int_2,
    predicate in_range_base = in_range_base_2,
    predicate in_range      = in_range_2

  type __split = Array__2.map component_type
  type __t =
    { elts     : __split;
      rt       : I1.t;
      rt_2     : I2.t
    }

  function to_array (a : __t) : __split =
    a.elts

  function of_array (a : __split)
    (f l f2 l2 : int) : __t =
    { elts = a;
      rt = I1.mk f l;
      rt_2 = I2.mk f2 l2 }

  function first (a : __t) : int = to_int (I1.first a.rt)
  function last (a : __t) : int = to_int (I1.last a.rt)
  function length (a : __t) : int =
    if first a <= last a then
      last a - first a + 1 else 0

  function first_2 (a : __t) : int = to_int_2 (I2.first a.rt_2)
  function last_2 (a : __t) : int = to_int_2 (I2.last a.rt_2)
  function length_2 (a : __t) : int =
    if first_2 a <= last_2 a then
      last_2 a - first_2 a + 1 else 0

  predicate range_check (f1 l1 f2 l2 : int) =
    I1.range_check f1 l1 /\ I2.range_check f2 l2

  function user_eq (x : __t) (y : __t) : bool
  function bool_eq (x : __t) (y : __t) : bool =
    Array__2.bool_eq
      x.elts (to_int (I1.first x.rt)) (to_int (I1.last x.rt))
             (to_int_2 (I2.first x.rt_2)) (to_int_2 (I2.last x.rt_2))
      y.elts (to_int (I1.first y.rt)) (to_int (I1.last y.rt))
             (to_int_2 (I2.first y.rt_2)) (to_int_2 (I2.last y.rt_2))

  function dummy : __t
end

module Unconstr_Array_3
  (* The module to be cloned for an unconstrained array of dimension 1 *)

  use import int.Int
  use "_gnatprove_standard".Array__3

  type component_type

  type base_type
  function to_int base_type : int
  predicate in_range_base int
  predicate in_range int

  type base_type_2
  function to_int_2 base_type_2 : int
  predicate in_range_base_2 int
  predicate in_range_2 int

  type base_type_3
  function to_int_3 base_type_3 : int
  predicate in_range_base_3 int
  predicate in_range_3 int


  clone Index_Type as I1 with
    type      base          = base_type,
    function  to_int        = to_int,
    predicate in_range_base = in_range_base,
    predicate in_range      = in_range

  clone Index_Type as I2 with
    type      base          = base_type_2,
    function  to_int        = to_int_2,
    predicate in_range_base = in_range_base_2,
    predicate in_range      = in_range_2

  clone Index_Type as I3 with
    type      base          = base_type_3,
    function  to_int        = to_int_3,
    predicate in_range_base = in_range_base_3,
    predicate in_range      = in_range_3

  type __split = Array__3.map component_type
  type __t =
    { elts     : __split;
      rt       : I1.t;
      rt_2     : I2.t;
      rt_3     : I3.t
    }

  function to_array (a : __t) : __split =
    a.elts

  function of_array (a : __split)
    (f l f2 l2 f3 l3 : int) : __t =
    { elts = a;
      rt = I1.mk f l;
      rt_2 = I2.mk f2 l2;
      rt_3 = I3.mk f3 l3
    }

  function first (a : __t) : int = to_int (I1.first a.rt)
  function last (a : __t) : int = to_int (I1.last a.rt)
  function length (a : __t) : int =
    if first a <= last a then
      last a - first a + 1 else 0

  function first_2 (a : __t) : int = to_int_2 (I2.first a.rt_2)
  function last_2 (a : __t) : int = to_int_2 (I2.last a.rt_2)
  function length_2 (a : __t) : int =
    if first_2 a <= last_2 a then
      last_2 a - first_2 a + 1 else 0

  function first_3 (a : __t) : int = to_int_3 (I3.first a.rt_3)
  function last_3 (a : __t) : int = to_int_3 (I3.last a.rt_3)
  function length_3 (a : __t) : int =
    if first_3 a <= last_3 a then
      last_3 a - first_3 a + 1 else 0

  predicate range_check (f1 l1 f2 l2 f3 l3 : int) =
    I1.range_check f1 l1 /\ I2.range_check f2 l2 /\ I3.range_check f3 l3

  function user_eq (x : __t) (y : __t) : bool

  function bool_eq (x : __t) (y : __t) : bool =
    Array__3.bool_eq
      x.elts (to_int (I1.first x.rt))   (to_int (I1.last x.rt))
             (to_int_2 (I2.first x.rt_2)) (to_int_2 (I2.last x.rt_2))
             (to_int_3 (I3.first x.rt_3)) (to_int_3 (I3.last x.rt_3))
      y.elts (to_int (I1.first y.rt))   (to_int (I1.last y.rt))
             (to_int_2 (I2.first y.rt_2)) (to_int_2 (I2.last y.rt_2))
             (to_int_3 (I3.first y.rt_3)) (to_int_3 (I3.last y.rt_3))

  function dummy : __t
end

module Unconstr_Array_4
  (* The module to be cloned for an unconstrained array of dimension 1 *)

  use import int.Int
  use "_gnatprove_standard".Array__4

  type component_type

  type base_type
  function to_int base_type : int
  predicate in_range_base int
  predicate in_range int

  type base_type_2
  function to_int_2 base_type_2 : int
  predicate in_range_base_2 int
  predicate in_range_2 int

  type base_type_3
  function to_int_3 base_type_3 : int
  predicate in_range_base_3 int
  predicate in_range_3 int

  type base_type_4
  function to_int_4 base_type_4 : int
  predicate in_range_base_4 int
  predicate in_range_4 int


  clone Index_Type as I1 with
    type      base          = base_type,
    function  to_int        = to_int,
    predicate in_range_base = in_range_base,
    predicate in_range      = in_range

  clone Index_Type as I2 with
    type      base          = base_type_2,
    function  to_int        = to_int_2,
    predicate in_range_base = in_range_base_2,
    predicate in_range      = in_range_2

  clone Index_Type as I3 with
    type      base          = base_type_3,
    function  to_int        = to_int_3,
    predicate in_range_base = in_range_base_3,
    predicate in_range      = in_range_3

  clone Index_Type as I4 with
    type      base          = base_type_4,
    function  to_int        = to_int_4,
    predicate in_range_base = in_range_base_4,
    predicate in_range      = in_range_4

  type __split = Array__4.map component_type

  type __t =
    { elts     : __split;
      rt       : I1.t;
      rt_2     : I2.t;
      rt_3     : I3.t;
      rt_4     : I4.t
    }

  function to_array (a : __t) : __split =
    a.elts

  function of_array (a : __split)
    (f l f2 l2 f3 l3 f4 l4 : int) : __t =
    { elts = a;
      rt = I1.mk f l;
      rt_2 = I2.mk f2 l2;
      rt_3 = I3.mk f3 l3;
      rt_4 = I4.mk f4 l4
    }

  function first (a : __t) : int = to_int (I1.first a.rt)
  function last (a : __t) : int = to_int (I1.last a.rt)
  function length (a : __t) : int =
    if first a <= last a then
      last a - first a + 1 else 0

  function first_2 (a : __t) : int = to_int_2 (I2.first a.rt_2)
  function last_2 (a : __t) : int = to_int_2 (I2.last a.rt_2)
  function length_2 (a : __t) : int =
    if first_2 a <= last_2 a then
      last_2 a - first_2 a + 1 else 0

  function first_3 (a : __t) : int = to_int_3 (I3.first a.rt_3)
  function last_3 (a : __t) : int = to_int_3 (I3.last a.rt_3)
  function length_3 (a : __t) : int =
    if first_3 a <= last_3 a then
      last_3 a - first_3 a + 1 else 0

  function first_4 (a : __t) : int = to_int_4 (I4.first a.rt_4)
  function last_4 (a : __t) : int = to_int_4 (I4.last a.rt_4)
  function length_4 (a : __t) : int =
    if first_4 a <= last_4 a then
      last_4 a - first_4 a + 1 else 0

  predicate range_check (f1 l1 f2 l2 f3 l3 f4 l4 : int) =
    I1.range_check f1 l1 /\ I2.range_check f2 l2 /\
    I3.range_check f3 l3 /\ I4.range_check f4 l4

  function user_eq (x : __t) (y : __t) : bool

  function bool_eq (x : __t) (y : __t) : bool =
    Array__4.bool_eq
      x.elts (to_int (I1.first x.rt))   (to_int (I1.last x.rt))
             (to_int_2 (I2.first x.rt_2)) (to_int_2 (I2.last x.rt_2))
             (to_int_3 (I3.first x.rt_3)) (to_int_3 (I3.last x.rt_3))
             (to_int_4 (I4.first x.rt_4)) (to_int_4 (I4.last x.rt_4))
      y.elts (to_int (I1.first y.rt))   (to_int (I1.last y.rt))
             (to_int_2 (I2.first y.rt_2)) (to_int_2 (I2.last y.rt_2))
             (to_int_3 (I3.first y.rt_3)) (to_int_3 (I3.last y.rt_3))
             (to_int_4 (I4.first y.rt_4)) (to_int_4 (I4.last y.rt_4))

  function dummy : __t
end

module Constr_Array
  use import int.Int
  use "_gnatprove_standard".Array__1

  type component_type

  function first : int
  function last  : int

  type __t = Array__1.map component_type

  function to_array  (a : __t) : Array__1.map component_type = a

  function of_array  (a : Array__1.map component_type) : __t = a

  function dummy : __t

  function user_eq (x : __t) (y : __t) : bool
  function bool_eq (x : __t) (y : __t) : bool =
    Array__1.bool_eq x first last
                     y first last
end

module Constr_Array_2
  use import int.Int
  use "_gnatprove_standard".Array__2

  type component_type

  function first : int
  function last  : int

  function first_2 : int
  function last_2  : int

  type __t = Array__2.map component_type

  function to_array  (a : __t) : Array__2.map component_type = a

  function of_array  (a : Array__2.map component_type) : __t = a

  function dummy : __t
  function user_eq (x : __t) (y : __t) : bool
  function bool_eq (x : __t) (y : __t) : bool =
    Array__2.bool_eq x first last first_2 last_2
                     y first last first_2 last_2
end

module Constr_Array_3
  use import int.Int
  use "_gnatprove_standard".Array__3

  type component_type

  function first : int
  function last  : int

  function first_2 : int
  function last_2  : int

  function first_3 : int
  function last_3  : int

  type __t = Array__3.map component_type

  function to_array  (a : __t) : Array__3.map component_type = a

  function of_array  (a : Array__3.map component_type) : __t = a

  function dummy : __t
  function user_eq (x : __t) (y : __t) : bool
  function bool_eq (x : __t) (y : __t) : bool =
    Array__3.bool_eq x first last first_2 last_2 first_3 last_3
                     y first last first_2 last_2 first_3 last_3
end

module Constr_Array_4
  use import int.Int
  use "_gnatprove_standard".Array__4

  type component_type

  function first : int
  function last  : int

  function first_2 : int
  function last_2  : int

  function first_3 : int
  function last_3  : int

  function first_4 : int
  function last_4  : int

  type __t = Array__4.map component_type

  function to_array  (a : __t) : Array__4.map component_type = a

  function of_array  (a : Array__4.map component_type) : __t = a

  function dummy : __t
  function user_eq (x : __t) (y : __t) : bool
  function bool_eq (x : __t) (y : __t) : bool =
    Array__4.bool_eq x first last first_2 last_2 first_3 last_3 first_4 last_4
                     y first last first_2 last_2 first_3 last_3 first_4 last_4
end

module Discrete_Base
  (* The module that is used as basis for all discrete types. It contains the
    whole discrete theory, except the coerce_axiom which differs between
    modular and non-modular types. *)

  use import int.Int
  use import "_gnatprove_standard".Main
  use        "_gnatprove_standard".Integer

  use export "ada__model_th".Discrete_Base_Theory

  type t

  function attr__ATTRIBUTE_FIRST : int

  function attr__ATTRIBUTE_LAST : int

  function attr__ATTRIBUTE_IMAGE int : __image

  predicate attr__ATTRIBUTE_VALUE__pre_check (x : __image)

  function attr__ATTRIBUTE_VALUE __image : int

  val attr__ATTRIBUTE_VALUE_ (x : __image)  :int
    requires { attr__ATTRIBUTE_VALUE__pre_check x }
    ensures { true }

  predicate in_range  (x : int) =
    ( attr__ATTRIBUTE_FIRST <= x <= attr__ATTRIBUTE_LAST )

  function to_int t : int

  function of_int int : t

  val of_int (x : int) : t
    requires { true }
    ensures { to_int(result) = x }

  val range_check_ (n : int) : int
    requires { in_range n }
    ensures { result = n }

  val check_not_last (n : int) : int
    requires { n <> attr__ATTRIBUTE_LAST }
    ensures { result = n }

  val check_not_first (n : int) : int
    requires { n <> attr__ATTRIBUTE_FIRST }
    ensures { result = n }

  predicate eq (x : t) (y : t) = ( to_int x = to_int y )

  axiom range_axiom :
    forall x : t. in_range (to_int x)

  axiom inversion_axiom :
    forall x : t [to_int x].
    of_int (to_int (x)) = x

  function dummy : t
end

module Discrete
  use import int.Int
  clone export Discrete_Base

  axiom coerce_axiom :
    forall x  : int [to_int (of_int x)].
      in_range x -> to_int (of_int x) = x

end

module Modular
  clone export Discrete_Base

  function attr__ATTRIBUTE_MODULUS : int

  axiom coerce_axiom :
    forall x  : int [to_int (of_int x)].
      to_int (of_int x) = Integer.math_mod x attr__ATTRIBUTE_MODULUS

end

module Floating_Point
  use import "_gnatprove_standard".Main
  use        "_gnatprove_standard".Floating
  use import real.RealInfix
  use export "ada__model_th".Floating_Point_Theory

  type t

  (* This module will be cloned and round_real_tmp possibly replaced.
     We keep round_real to denote the resulting rounding function. *)

  function round_real_tmp real : real
  function round_real (x : real) : real = round_real_tmp (x)

  function attr__ATTRIBUTE_FIRST  : real

  function attr__ATTRIBUTE_LAST  : real

  (* The first and last value of the floating-point type are exactly
     represented. So round_real is the identity on such values. *)

  axiom representable_first :
    round_real attr__ATTRIBUTE_FIRST = attr__ATTRIBUTE_FIRST

  axiom representable_last :
    round_real attr__ATTRIBUTE_LAST = attr__ATTRIBUTE_LAST

  predicate in_range  (x : real) =
   ( attr__ATTRIBUTE_FIRST <=. x <=. attr__ATTRIBUTE_LAST )

  function to_real t : real

  function of_real real : t

  val of_real (x : real) : t
    requires { true }
    ensures  { to_real (result) = x }

  val range_check_ (n : real)  :real
    requires { in_range n }
    ensures { result = n }

  predicate eq  (x : t) (y : t) = (to_real x = to_real y)

  axiom range_axiom :
    forall x  : t.  in_range (to_real x)

  axiom coerce_axiom :
    forall x  : real [to_real (of_real x) | in_range x, of_real x].
      in_range x -> to_real (of_real x) = x

  axiom inversion_axiom :
    forall x : t [to_real x].
      of_real ( to_real(x) ) = x

  function attr__ATTRIBUTE_IMAGE real : __image

  predicate attr__ATTRIBUTE_VALUE__pre_check (x : __image)

  function attr__ATTRIBUTE_VALUE __image : real

  val attr__ATTRIBUTE_VALUE_ (x : __image) : real
    requires { attr__ATTRIBUTE_VALUE__pre_check x }
    ensures { true }

 function dummy :t
end

module IEEE_Floating_Point_32
  use import "_gnatprove_standard".Main
  use import ieee754.Single_RNE

  type t

  function attr__ATTRIBUTE_FIRST : real
  function attr__ATTRIBUTE_LAST  : real

  function to_float t : single
  function of_float single : t

  function of_real (x: real) : single       = from_real x
  function ieee_to_real (x : single) : real = to_real x

  function int_to_ieee (x: int) : single   = from_int x
  function ieee_to_int (x : single) : int  = to_int x

  predicate in_range  (x : single) =
   ( fp_leq (of_real attr__ATTRIBUTE_FIRST) x /\
     fp_leq x (of_real attr__ATTRIBUTE_LAST) )

  val of_float (x : single) : t
    requires { true }
    ensures  { to_float (result) = x }

  val range_check_ (n : single) : single
    requires { in_range n }
    ensures { result = n }

  predicate eq (x : t) (y : t) = fp_eq (to_float x) (to_float y)

  axiom range_axiom :
    forall x  : t.  in_range (to_float x)

  axiom coerce_axiom :
    forall x  : single [to_float (of_float x) | in_range x, of_float x].
      in_range x -> to_float (of_float x) = x

  axiom inversion_axiom :
    forall x : t [to_float x].
      of_float ( to_float(x) ) = x

  function attr__ATTRIBUTE_IMAGE single : __image

  predicate attr__ATTRIBUTE_VALUE__pre_check (x : __image)

  function attr__ATTRIBUTE_VALUE __image : single

  val attr__ATTRIBUTE_VALUE_ (x : __image) : single
    requires { attr__ATTRIBUTE_VALUE__pre_check x }
    ensures { true }

  function dummy : t

  function div_float (x : single) (y : single) : single = fp_div x y

  val div_float_ (x:single) (y:single) : single
    requires { not fp_eq y fp_constant_zero }
    ensures { result = div_float x y }

end

module IEEE_Floating_Point_64
  use import "_gnatprove_standard".Main
  use import ieee754.Double_RNE

  type t

  function attr__ATTRIBUTE_FIRST : real
  function attr__ATTRIBUTE_LAST  : real

  function to_float t : double
  function of_float double : t

  function of_real (x: real) : double       = from_real x
  function ieee_to_real (x : double) : real = to_real x

  predicate in_range  (x : double) =
   ( fp_leq (of_real attr__ATTRIBUTE_FIRST) x /\
     fp_leq x (of_real attr__ATTRIBUTE_LAST) )

  val of_float (x : double) : t
    requires { true }
    ensures  { to_float (result) = x }

  val range_check_ (n : double) : double
    requires { in_range n }
    ensures { result = n }

  predicate eq (x : t) (y : t) = fp_eq (to_float x) (to_float y)

  axiom range_axiom :
    forall x  : t.  in_range (to_float x)

  axiom coerce_axiom :
    forall x  : double [to_float (of_float x) | in_range x, of_float x].
      in_range x -> to_float (of_float x) = x

  axiom inversion_axiom :
    forall x : t [to_float x].
      of_float ( to_float(x) ) = x

  function attr__ATTRIBUTE_IMAGE double : __image

  predicate attr__ATTRIBUTE_VALUE__pre_check (x : __image)

  function attr__ATTRIBUTE_VALUE __image : double

  val attr__ATTRIBUTE_VALUE_ (x : __image) : double
    requires { attr__ATTRIBUTE_VALUE__pre_check x }
    ensures { true }

  function dummy : t

  function div_float (x : double) (y : double) : double = fp_div x y

  val div_float_ (x:double) (y:double) : double
    requires { not fp_eq y fp_constant_zero }
    ensures { result = div_float x y }

end


(* The following modules are templates for unconstrained and constrained array
types. Only the one for one dimension is commented, the others are very similar *)

(* ??? TBD Index types of arrays are treated in a special way, but there is no
reason for that: something similar could be the basis for all
scalar types. To be done. *)

module Index_Type
  (* This is the module for an index type of an unconstrained array. first
  and last are always in the base type, but when first <= last, then they are
  actually in the index subtype. *)

  use import int.Int

  (* These are filled in for every instance of an index type *)
  type base

  function to_int base : int
  predicate in_range_base int
  predicate in_range int

  (* the index type itself *)
  type t

  (* first and last of an index *)
  function first t : base

  function last t : base

  (* constructing and deconstructing the index *)
  function mk int int : t

  axiom range_axiom_first :
    forall a : t [first a].
      to_int (first a) <= to_int (last a) ->
        in_range (to_int (first a))

  axiom range_axiom_last :
    forall a : t [last a].
      to_int (first a) <= to_int (last a) ->
        in_range (to_int (last a))

  axiom mk_def :
    forall f l : int [mk f l].
      in_range_base f ->
      in_range_base l ->
      (f <= l -> (in_range f /\ in_range l))
        ->
        to_int (first (mk f l)) = f /\
        to_int (last (mk f l)) = l

  (* The range check that is required by conversion to an unconstrained array.
     See RM 3.6.2(4-6) and 4.6(38) *)
  predicate range_check (low : int) (high : int) =
    in_range_base low /\ in_range_base high /\
       (high >= low -> (in_range low /\ in_range high))

end

module Unconstr_Array
  (* The module to be cloned for an unconstrained array of dimension 1 *)

  use import int.Int
  use "_gnatprove_standard".Array__1

  (* These declarations have to be filled in by gnat2why for each
  unconstrained array type *)
  type component_type

  type base_type
  function to_int base_type : int
  predicate in_range_base int
  predicate in_range int

  clone Index_Type as I1 with
    type      base          = base_type,
    function  to_int        = to_int,
    predicate in_range_base = in_range_base,
    predicate in_range      = in_range


  (* An unconstrained array comes with its bounds *)
  type __t =
    { elts : (Array__1.map component_type); rt : I1.t }

  function to_array (a : __t) : (Array__1.map component_type) = a.elts

  function of_array (a : Array__1.map component_type) (f l : int) : __t =
    { elts = a; rt = I1.mk f l }

  function attr__ATTRIBUTE_FIRST (a : __t) : int = to_int (I1.first a.rt)
  function attr__ATTRIBUTE_LAST (a : __t) : int = to_int (I1.last a.rt)
  function attr__ATTRIBUTE_LENGTH (a : __t) : int =
    if attr__ATTRIBUTE_FIRST a <= attr__ATTRIBUTE_LAST a then
      attr__ATTRIBUTE_LAST a - attr__ATTRIBUTE_FIRST a + 1 else 0

  predicate range_check (f1 l1 : int) =
    I1.range_check f1 l1

  function dummy : __t
end


module Unconstr_Array_2
  (* The module to be cloned for an unconstrained array of dimension 1 *)

  use import int.Int
  use "_gnatprove_standard".Array__2

  type component_type

  type base_type
  function to_int base_type : int
  predicate in_range_base int
  predicate in_range int

  type base_type_2
  function to_int_2 base_type_2 : int
  predicate in_range_base_2 int
  predicate in_range_2 int

  clone Index_Type as I1 with
    type      base          = base_type,
    function  to_int        = to_int,
    predicate in_range_base = in_range_base,
    predicate in_range      = in_range

  clone Index_Type as I2 with
    type      base          = base_type_2,
    function  to_int        = to_int_2,
    predicate in_range_base = in_range_base_2,
    predicate in_range      = in_range_2

  type __t =
    { elts     : Array__2.map component_type;
      rt       : I1.t;
      rt_2     : I2.t
    }

  function to_array (a : __t) : (Array__2.map component_type) =
    a.elts

  function of_array (a : Array__2.map component_type)
    (f l f2 l2 : int) : __t =
    { elts = a;
      rt = I1.mk f l;
      rt_2 = I2.mk f2 l2 }

  function attr__ATTRIBUTE_FIRST (a : __t) : int = to_int (I1.first a.rt)
  function attr__ATTRIBUTE_LAST (a : __t) : int = to_int (I1.last a.rt)
  function attr__ATTRIBUTE_LENGTH (a : __t) : int =
    if attr__ATTRIBUTE_FIRST a <= attr__ATTRIBUTE_LAST a then
      attr__ATTRIBUTE_LAST a - attr__ATTRIBUTE_FIRST a + 1 else 0

  function attr__ATTRIBUTE_FIRST_2 (a : __t) : int = to_int_2 (I2.first a.rt_2)
  function attr__ATTRIBUTE_LAST_2 (a : __t) : int = to_int_2 (I2.last a.rt_2)
  function attr__ATTRIBUTE_LENGTH_2 (a : __t) : int =
    if attr__ATTRIBUTE_FIRST_2 a <= attr__ATTRIBUTE_LAST_2 a then
      attr__ATTRIBUTE_LAST_2 a - attr__ATTRIBUTE_FIRST_2 a + 1 else 0

  predicate range_check (f1 l1 f2 l2 : int) =
    I1.range_check f1 l1 /\ I2.range_check f2 l2

  function dummy : __t
end

module Unconstr_Array_3
  (* The module to be cloned for an unconstrained array of dimension 1 *)

  use import int.Int
  use "_gnatprove_standard".Array__3

  type component_type

  type base_type
  function to_int base_type : int
  predicate in_range_base int
  predicate in_range int

  type base_type_2
  function to_int_2 base_type_2 : int
  predicate in_range_base_2 int
  predicate in_range_2 int

  type base_type_3
  function to_int_3 base_type_3 : int
  predicate in_range_base_3 int
  predicate in_range_3 int


  clone Index_Type as I1 with
    type      base          = base_type,
    function  to_int        = to_int,
    predicate in_range_base = in_range_base,
    predicate in_range      = in_range

  clone Index_Type as I2 with
    type      base          = base_type_2,
    function  to_int        = to_int_2,
    predicate in_range_base = in_range_base_2,
    predicate in_range      = in_range_2

  clone Index_Type as I3 with
    type      base          = base_type_3,
    function  to_int        = to_int_3,
    predicate in_range_base = in_range_base_3,
    predicate in_range      = in_range_3

  type __t =
    { elts     : Array__3.map component_type;
      rt       : I1.t;
      rt_2     : I2.t;
      rt_3     : I3.t
    }

  function to_array (a : __t) : (Array__3.map component_type) =
    a.elts

  function of_array (a : Array__3.map component_type)
    (f l f2 l2 f3 l3 : int) : __t =
    { elts = a;
      rt = I1.mk f l;
      rt_2 = I2.mk f2 l2;
      rt_3 = I3.mk f3 l3
    }

  function attr__ATTRIBUTE_FIRST (a : __t) : int = to_int (I1.first a.rt)
  function attr__ATTRIBUTE_LAST (a : __t) : int = to_int (I1.last a.rt)
  function attr__ATTRIBUTE_LENGTH (a : __t) : int =
    if attr__ATTRIBUTE_FIRST a <= attr__ATTRIBUTE_LAST a then
      attr__ATTRIBUTE_LAST a - attr__ATTRIBUTE_FIRST a + 1 else 0

  function attr__ATTRIBUTE_FIRST_2 (a : __t) : int = to_int_2 (I2.first a.rt_2)
  function attr__ATTRIBUTE_LAST_2 (a : __t) : int = to_int_2 (I2.last a.rt_2)
  function attr__ATTRIBUTE_LENGTH_2 (a : __t) : int =
    if attr__ATTRIBUTE_FIRST_2 a <= attr__ATTRIBUTE_LAST_2 a then
      attr__ATTRIBUTE_LAST_2 a - attr__ATTRIBUTE_FIRST_2 a + 1 else 0

  function attr__ATTRIBUTE_FIRST_3 (a : __t) : int = to_int_3 (I3.first a.rt_3)
  function attr__ATTRIBUTE_LAST_3 (a : __t) : int = to_int_3 (I3.last a.rt_3)
  function attr__ATTRIBUTE_LENGTH_3 (a : __t) : int =
    if attr__ATTRIBUTE_FIRST_3 a <= attr__ATTRIBUTE_LAST_3 a then
      attr__ATTRIBUTE_LAST_3 a - attr__ATTRIBUTE_FIRST_3 a + 1 else 0

  predicate range_check (f1 l1 f2 l2 f3 l3 : int) =
    I1.range_check f1 l1 /\ I2.range_check f2 l2 /\ I3.range_check f3 l3

  function dummy : __t
end

module Unconstr_Array_4
  (* The module to be cloned for an unconstrained array of dimension 1 *)

  use import int.Int
  use "_gnatprove_standard".Array__4

  type component_type

  type base_type
  function to_int base_type : int
  predicate in_range_base int
  predicate in_range int

  type base_type_2
  function to_int_2 base_type_2 : int
  predicate in_range_base_2 int
  predicate in_range_2 int

  type base_type_3
  function to_int_3 base_type_3 : int
  predicate in_range_base_3 int
  predicate in_range_3 int

  type base_type_4
  function to_int_4 base_type_4 : int
  predicate in_range_base_4 int
  predicate in_range_4 int


  clone Index_Type as I1 with
    type      base          = base_type,
    function  to_int        = to_int,
    predicate in_range_base = in_range_base,
    predicate in_range      = in_range

  clone Index_Type as I2 with
    type      base          = base_type_2,
    function  to_int        = to_int_2,
    predicate in_range_base = in_range_base_2,
    predicate in_range      = in_range_2

  clone Index_Type as I3 with
    type      base          = base_type_3,
    function  to_int        = to_int_3,
    predicate in_range_base = in_range_base_3,
    predicate in_range      = in_range_3

  clone Index_Type as I4 with
    type      base          = base_type_4,
    function  to_int        = to_int_4,
    predicate in_range_base = in_range_base_4,
    predicate in_range      = in_range_4

  type __t =
    { elts     : Array__4.map component_type;
      rt       : I1.t;
      rt_2     : I2.t;
      rt_3     : I3.t;
      rt_4     : I4.t
    }

  function to_array (a : __t) : (Array__4.map component_type) =
    a.elts

  function of_array (a : Array__4.map component_type)
    (f l f2 l2 f3 l3 f4 l4 : int) : __t =
    { elts = a;
      rt = I1.mk f l;
      rt_2 = I2.mk f2 l2;
      rt_3 = I3.mk f3 l3;
      rt_4 = I4.mk f4 l4
    }

  function attr__ATTRIBUTE_FIRST (a : __t) : int = to_int (I1.first a.rt)
  function attr__ATTRIBUTE_LAST (a : __t) : int = to_int (I1.last a.rt)
  function attr__ATTRIBUTE_LENGTH (a : __t) : int =
    if attr__ATTRIBUTE_FIRST a <= attr__ATTRIBUTE_LAST a then
      attr__ATTRIBUTE_LAST a - attr__ATTRIBUTE_FIRST a + 1 else 0

  function attr__ATTRIBUTE_FIRST_2 (a : __t) : int = to_int_2 (I2.first a.rt_2)
  function attr__ATTRIBUTE_LAST_2 (a : __t) : int = to_int_2 (I2.last a.rt_2)
  function attr__ATTRIBUTE_LENGTH_2 (a : __t) : int =
    if attr__ATTRIBUTE_FIRST_2 a <= attr__ATTRIBUTE_LAST_2 a then
      attr__ATTRIBUTE_LAST_2 a - attr__ATTRIBUTE_FIRST_2 a + 1 else 0

  function attr__ATTRIBUTE_FIRST_3 (a : __t) : int = to_int_3 (I3.first a.rt_3)
  function attr__ATTRIBUTE_LAST_3 (a : __t) : int = to_int_3 (I3.last a.rt_3)
  function attr__ATTRIBUTE_LENGTH_3 (a : __t) : int =
    if attr__ATTRIBUTE_FIRST_3 a <= attr__ATTRIBUTE_LAST_3 a then
      attr__ATTRIBUTE_LAST_3 a - attr__ATTRIBUTE_FIRST_3 a + 1 else 0

  function attr__ATTRIBUTE_FIRST_4 (a : __t) : int = to_int_4 (I4.first a.rt_4)
  function attr__ATTRIBUTE_LAST_4 (a : __t) : int = to_int_4 (I4.last a.rt_4)
  function attr__ATTRIBUTE_LENGTH_4 (a : __t) : int =
    if attr__ATTRIBUTE_FIRST_4 a <= attr__ATTRIBUTE_LAST_4 a then
      attr__ATTRIBUTE_LAST_4 a - attr__ATTRIBUTE_FIRST_4 a + 1 else 0

  predicate range_check (f1 l1 f2 l2 f3 l3 f4 l4 : int) =
    I1.range_check f1 l1 /\ I2.range_check f2 l2 /\
    I3.range_check f3 l3 /\ I4.range_check f4 l4

  function dummy : __t
end

module Constr_Array
  use import int.Int
  use "_gnatprove_standard".Array__1

  type component_type

  function attr__ATTRIBUTE_FIRST : int
  function attr__ATTRIBUTE_LAST  : int

  type __t = Array__1.map component_type

  function to_array  (a : __t) : Array__1.map component_type = a

  function of_array  (a : Array__1.map component_type) : __t = a

  function dummy : __t

end

module Constr_Array_2
  use import int.Int
  use "_gnatprove_standard".Array__2

  type component_type

  function attr__ATTRIBUTE_FIRST : int
  function attr__ATTRIBUTE_LAST  : int

  function attr__ATTRIBUTE_FIRST_2 : int
  function attr__ATTRIBUTE_LAST_2  : int

  type __t = Array__2.map component_type

  function to_array  (a : __t) : Array__2.map component_type = a

  function of_array  (a : Array__2.map component_type) : __t = a

  function dummy : __t
end

module Constr_Array_3
  use import int.Int
  use "_gnatprove_standard".Array__3

  type component_type

  function attr__ATTRIBUTE_FIRST : int
  function attr__ATTRIBUTE_LAST  : int

  function attr__ATTRIBUTE_FIRST_2 : int
  function attr__ATTRIBUTE_LAST_2  : int

  function attr__ATTRIBUTE_FIRST_3 : int
  function attr__ATTRIBUTE_LAST_3  : int

  type __t = Array__3.map component_type

  function to_array  (a : __t) : Array__3.map component_type = a

  function of_array  (a : Array__3.map component_type) : __t = a

  function dummy : __t
end

module Constr_Array_4
  use import int.Int
  use "_gnatprove_standard".Array__4

  type component_type

  function attr__ATTRIBUTE_FIRST : int
  function attr__ATTRIBUTE_LAST  : int

  function attr__ATTRIBUTE_FIRST_2 : int
  function attr__ATTRIBUTE_LAST_2  : int

  function attr__ATTRIBUTE_FIRST_3 : int
  function attr__ATTRIBUTE_LAST_3  : int

  function attr__ATTRIBUTE_FIRST_4 : int
  function attr__ATTRIBUTE_LAST_4  : int

  type __t = Array__4.map component_type

  function to_array  (a : __t) : Array__4.map component_type = a

  function of_array  (a : Array__4.map component_type) : __t = a

  function dummy : __t
end

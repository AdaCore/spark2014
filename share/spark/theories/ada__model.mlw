module Discrete_Base
  (* The module that is used as basis for all discrete types. It contains the
    whole discrete theory, except the coerce_axiom which differs between
    modular and non-modular types, and range-related functions and axioms which
    differ between "static" and "dynamic" discrete types. *)

  use import int.Int
  use import "_gnatprove_standard".Main
  use        "_gnatprove_standard".Integer

  use export "ada__model_th".Discrete_Base_Theory

  type t "bounded_type"

  function attr__ATTRIBUTE_IMAGE int : __image

  predicate attr__ATTRIBUTE_VALUE__pre_check (x : __image)

  function attr__ATTRIBUTE_VALUE __image : int

  val attr__ATTRIBUTE_VALUE_ (x : __image) : int
    requires { attr__ATTRIBUTE_VALUE__pre_check x }
    ensures { true }

  function to_int "bounded_type" t : int

  function of_int "bounded_type" int : t

  val of_int (x : int) : t
    requires { true }
    ensures { to_int(result) = x }

  function user_eq  (x : t) (y : t) : bool

  axiom inversion_axiom "bounded_type" :
    forall x : t [to_int x].
    of_int (to_int (x)) = x

  function dummy : t
end

module Static_Discrete_Base
  (* The module that is used as basis for all "static" discrete types.
     It contains the whole discrete theory, except the coerce_axiom which
     differs between modular and non-modular types. "Static" here means that
     Why only sees a static version of the type, with constants for the bounds,
     even though this might correspond to dynamic types in Ada. *)

  use import int.Int

  clone export Discrete_Base

  function first : int

  function last : int

  val check_not_last (n : int) : int
    requires { n <> last }
    ensures { result = n }

  val check_not_first (n : int) : int
    requires { n <> first }
    ensures { result = n }

  predicate in_range "bounded_type" (x : int)

  val range_check_ (n : int) : int
    requires { in_range n }
    ensures { result = n }

  axiom range_axiom "bounded_type" :
    forall x : t. in_range (to_int x)

  predicate dynamic_property "inline" (f l x : int) = in_range x
end

module Static_Discrete
  use import int.Int
  clone export Static_Discrete_Base

  axiom coerce_axiom "bounded_type" :
    forall x  : int [to_int (of_int x)].
      in_range x -> to_int (of_int x) = x
end

module Static_Modular
  clone export Static_Discrete_Base
  use _gnatprove_standard.Int_Division

  function attr__ATTRIBUTE_MODULUS : int
  axiom coerce_axiom :
    forall x  : int [to_int (of_int x)].
      let y = Int_Division.math_mod x attr__ATTRIBUTE_MODULUS in
       in_range y -> to_int (of_int x) = y
end

module Dynamic_Discrete
 use import "int".Int

 type base

 function to_int_base base : int
 function of_int_base int : base

 function to_int "inline" (x : base) : int = to_int_base (x)
 function of_int "inline" (x : int) : base = of_int_base (x)

 predicate dynamic_property (first : int) (last : int) (x : int) =
    first <= x /\ x <= last

 function dummy : base
end

module Dynamic_Modular
  use import int.Int
  use import ref.Ref
  clone export Discrete_Base
  use _gnatprove_standard.Int_Division

  (* left uninterpreted, used for unconstrained arrays based on this index range *)
  predicate in_range "bounded_type" (x : int)

  val first : ref int

  val last : ref int

  function attr__ATTRIBUTE_MODULUS : int

  axiom coerce_axiom "bounded_type" :
    forall x  : int [to_int (of_int x)].
      to_int (of_int x) = Int_Division.math_mod x attr__ATTRIBUTE_MODULUS

  predicate dynamic_property "inline" (f l x : int) = in_range x
end

module Fixed_Point_Base
  (* The module that is used as basis for all fixed-point types.
     We only support currently a subset of all Ada fixed-point types and
     fixed-point operations:
     1. fixed-point types must have a small that is a negative power of 2 or 10
     2. multiplication and division between different fixed-point types and
        universal real are rejected

    (restriction 1 allows to have a simple axiomatization of mult/div of fixed
    point types, using the integral inverse of the small. restriction 2 avoids
    introducing a new uninterpreted operation for every triple of argument and
    result type)

    These restrictions enforce in particular that the result of all
    multiplication and division operations on fixed-pints (with both fixed-point
    arguments, or an integer argument) is in the "perfect result set" as defined
    in Ada RM G.2.3: the result is either exact, or one of the two representable
    values that are closest to the exact result. This property is axiomatized
    below.

    We use a type "__fixed" that is an alias of "int", to avoid confusion, for
    the internal integer representation of a fixed-point value. This type is
    used for performing all operations. In particular, addition, subtraction,
    comparisons, Succ and Pred are directly operating on this type. Literals
    are also expressed in this type. Multiplication and division are axiomatized
    to reflect the constraints of Ada RM G.2.3.
  *)

  use import int.Int
  use import real.RealInfix
  use import "_gnatprove_standard".Main
  use import "_gnatprove_standard".Int_Division

  type t

  function dummy : t

  function attr__ATTRIBUTE_IMAGE __fixed : __image

  predicate attr__ATTRIBUTE_VALUE__pre_check (x : __image)

  function attr__ATTRIBUTE_VALUE __image : __fixed

  val attr__ATTRIBUTE_VALUE_ (x : __image) : __fixed
    requires { attr__ATTRIBUTE_VALUE__pre_check x }
    ensures { true }

  (* A fixed-point type is represented internally as an integer. *)

  function to_fixed t : __fixed

  function of_fixed __fixed : t

  val of_fixed (x : __fixed) : t
    requires { true }
    ensures { to_fixed(result) = x }

  (* Inverse of the "small" value of the corresponding fixed-point type.
     This is guaranteed to be a positive whole number, because we restrict
     gnatprove analysis to fixed-point types with a "small" that is a negative
     power of 2 or 10.

     The real value of a fixed-point number can be obtained by dividing its
     integer representation by inv_small.
   *)
  function inv_small : __fixed

  function user_eq  (x : t) (y : t) : bool

  axiom inversion_axiom :
    forall x : t [to_fixed x].
    of_fixed (to_fixed (x)) = x

  (* Helper predicate to define the result of operations on fixed-points.
     It is used with non-negative values for [num] and positive values for [den].
     It expresses that [res] is either the result of the integer division
     num/den when exact, or one of the two closest integers.
  *)

  predicate pos_div_relation (res : int) (num : int) (den : int) =
    let exact = div num den in
    (* case 1: special case for zero *)
    if num = 0 then
      res = 0
    (* case 2: RM G.2.3(9,13) if the result is exact, that's it *)
    else if num = exact * den then
      res = exact
    (* case 3: RM G.2.3(10,14/3) if the result is not exact, that's one of
       the closest integers. *)
    else
      exact <= res <= exact + 1

  (* multiplication between two fixed-point values
     case 1:
         If any argument is zero, the result is zero
     case 2:
         If both arguments are of the same sign, then the mathematical
         result is either exact, or between exact and exact+1, which are the
         possible results.

         for example, with inv_small = 4:
              x =  5, y =  3, exact = 3, math = 3.75, result in { 3, 4 }
              x = -5, y = -3, exact = 3, math = 3.75, result in { 3, 4 }
     case 3:
         If arguments are of opposite signs, then the mathematical
         result is either exact, or between exact-1 and exact, which are the
         possible results.

         for example, with inv_small = 4:
              x =  5, y = -3, exact = -3, math = -3.75, result in { -4, -3 }
              x = -5, y =  3, exact = -3, math = -3.75, result in { -4, -3 }
  *)

  function fxp_mult (x : __fixed) (y : __fixed) : __fixed

  axiom fxp_mult_def :
    forall x : __fixed. forall y : __fixed [fxp_mult x y].
      if x = 0 \/ y = 0 then
        fxp_mult x y = 0
      else if (x > 0 /\ y > 0) \/ (x < 0 /\ y < 0) then
        pos_div_relation (fxp_mult x y) (x * y) inv_small
      else (* (x < 0 /\ y > 0) \/ (x > 0 /\ y < 0) *)
        pos_div_relation (- (fxp_mult x y)) (- (x * y)) inv_small

  (* division between two fixed-point values
     case 1:
         If the dividand is zero, then the result is zero.
     case 2:
         If both arguments are of the same sign, then the mathematical
         result is either exact, or between exact and exact+1, which are the
         possible results.

         for example, with inv_small = 4:
              x =  5, y =  3, exact = 6, math = 6.666.., result in { 6, 7 }
              x = -5, y = -3, exact = 6, math = 6.666.., result in { 6, 7 }
     case 3:
         If arguments are of opposite signs, then the mathematical
         result is either exact, or between exact-1 and exact, which are the
         possible results.

         for example, with inv_small = 4:
              x = -5, y =  3, exact = -6, math = -6.666.., result in { -7, -6 }
              x =  5, y = -3, exact = -6, math = -6.666.., result in { -7, -6 }
  *)

  function fxp_div (x : __fixed) (y : __fixed) : __fixed

  val fxp_div_ (x : __fixed) (y : __fixed) : __fixed
     requires { y<>0 }
     ensures { result = fxp_div x y }

  axiom fxp_div_def :
    forall x : __fixed. forall y : __fixed [fxp_div x y].
      if x = 0 then
        fxp_div x y = 0
      else if x > 0 /\ y > 0 then
        pos_div_relation (fxp_div x y) (x * inv_small) y
      else if x < 0 /\ y < 0 then
        pos_div_relation (fxp_div x y) (-x * inv_small) (-y)
      else if x < 0 /\ y > 0 then
        pos_div_relation (- (fxp_div x y)) (-x * inv_small) y
      else if x > 0 /\ y < 0 then
        pos_div_relation (- (fxp_div x y)) (x * inv_small) (-y)
      else (* y = 0 *)
        true

  (* multiplication between a fixed-point value and an integer *)

  function fxp_mult_int (x : __fixed) (y : int) : __fixed = x * y

  (* division between a fixed-point value and an integer
     case 1:
         If the dividant is zero, then the result is zero.
     case 2:
         If both arguments are of the same sign, then the mathematical
         result is either exact, or between exact and exact+1, which are the
         possible results.

         for example:
              x =  5, y =  3, exact = 1, math = 1.666.., result in { 1, 2 }
              x = -5, y = -3, exact = 1, math = 1.666.., result in { 1, 2 }
     case 3:
         If arguments are of opposite signs, then the mathematical
         result is either exact, or between exact-1 and exact, which are the
         possible results.

         for example:
              x = -5, y =  3, exact = -1, math = -1.666.., result in { -2, -1 }
              x =  5, y = -3, exact = -1, math = -1.666.., result in { -2, -1 }
  *)

  function fxp_div_int (x : __fixed) (y : int) : __fixed

  val fxp_div_int_ (x : __fixed) (y : int) : __fixed
     requires { y<>0 }
     ensures { result = fxp_div_int x y }

  axiom fxp_div_int_def :
    forall x : __fixed. forall y : int [fxp_div_int x y].
      if x = 0 then
        fxp_div_int x y = 0
      else if x > 0 /\ y > 0 then
        pos_div_relation (fxp_div_int x y) x y
      else if x < 0 /\ y < 0 then
        pos_div_relation (fxp_div_int x y) (-x) (-y)
      else if x < 0 /\ y > 0 then
        pos_div_relation (- (fxp_div_int x y)) (-x) y
      else if x > 0 /\ y < 0 then
        pos_div_relation (- (fxp_div_int x y)) x (-y)
      else (* y = 0 *)
        true

  (* conversion functions to/from int. 3 cases for the conversion to int:
     case 1:
         If the argument is zero, then the result is zero.
     case 2:
         If the argument is positive, then the mathematical result is either
         exact, or between exact and exact+1, which are the possible results.

         for example, with inv_small = 4:
              x = 5, exact = 1, math = 1.25, result in { 1, 2 }
     case 3:
         If the argument is negative, then the mathematical result is either
         exact, or between exact-1 and exact, which are the possible results.

         for example, with inv_small = 4:
              x = -5, exact = -1, math = -1.25, result in { -2, -1 }
  *)

  function to_int (x : __fixed) : int

  function of_int (x : int) : __fixed = x * inv_small

  axiom to_int_def :
    forall x : __fixed [to_int x].
      if x = 0 then
        to_int x = 0
      else if x > 0 then
        pos_div_relation (to_int x) x inv_small
      else (* x < 0 *)
        pos_div_relation (- (to_int x)) (-x) inv_small

  (* conversion functions from/to real *)

  function to_real __fixed : real

  function of_real real : __fixed

end

module Static_Fixed_Point
  (* The module that is used as basis for all "static" fixed-point types.
     "Static" here means that Why only sees a static version of the type,
     with constants for the bounds, even though this might correspond to
     dynamic types in Ada. *)

  use import "_gnatprove_standard".Main
  use import int.Int

  clone export Fixed_Point_Base

  function first : __fixed

  function last : __fixed

  val check_not_last (n : __fixed) : __fixed
    requires { n <> last }
    ensures { result = n }

  val check_not_first (n : __fixed) : __fixed
    requires { n <> first }
    ensures { result = n }

  predicate in_range (x : __fixed)

  val range_check_ (n : __fixed) : __fixed
    requires { in_range n }
    ensures { result = n }

  axiom range_axiom :
    forall x : t. in_range (to_fixed x)
end

module Dynamic_Fixed_Point
  (* The module that is used as basis for all "dynamic" fixed-point types.
     "Dynamic" here means that Why sees a dynamic version of the type, with
     references for the bounds, which correspond to some cases of dynamic
     types in Ada. *)

  use import "_gnatprove_standard".Main
  use import int.Int
  use import ref.Ref

  clone export Fixed_Point_Base

  val first : ref __fixed

  val last : ref __fixed
end

module Floating_Point_Base
  (* The module that is used as basis for all floating-point types. *)

  use import "_gnatprove_standard".Main
  use        "_gnatprove_standard".Floating
  use import real.RealInfix
  use export "ada__model_th".Floating_Point_Theory

  type t

  (* This module will be cloned and round_real_tmp possibly replaced.
     We keep round_real to denote the resulting rounding function. *)

  function round_real_tmp real : real
  function round_real (x : real) : real = round_real_tmp (x)

  function to_real t : real

  function of_real real : t

  val of_real (x : real) : t
    requires { true }
    ensures  { to_real (result) = x }

  function user_eq  (x : t) (y : t) : bool

  axiom inversion_axiom :
    forall x : t [to_real x].
      of_real (to_real(x)) = x

  (* Next and previous representable reals. The functions return respectively
     the representable real greater than or lower than the argument x, which
     may or not be representable. *)

  function next_representable (x : real) : real
  function prev_representable (x : real) : real

  axiom next_representable_def :
    forall x : real [next_representable x]. next_representable x >. x

  axiom prev_representable_def :
    forall x : real [prev_representable x]. prev_representable x <. x

  function attr__ATTRIBUTE_IMAGE real : __image

  predicate attr__ATTRIBUTE_VALUE__pre_check (x : __image)

  function attr__ATTRIBUTE_VALUE __image : real

  val attr__ATTRIBUTE_VALUE_ (x : __image) : real
    requires { attr__ATTRIBUTE_VALUE__pre_check x }
    ensures { true }

  function dummy :t
end

module Static_Floating_Point
  (* The module that is used as basis for all "static" floating-point types. *)

  use import real.RealInfix
  clone export Floating_Point_Base

  function first  : real

  function last  : real

  (* The first and last value of the floating-point type are exactly
     represented. So round_real is the identity on such values. *)

  axiom representable_first :
    round_real first = first

  axiom representable_last :
    round_real last = last

  val check_not_last (n : real) : real
    requires { n <> last }
    ensures { result = n }

  val check_not_first (n : real) : real
    requires { n <> first }
    ensures { result = n }

  predicate in_range  (x : real)

  val range_check_ (n : real)  :real
    requires { in_range n }
    ensures { result = n }

  axiom range_axiom :
    forall x : t. in_range (to_real x)
end

module Dynamic_Floating_Point
  (* The module that is used as basis for all "dynamic" floating-point types. *)

  use import ref.Ref
  clone export Floating_Point_Base

  val first : ref real

  val last  : ref real
end

module Unconstrained_Private_Type
  (* The module that is used as basis for unconstrained subtypes or derived types
 of  a private type from a module with External_Axiomatization. *)

   type t

   function to_base "inline" (x : t) : t = x
   function of_base "inline" (x : t) : t = x
 end

module Constrained_Private_Type
  (* The module that is used as basis for constrained subtypes or derived types
 of  a private type from a module with External_Axiomatization. *)

   type t
   type base_type

   function to_base t : base_type
   function of_base base_type : t

   axiom inversion_axiom:
      forall x : t [of_base (to_base x)]. of_base (to_base x) = x
 end

(* The following modules are templates for unconstrained and constrained array
types. Only the one for one dimension is commented, the others are very similar *)

(* ??? TBD Index types of arrays are treated in a special way, but there is no
reason for that: something similar could be the basis for all
scalar types. To be done. *)

module Index_Type
  (* This is the module for an index type of an unconstrained array. first
  and last are always in the base type, but when first <= last, then they are
  actually in the index subtype. *)

  use import int.Int

  (* These are filled in for every instance of an index type *)
  type base

  function to_int base : int
  predicate in_range_base int
  predicate index_dynamic_property int int int

  (* the index type itself *)
  type t

  (* first and last of an index *)
  function first t : base

  function last t : base

  (* constructing and deconstructing the index *)
  function mk int int : t

  axiom mk_def :
    forall f l : int [mk f l].
      in_range_base f ->
      in_range_base l ->
      (to_int (first (mk f l)) = f /\
        to_int (last (mk f l)) = l)

  (* The range check that is required by conversion to an unconstrained array.
     See RM 3.6.2(4-6) and 4.6(38) *)
  predicate dynamic_property (range_first : int) (range_last : int) (low : int) (high : int) =
    in_range_base low /\ in_range_base high /\
       (high >= low -> (index_dynamic_property range_first range_last low /\ index_dynamic_property range_first range_last high))

end

module Array_Comparison_Axiom
  use import int.Int
  use "_gnatprove_standard".Array__1

  (* These declarations have to be filled in by gnat2why for each
  discrete 1 dimension array type *)
  type component_type

   function to_int component_type : int

   axiom compare_def :
    forall a b : Array__1.map component_type.
    forall a_first a_last b_first b_last : int [Array__1.compare a a_first a_last b b_first b_last].
      (Array__1.compare a a_first a_last b b_first b_last = 0 <->
          Array__1.bool_eq a a_first a_last b b_first b_last = True) /\
      (Array__1.compare a a_first a_last b b_first b_last < 0 <->
         exists i j : int. i <= a_last /\ j < b_last /\
             (Array__1.bool_eq a a_first  i b b_first j = True /\
             (i = a_last \/
                   i < a_last /\
                       to_int (Array__1.get a (i + 1)) < to_int (Array__1.get b (j + 1))))) /\
      (Array__1.compare a a_first a_last b b_first b_last > 0 <->
         exists i j : int. i <= b_last /\ j < a_last /\
             (Array__1.bool_eq a a_first j b b_first i = True /\
             (i = b_last \/ i < b_last /\
                       to_int (Array__1.get a (j + 1)) > to_int (Array__1.get b (i + 1)))))

end

module Array_Generic_Op_Axiom
  use import int.Int
  use "_gnatprove_standard".Array__1

  type component_type

   function to_bool component_type : bool
   function array_op (Array__1.map component_type) int int (Array__1.map component_type) int int : Array__1.map component_type
   function base_op bool bool : bool

   axiom op_def:
    forall a b : Array__1.map component_type.
    forall a_first a_last b_first b_last : int.
    forall i : int [Array__1.get (array_op a a_first a_last b b_first b_last) i].
      a_first <= i <= a_last ->
      to_bool (Array__1.get (array_op a a_first a_last b b_first b_last) i) =
             base_op (to_bool (Array__1.get a i)) (to_bool (Array__1.get b (i - a_first + b_first)))
end

module Array_Logical_Op_Generic_Axioms
  use import bool.Bool
  use import int.Int
  use "_gnatprove_standard".Array__1

  (* These declarations have to be filled in by gnat2why for each
       boolean 1 dimension array type *)
   type component_type
   function to_bool component_type : bool

   clone Array_Generic_Op_Axiom as Or_Axiom with
     type component_type = component_type,
     function to_bool = to_bool,
     function array_op = Array__1.orb,
     function base_op = orb

   clone Array_Generic_Op_Axiom as And_Axiom with
     type component_type = component_type,
     function to_bool = to_bool,
     function array_op = Array__1.andb,
     function base_op = andb

   clone Array_Generic_Op_Axiom as Xor_Axiom with
     type component_type = component_type,
     function to_bool = to_bool,
     function array_op = Array__1.xorb,
     function base_op = xorb

   axiom notb_def:
    forall a : Array__1.map component_type.
    forall a_first a_last : int.
    forall i : int [Array__1.get (Array__1.notb a a_first a_last) i].
      a_first <= i <= a_last ->
      to_bool (Array__1.get (Array__1.notb a a_first a_last) i) =
             notb (to_bool (Array__1.get a i))
end

module Standard_Array_Logical_Op_Axioms
  use import bool.Bool

  function bool_id "inline" (b : bool) : bool = b

  clone Array_Logical_Op_Generic_Axioms with
     type component_type = bool,
     function to_bool = bool_id
end

module Subtype_Array_Logical_Op_Axioms
  use import int.Int
  use "_gnatprove_standard".Boolean

   type component_type
   function to_int component_type : int

  function to_bool "inline" (x : component_type) : bool = Boolean.of_int (to_int (x))

  clone Array_Logical_Op_Generic_Axioms with
     type component_type = component_type,
     function to_bool = to_bool
end

module Unconstr_Array
  (* The module to be cloned for an unconstrained array of dimension 1 *)

  use import int.Int
  use "_gnatprove_standard".Array__1

  (* These declarations have to be filled in by gnat2why for each
  unconstrained array type *)
  type component_type

  type base_type
  function to_int base_type : int
  predicate in_range_base int
  predicate index_dynamic_property int int int

  clone Index_Type as I1 with
    type      base          = base_type,
    function  to_int        = to_int,
    predicate in_range_base = in_range_base,
    predicate index_dynamic_property  = index_dynamic_property

  type __split = Array__1.map component_type

  (* An unconstrained array comes with its bounds *)
  type __t =
    { elts : __split; rt : I1.t }

  function to_array (a : __t) : __split = a.elts

  function of_array (a : __split) (f l : int) : __t =
    { elts = a; rt = I1.mk f l }

  function first (a : __t) : int = to_int (I1.first a.rt)
  function last (a : __t) : int = to_int (I1.last a.rt)
  function length (a : __t) : int =
    if first a <= last a then
      last a - first a + 1 else 0

  predicate dynamic_property (range_first range_last f1 l1 : int) =
    I1.dynamic_property range_first range_last f1 l1

  function bool_eq (x : __t) (y : __t) : bool =
    Array__1.bool_eq
      x.elts (to_int (I1.first x.rt)) (to_int (I1.last x.rt))
      y.elts (to_int (I1.first y.rt)) (to_int (I1.last y.rt))

  function user_eq (x : __t) (y : __t) : bool

  function dummy : __t
end

module Unconstr_Array_2
  (* The module to be cloned for an unconstrained array of dimension 1 *)

  use import int.Int
  use "_gnatprove_standard".Array__2

  type component_type

  type base_type
  function to_int base_type : int
  predicate in_range_base int
  predicate index_dynamic_property int int int

  type base_type_2
  function to_int_2 base_type_2 : int
  predicate in_range_base_2 int
  predicate index_dynamic_property_2 int int int

  clone Index_Type as I1 with
    type      base          = base_type,
    function  to_int        = to_int,
    predicate in_range_base = in_range_base,
    predicate index_dynamic_property      = index_dynamic_property

  clone Index_Type as I2 with
    type      base          = base_type_2,
    function  to_int        = to_int_2,
    predicate in_range_base = in_range_base_2,
    predicate index_dynamic_property      = index_dynamic_property_2

  type __split = Array__2.map component_type
  type __t =
    { elts     : __split;
      rt       : I1.t;
      rt_2     : I2.t
    }

  function to_array (a : __t) : __split =
    a.elts

  function of_array (a : __split)
    (f l f2 l2 : int) : __t =
    { elts = a;
      rt = I1.mk f l;
      rt_2 = I2.mk f2 l2 }

  function first (a : __t) : int = to_int (I1.first a.rt)
  function last (a : __t) : int = to_int (I1.last a.rt)
  function length (a : __t) : int =
    if first a <= last a then
      last a - first a + 1 else 0

  function first_2 (a : __t) : int = to_int_2 (I2.first a.rt_2)
  function last_2 (a : __t) : int = to_int_2 (I2.last a.rt_2)
  function length_2 (a : __t) : int =
    if first_2 a <= last_2 a then
      last_2 a - first_2 a + 1 else 0

  predicate dynamic_property (range_first1 range_last1 f1 l1 range_first2 range_last2 f2 l2 : int) =
    I1.dynamic_property range_first1 range_last1 f1 l1 /\ I2.dynamic_property range_first2 range_last2 f2 l2

  function user_eq (x : __t) (y : __t) : bool
  function bool_eq (x : __t) (y : __t) : bool =
    Array__2.bool_eq
      x.elts (to_int (I1.first x.rt)) (to_int (I1.last x.rt))
             (to_int_2 (I2.first x.rt_2)) (to_int_2 (I2.last x.rt_2))
      y.elts (to_int (I1.first y.rt)) (to_int (I1.last y.rt))
             (to_int_2 (I2.first y.rt_2)) (to_int_2 (I2.last y.rt_2))

  function dummy : __t
end

module Unconstr_Array_3
  (* The module to be cloned for an unconstrained array of dimension 1 *)

  use import int.Int
  use "_gnatprove_standard".Array__3

  type component_type

  type base_type
  function to_int base_type : int
  predicate in_range_base int
  predicate index_dynamic_property int int int

  type base_type_2
  function to_int_2 base_type_2 : int
  predicate in_range_base_2 int
  predicate index_dynamic_property_2 int int int

  type base_type_3
  function to_int_3 base_type_3 : int
  predicate in_range_base_3 int
  predicate index_dynamic_property_3 int int int


  clone Index_Type as I1 with
    type      base          = base_type,
    function  to_int        = to_int,
    predicate in_range_base = in_range_base,
    predicate index_dynamic_property      = index_dynamic_property

  clone Index_Type as I2 with
    type      base          = base_type_2,
    function  to_int        = to_int_2,
    predicate in_range_base = in_range_base_2,
    predicate index_dynamic_property      = index_dynamic_property_2

  clone Index_Type as I3 with
    type      base          = base_type_3,
    function  to_int        = to_int_3,
    predicate in_range_base = in_range_base_3,
    predicate index_dynamic_property      = index_dynamic_property_3

  type __split = Array__3.map component_type
  type __t =
    { elts     : __split;
      rt       : I1.t;
      rt_2     : I2.t;
      rt_3     : I3.t
    }

  function to_array (a : __t) : __split =
    a.elts

  function of_array (a : __split)
    (f l f2 l2 f3 l3 : int) : __t =
    { elts = a;
      rt = I1.mk f l;
      rt_2 = I2.mk f2 l2;
      rt_3 = I3.mk f3 l3
    }

  function first (a : __t) : int = to_int (I1.first a.rt)
  function last (a : __t) : int = to_int (I1.last a.rt)
  function length (a : __t) : int =
    if first a <= last a then
      last a - first a + 1 else 0

  function first_2 (a : __t) : int = to_int_2 (I2.first a.rt_2)
  function last_2 (a : __t) : int = to_int_2 (I2.last a.rt_2)
  function length_2 (a : __t) : int =
    if first_2 a <= last_2 a then
      last_2 a - first_2 a + 1 else 0

  function first_3 (a : __t) : int = to_int_3 (I3.first a.rt_3)
  function last_3 (a : __t) : int = to_int_3 (I3.last a.rt_3)
  function length_3 (a : __t) : int =
    if first_3 a <= last_3 a then
      last_3 a - first_3 a + 1 else 0

  predicate dynamic_property (range_first1 range_last1 f1 l1 range_first2 range_last2 f2 l2 range_first3 range_last3 f3 l3 : int) =
    I1.dynamic_property range_first1 range_last1 f1 l1 /\ I2.dynamic_property range_first2 range_last2 f2 l2 /\ I3.dynamic_property range_first3 range_last3 f3 l3

  function user_eq (x : __t) (y : __t) : bool

  function bool_eq (x : __t) (y : __t) : bool =
    Array__3.bool_eq
      x.elts (to_int (I1.first x.rt))   (to_int (I1.last x.rt))
             (to_int_2 (I2.first x.rt_2)) (to_int_2 (I2.last x.rt_2))
             (to_int_3 (I3.first x.rt_3)) (to_int_3 (I3.last x.rt_3))
      y.elts (to_int (I1.first y.rt))   (to_int (I1.last y.rt))
             (to_int_2 (I2.first y.rt_2)) (to_int_2 (I2.last y.rt_2))
             (to_int_3 (I3.first y.rt_3)) (to_int_3 (I3.last y.rt_3))

  function dummy : __t
end

module Unconstr_Array_4
  (* The module to be cloned for an unconstrained array of dimension 1 *)

  use import int.Int
  use "_gnatprove_standard".Array__4

  type component_type

  type base_type
  function to_int base_type : int
  predicate in_range_base int
  predicate index_dynamic_property int int int

  type base_type_2
  function to_int_2 base_type_2 : int
  predicate in_range_base_2 int
  predicate index_dynamic_property_2 int int int

  type base_type_3
  function to_int_3 base_type_3 : int
  predicate in_range_base_3 int
  predicate index_dynamic_property_3 int int int

  type base_type_4
  function to_int_4 base_type_4 : int
  predicate in_range_base_4 int
  predicate index_dynamic_property_4 int int int


  clone Index_Type as I1 with
    type      base          = base_type,
    function  to_int        = to_int,
    predicate in_range_base = in_range_base,
    predicate index_dynamic_property      = index_dynamic_property

  clone Index_Type as I2 with
    type      base          = base_type_2,
    function  to_int        = to_int_2,
    predicate in_range_base = in_range_base_2,
    predicate index_dynamic_property      = index_dynamic_property_2

  clone Index_Type as I3 with
    type      base          = base_type_3,
    function  to_int        = to_int_3,
    predicate in_range_base = in_range_base_3,
    predicate index_dynamic_property      = index_dynamic_property_3

  clone Index_Type as I4 with
    type      base          = base_type_4,
    function  to_int        = to_int_4,
    predicate in_range_base = in_range_base_4,
    predicate index_dynamic_property      = index_dynamic_property_4

  type __split = Array__4.map component_type

  type __t =
    { elts     : __split;
      rt       : I1.t;
      rt_2     : I2.t;
      rt_3     : I3.t;
      rt_4     : I4.t
    }

  function to_array (a : __t) : __split =
    a.elts

  function of_array (a : __split)
    (f l f2 l2 f3 l3 f4 l4 : int) : __t =
    { elts = a;
      rt = I1.mk f l;
      rt_2 = I2.mk f2 l2;
      rt_3 = I3.mk f3 l3;
      rt_4 = I4.mk f4 l4
    }

  function first (a : __t) : int = to_int (I1.first a.rt)
  function last (a : __t) : int = to_int (I1.last a.rt)
  function length (a : __t) : int =
    if first a <= last a then
      last a - first a + 1 else 0

  function first_2 (a : __t) : int = to_int_2 (I2.first a.rt_2)
  function last_2 (a : __t) : int = to_int_2 (I2.last a.rt_2)
  function length_2 (a : __t) : int =
    if first_2 a <= last_2 a then
      last_2 a - first_2 a + 1 else 0

  function first_3 (a : __t) : int = to_int_3 (I3.first a.rt_3)
  function last_3 (a : __t) : int = to_int_3 (I3.last a.rt_3)
  function length_3 (a : __t) : int =
    if first_3 a <= last_3 a then
      last_3 a - first_3 a + 1 else 0

  function first_4 (a : __t) : int = to_int_4 (I4.first a.rt_4)
  function last_4 (a : __t) : int = to_int_4 (I4.last a.rt_4)
  function length_4 (a : __t) : int =
    if first_4 a <= last_4 a then
      last_4 a - first_4 a + 1 else 0

  predicate dynamic_property (range_first1 range_last1 f1 l1 range_first2 range_last2 f2 l2 range_first3 range_last3 f3 l3 range_first4 range_last4 f4 l4 : int) =
    I1.dynamic_property range_first1 range_last1 f1 l1 /\ I2.dynamic_property range_first2 range_last2 f2 l2 /\
    I3.dynamic_property range_first3 range_last3 f3 l3 /\ I4.dynamic_property range_first4 range_last4 f4 l4

  function user_eq (x : __t) (y : __t) : bool

  function bool_eq (x : __t) (y : __t) : bool =
    Array__4.bool_eq
      x.elts (to_int (I1.first x.rt))   (to_int (I1.last x.rt))
             (to_int_2 (I2.first x.rt_2)) (to_int_2 (I2.last x.rt_2))
             (to_int_3 (I3.first x.rt_3)) (to_int_3 (I3.last x.rt_3))
             (to_int_4 (I4.first x.rt_4)) (to_int_4 (I4.last x.rt_4))
      y.elts (to_int (I1.first y.rt))   (to_int (I1.last y.rt))
             (to_int_2 (I2.first y.rt_2)) (to_int_2 (I2.last y.rt_2))
             (to_int_3 (I3.first y.rt_3)) (to_int_3 (I3.last y.rt_3))
             (to_int_4 (I4.first y.rt_4)) (to_int_4 (I4.last y.rt_4))

  function dummy : __t
end

module Constr_Array
  use import int.Int
  use "_gnatprove_standard".Array__1

  type component_type

  function first : int
  function last  : int

  type __t = Array__1.map component_type

  function to_array  (a : __t) : Array__1.map component_type = a

  function of_array  (a : Array__1.map component_type) : __t = a

  function dummy : __t

  function attr__size : int

  function user_eq (x : __t) (y : __t) : bool
  function bool_eq (x : __t) (y : __t) : bool =
    Array__1.bool_eq x first last
                     y first last
end

module Constr_Array_2
  use import int.Int
  use "_gnatprove_standard".Array__2

  type component_type

  function first : int
  function last  : int

  function first_2 : int
  function last_2  : int

  type __t = Array__2.map component_type

  function to_array  (a : __t) : Array__2.map component_type = a

  function of_array  (a : Array__2.map component_type) : __t = a

  function dummy : __t

  function attr__size : int

  function user_eq (x : __t) (y : __t) : bool
  function bool_eq (x : __t) (y : __t) : bool =
    Array__2.bool_eq x first last first_2 last_2
                     y first last first_2 last_2
end

module Constr_Array_3
  use import int.Int
  use "_gnatprove_standard".Array__3

  type component_type

  function first : int
  function last  : int

  function first_2 : int
  function last_2  : int

  function first_3 : int
  function last_3  : int

  type __t = Array__3.map component_type

  function to_array  (a : __t) : Array__3.map component_type = a

  function of_array  (a : Array__3.map component_type) : __t = a

  function dummy : __t

  function attr__size : int

  function user_eq (x : __t) (y : __t) : bool
  function bool_eq (x : __t) (y : __t) : bool =
    Array__3.bool_eq x first last first_2 last_2 first_3 last_3
                     y first last first_2 last_2 first_3 last_3
end

module Constr_Array_4
  use import int.Int
  use "_gnatprove_standard".Array__4

  type component_type

  function first : int
  function last  : int

  function first_2 : int
  function last_2  : int

  function first_3 : int
  function last_3  : int

  function first_4 : int
  function last_4  : int

  type __t = Array__4.map component_type

  function to_array  (a : __t) : Array__4.map component_type = a

  function of_array  (a : Array__4.map component_type) : __t = a

  function dummy : __t

  function attr__size : int

  function user_eq (x : __t) (y : __t) : bool
  function bool_eq (x : __t) (y : __t) : bool =
    Array__4.bool_eq x first last first_2 last_2 first_3 last_3 first_4 last_4
                     y first last first_2 last_2 first_3 last_3 first_4 last_4
end

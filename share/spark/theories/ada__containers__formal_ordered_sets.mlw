module Ada__containers__formal_ordered_sets__witness
  use import real.Real
  use "ada__containers__formal_ordered_sets__args".Ada__containers__formal_ordered_sets__element_type
  use "ada__containers__formal_ordered_sets__args".Ada__containers__formal_ordered_sets__olt

  function witness Ada__containers__formal_ordered_sets__element_type.base_type : real

  axiom olt_witness :
    (forall k1  k2 : Ada__containers__formal_ordered_sets__element_type.base_type [Ada__containers__formal_ordered_sets__olt.olt k1 k2].
	Real.(<) (witness k1) (witness k2) <-> Ada__containers__formal_ordered_sets__olt.olt k1 k2 = True)
end

module Ada__containers__formal_ordered_sets__set
  use import int.Int
  use import "_gnatprove_standard".Main
  use Ada__containers__hash_type
  use Ada__containers__count_type

  type __split_discrs = {rec__capacity : Ada__containers__count_type.count_type}

  type __split_fields = { rec__main__ : __private }

  type set = { __split_discrs : __split_discrs; __split_fields : __split_fields }

  predicate set_inv "inline" (l : set) =
     l = { __split_discrs = { rec__capacity = l.__split_discrs.rec__capacity }; __split_fields = { rec__main__ = l.__split_fields.rec__main__ } }

   function capacity  (co : set) : int =
          Ada__containers__count_type.to_rep (rec__capacity (__split_discrs co))

  function bool_eq set set : bool
  function user_eq set set : bool
end

module Ada__containers__formal_ordered_sets__length
  use import int.Int
  use import "_gnatprove_standard".Main
  use Ada__containers__count_type
  use import Ada__containers__formal_ordered_sets__set

  function length__logic set : int

  function length_ "inline" (co : set) : int =
    length__logic co

  axiom length_range:
    forall co:set [length__logic co]. 0 <= length_ co <= capacity co

  val length (co : set) : int
     ensures { result = length__logic co }
end

module Ada__containers__formal_ordered_sets__cursor
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_ordered_sets__args".Ada__containers__formal_ordered_sets__element_type
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length

  type __split_fields = { rec__main__ : __private }

  type cursor = { __split_fields : __split_fields }

  function dummy : cursor

  function position set cursor : int

  function position_inv set int : cursor

  axiom position_gte_zero:
    forall co:set, cu:cursor [position co cu].
        length_ co >= position co cu >= 0

  axiom position_eq1:
   forall co:set, i :int [position co (position_inv co i)]. 0 < i <= length_ co ->
              position co (position_inv co i) = i

  axiom position_eq2:
    forall co:set, cu:cursor [position co cu].
          position co cu > 0 -> position_inv co (position co cu) = cu

  function bool_eq "inline" (c1:cursor) (c2:cursor) : bool = c1 = c2
  function user_eq cursor cursor : bool
end

module Ada__containers__formal_ordered_sets__no_element
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor

  function no_element : cursor

  axiom position_no_element:
    forall co:set [position co no_element]. position co no_element = 0
end

module Ada__containers__formal_ordered_sets__empty_set
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length

  function empty_set : set

  axiom Empty_is_empty: length_ empty_set = 0
end

module Ada__containers__formal_ordered_sets__is_empty
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length

  function is_empty__logic set : bool

  axiom is_empty:
    forall co:set [is_empty__logic (co)].
          is_empty__logic (co) = True <-> length_ co = 0

  val is_empty (co:set) : bool
     ensures  { result = is_empty__logic co }
end

module Ada__containers__formal_ordered_sets__element
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_ordered_sets__args".Ada__containers__formal_ordered_sets__element_type
  use import Ada__containers__formal_ordered_sets__witness
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor

  function element__logic set cursor : Ada__containers__formal_ordered_sets__element_type.base_type

  axiom element__range:
   forall co:set, cu:cursor. Ada__containers__formal_ordered_sets__element_type.valid (element__logic co cu)

  axiom ordered:
    forall s:set, cu1 cu2:cursor [element__logic s cu2, element__logic s cu1].
       position s cu1 > 0 -> position s cu2 > 0 ->
         (position s cu1 > position s cu2 <-> Real.(>) (witness (element__logic s cu1)) (witness (element__logic s cu2)))

  val element (co:set) (cu:cursor) : Ada__containers__formal_ordered_sets__element_type.base_type
     requires { position co cu > 0 }
     ensures  { result = element__logic co cu }
end

module Ada__containers__formal_ordered_sets__previous
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__no_element

  function previous__logic set cursor : cursor

  axiom previous_in:
    forall co:set, cu:cursor [previous__logic co cu].
	(position co cu > 1 \/ position co (previous__logic co cu) > 0) ->
	position co (previous__logic co cu) = position co cu - 1

  axiom previous_ext:
    forall co:set, cu:cursor [previous__logic co cu].
        (position co cu = 1 \/ cu = no_element) -> previous__logic co cu = no_element

  val previous (co:set) (cu:cursor) : cursor
     requires { cu = no_element \/ position co cu > 0 }
     ensures  { result = previous__logic co cu }
end

module Ada__containers__formal_ordered_sets__previous__2
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__no_element
  use import Ada__containers__formal_ordered_sets__previous

  val previous__2 (co:set) (cu:ref cursor) : unit
     requires { !cu = no_element \/ position co !cu > 0 }
     writes     { cu }
     reads      { cu }
     ensures  { !cu = previous__logic co (old !cu) }
end

module Ada__containers__formal_ordered_sets__next
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__no_element

  function next__logic set cursor : cursor

  axiom next_in:
    forall co:set, cu:cursor [next__logic co cu].
	(length_ co > position co cu > 0 \/ position co (next__logic co cu) > 0) ->
	position co (next__logic co cu) = position co cu + 1

  axiom next_ext:
    forall co:set, cu:cursor [next__logic co cu].
        (position co cu = length_ co \/ cu = no_element) -> next__logic co cu = no_element

  val next (co:set) (cu:cursor) : cursor
     requires { cu = no_element \/ position co cu > 0 }
     ensures  { result = next__logic co cu }
end

module Ada__containers__formal_ordered_sets__next__2
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__no_element
  use import Ada__containers__formal_ordered_sets__next

  val next__2 (co:set) (cu:ref cursor) : unit
     requires { !cu = no_element \/ position co !cu > 0 }
     writes     { cu }
     reads      { cu }
     ensures  { !cu = next__logic co (old !cu) }
end

module Ada__containers__formal_ordered_sets__last
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__no_element

  function last__logic set : cursor

  axiom last_empty:
    forall co:set [last__logic co]. length_ co = 0 <-> last__logic co = no_element

  axiom last_gen:
    forall co:set [last__logic co]. length_ co = position co (last__logic co)

  val last (co:set) : cursor
     ensures  { result = last__logic co }
end

module Ada__containers__formal_ordered_sets__first
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__no_element

  function first__logic set : cursor

  axiom first_empty:
    forall co:set [first__logic co]. length_ co = 0 <-> first__logic co = no_element

  axiom first_gen:
    forall co:set [first__logic co]. length_ co > 0 -> position co (first__logic co) = 1

  val first (co:set) : cursor
     ensures  { result = first__logic co }
end

module Ada__containers__formal_ordered_sets__first_element
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_ordered_sets__args".Ada__containers__formal_ordered_sets__element_type
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__first
  use import Ada__containers__formal_ordered_sets__element

  function first_element__logic (co:set) : Ada__containers__formal_ordered_sets__element_type.base_type = element__logic co (first__logic co)

  val first_element (co:set) : Ada__containers__formal_ordered_sets__element_type.base_type
     requires { length_ co > 0 }
     ensures  { result = element__logic co (first__logic co) }
end

module Ada__containers__formal_ordered_sets__last_element
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_ordered_sets__args".Ada__containers__formal_ordered_sets__element_type
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__last
  use import Ada__containers__formal_ordered_sets__element

  function last_element__logic (co:set) : Ada__containers__formal_ordered_sets__element_type.base_type = element__logic co (last__logic co)

  val last_element (co:set) : Ada__containers__formal_ordered_sets__element_type.base_type
     requires { length_ co > 0 }
     ensures  { result = element__logic co (last__logic co) }
end

module Ada__containers__formal_ordered_sets__find
  use import int.Int
  use import "_gnatprove_standard".Main
  use  "ada__containers__formal_ordered_sets__args".Ada__containers__formal_ordered_sets__element_type
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__witness
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__no_element
  use import Ada__containers__formal_ordered_sets__element

  function find_ set real : cursor

  predicate find__ (co : set) (i : real) (cu : cursor) =
    (cu = (no_element  : cursor) /\
      (forall cun:cursor.
        position co cun >  0 ->
         witness (element__logic co cun) <> i)) \/
     (position co cu > 0 /\
      witness (element__logic co cu) = i)

  axiom Find_find_val:
    (forall co:set.
      (forall i:real.
        ((find__ co i (find_ co i)) /\
         ((length_ co = 0) -> (find_ co i = no_element )))))

  function find__logic "inline" (co : set) (e:Ada__containers__formal_ordered_sets__element_type.base_type) : cursor =
  find_ co (witness e)

  val find (co:set) (e:Ada__containers__formal_ordered_sets__element_type.base_type)  : cursor
     ensures  { result = find__logic co e }
end

module Ada__containers__formal_ordered_sets__ceiling
  use import int.Int
  use import "_gnatprove_standard".Main
  use  "ada__containers__formal_ordered_sets__args".Ada__containers__formal_ordered_sets__element_type
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__witness
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__no_element
  use import Ada__containers__formal_ordered_sets__last
  use import Ada__containers__formal_ordered_sets__element

  function ceiling_ set real : cursor

  predicate is_ceiling (s : set) (i : real) (cu : cursor) =
     (cu = no_element  /\
       (length_ s = 0 \/ length_ s > 0 /\
        Real.(>) i (witness (element__logic s (last__logic s))))) \/
      (position s cu > 0 /\
       Real.(<=) i (witness (element__logic s cu)) /\
	(forall cun : cursor [element__logic s cun]. 0 < position s cun < position s cu
	 -> Real.(>) i (witness (element__logic s cun))))

  axiom ceiling_is_ceiling:
    forall s:set.
      forall i:real [(ceiling_ s i : cursor)].
        is_ceiling s i (ceiling_ s i : cursor)

  function ceiling__logic  "inline" (co:set) (e:Ada__containers__formal_ordered_sets__element_type.base_type) : cursor =
 ceiling_ co (witness e)

  val ceiling (co:set) (e:Ada__containers__formal_ordered_sets__element_type.base_type) :cursor
     ensures { result = ceiling_ co (witness e) }
end

module Ada__containers__formal_ordered_sets__floor
  use import int.Int
  use import "_gnatprove_standard".Main
  use  "ada__containers__formal_ordered_sets__args".Ada__containers__formal_ordered_sets__element_type
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__witness
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__no_element
  use import Ada__containers__formal_ordered_sets__first
  use import Ada__containers__formal_ordered_sets__element

  function floor_ set real : cursor

  predicate is_floor (s : set) (i : real) (cu : cursor) =
     (cu = no_element  /\
       (length_ s = 0 \/ length_ s > 0 /\
         Real.(<) i (witness (element__logic s (first__logic s))))) \/
      (position s cu > 0 /\
       Real.(>=) i (witness (element__logic s cu)) /\
	(forall cun : cursor. position s cu < position s cun
	 ->  Real.(<) i (witness (element__logic s cun))))

  axiom floor_is_floor:
    (forall s:set.
      (forall i:real [(floor_ s i : cursor)].
        (is_floor s i (floor_ s i : cursor))))

  function floor__logic  "inline" (co:set) (e:Ada__containers__formal_ordered_sets__element_type.base_type) : cursor =
 floor_ co (witness e)

  val floor (co:set) (e:Ada__containers__formal_ordered_sets__element_type.base_type) :cursor
     ensures { result = floor_ co (witness e) }
end

module Ada__containers__formal_ordered_sets__first_to_previous
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_sets__witness
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__no_element
  use import Ada__containers__formal_ordered_sets__element
  use import Ada__containers__formal_ordered_sets__find

  function first_to_previous__logic set cursor : set

  axiom first_to_previous_no_element:
    forall co:set [first_to_previous__logic co no_element]. first_to_previous__logic co no_element = co

  axiom first_to_previous_length_:
    forall co:set, cu:cursor [first_to_previous__logic co cu].
	position co cu > 0 -> length_ (first_to_previous__logic co cu) = position co cu - 1

  axiom first_to_previous_position_in:
    forall co:set, cu cun:cursor [position (first_to_previous__logic co cu) cun | first_to_previous__logic co cu, position co cun].
	(position (first_to_previous__logic co cu) cun > 0 \/ position co cun < position co cu) ->
	position (first_to_previous__logic co cu) cun = position co cun

  axiom first_to_previous_position_ext:
    forall co:set, cu cun:cursor [position (first_to_previous__logic co cu) cun].
	position co cun >= position co cu > 0 ->
	position (first_to_previous__logic co cu) cun = 0

  axiom first_to_previous_element:
    forall co:set, cu cun:cursor [element__logic (first_to_previous__logic co cu) cun | first_to_previous__logic co cu, element__logic co cun].
	(position (first_to_previous__logic co cu) cun > 0 \/ 0 < position co cun < position co cu) ->
	element__logic (first_to_previous__logic co cu) cun = element__logic co cun

  axiom first_to_previous_find :
    forall co:set, cu:cursor, w:real [find_ co w, first_to_previous__logic co cu|
     find_ (first_to_previous__logic co cu) w].
     ((position co cu > position co (find_ co w) > 0 \/
      position (first_to_previous__logic co cu) (find_ (first_to_previous__logic co cu) w) > 0) ->
      find_ co w = find_ (first_to_previous__logic co cu) w) /\
      (position co (find_ co w) >= position co cu -> find_ (first_to_previous__logic co cu) w = no_element)

  axiom first_to_previous_find_elt :
    forall co:set, cu:cursor, w:real [element__logic co cu, find_ co w, first_to_previous__logic co cu|
     element__logic co cu, find_ (first_to_previous__logic co cu) w].
     (Real.(>) (witness (element__logic co cu)) w  ->
      find_ co w = find_ (first_to_previous__logic co cu) w) /\
     (Real.(<=) (witness (element__logic co cu)) w  ->
      find_ (first_to_previous__logic co cu) w = no_element)

  val first_to_previous (co:set) (cu:cursor) : set
     requires { cu = no_element \/ position co cu > 0 }
     ensures  { result = first_to_previous__logic co cu /\ set_inv result }
end

module Ada__containers__formal_ordered_sets__current_to_last
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_sets__witness
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__empty_set
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__no_element
  use import Ada__containers__formal_ordered_sets__element
  use import Ada__containers__formal_ordered_sets__find

  function current_to_last__logic set cursor : set

  axiom current_to_last_no_element:
    forall co:set [current_to_last__logic co no_element]. current_to_last__logic co no_element = empty_set

  axiom current_to_last_length_:
    forall co:set, cu:cursor [length_ (current_to_last__logic co cu) ].
	position co cu > 0 -> length_ (current_to_last__logic co cu) = (length_ co) - (position co cu) + 1

  axiom current_to_last_position_in:
    forall co:set, cu cun:cursor [position (current_to_last__logic co cu) cun | current_to_last__logic co cu, position co cun].
	(position (current_to_last__logic co cu) cun > 0 \/ position co cun >= position co cu > 0) ->
	position (current_to_last__logic co cu) cun = (position co cun) - (position co cu) + 1

  axiom current_to_last_position_ext:
    forall co:set, cu cun:cursor [position (current_to_last__logic co cu) cun].
	position co cun < position co cu -> position (current_to_last__logic co cu) cun = 0

  axiom current_to_last_element:
    forall co:set, cu cun:cursor [element__logic (current_to_last__logic co cu) cun | current_to_last__logic co cu, element__logic co cun].
	(position (current_to_last__logic co cu) cun > 0 \/ 0 < position co cu <= position co cun) ->
	element__logic (current_to_last__logic co cu) cun = element__logic co cun

  axiom current_to_last_find :
    forall co:set, cu:cursor, w:real [find_ (current_to_last__logic co cu) w| current_to_last__logic co cu,
     find_ co w].
     ((0 < position co cu <= position co (find_ co w) \/
      position (current_to_last__logic co cu) (find_ (current_to_last__logic co cu) w) > 0) ->
      find_ co w = find_ (current_to_last__logic co cu) w) /\
      (position co (find_ co w) < position co cu -> find_ (current_to_last__logic co cu) w = no_element)

  axiom current_to_last_find_elt :
    forall co:set, cu:cursor, w:real [element__logic co cu, find_ co w, current_to_last__logic co cu|
     element__logic co cu, find_ (current_to_last__logic co cu) w].
     (Real.(<=) (witness (element__logic co cu)) w  ->
      find_ co w = find_ (current_to_last__logic co cu) w) /\
     (Real.(>) (witness (element__logic co cu)) w  ->
      find_ (current_to_last__logic co cu) w = no_element)

  val current_to_last (co:set) (cu:cursor) : set
     requires { cu = no_element \/ position co cu > 0 }
     ensures  { result = current_to_last__logic co cu /\ set_inv result }
end

module Ada__containers__formal_ordered_sets__replace
  use import int.Int
  use import "_gnatprove_standard".Main
  use  "ada__containers__formal_ordered_sets__args".Ada__containers__formal_ordered_sets__element_type
  use "ada__containers__formal_ordered_sets__args".Ada__containers__formal_ordered_sets__oeq
  use import Ada__containers__formal_ordered_sets__witness
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__empty_set
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__no_element
  use import Ada__containers__formal_ordered_sets__element
  use import Ada__containers__formal_ordered_sets__find

  predicate replace (co1:set) (e:Ada__containers__formal_ordered_sets__element_type.base_type) (co2:set) =
    (position co1 (find_ co1 (witness e)) > 0 /\
      length_ co1 = length_ co2 /\
       Ada__containers__formal_ordered_sets__oeq.oeq (element__logic co2 (find_ co1 (witness e))) e /\
        (forall cun:cursor [position co2 cun | position co1 cun]. position co2 cun = position co1 cun) /\
         (forall cun:cursor [element__logic co2 cun | element__logic co1 cun].
           position co1 cun > 0 /\ not cun = find_ co1 (witness e) ->
            element__logic co2 cun = element__logic co1 cun) /\
          (forall w:real [find_ co1 w | find_ co2 w]. find_ co1 w = find_ co2 w)) /\
     capacity co1 = capacity co2

  val replace (co:ref Ada__containers__formal_ordered_sets__set.__split_fields) (cap : Ada__containers__formal_ordered_sets__set.__split_discrs) (e:Ada__containers__formal_ordered_sets__element_type.base_type) : unit
     requires { let rec_co = {Ada__containers__formal_ordered_sets__set.__split_fields = !co;
                              Ada__containers__formal_ordered_sets__set.__split_discrs = cap}  in
                   find_ rec_co (witness e) <> no_element }
     writes { co }
     reads { co }
     ensures { let rec_co = {Ada__containers__formal_ordered_sets__set.__split_fields = !co;
                              Ada__containers__formal_ordered_sets__set.__split_discrs = cap}  in
               let old_co = {Ada__containers__formal_ordered_sets__set.__split_fields = old !co;
                              Ada__containers__formal_ordered_sets__set.__split_discrs = cap}  in
                   replace old_co e rec_co }
end

module Ada__containers__formal_ordered_sets__replace_element
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_ordered_sets__args".Ada__containers__formal_ordered_sets__element_type
  use "ada__containers__formal_ordered_sets__args".Ada__containers__formal_ordered_sets__oeq
  use import Ada__containers__formal_ordered_sets__witness
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__no_element
  use import Ada__containers__formal_ordered_sets__element
  use import Ada__containers__formal_ordered_sets__find

  predicate replace_element set cursor Ada__containers__formal_ordered_sets__element_type.base_type set

  axiom replace_element_length_:
    forall co1 co2:set, cu:cursor, e:Ada__containers__formal_ordered_sets__element_type.base_type
      [replace_element co1 cu e co2].
      replace_element co1 cu e co2 -> length_ co1 = length_ co2

  axiom replace_element_capacity:
    forall co1 co2:set, cu:cursor, e:Ada__containers__formal_ordered_sets__element_type.base_type
      [replace_element co1 cu e co2, capacity co1|replace_element co1 cu e co2, capacity co2].
      replace_element co1 cu e co2 -> capacity co1 = capacity co2

  axiom replace_element_position:
    forall co1 co2:set, cu cun:cursor, e:Ada__containers__formal_ordered_sets__element_type.base_type
      [replace_element co1 cu e co2, position co2 cun
     | replace_element co1 cu e co2, position co1 cun].
      replace_element co1 cu e co2 -> (position co2 cun > 0 <-> position co1 cun > 0)

  axiom replace_element_element_in:
    forall co1 co2:set, cu:cursor, e:Ada__containers__formal_ordered_sets__element_type.base_type
      [replace_element co1 cu e co2].
      replace_element co1 cu e co2 -> Ada__containers__formal_ordered_sets__oeq.oeq (element__logic co2 cu) e /\ find_ co2 (witness  e) = cu

  axiom replace_element_element_ext:
    forall co1 co2:set, cu cun:cursor, e:Ada__containers__formal_ordered_sets__element_type.base_type
      [replace_element co1 cu e co2, element__logic co2 cun
     | replace_element co1 cu e co2, element__logic co1 cun].
      replace_element co1 cu e co2 -> cu <> cun -> position co1 cun > 0 ->
        element__logic co2 cun = element__logic co1 cun

  axiom replace_element_find:
    forall co1 co2:set, cu:cursor, w:real, e:Ada__containers__formal_ordered_sets__element_type.base_type
      [replace_element co1 cu e co2, find_ co2 w
     | replace_element co1 cu e co2, find_ co1 w].
       replace_element co1 cu e co2 -> not witness e = w ->
       find_ co1 w = find_ co2 w

  val replace_element (co:ref Ada__containers__formal_ordered_sets__set.__split_fields) (cap : Ada__containers__formal_ordered_sets__set.__split_discrs) (cu:cursor) (e:Ada__containers__formal_ordered_sets__element_type.base_type) : unit
     requires { let rec_co = {Ada__containers__formal_ordered_sets__set.__split_fields = !co;
                              Ada__containers__formal_ordered_sets__set.__split_discrs = cap}  in
                   position rec_co cu > 0 /\ (find_ rec_co (witness e) = no_element \/ find_ rec_co (witness e) = cu) }
     writes     { co }
     reads      { co }
     ensures { let rec_co = {Ada__containers__formal_ordered_sets__set.__split_fields = !co;
                              Ada__containers__formal_ordered_sets__set.__split_discrs = cap}  in
               let old_co = {Ada__containers__formal_ordered_sets__set.__split_fields = old !co;
                              Ada__containers__formal_ordered_sets__set.__split_discrs = cap}  in
                   replace_element old_co cu e rec_co }
end

module Ada__containers__formal_ordered_sets__insert
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_ordered_sets__args".Ada__containers__formal_ordered_sets__element_type
  use "ada__containers__formal_ordered_sets__args".Ada__containers__formal_ordered_sets__oeq
  use import Ada__containers__formal_ordered_sets__witness
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__no_element
  use import Ada__containers__formal_ordered_sets__last
  use import Ada__containers__formal_ordered_sets__element
  use import Ada__containers__formal_ordered_sets__find
  use import Ada__containers__formal_ordered_sets__ceiling

  predicate insert set Ada__containers__formal_ordered_sets__element_type.base_type set

  axiom insert_length_:
    forall co1 co2:set,  e:Ada__containers__formal_ordered_sets__element_type.base_type
      [insert co1 e co2].
      insert co1 e co2 -> length_ co1 + 1 = length_ co2 /\ find_ co1 (witness e) = no_element /\ Ada__containers__formal_ordered_sets__oeq.oeq (element__logic co2 (find_ co2 (witness e))) e

  axiom insert_capacity:
    forall co1 co2:set, e:Ada__containers__formal_ordered_sets__element_type.base_type
      [insert co1 e co2, capacity co1|insert co1 e co2, capacity co2].
      insert co1 e co2 -> capacity co1 = capacity co2

  axiom insert_new:
    forall co1 co2:set, e:Ada__containers__formal_ordered_sets__element_type.base_type [insert co1 e co2].
      insert co1 e co2 -> (ceiling_ co1 (witness e) <> no_element ->
      position co2 (find_ co2 (witness e)) = position co1 (ceiling_ co1 (witness e))) /\ (ceiling_ co1 (witness e) = no_element ->
      find_ co2 (witness e) = last__logic co2)

  axiom insert_position_before:
    forall co1 co2:set, cun:cursor, e:Ada__containers__formal_ordered_sets__element_type.base_type
      [insert co1 e co2,  position co1 cun
     | insert co1 e co2,  position co2 cun].
    let i = position co2 (find_ co2 (witness e)) in
      insert co1 e co2 ->
      (i > position co1 cun > 0 \/ position co2 cun < i) ->
        position co1 cun = position co2 cun

  axiom insert_position_after:
    forall co1 co2:set, cun:cursor, e:Ada__containers__formal_ordered_sets__element_type.base_type
      [insert co1 e co2,  position co1 cun
     | insert co1 e co2,  position co2 cun].
    let i = position co2 (find_ co2 (witness e)) in
      insert co1 e co2 ->
      (position co1 cun >= i \/ position co2 cun > i) ->
        position co1 cun + 1 = position co2 cun

  axiom insert_element:
    forall co1 co2:set, cun:cursor, e:Ada__containers__formal_ordered_sets__element_type.base_type
      [insert co1 e co2,  element__logic co1 cun
     | insert co1 e co2,  element__logic co2 cun].
      insert co1 e co2 ->
      (position co1 cun > 0 \/ position co2 cun > 0 /\ find_ co2 (witness e) <> cun) ->
        element__logic co1 cun = element__logic co2 cun

  axiom insert_find :
    forall co1:set, co2:set, w:real, e:Ada__containers__formal_ordered_sets__element_type.base_type
     [insert co1 e co2, find_ co1 w| insert co1 e co2, find_ co2 w].
     insert co1 e co2 -> not witness e = w -> find_ co1 w = find_ co2 w

  val insert (co:ref Ada__containers__formal_ordered_sets__set.__split_fields) (cap : Ada__containers__formal_ordered_sets__set.__split_discrs) (e:Ada__containers__formal_ordered_sets__element_type.base_type)  (p:ref cursor) (inserted : ref bool) : unit
     requires { let rec_co = {Ada__containers__formal_ordered_sets__set.__split_fields = !co;
                              Ada__containers__formal_ordered_sets__set.__split_discrs = cap}  in
                   length_ rec_co < capacity rec_co }
     writes     { co, p, inserted }
     reads      { co }
     ensures { let rec_co = {Ada__containers__formal_ordered_sets__set.__split_fields = !co;
                              Ada__containers__formal_ordered_sets__set.__split_discrs = cap}  in
               let old_co = {Ada__containers__formal_ordered_sets__set.__split_fields = old !co;
                              Ada__containers__formal_ordered_sets__set.__split_discrs = cap}  in
                   (!inserted = True <-> find_ old_co (witness e) = no_element) /\ !p = find_ rec_co (witness e) /\
                          if !inserted = True then (insert old_co e rec_co)
                                                                 else (!co = old !co) }
end

module Ada__containers__formal_ordered_sets__insert__2
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_ordered_sets__args".Ada__containers__formal_ordered_sets__element_type
  use import Ada__containers__formal_ordered_sets__witness
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__no_element
  use import Ada__containers__formal_ordered_sets__insert
  use import Ada__containers__formal_ordered_sets__find

  val insert__2 (co:ref Ada__containers__formal_ordered_sets__set.__split_fields) (cap : Ada__containers__formal_ordered_sets__set.__split_discrs) (e:Ada__containers__formal_ordered_sets__element_type.base_type) : unit
     requires { let rec_co = {Ada__containers__formal_ordered_sets__set.__split_fields = !co;
                              Ada__containers__formal_ordered_sets__set.__split_discrs = cap}  in
                   length_ rec_co < capacity rec_co /\ find_ rec_co (witness e) = no_element }
     writes     { co }
     reads      { co }
     ensures { let rec_co = {Ada__containers__formal_ordered_sets__set.__split_fields = !co;
                              Ada__containers__formal_ordered_sets__set.__split_discrs = cap}  in
               let old_co = {Ada__containers__formal_ordered_sets__set.__split_fields = old !co;
                              Ada__containers__formal_ordered_sets__set.__split_discrs = cap}  in
                   insert old_co e rec_co }
end

module Ada__containers__formal_ordered_sets__delete
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_ordered_sets__args".Ada__containers__formal_ordered_sets__element_type
  use import Ada__containers__formal_ordered_sets__witness
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__no_element
  use import Ada__containers__formal_ordered_sets__next
  use import Ada__containers__formal_ordered_sets__element
  use import Ada__containers__formal_ordered_sets__find

  predicate delete set cursor set

  axiom delete_capacity:
    forall co1 co2:set, cu:cursor
      [delete co1 cu co2, capacity co1|delete co1 cu co2, capacity co2].
      delete co1 cu co2 -> capacity co1 = capacity co2

  axiom delete_length_:
    forall co1 co2:set, cu:cursor
      [delete co1 cu co2].
      delete co1 cu co2 -> length_ co1 = length_ co2 + 1

  axiom delete_position_before:
    forall co1 co2:set, cu cun:cursor
      [delete co1 cu co2,  position co1 cun
     | delete co1 cu co2,  position co2 cun].
      delete co1 cu co2 ->
      (position co1 cu > position co1 cun \/ 0 < position co2 cun < position co1 cu) ->
        position co1 cun = position co2 cun

  axiom delete_position_after:
    forall co1 co2:set, cu cun:cursor
      [delete co1 cu co2,  position co1 cun | delete co1 cu co2,  position co2 cun].
      delete co1 cu co2 ->
      (position co1 cun > position co1 cu \/ position co2 cun >= position co1 cu) ->
        position co1 cun = position co2 cun + 1

  axiom delete_position_range:
    forall co1 co2:set, cu:cursor [delete co1 cu co2].
      delete co1 cu co2 -> position co2 cu = 0 /\ 0 < position co1 cu /\ find_ co2 (witness (element__logic co1 cu)) = no_element

  axiom delete_position_next:
    forall co1 co2:set, cu:cursor [delete co1 cu co2].
      delete co1 cu co2 -> position co1 (next__logic co1 cu) >= 0

  axiom delete_element:
    forall co1 co2:set, cu cun:cursor
      [delete co1 cu co2,  element__logic co1 cun
     | delete co1 cu co2,  element__logic co2 cun].
      delete co1 cu co2 ->
      0 < position co2 cun ->
        element__logic co1 cun = element__logic co2 cun

  axiom delete_find :
    forall co1:set, co2:set, cu:cursor, w:real [delete co1 cu co2,
     find_ co1 w| delete co1 cu co2, find_ co2 w].
     delete co1 cu co2 -> not witness (element__logic co1 cu) = w -> find_ co1 w = find_ co2 w

  val delete (co:ref Ada__containers__formal_ordered_sets__set.__split_fields) (cap : Ada__containers__formal_ordered_sets__set.__split_discrs) (e : Ada__containers__formal_ordered_sets__element_type.base_type) : unit
     requires { let rec_co = {Ada__containers__formal_ordered_sets__set.__split_fields = !co;
                              Ada__containers__formal_ordered_sets__set.__split_discrs = cap}  in
                   find_ rec_co (witness e) <> no_element }
     writes     { co }
     reads      { co }
     ensures { let rec_co = {Ada__containers__formal_ordered_sets__set.__split_fields = !co;
                              Ada__containers__formal_ordered_sets__set.__split_discrs = cap}  in
               let old_co = {Ada__containers__formal_ordered_sets__set.__split_fields = old !co;
                              Ada__containers__formal_ordered_sets__set.__split_discrs = cap}  in
                   delete old_co (find_ old_co (witness e)) rec_co }
end

module Ada__containers__formal_ordered_sets__delete__2
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__no_element
  use import Ada__containers__formal_ordered_sets__delete

  val delete__2 (co:ref Ada__containers__formal_ordered_sets__set.__split_fields) (cap : Ada__containers__formal_ordered_sets__set.__split_discrs) (cu:ref cursor) : unit
     requires { let rec_co = {Ada__containers__formal_ordered_sets__set.__split_fields = !co;
                              Ada__containers__formal_ordered_sets__set.__split_discrs = cap}  in
                   position rec_co !cu > 0 }
     writes     { co, cu }
     reads      { co }
     ensures { let rec_co = {Ada__containers__formal_ordered_sets__set.__split_fields = !co;
                              Ada__containers__formal_ordered_sets__set.__split_discrs = cap}  in
               let old_co = {Ada__containers__formal_ordered_sets__set.__split_fields = old !co;
                              Ada__containers__formal_ordered_sets__set.__split_discrs = cap}  in
                   delete old_co (old !cu) rec_co /\ !cu = no_element}
 end

module Ada__containers__formal_ordered_sets__delete_first
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__no_element
  use import Ada__containers__formal_ordered_sets__first
  use import Ada__containers__formal_ordered_sets__delete

  val delete__first (co:ref Ada__containers__formal_ordered_sets__set.__split_fields) (cap : Ada__containers__formal_ordered_sets__set.__split_discrs) : unit
     writes     { co }
     reads      { co }
     ensures { let rec_co = {Ada__containers__formal_ordered_sets__set.__split_fields = !co;
                              Ada__containers__formal_ordered_sets__set.__split_discrs = cap}  in
               let old_co = {Ada__containers__formal_ordered_sets__set.__split_fields = old !co;
                              Ada__containers__formal_ordered_sets__set.__split_discrs = cap}  in
                   if length_ old_co = 0 then !co = (old !co) else delete old_co (first__logic old_co) rec_co }
 end

module Ada__containers__formal_ordered_sets__delete_last
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__no_element
  use import Ada__containers__formal_ordered_sets__last
  use import Ada__containers__formal_ordered_sets__delete

  val delete__last (co:ref Ada__containers__formal_ordered_sets__set.__split_fields) (cap : Ada__containers__formal_ordered_sets__set.__split_discrs) : unit
     writes     { co }
     reads      { co }
     ensures { let rec_co = {Ada__containers__formal_ordered_sets__set.__split_fields = !co;
                              Ada__containers__formal_ordered_sets__set.__split_discrs = cap}  in
               let old_co = {Ada__containers__formal_ordered_sets__set.__split_fields = old !co;
                              Ada__containers__formal_ordered_sets__set.__split_discrs = cap}  in
                   if length_ old_co = 0 then !co = (old !co) else delete old_co (last__logic old_co) rec_co }
 end

module Ada__containers__formal_ordered_sets__include
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_ordered_sets__args".Ada__containers__formal_ordered_sets__element_type
  use import Ada__containers__formal_ordered_sets__witness
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__no_element
  use import Ada__containers__formal_ordered_sets__replace
  use import Ada__containers__formal_ordered_sets__insert
  use import Ada__containers__formal_ordered_sets__find

  val include (co:ref Ada__containers__formal_ordered_sets__set.__split_fields) (cap : Ada__containers__formal_ordered_sets__set.__split_discrs) (e :Ada__containers__formal_ordered_sets__element_type.base_type) : unit
     requires { let rec_co = {Ada__containers__formal_ordered_sets__set.__split_fields = !co;
                              Ada__containers__formal_ordered_sets__set.__split_discrs = cap}  in
                   length_ rec_co  < capacity rec_co}
     writes     { co }
     reads      { co }
     ensures { let rec_co = {Ada__containers__formal_ordered_sets__set.__split_fields = !co;
                              Ada__containers__formal_ordered_sets__set.__split_discrs = cap}  in
               let old_co = {Ada__containers__formal_ordered_sets__set.__split_fields = old !co;
                              Ada__containers__formal_ordered_sets__set.__split_discrs = cap}  in
                   if find_ old_co (witness e) <> no_element then replace old_co e rec_co
                         else insert old_co e rec_co  }
end

module Ada__containers__formal_ordered_sets__exclude
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_ordered_sets__args".Ada__containers__formal_ordered_sets__element_type
  use import Ada__containers__formal_ordered_sets__witness
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__no_element
  use import Ada__containers__formal_ordered_sets__delete
  use import Ada__containers__formal_ordered_sets__find

  val exclude (co:ref Ada__containers__formal_ordered_sets__set.__split_fields) (cap : Ada__containers__formal_ordered_sets__set.__split_discrs) (e :Ada__containers__formal_ordered_sets__element_type.base_type) : unit
     writes     { co }
     reads      { co }
     ensures { let rec_co = {Ada__containers__formal_ordered_sets__set.__split_fields = !co;
                              Ada__containers__formal_ordered_sets__set.__split_discrs = cap}  in
               let old_co = {Ada__containers__formal_ordered_sets__set.__split_fields = old !co;
                              Ada__containers__formal_ordered_sets__set.__split_discrs = cap}  in
                   if find_ old_co (witness e) = no_element then  old !co = !co
                         else delete old_co (find_ old_co (witness e)) rec_co  }
end

module Ada__containers__formal_ordered_sets__to_set
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_ordered_sets__args".Ada__containers__formal_ordered_sets__element_type
  use "ada__containers__formal_ordered_sets__args".Ada__containers__formal_ordered_sets__oeq
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__first
  use import Ada__containers__formal_ordered_sets__element

  function to_set__logic Ada__containers__formal_ordered_sets__element_type.base_type : set

  axiom to_set__def:
  forall e : Ada__containers__formal_ordered_sets__element_type.base_type [to_set__logic e].
    length_ (to_set__logic e) = 1 /\ Ada__containers__formal_ordered_sets__oeq.oeq (element__logic (to_set__logic e) (first__logic (to_set__logic e))) e

 val  to_set  (e: Ada__containers__formal_ordered_sets__element_type.base_type) : set
     ensures { result = to_set__logic e /\ set_inv result }
end

module Ada__containers__formal_ordered_sets__has_element
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor

  function has_element__logic set cursor : bool

  axiom has_element_pos:
    forall co:set, cu:cursor [has_element__logic co cu].
    has_element__logic co cu = True -> 0 < position co cu

  axiom has_element_neg:
    forall co:set, cu:cursor [has_element__logic co cu].
    has_element__logic co cu <> True -> position co cu = 0

  val has_element (co:set) (cu:cursor) : bool
     ensures { has_element__logic co cu = result }
end

module Ada__containers__formal_ordered_sets__contains
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_ordered_sets__args".Ada__containers__formal_ordered_sets__element_type
  use import Ada__containers__formal_ordered_sets__witness
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__find

  function contains__logic set Ada__containers__formal_ordered_sets__element_type.base_type : bool

  axiom contains_c:
  forall co : set, e : Ada__containers__formal_ordered_sets__element_type.base_type [contains__logic co e].
    contains__logic co e = True <-> 0 < position co (find_ co (witness e))

  val contains (co:set) (e:Ada__containers__formal_ordered_sets__element_type.base_type) : bool
     ensures { contains__logic co e = result }
end

module Ada__containers__formal_ordered_sets__strict_equal
  use import int.Int
  use import "_gnatprove_standard".Main
  use  "ada__containers__formal_ordered_sets__args".Ada__containers__formal_ordered_sets__element_type
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__element

  function strict_equal__logic set set : bool

  axiom strict_equal__def:
    forall co1 co2 : set [strict_equal__logic co1 co2].
    ((forall cu:cursor [position co1 cu | position co2 cu].
       position co1 cu > 0 <-> position co2 cu > 0) /\
     (forall cu:cursor [element__logic co1 cu | element__logic co2 cu]. position co1 cu > 0 ->
        element__logic co1 cu = element__logic co2 cu)) <->  strict_equal__logic co1 co2 = True

  axiom strict_equal__pos:
    forall co1 co2 : set [strict_equal__logic co1 co2].
    strict_equal__logic co1 co2 = True -> (forall cu:cursor [position co1 cu | position co2 cu].
       position co1 cu = position co2 cu)

  axiom strict_equal_length_:
    forall co1 co2 : set [strict_equal__logic co1 co2].
     strict_equal__logic co1 co2 = True -> length_ co1 = length_ co2

    val strict_equal (co1:set) (co2:set) : bool
     ensures  { result  = strict_equal__logic co1 co2 }
end

module Ada__containers__formal_ordered_sets__Oeq__2
  use import int.Int
  use  "ada__containers__formal_ordered_sets__args".Ada__containers__formal_ordered_sets__element_type
  use "ada__containers__formal_ordered_sets__args".Ada__containers__formal_ordered_sets__oeq
  use import Ada__containers__formal_ordered_sets__witness
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__no_element
  use import Ada__containers__formal_ordered_sets__element
  use import Ada__containers__formal_ordered_sets__find

  function oeq__2__logic set set : bool

  axiom oeq__2_length_:
   forall co1 co2 : set [oeq__2__logic co1 co2].
   oeq__2__logic co1 co2 = True -> length_ co1 = length_ co2

  axiom oeq__2_element:
   forall co1 co2 : set [oeq__2__logic co1 co2]. oeq__2__logic co1 co2 = True ->
   forall cu1 : cursor [element__logic co1 cu1]. position co1 cu1 > 0 ->
	let cu2 = find_ co2 (witness (element__logic co1 cu1)) in
          position co2 cu2 > 0 /\
          Ada__containers__formal_ordered_sets__oeq.oeq (element__logic co2 cu2) (element__logic co1 cu1) = True

  axiom oeq__2_inv:
   forall co1 co2 : set [oeq__2__logic co1 co2]. oeq__2__logic co1 co2 <> True ->
   (length_ co1 <> length_ co2 \/
   exists e : real. position co1 (find_ co1 e) > 0 /\
         (find_ co2 e = no_element \/ position co2 (find_ co2 e) > 0 /\
          Ada__containers__formal_ordered_sets__oeq.oeq (element__logic co2 (find_ co2 e)) (element__logic co1 (find_ co1 e)) <> True))

  axiom oeq__2_sym :
  forall e1 e2 : set [oeq__2__logic e1 e2].
	oeq__2__logic e1 e2 = True -> oeq__2__logic e2 e1 = True

  axiom oeq__2_trans :
  forall e1 e2 e3 : set [oeq__2__logic e1 e2, oeq__2__logic e1 e3 | oeq__2__logic e1 e2, oeq__2__logic e2 e3].
	oeq__2__logic e1 e2 = True -> oeq__2__logic e2 e3 = True -> oeq__2__logic e1 e3 = True

  val oeq__2 (co1:set) (co2:set) : bool
     ensures  { result  = oeq__2__logic co1 co2 }
end

module Ada__containers__formal_ordered_sets__equivalent_sets
  use import int.Int
  use import "_gnatprove_standard".Main
  use  "ada__containers__formal_ordered_sets__args".Ada__containers__formal_ordered_sets__element_type
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__no_element
  use import Ada__containers__formal_ordered_sets__find

  function equivalent_sets__logic set set : bool

  axiom equivalent_sets__def :
    forall co1:set, co2:set [equivalent_sets__logic co1 co2].
     (forall i:real.
       not find_ co1 i = no_element -> not find_ co2 i = no_element) /\
      length_ co1 = length_ co2 <-> equivalent_sets__logic co1 co2 = True

  axiom equivalent_sym :
    forall co1:set.
     forall co2:set [equivalent_sets__logic co2 co1| equivalent_sets__logic co1 co2].
      equivalent_sets__logic co1 co2 = True -> equivalent_sets__logic co2 co1 = True

  val equivalent_sets (co1:set) (co2:set) : bool
  ensures { result  = equivalent_sets__logic co1 co2 }
end

module Ada__containers__formal_ordered_sets__intersection
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__no_element
  use import Ada__containers__formal_ordered_sets__find

  function intersection set set : set

  predicate is_inter (s1:set) (s2:set) (i:set) =
    forall j:real [find_ s1 j, find_ s2 j| find_ i j].
     (not find_ s1 j = no_element /\ not find_ s2 j = no_element ->
       not find_ i j = no_element) /\
      (find_ s1 j = no_element \/ find_ s2 j = no_element ->
        find_ i j = no_element)

  axiom Inter_is_inter :
    forall s1:set.
     forall s2:set [intersection s1 s2].
      is_inter s1 s2 (intersection s1 s2) /\
       length_ (intersection s1 s2) = length_ (intersection s2 s1)

  val intersection (co1:ref Ada__containers__formal_ordered_sets__set.__split_fields) (cap : Ada__containers__formal_ordered_sets__set.__split_discrs) (co2:set) :unit
     reads { co1 }
     writes { co1 }
     ensures { let rec_co1 = {Ada__containers__formal_ordered_sets__set.__split_fields = !co1;
                              Ada__containers__formal_ordered_sets__set.__split_discrs = cap}  in
               let old_co1 = {Ada__containers__formal_ordered_sets__set.__split_fields = old !co1;
                              Ada__containers__formal_ordered_sets__set.__split_discrs = cap}  in
                   rec_co1 = intersection old_co1 co2 }
end

module Ada__containers__formal_ordered_sets__intersection__2
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__intersection

  function intersection__2__logic "inline" (co1 co2 : set) : set = intersection co1 co2

  val intersection__2 (co1 co2 : set) : set
    ensures { result = intersection co1 co2 /\ set_inv result }
end

module Ada__containers__formal_ordered_sets__union
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__no_element
  use import Ada__containers__formal_ordered_sets__find
  use import Ada__containers__formal_ordered_sets__intersection

  function union set set : set

  predicate is_union (s1:set) (s2:set) (u:set) =
    (forall i:real [find_ s1 i, find_ s2 i| find_ u i].
      (not find_ s1 i = no_element \/ not find_ s2 i = no_element ->
        not find_ u i = no_element) /\
       (find_ s1 i = no_element /\ find_ s2 i = no_element ->
         find_ u i = no_element)) /\
     length_ u = ((length_ s1 + length_ s2) - length_ (intersection s1 s2))

  axiom union_is_union :
    forall s1:set. forall s2:set [union s1 s2]. is_union s1 s2 (union s1 s2)

  val union (co1:ref Ada__containers__formal_ordered_sets__set.__split_fields) (cap : Ada__containers__formal_ordered_sets__set.__split_discrs)(co2:set) :unit
     requires { let rec_co1 = {Ada__containers__formal_ordered_sets__set.__split_fields = !co1;
                              Ada__containers__formal_ordered_sets__set.__split_discrs = cap}  in
                   length_ (union rec_co1 co2) <= capacity rec_co1}
     reads { co1 }
     writes { co1 }
     ensures { let rec_co1 = {Ada__containers__formal_ordered_sets__set.__split_fields = !co1;
                              Ada__containers__formal_ordered_sets__set.__split_discrs = cap}  in
               let old_co1 = {Ada__containers__formal_ordered_sets__set.__split_fields = old !co1;
                              Ada__containers__formal_ordered_sets__set.__split_discrs = cap}  in
                   rec_co1 = union old_co1 co2 }
end

module Ada__containers__formal_ordered_sets__union__2
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__union

  function union__2__logic set set : set

  axiom union__2__def :
     forall co1 co2 : set [union__2__logic co1 co2].
	  length_ (union co1 co2) <=  Ada__containers__count_type.last ->
          union__2__logic co1 co2 = union co1 co2

  val union__2 (co1 co2 : set) : set
    requires { length_ (union co1 co2) <=  Ada__containers__count_type.last }
    ensures { result = union co1 co2 /\ set_inv result }
end

module Ada__containers__formal_ordered_sets__difference
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__no_element
  use import Ada__containers__formal_ordered_sets__find
  use import Ada__containers__formal_ordered_sets__intersection

  function difference set set : set

  predicate is_diff (s1:set) (s2:set) (d:set) =
    (forall i:real [find_ s1 i, find_ s2 i| find_ d i].
      (not find_ s1 i = no_element /\ find_ s2 i = no_element ->
        not find_ d i = no_element) /\
       (find_ s1 i = no_element \/ not find_ s2 i = no_element ->
         find_ d i = no_element)) /\
     length_ d = (length_ s1 - length_ (intersection s1 s2))

  axiom diff_is_diff :
    forall s1:set.
     forall s2:set [difference s1 s2]. is_diff s1 s2 (difference s1 s2)

  val difference (co1:ref Ada__containers__formal_ordered_sets__set.__split_fields) (cap : Ada__containers__formal_ordered_sets__set.__split_discrs) (co2:set) :unit
     reads { co1 }
     writes { co1 }
     ensures { let rec_co1 = {Ada__containers__formal_ordered_sets__set.__split_fields = !co1;
                              Ada__containers__formal_ordered_sets__set.__split_discrs = cap}  in
               let old_co1 = {Ada__containers__formal_ordered_sets__set.__split_fields = old !co1;
                              Ada__containers__formal_ordered_sets__set.__split_discrs = cap}  in
                   rec_co1 = difference old_co1 co2 }
end

module Ada__containers__formal_ordered_sets__difference__2
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__difference

  function difference__2__logic "inline" (co1 co2 : set) : set = difference co1 co2

  val difference__2 (co1 co2 : set) : set
    ensures { result = difference co1 co2 /\ set_inv result }
end

module Ada__containers__formal_ordered_sets__symmetric_difference
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__no_element
  use import Ada__containers__formal_ordered_sets__find
  use import Ada__containers__formal_ordered_sets__intersection

  function symmetric_difference set set : set

  predicate is_sdiff (s1:set) (s2:set) (d:set) =
    (forall i:real [find_ s1 i, find_ s2 i| find_ d i].
      (not find_ s1 i = no_element /\ find_ s2 i = no_element ->
        not find_ d i = no_element) /\
       (not find_ s2 i = no_element /\ find_ s1 i = no_element ->
         not find_ d i = no_element) /\
        (find_ s2 i = no_element /\ find_ s1 i = no_element ->
          find_ d i = no_element) /\
         (not find_ s2 i = no_element /\ not find_ s1 i = no_element ->
           find_ d i = no_element)) /\
     length_ d =
      ((length_ s1 + length_ s2) - (2 * length_ (intersection s1 s2)))

  axiom sdiff_is_sdiff :
    forall s1:set.
     forall s2:set [symmetric_difference s1 s2].
      is_sdiff s1 s2 (symmetric_difference s1 s2)

  val symmetric_difference (co1:ref Ada__containers__formal_ordered_sets__set.__split_fields) (cap : Ada__containers__formal_ordered_sets__set.__split_discrs) (co2:set) :unit
     requires { let rec_co1 = {Ada__containers__formal_ordered_sets__set.__split_fields = !co1;
                              Ada__containers__formal_ordered_sets__set.__split_discrs = cap}  in
                   length_ (symmetric_difference rec_co1 co2) <= capacity rec_co1}
     reads { co1 }
     writes { co1 }
     ensures { let rec_co1 = {Ada__containers__formal_ordered_sets__set.__split_fields = !co1;
                              Ada__containers__formal_ordered_sets__set.__split_discrs = cap}  in
               let old_co1 = {Ada__containers__formal_ordered_sets__set.__split_fields = old !co1;
                              Ada__containers__formal_ordered_sets__set.__split_discrs = cap}  in
                   rec_co1 = symmetric_difference old_co1 co2 }
end

module Ada__containers__formal_ordered_sets__symmetric_difference__2
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__symmetric_difference

  function symmetric_difference__2__logic set set : set

  axiom symmetric_difference__2__def :
     forall co1 co2 : set [symmetric_difference__2__logic co1 co2].
	  length_ (symmetric_difference co1 co2) <=
          Ada__containers__count_type.last ->
          symmetric_difference__2__logic co1 co2 = symmetric_difference co1 co2

  val symmetric_difference__2 (co1 co2 : set) : set
    requires { length_ (symmetric_difference co1 co2) <=
    Ada__containers__count_type.last }
    ensures { result = symmetric_difference co1 co2 /\ set_inv result }
end

module Ada__containers__formal_ordered_sets__is_subset
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__no_element
  use import Ada__containers__formal_ordered_sets__find

  function is_subset__logic set set : bool

  axiom is_subset__def :
    forall s1:set, s2:set [is_subset__logic s1 s2].
     is_subset__logic s1 s2 = True <->
      (forall i:real [find_ s1 i | find_ s2 i]. find_ s1 i = no_element -> find_ s2 i = no_element)

  val is_subset (co1 co2:set) : bool
     ensures { result = is_subset__logic co1 co2 }
end

module Ada__containers__formal_ordered_sets__overlap
  use import int.Int
  use import "_gnatprove_standard".Main
  use  "ada__containers__formal_ordered_sets__args".Ada__containers__formal_ordered_sets__element_type
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__no_element
  use import Ada__containers__formal_ordered_sets__find

  function overlap__logic set set : bool

  axiom overlap__def :
    forall s1:set, s2:set [overlap__logic s1 s2].
     overlap__logic s1 s2 <> True <->
      (forall i:real [find_ s1 i| find_ s2 i].
        find_ s1 i = no_element \/ find_ s2 i = no_element)

  val overlap (co1 co2:set) : bool
     ensures { result = overlap__logic co1 co2 }
end

module Ada__containers__formal_ordered_sets__capacity
  use import int.Int
  use import "_gnatprove_standard".Main
  use Ada__containers__count_type
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length

  function capacity__logic (co : set) : int = Ada__containers__count_type.to_rep (rec__capacity (__split_discrs co))

  val capacity (co : set) : int
    ensures { result = Ada__containers__count_type.to_rep (rec__capacity (__split_discrs co)) }
end

module Ada__containers__formal_ordered_sets__reserve_capacity
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_sets__set

  val reserve_capacity (co:ref Ada__containers__formal_ordered_sets__set.__split_fields) (cap : Ada__containers__formal_ordered_sets__set.__split_discrs) (c : int) : unit
    requires { Ada__containers__count_type.to_rep (cap.rec__capacity) >= c }
    ensures { !co = old !co }
end

module Ada__containers__formal_ordered_sets__equivalent_elements__2
  use "ada__containers__formal_ordered_sets__args".Ada__containers__formal_ordered_sets__element_type
  use import Ada__containers__formal_ordered_sets__witness
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__element

  function equivalent_elements__2__logic (co1:set) (e1:Ada__containers__formal_ordered_sets__element_type.base_type) (co2:set) (e2:Ada__containers__formal_ordered_sets__element_type.base_type) : bool =
  if witness e1 = witness e2 then True else False

 val equivalent_elements__2  (co1:set) (e1:Ada__containers__formal_ordered_sets__element_type.base_type) (co2:set) (e2:Ada__containers__formal_ordered_sets__element_type.base_type) : bool
	ensures {  result = equivalent_elements__2__logic co1 e1 co2 e2 }
end

module Ada__containers__formal_ordered_sets__clear
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length

  val clear (co:ref Ada__containers__formal_ordered_sets__set.__split_fields) (cap : Ada__containers__formal_ordered_sets__set.__split_discrs) : unit
     writes     { co }
     ensures { let rec_co = {Ada__containers__formal_ordered_sets__set.__split_fields = !co;
                              Ada__containers__formal_ordered_sets__set.__split_discrs = cap}  in
                   length_ rec_co = 0 }
end

module Ada__containers__formal_ordered_sets__assign
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__Oeq__2

  val assign (target:ref Ada__containers__formal_ordered_sets__set.__split_fields) (cap : Ada__containers__formal_ordered_sets__set.__split_discrs) (source:set) : unit
     requires { Ada__containers__count_type.to_rep (cap.rec__capacity) >= length_ source }
     writes     { target }
     reads      { target }
     ensures { let rec_t = {Ada__containers__formal_ordered_sets__set.__split_fields = !target;
                              Ada__containers__formal_ordered_sets__set.__split_discrs = cap}  in
                   oeq__2__logic rec_t source = True }
end

module Ada__containers__formal_ordered_sets__move
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__Oeq__2

  val move (target:ref Ada__containers__formal_ordered_sets__set.__split_fields) (t_cap : Ada__containers__formal_ordered_sets__set.__split_discrs) (source:ref Ada__containers__formal_ordered_sets__set.__split_fields) (s_cap : Ada__containers__formal_ordered_sets__set.__split_discrs) : unit
     requires { let rec_s = {Ada__containers__formal_ordered_sets__set.__split_fields = !source;
                              Ada__containers__formal_ordered_sets__set.__split_discrs = s_cap}  in
                   Ada__containers__count_type.to_rep (t_cap.rec__capacity) >= length_ rec_s }
     writes     { target, source }
     reads      { target, source }
     ensures { let rec_t = {Ada__containers__formal_ordered_sets__set.__split_fields = !target;
                              Ada__containers__formal_ordered_sets__set.__split_discrs = t_cap}  in
               let rec_s = {Ada__containers__formal_ordered_sets__set.__split_fields = !source;
                              Ada__containers__formal_ordered_sets__set.__split_discrs = s_cap}  in
               let old_s = {Ada__containers__formal_ordered_sets__set.__split_fields = old !source;
                              Ada__containers__formal_ordered_sets__set.__split_discrs = s_cap}  in
                   oeq__2__logic rec_t old_s = True /\ length_ rec_s = 0 }
end

module Ada__containers__formal_ordered_sets__copy
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__strict_equal

  function copy__logic set int : set

  axiom copy__def:
    forall co : set, cap : int [copy__logic co cap].
       strict_equal__logic co (copy__logic co cap) = True /\
       (cap = 0 -> capacity co = capacity (copy__logic co cap)) /\
       (cap >= capacity co ->  capacity (copy__logic co cap) = cap)

  val copy (co: set) (cap:int) : set
     requires { cap = 0 \/ cap >= capacity co}
     ensures { result = copy__logic co cap /\ set_inv result }
end

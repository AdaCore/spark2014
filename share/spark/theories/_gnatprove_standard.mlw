module Main
  (* the module of references is needed in all modules *)
  use export ref.Ref
  (* dito for boolean functions *)
  use export bool.Bool
  use export "_gnatprove_standard_th".Main_Main

  (* exception used to simulate return statements *)
  exception Return__exc

  (* The type for the heap, and the heap variable. This variable represents
     all effects that we cannot describe more precisely, and that do not
     interfere with other variables, i.e., writes through pointers, aliased
     variables etc. *)
  type __type_of_heap
  val __HEAP : ref __type_of_heap

  (* the return type for the functions that correspond to 'Image *)
  type __image

  (* A predicate symbol that ignores its argument.
       It is used for instantiation of generic package with a user-defined
       axiomatization. *)
  predicate __ignore "inline" (x : 'a) = true

  (* Program function that sets the value of its parameter to any possible
     value allowed by its type. *)
  val __havoc (x : ref 'a) : unit
     writes { x }

end

module Integer
  use import int.Int
  use export int.Abs
  use export int.Power

  use export "_gnatprove_standard_th".Integer_Func

  (* These program functions are there to generate division checks *)

  val div_ (x:int) (y:int) : int
     requires { y<>0 }
     ensures { result = div x y }

  val rem_ (x:int) (y:int) : int
     requires { y<>0 }
     ensures{ result = rem x y }

  val mod_ (x:int) (y:int) : int
     requires { y<>0 }
     ensures { result = mod x y }

  (* Bitwise operations in Ada are allowed on modular types only, which always
  range from 0 to some value N - 1. In consequence, there is no (trouble with
  the) sign bit, and in fact there is only one bitwise operation of each kind
  (and, or, xor), and not one for each type. *)

  function bitwise_and int int : int
  function bitwise_or int int : int
  function bitwise_xor int int : int

end

module Floating
  use real.Real
  use import real.RealInfix
  use real.Abs as AbsReal
  use export real.Truncate
  use export real.PowerInt
  use real.MinMax
  use real.FromInt

  use floating_point.Rounding
  use floating_point.Single
  use floating_point.Double

  function round_single (x : real) : real = Single.round Rounding.NearestTiesToEven x

  function round_double (x : real) : real = Double.round Rounding.NearestTiesToEven x

  (* The rounding error on a floating-point operation can be bounded, see page 7 of
     paper "The pitfalls of verifying floating-point computations" by David Monniaux:
     http://arxiv.org/abs/cs/0701192

     "As a result, for any floating-point type with a bounded number of bits,
      there exist two positive reals εrel and εabs such that
        |x − r(x)| ≤ max(εrel.|x|, εabs)
      The following, coarser, property may be easier to use in some contexts:
        |x − r(x)| ≤ εrel.|x| + εabs"

     The first part is the error made when rounding to a normal number (which is
     proportional to the absolute value of the exact mathematical result), and the
     second part is the error made when rounding to a subnormal number. In the case
     of round-to-even, we have:

     εrel = 2 ** (-p) where p is the number of bits of the mantissa
     εabs = 2 ** (Emin - p) where Emin is the minimal value of the exponent

     with for single precision: p = 24, Emin = -126
          for double precision: p = 53, Emin = -1022
  *)

  axiom round_single_bound :
    forall x : real [round_single x].
      x -. 0x1p-24 *. AbsReal.abs(x) -. 0x1p-150 <=. round_single x <=. x +. 0x1p-24 *. AbsReal.abs(x) +. 0x1p-150

  axiom round_double_bound :
    forall x : real [round_double x].
      x -. 0x1p-53 *. AbsReal.abs(x) -. 0x1p-1075 <=. round_single x <=. x +. 0x1p-53 *. AbsReal.abs(x) +. 0x1p-1075

  use export _gnatprove_standard_th.Floating_Func

  function real_of_int (x : int) : real = FromInt.from_int x

  function round real : int

  axiom Round_down:
    forall x:real. x -. real_of_int (floor x) <. 0.5 -> round (x) = floor (x)

  axiom Round_up:
    forall x:real. real_of_int (ceil x) -. x <. 0.5 -> round (x) = ceil (x)

  axiom Round_neg_tie:
    forall x:real.
      x -. real_of_int (floor x) = 0.5 /\ x <. 0.0 -> round (x) = floor (x)

  axiom Round_pos_tie:
    forall x:real.
      real_of_int (ceil x) -. x = 0.5 /\ x >. 0.0 -> round (x) = ceil (x)

  axiom Round_int :
    forall i:int [round (real_of_int i)]. round (real_of_int i) = i

  axiom Round_near_int :
    forall i:int. forall x:real.
      -.0.5 <. x /\ x <. 0.5 -> (round(real_of_int(i) +. x) = i)

  axiom Round_monotonic:
    forall x y:real. x <=. y -> Int.(<=) (round x) (round y)

  axiom Round_monotonic_int1:
    forall x:real, i:int. x <=. real_of_int i -> Int.(<=) (round x) i

  axiom Round_monotonic_int2:
    forall x:real, i:int. real_of_int i <=. x -> Int.(<=) i (round x)

  axiom Round_bound:
    forall x:real.
      x -. 0.5 <=. real_of_int (round x) /\ real_of_int (round x) <=. x +. 0.5

  function div_real (x : real) (y : real) : real = x /. y

  val div_real_ (x:real) (y:real) : real
    requires { y<>0.0 }
    ensures { result = div_real x y }

end

module Boolean
  use import bool.Bool
  use export bool.Ite
  use import int.Int
  use import Main

  use export "_gnatprove_standard_th".Boolean_Func

  (* Boolean logical connectors, functions for conversion of booleans, etc *)

  function to_int (b : bool) : int =
   if b = True then 1 else 0

  function of_int (i : int) : bool =
   if i = 0 then False else True

  function last : int = 1
  function first : int = 0

  predicate in_range (x : int) = x = 0 \/ x = 1

  predicate dynamic_property "inline" (f l x : int) = in_range x

  function attr__ATTRIBUTE_IMAGE bool : __image

  predicate attr__ATTRIBUTE_VALUE__pre_check (x : __image)

  function attr__ATTRIBUTE_VALUE __image : bool

  val attr__ATTRIBUTE_VALUE_ (x : __image)  : bool
    requires { attr__ATTRIBUTE_VALUE__pre_check x }
    ensures { true }

  val range_check_ (n : int) : int
    requires { in_range n }
    ensures { result = n }

  val check_not_last (n : int) : int
    requires { n <> last }
    ensures { result = n }

  val check_not_first (n : int) : int
    requires { n <> first }
    ensures { result = n }

end

(* The following theories care about the *contents* of Arrays, and defines
   access and update functions. It does not care about properties of bounds.
   However, boolean equality and sliding needs array bounds as *input*. These
   functions are independent of the representation of
   constrained/unconstrained arrays. This also means that there is some
   special circuitry in gnat2why to actually call these functions.

   For Boolean equality, the arguments are, in order:
    - the first array
    - for each dimension, first and last
    - the second array
    - for each dimension, first and last

  Boolean equality is true when all dimensions of the two arrays are of the
  same length, and the arrays contain the same elements in their valid range
  (note that access needs to be slided when the bounds do not coincide, but
  the length is the same)

  For sliding, the arguments are, in order:
    - the array
    - for each dimension, the old and new value of first

  Sliding shifts the elements of the array according to the difference between
  the old and new value of first

*)
theory Array__1

  use import int.Int
  use import bool.Bool

  type map 'a

  function get (map 'a) int : 'a
  function set (map 'a) int 'a : map 'a

  axiom Select_eq :
    forall m : map 'a. forall i : int.
    forall a : 'a [set m i a].  get (set m i a) i = a

  axiom Select_neq :
    forall m : map 'a. forall i j : int.
    forall a : 'a [get (set m i a) j| set m i a, get m j].
    i <> j -> get (set m i a) j = get m j

  function bool_eq (map 'a) int int (map 'a) int int : bool

   axiom T__ada_array___equal_def:
     forall a:map 'a.
     forall af : int. forall al : int.
     forall b:map 'a.
     forall bf : int. forall bl : int [bool_eq a af al b bf bl].
         ((if af <= al then al - af + 1 = bl - bf + 1 else bf > bl)
          /\ (forall i:int[get a i].
                af <= i <= al ->
                (get a i = get b (bf - af + i))))
         <-> bool_eq a af al b bf bl = True

  function slide (map 'a) int int : map 'a

  axiom slide_def :
    forall a : map 'a.
    forall old_first : int.
    forall new_first : int.
    forall i : int
      [get (slide a old_first new_first) i].
      get (slide a old_first new_first) i = get a (i - (new_first - old_first))

  (* Concatenation is only defined for one-dimensional arrays; it appends a
     map to another. We do not really care about the valid ranges of the
     original arrays, but we need to know for each access to the
     concatenation, which of the arguments we need to look at. Also, if we are
     interested in the second argument, a shift must be made depending on the
     original "first" value. *)

  function concat (map 'a) int int (map 'a) int int : map 'a

  axiom concat_def :
    forall a b : map 'a.
    forall a_first a_last b_first b_last : int.
    forall i : int [get (concat a a_first a_last b b_first b_last) i].
      (a_first <= i <= a_last ->
          get (concat a a_first a_last b b_first b_last) i = get a i)
          /\
      (i > a_last ->
        get (concat a a_first a_last b b_first b_last) i = get b (i-a_last + b_first - 1))

   (* Comparison between arrays. Only defined for arrays of discrete.  *)

   function compare (map 'a) int int (map 'a) int int : int

   (* Logical operators on arrays. Only defined for arrays of boolean. *)

   function xorb (map 'a) int int (map 'a) int int : map 'a
   function andb (map 'a) int int (map 'a) int int : map 'a
   function orb (map 'a) int int (map 'a) int int : map 'a
   function notb (map 'a) int int : map 'a

   (* a singleton array is the array which is defined only at the given
   position, and yields the given value. *)

   function singleton 'a int : map 'a

   axiom singleton_def :
    forall v : 'a.
    forall i : int  [get (singleton v i) i].
      get (singleton v i) i = v
end

theory Array__2
  use import int.Int
  use import bool.Bool

  type map 'a

  function get (map 'a) int int : 'a
  function set (map 'a) int int 'a : map 'a

  axiom Select_eq :
    forall m : map 'a.
    forall i j : int.
    forall a : 'a [set m i j a].  get (set m i j a) i j = a

  axiom Select_neq :
    forall m : map 'a.
    forall i j i2 j2 : int.
    forall a : 'a [get (set m i j a) i2 j2| set m i j a, get m i2 j2].
    not (i = i2 /\ j = j2) -> get (set m i j a) i2 j2 = get m i2 j2

  function bool_eq (map 'a) int int int int (map 'a) int int int int : bool

   axiom T__ada_array___equal_def:
     forall a:map 'a.
     forall af al af2 al2 : int.
     forall b:map 'a.
     forall bf bl bf2 bl2 : int [bool_eq a af al af2 al2 b bf bl bf2 bl2].
         ((if af <= al then al - af + 1 = bl - bf + 1 else bf > bl) /\
          (if af2 <= al2 then al2 - af2 + 1 = bl2 - bf2 + 1 else bf2 > bl2) /\
          (forall i j:int[get a i j].
                af <= i <= al ->
                af2 <= j <= al2 ->
                (get a i j = get b (bf - af + i) (bf2 - af2 + j))))
         <-> bool_eq a af al af2 al2 b bf bl bf2 bl2 = True

  function slide (map 'a) int int int int : map 'a

  axiom slide_def :
    forall a : map 'a.
    forall old_first old_first_2 : int.
    forall new_first new_first_2 : int.
    forall i j : int
      [get (slide a old_first new_first old_first_2 new_first_2) i j].
      get (slide a old_first new_first old_first_2 new_first_2) i j =
        get a (i - (new_first - old_first)) (j - (new_first_2 - old_first_2))
end

theory Array__3
  use import int.Int
  use import bool.Bool

  type map 'a

  function get (map 'a) int int int : 'a
  function set (map 'a) int int int 'a : map 'a

  axiom Select_eq :
    forall m : map 'a.
    forall i j k : int.
    forall a : 'a [set m i j k a].  get (set m i j k a) i j k = a

  axiom Select_neq :
    forall m : map 'a.
    forall i j k i2 j2 k2 : int.
    forall a : 'a [get (set m i j k a) i2 j2 k2| set m i j k a, get m i2 j2 k2].
    not (i = i2 /\ j = j2 /\ k = k2) ->
      get (set m i j k a) i2 j2 k2 = get m i2 j2 k2

  function bool_eq (map 'a)
    int int int int int int (map 'a) int int int int int int : bool

   axiom T__ada_array___equal_def:
     forall a:map 'a.
     forall af al af2 al2 af3 al3 : int.
     forall b:map 'a.
     forall bf bl bf2 bl2 bf3 bl3 : int
      [bool_eq a af al af2 al2 af3 al3 b bf bl bf2 bl2 bf3 bl3].
         ((if af <= al then al - af + 1 = bl - bf + 1 else bf > bl) /\
          (if af2 <= al2 then al2 - af2 + 1 = bl2 - bf2 + 1 else bf2 > bl2) /\
          (if af3 <= al3 then al3 - af3 + 1 = bl3 - bf3 + 1 else bf3 > bl3) /\
          (forall i j k:int[get a i j k].
                af <= i <= al ->
                af2 <= j <= al2 ->
                af3 <= k <= al3 ->
                (get a i j k = get b (bf - af + i) (bf2 - af2 + j) (bf3 - af3 + k))))
         <-> bool_eq a af al af2 al2 af3 al3 b bf bl bf2 bl2 bf3 bl3 = True

  function slide (map 'a) int int int int int int : map 'a

  axiom slide_def :
    forall a : map 'a.
    forall old_first old_first_2 old_first_3 : int.
    forall new_first new_first_2 new_first_3 : int.
    forall i j k : int
      [get (slide a old_first new_first old_first_2 new_first_2
                    old_first_3 new_first_3) i j k].
      get (slide a old_first new_first old_first_2 new_first_2
                   old_first_3 new_first_3) i j k =
        get a (i - (new_first - old_first))
              (j - (new_first_2 - old_first_2))
              (k - (new_first_3 - old_first_3))
end

theory Array__4
  use import int.Int
  use import bool.Bool

  type map 'a

  function get (map 'a) int int int int : 'a
  function set (map 'a) int int int int 'a : map 'a

  axiom Select_eq :
    forall m : map 'a.
    forall i j k l : int.
    forall a : 'a [set m i j k l a].  get (set m i j k l a) i j k l = a

  axiom Select_neq :
    forall m : map 'a.
    forall i j k l i2 j2 k2 l2 : int.
    forall a : 'a
      [get (set m i j k l a) i2 j2 k2 l2|
       set m i j k l a, get m i2 j2 k2 l2].
    not (i = i2 /\ j = j2 /\ k = k2 /\ l = l2) ->
      get (set m i j k l a) i2 j2 k2 l2 = get m i2 j2 k2 l2

  function bool_eq (map 'a)
    int int int int int int int int (map 'a) int int int int int int int int : bool

   axiom T__ada_array___equal_def:
     forall a:map 'a.
     forall af al af2 al2 af3 al3 af4 al4 : int.
     forall b:map 'a.
     forall bf bl bf2 bl2 bf3 bl3 bf4 bl4 : int
      [bool_eq a af al af2 al2 af3 al3 af4 al4 b bf bl bf2 bl2 bf3 bl3 bf4 bl4].
         ((if af <= al then al - af + 1 = bl - bf + 1 else bf > bl) /\
          (if af2 <= al2 then al2 - af2 + 1 = bl2 - bf2 + 1 else bf2 > bl2) /\
          (if af3 <= al3 then al3 - af3 + 1 = bl3 - bf3 + 1 else bf3 > bl3) /\
          (if af4 <= al4 then al4 - af4 + 1 = bl4 - bf4 + 1 else bf4 > bl4) /\
          (forall i j k l:int[get a i j k l].
                af <= i <= al ->
                af2 <= j <= al2 ->
                af3 <= k <= al3 ->
                af4 <= l <= al4 ->
                (get a i j k l = get b (bf - af + i) (bf2 - af2 + j) (bf3 - af3 + k) (bf4 - af4 + l))))
         <-> bool_eq a af al af2 al2 af3 al3 af4 al4 b bf bl bf2 bl2 bf3 bl3 bf4 bl4 = True

  function slide (map 'a) int int int int int int int int : map 'a

  axiom slide_def :
    forall a : map 'a.
    forall old_first old_first_2 old_first_3 old_first_4 : int.
    forall new_first new_first_2 new_first_3 new_first_4 : int.
    forall i j k l : int
      [get (slide a old_first new_first old_first_2 new_first_2
                    old_first_3 new_first_3 old_first_4 new_first_4) i j k l].
      get (slide a old_first new_first old_first_2 new_first_2
                   old_first_3 new_first_3 old_first_4 new_first_4) i j k l =
        get a (i - (new_first - old_first))
              (j - (new_first_2 - old_first_2))
              (k - (new_first_3 - old_first_3))
              (l - (new_first_4 - old_first_4))
end

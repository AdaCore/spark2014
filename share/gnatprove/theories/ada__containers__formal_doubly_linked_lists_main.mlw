module $Main
  use import int.Int
  use $$oeq
  use $$element_type
  use $$cursor
  use $$list
  use "a-contai__types_in_spec".Ada__containers__count_type

  function oeq (e1:$element_type.t) (e2:$element_type.t) : bool = $oeq.log e1 e2

  function capacity $list.t : int

  axiom capacity_range:
    forall co : $list.t [capacity co].
      Ada__containers__count_type.in_range (capacity co)

  function no_element : $cursor.t

  function empty_ : $list.t

  function length $list.t : int

  axiom length_range:
    forall co:$list.t [length co]. 0 <= length co <= capacity co

  function position_ $list.t $cursor.t : int

  axiom position_gte_zero:
    forall co:$list.t, cu:$cursor.t [position_ co cu].
        length co >= position_ co cu /\ position_ co cu >= 0

  axiom position_no_element:
    forall co:$list.t [position_ co no_element]. position_ co no_element = 0

  axiom position_eq:
    forall co:$list.t, cu1 cu2:$cursor.t [position_ co cu1, position_ co cu2].
          position_ co cu1 > 0 -> position_ co cu1 = position_ co cu2 -> cu1 = cu2

  predicate is_empty_ $list.t

  axiom is_empty:
    forall co:$list.t [is_empty_ (co)]. is_empty_ (co) <-> length co = 0

  axiom Empty_is_empty: is_empty_ empty_

  function previous_ $list.t $cursor.t : $cursor.t

  axiom previous_in:
    forall co:$list.t, cu:$cursor.t [previous_ co cu].
	(position_ co cu > 1 \/ position_ co (previous_ co cu) > 0) ->
	position_ co (previous_ co cu) = position_ co cu - 1

  axiom previous_ext:
    forall co:$list.t, cu:$cursor.t [previous_ co cu].
        (position_ co cu = 1 \/ cu = no_element) -> previous_ co cu = no_element

  function next_ $list.t $cursor.t : $cursor.t

  axiom next_in:
    forall co:$list.t, cu:$cursor.t [next_ co cu].
	(length co > position_ co cu > 0 \/ position_ co (next_ co cu) > 0) ->
	position_ co (next_ co cu) = position_ co cu + 1

  axiom next_ext:
    forall co:$list.t, cu:$cursor.t [next_ co cu].
        (position_ co cu = length co \/ cu = no_element) -> next_ co cu = no_element

  function last $list.t : $cursor.t

  axiom last_empty:
    forall co:$list.t [last co]. length co = 0 <-> last co = no_element

  axiom last_gen:
    forall co:$list.t [last co]. length co = position_ co (last co)

  function first $list.t : $cursor.t

  axiom first_empty:
    forall co:$list.t [first co]. length co = 0 <-> first co = no_element

  axiom first_gen:
    forall co:$list.t [first co]. length co > 0 -> position_ co (first co) = 1

  function element_ $list.t $cursor.t : $element_type.t

  function left_ $list.t $cursor.t : $list.t

  axiom left_no_element:
    forall co:$list.t [left_ co no_element]. left_ co no_element = co

  axiom left_length:
    forall co:$list.t, cu:$cursor.t [left_ co cu].
	position_ co cu > 0 -> length (left_ co cu) = position_ co cu - 1

  axiom left_position_in:
    forall co:$list.t, cu cun:$cursor.t [position_ (left_ co cu) cun | left_ co cu, position_ co cun].
	(position_ (left_ co cu) cun > 0 \/ position_ co cun < position_ co cu) ->
	position_ (left_ co cu) cun = position_ co cun

  axiom left_position_ext:
    forall co:$list.t, cu cun:$cursor.t [position_ (left_ co cu) cun].
	position_ co cun >= position_ co cu > 0 ->
	position_ (left_ co cu) cun = 0

  axiom left_element:
    forall co:$list.t, cu cun:$cursor.t [element_ (left_ co cu) cun | left_ co cu, element_ co cun].
	(position_ (left_ co cu) cun > 0 \/ 0 < position_ co cun < position_ co cu) ->
	element_ (left_ co cu) cun = element_ co cun

  function right_ $list.t $cursor.t : $list.t

  axiom right_no_element:
    forall co:$list.t [right_ co no_element]. right_ co no_element = empty_

  axiom right_length:
    forall co:$list.t, cu:$cursor.t [length (right_ co cu) ].
	position_ co cu > 0 -> length (right_ co cu) = (length co) - (position_ co cu) + 1

  axiom right_position_in:
    forall co:$list.t, cu cun:$cursor.t [position_ (right_ co cu) cun | right_ co cu, position_ co cun].
	(position_ (right_ co cu) cun > 0 \/ position_ co cun >= position_ co cu > 0) ->
	position_ (right_ co cu) cun = (position_ co cun) - (position_ co cu) + 1

  axiom right_position_ext:
    forall co:$list.t, cu cun:$cursor.t [position_ (right_ co cu) cun].
	position_ co cun < position_ co cu -> position_ (right_ co cu) cun = 0

  axiom right_element:
    forall co:$list.t, cu cun:$cursor.t [element_ (right_ co cu) cun | right_ co cu, element_ co cun].
	(position_ (right_ co cu) cun > 0 \/ 0 < position_ co cu <= position_ co cun) ->
	element_ (right_ co cu) cun = element_ co cun

  function findfirst $list.t $element_type.t : $cursor.t

  axiom find_range:
    forall co:$list.t, e:$element_type.t [findfirst co e].
	findfirst co e = no_element \/ position_ co (findfirst co e) > 0

  axiom find_not:
    forall co:$list.t, e:$element_type.t, cu : $cursor.t [findfirst co e, element_ co cu].
	findfirst co e = no_element -> position_ co cu > 0 ->
	oeq (element_ co cu) e = False

  axiom find_yes:
    forall co:$list.t, e:$element_type.t, cu : $cursor.t [findfirst co e, element_ co cu].
	0 < position_ co cu < position_ co (findfirst co e) ->
	oeq (element_ co cu) e = False

  axiom find_element:
    forall co:$list.t, e:$element_type.t [findfirst co e].
	0 < position_ co (findfirst co e) ->
	oeq (element_ co (findfirst co e)) e = True

  function find (l : $list.t) (e : $element_type.t) (cu : $cursor.t) : $cursor.t =
    if cu = no_element then (findfirst (right_ l (first l)) e) else (findfirst (right_ l cu) e)

  predicate strict_equal $list.t $list.t

  axiom strict_equal_a:
    forall co1 co2 : $list.t [strict_equal co1 co2].
    ((forall cu:$cursor.t [position_ co1 cu | position_ co2 cu].
       position_ co1 cu = position_ co2 cu) /\
     (forall cu:$cursor.t [element_ co1 cu | element_ co2 cu]. position_ co1 cu > 0 ->
        element_ co1 cu = element_ co2 cu)) <->  strict_equal co1 co2

  axiom strict_equal_length:
    forall co1 co2 : $list.t [strict_equal co1 co2, length co1 | strict_equal co1 co2, length co2].
     strict_equal co1 co2 -> length co1 = length co2

  predicate equal_ $list.t $list.t

  axiom equal_length:
   forall co1 co2 : $list.t [equal_ co1 co2, length co1 | equal_ co1 co2, length co2].
   equal_ co1 co2 -> length co1 = length co2

  axiom equal_element:
   forall co1 co2 : $list.t [equal_ co1 co2]. equal_ co1 co2 ->
   forall cu1 : $cursor.t [element_ co1 cu1]. position_ co1 cu1 > 0 ->
	exists cu2 : $cursor.t. position_ co2 cu2 = position_ co1 cu1 /\ oeq (element_ co2 cu2) (element_ co1 cu1) = True

  axiom equal_inv:
   forall co1 co2 : $list.t [equal_ co1 co2]. not equal_ co1 co2 ->
   (length co1 <> length co2 \/
   exists cu1 cu2 : $cursor.t. position_ co1 cu1 > 0 /\ position_ co2 cu2 = position_ co1 cu1 /\
	oeq (element_ co2 cu2) (element_ co1 cu1) = False)

  axiom equal_sym :
  forall e1 e2 : $list.t [equal_ e1 e2].
	equal_ e1 e2 -> equal_ e2 e1

  axiom equal_trans :
  forall e1 e2 e3 : $list.t [equal_ e1 e2, equal_ e1 e3 | equal_ e1 e2, equal_ e2 e3].
	equal_ e1 e2 -> equal_ e2 e3 -> equal_ e1 e3

  predicate replace_element_ $list.t $cursor.t $element_type.t $list.t

  axiom replace_element_length:
    forall co1 co2:$list.t, cu:$cursor.t, e:$element_type.t
      [replace_element_ co1 cu e co2].
      replace_element_ co1 cu e co2 -> length co1 = length co2

  axiom replace_element_position_ext:
    forall co1 co2:$list.t, cu cun:$cursor.t, e:$element_type.t
      [replace_element_ co1 cu e co2, position_ co2 cun
     | replace_element_ co1 cu e co2, position_ co1 cun].
      replace_element_ co1 cu e co2 -> position_ co2 cun = position_ co1 cun

  axiom replace_element_position_in:
    forall co1 co2:$list.t, cu:$cursor.t, e:$element_type.t
      [replace_element_ co1 cu e co2].
      replace_element_ co1 cu e co2 -> position_ co2 cu > 0

  axiom replace_element_element_in:
    forall co1 co2:$list.t, cu:$cursor.t, e:$element_type.t
      [replace_element_ co1 cu e co2].
      replace_element_ co1 cu e co2 -> element_ co2 cu = e

  axiom replace_element_element_ext:
    forall co1 co2:$list.t, cu cun:$cursor.t, e:$element_type.t
      [replace_element_ co1 cu e co2, element_ co2 cun
     | replace_element_ co1 cu e co2, element_ co1 cun].
      replace_element_ co1 cu e co2 -> cu <> cun -> position_ co1 cun > 0 ->
        element_ co2 cun = element_ co1 cun

  predicate insert_ $list.t $cursor.t $element_type.t $list.t

  axiom insert_range:
    forall co1 co2:$list.t, cu:$cursor.t, e:$element_type.t [insert_ co1 cu e co2].
      insert_ co1 cu e co2 -> cu = no_element \/ position_ co1 cu > 0

  axiom insert_length:
    forall co1 co2:$list.t, cu:$cursor.t, e:$element_type.t
      [insert_ co1 cu e co2].
      insert_ co1 cu e co2 -> length co1 + 1 = length co2

  axiom insert_new:
    forall co1 co2:$list.t, cu:$cursor.t, e:$element_type.t [insert_ co1 cu e co2].
      insert_ co1 cu e co2 -> position_ co1 cu > 0 ->
      (position_ co1 (previous_ co2 cu) = 0 /\ element_ co2 (previous_ co2 cu) = e)

  axiom insert_new_no_element:
    forall co1 co2:$list.t, e:$element_type.t [insert_ co1 no_element e co2].
      insert_ co1 no_element e co2 ->
        position_ co1 (last co2) = 0 /\ element_ co2 (last co2) = e

  axiom insert_position_before:
    forall co1 co2:$list.t, cu cun:$cursor.t, e:$element_type.t
      [insert_ co1 cu e co2,  position_ co1 cun
     | insert_ co1 cu e co2,  position_ co2 cun].
      insert_ co1 cu e co2 -> position_ co1 cu > 0 ->
      (position_ co1 cu > position_ co1 cun > 0 \/ position_ co2 cun < position_ co1 cu) ->
        position_ co1 cun = position_ co2 cun

  axiom insert_position_after:
    forall co1 co2:$list.t, cu cun:$cursor.t, e:$element_type.t
      [insert_ co1 cu e co2,  position_ co1 cun
     | insert_ co1 cu e co2,  position_ co2 cun].
      insert_ co1 cu e co2 -> position_ co1 cu > 0 ->
      (position_ co1 cun >= position_ co1 cu \/ position_ co2 cun > position_ co1 cu) ->
        position_ co1 cun + 1 = position_ co2 cun

  axiom insert_position_no_element:
    forall co1 co2:$list.t, cun:$cursor.t, e:$element_type.t
      [insert_ co1 no_element e co2,  position_ co1 cun
     | insert_ co1 no_element e co2,  position_ co2 cun].
      insert_ co1 no_element e co2 -> (position_ co1 cun > 0 \/ position_ co2 cun < length co2) ->
        position_ co1 cun = position_ co2 cun

  axiom insert_element:
    forall co1 co2:$list.t, cu cun:$cursor.t, e:$element_type.t
      [insert_ co1 cu e co2,  element_ co1 cun
     | insert_ co1 cu e co2,  element_ co2 cun].
      insert_ co1 cu e co2 -> position_ co1 cu > 0 ->
      position_ co1 cun > 0 ->
        element_ co1 cun = element_ co2 cun

  axiom insert_element_no_element:
    forall co1 co2:$list.t, cun:$cursor.t, e:$element_type.t
      [insert_ co1 no_element e co2,  element_ co1 cun
     | insert_ co1 no_element e co2,  element_ co2 cun].
      insert_ co1 no_element e co2 ->
      (position_ co1 cun > 0 \/ 0 < position_ co2 cun < length co2) ->
        element_ co1 cun = element_ co2 cun

  predicate insert_mult $list.t $cursor.t $element_type.t int $list.t

  axiom insert_mult_0 :
    forall li1 li2 : $list.t, cu : $cursor.t, e : $element_type.t [insert_mult li1 cu e 0 li2].
	insert_mult li1 cu e 0 li2 -> li1 = li2

  axiom insert_mult_1 :
    forall li1 li2 : $list.t, cu : $cursor.t, e : $element_type.t [insert_mult li1 cu e 1 li2].
	insert_mult li1 cu e 1 li2 -> insert_ li1 cu e li2

  axiom insert_mult_n :
    forall li1 li2 : $list.t, cu : $cursor.t, e : $element_type.t, c : int [insert_mult li1 cu e c li2].
	insert_mult li1 cu e c li2 -> c > 1 ->
	 exists nl : $list.t [insert_ li1 cu e nl].
    		(insert_ li1 cu e nl /\ insert_mult nl cu e (c - 1) li2)

  predicate delete_ $list.t $cursor.t $list.t

  axiom delete_length:
    forall co1 co2:$list.t, cu:$cursor.t
      [delete_ co1 cu co2].
      delete_ co1 cu co2 -> length co1 = length co2 + 1

  axiom delete_position_before:
    forall co1 co2:$list.t, cu cun:$cursor.t
      [delete_ co1 cu co2,  position_ co1 cun
     | delete_ co1 cu co2,  position_ co2 cun].
      delete_ co1 cu co2 ->
      (position_ co1 cu > position_ co1 cun \/ 0 < position_ co2 cun < position_ co1 cu) ->
        position_ co1 cun = position_ co2 cun

  axiom delete_position_after:
    forall co1 co2:$list.t, cu cun:$cursor.t
      [delete_ co1 cu co2,  position_ co1 cun | delete_ co1 cu co2,  position_ co2 cun].
      delete_ co1 cu co2 ->
      (position_ co1 cun > position_ co1 cu \/ position_ co2 cun >= position_ co1 cu) ->
        position_ co1 cun = position_ co2 cun + 1

  axiom delete_position_range:
    forall co1 co2:$list.t, cu:$cursor.t [delete_ co1 cu co2].
      delete_ co1 cu co2 -> position_ co2 cu = 0 /\ 0 < position_ co1 cu

(* for completeness (test_comp1), efficiency issues if a lot of delete (see test2). *)
  axiom delete_position_next:
    forall co1 co2:$list.t, cu:$cursor.t [delete_ co1 cu co2].
      delete_ co1 cu co2 -> position_ co1 (next_ co1 cu) >= 0

  axiom delete_element:
    forall co1 co2:$list.t, cu cun:$cursor.t
      [delete_ co1 cu co2,  element_ co1 cun
     | delete_ co1 cu co2,  element_ co2 cun].
      delete_ co1 cu co2 ->
      0 < position_ co2 cun ->
        element_ co1 cun = element_ co2 cun

  predicate delete_mult $list.t $cursor.t int $list.t

  axiom delete_mult_0 :
    forall li1 li2 : $list.t, cu : $cursor.t [delete_mult li1 cu 0 li2].
	delete_mult li1 cu 0 li2 -> li1 = li2

  axiom delete_mult_1 :
    forall li1 li2 : $list.t, cu : $cursor.t [delete_mult li1 cu 1 li2].
	delete_mult li1 cu 1 li2 -> delete_ li1 cu li2

  axiom delete_mult_n :
    forall li1 li2 : $list.t, cu : $cursor.t, c : int [delete_mult li1 cu c li2].
	delete_mult li1 cu c li2 -> c > 1 ->
	 exists nl : $list.t [delete_ li1 cu nl].
    		(delete_ li1 cu nl /\
                  (position_ li1 cu = length li1 \/
                    position_ li1 cu < length li1 /\ delete_mult nl (next_ li1 cu) (c - 1) li2))

  predicate has_element $list.t $cursor.t

  axiom has_element_pos:
    forall co:$list.t, cu:$cursor.t [has_element co cu].
    has_element co cu -> 0 < position_ co cu

  axiom has_element_neg:
    forall co:$list.t, cu:$cursor.t [has_element co cu].
    not (has_element co cu) -> position_ co cu = 0

  predicate contains $list.t $element_type.t

  axiom contains_c:
  forall co : $list.t, e : $element_type.t [contains co e].
    contains co e <-> 0 < position_ co (findfirst co e)

  predicate first_inserted (co1:$list.t) (cu:$cursor.t) (co2:$list.t) (p:$cursor.t) =
	    cu = no_element /\ length co1 > 0 /\
               p = next_ co2 (last co1) \/
             length co1 = 0 /\ p = first co2 \/
             position_ co1 cu = 1 /\ p = first co2 \/
             position_ co1 cu > 1 /\ p = next_ co2 (previous_ co1 cu)

end

module $no_element
  use $Main
  use $$cursor

  function obj : $cursor.t

  axiom log_def:
      obj = $Main.no_element
end

module $empty_list
  use $Main
  use $$list

  function obj : $list.t

  axiom log_def:
      obj = $Main.empty_
end

module $capacity
  use $Main
  use $$list
  use "a-contai__types_in_spec".Ada__containers__count_type

  function log $list.t : Ada__containers__count_type.t

  axiom log_def:
    forall co : $list.t [log co].
      log co = Ada__containers__count_type.of_int ($Main.capacity co)

  val func:
	  co:$list.t ->
	  { }
	  Ada__containers__count_type.t
	  { result = Ada__containers__count_type.of_int ($Main.capacity co) }
end

module $length
  use $Main
  use $$list
  use "a-contai__types_in_spec".Ada__containers__count_type

  function log $list.t: Ada__containers__count_type.t

  axiom log_def:
    forall co : $list.t [log co].
      log co = Ada__containers__count_type.of_int ($Main.length co)

  val func:
	  co:$list.t ->
	  { }
	  Ada__containers__count_type.t
	  { result = Ada__containers__count_type.of_int ($Main.length co) }
end

module $element
  use $Main
  use $$list
  use $$cursor
  use $$element_type

  function log $list.t $cursor.t: $element_type.t

  axiom log_def:
    forall co : $list.t, cu : $cursor.t [log co cu].
      log co cu = $Main.element_ co cu

  val func:
	  co:$list.t -> cu:$cursor.t ->
	  { $Main.has_element co cu }
	  $element_type.t
	  { result = $Main.element_ co cu }
end

module $has_element
  use $Main
  use $$list
  use $$cursor

  function log $list.t $cursor.t: bool

  axiom log_def:
    forall co : $list.t, cu : $cursor.t [log co cu].
      $Main.has_element co cu <-> log co cu = True

  val func:
	  co:$list.t -> cu:$cursor.t ->
	  { }
	  bool
	  { $Main.has_element co cu <-> result = True }
end

module $contains
  use $Main
  use $$list
  use $$element_type

  function log $list.t $element_type.t: bool

  axiom log_def:
    forall co : $list.t, e : $element_type.t [log co e].
      $Main.contains co e <-> log co e = True

  val func:
	  co:$list.t -> e:$element_type.t ->
	  { }
	  bool
	  { $Main.contains co e <-> result = True }
end

module $replace_element
  use $Main
  use $$list
  use $$cursor
  use $$element_type
  use import ref.Ref

  val func:
	  co:ref $list.t -> cu:$cursor.t -> e:$element_type.t ->
	  { $Main.has_element !co cu }
	  unit writes co
	  { $Main.replace_element_ (old !co) cu e !co }

end

module $insert
  use import int.Int
  use $Main
  use $$list
  use $$cursor
  use $$element_type
  use import ref.Ref
  use "a-contai__types_in_spec".Ada__containers__count_type

  val func:
	  co:ref $list.t -> cu:$cursor.t -> e:$element_type.t -> c:Ada__containers__count_type.t ->
	  { $Main.length !co + (Ada__containers__count_type.to_int c) <= $Main.capacity !co /\ ($Main.has_element !co cu \/ cu = $Main.no_element) }
	  unit reads co writes co
	  { $Main.insert_mult (old !co) cu e (Ada__containers__count_type.to_int c) !co }

end

module $insert__2
  use import int.Int
  use $Main
  use $$list
  use $$cursor
  use $$element_type
  use import ref.Ref
  use "a-contai__types_in_spec".Ada__containers__count_type

  val func:
	  co:ref $list.t -> cu:$cursor.t -> e:$element_type.t -> p:ref $cursor.t -> c:Ada__containers__count_type.t ->
	  { $Main.length !co + (Ada__containers__count_type.to_int c) <= $Main.capacity !co /\ ($Main.has_element !co cu \/ cu = $Main.no_element) }
	  unit reads co p writes co p
	  { $Main.insert_mult (old !co) cu e (Ada__containers__count_type.to_int c) !co /\
            $Main.first_inserted (old !co) cu !co !p }

end

module $prepend
  use import int.Int
  use $Main
  use $$list
  use $$element_type
  use import ref.Ref
  use "a-contai__types_in_spec".Ada__containers__count_type

  val func:
	  co:ref $list.t -> e:$element_type.t -> c:Ada__containers__count_type.t ->
	  { $Main.length !co + (Ada__containers__count_type.to_int c) <= $Main.capacity !co }
	  unit reads co writes co
	  { $Main.insert_mult (old !co) ($Main.first (old !co)) e (Ada__containers__count_type.to_int c) !co }

end

module $append
  use import int.Int
  use $Main
  use $$list
  use $$element_type
  use import ref.Ref
  use "a-contai__types_in_spec".Ada__containers__count_type

  val func:
	  co:ref $list.t -> e:$element_type.t -> c:Ada__containers__count_type.t ->
	  { $Main.length !co + (Ada__containers__count_type.to_int c) <= $Main.capacity !co }
	  unit reads co writes co
	  { $Main.insert_mult (old !co) $Main.no_element e (Ada__containers__count_type.to_int c) !co }

end

module $delete
  use $Main
  use $$list
  use $$cursor
  use import ref.Ref
  use "a-contai__types_in_spec".Ada__containers__count_type

  val func:
	  co:ref $list.t -> cu:$cursor.t -> c:Ada__containers__count_type.t ->
	  { $Main.has_element !co cu }
	  unit reads co writes co
	  { $Main.delete_mult (old !co) cu (Ada__containers__count_type.to_int c) !co }

end

module $delete_first
  use $Main
  use $$list
  use $$cursor
  use import ref.Ref
  use "a-contai__types_in_spec".Ada__containers__count_type

  val func:
	  co:ref $list.t -> c:Ada__containers__count_type.t ->
	  { not ($Main.is_empty_ !co) }
	  unit reads co writes co
	  { $Main.delete_mult (old !co) ($Main.first !co) (Ada__containers__count_type.to_int c) !co }

end

module $delete_last
  use $Main
  use $$list
  use $$cursor
  use import ref.Ref
  use "a-contai__types_in_spec".Ada__containers__count_type

  val func:
	  co:ref $list.t -> c:Ada__containers__count_type.t ->
	  { not ($Main.is_empty_ !co) }
	  unit reads co writes co
	  { $Main.delete_mult (old !co) ($Main.last !co) (Ada__containers__count_type.to_int c) !co }

end

module $previous
  use $Main
  use $$list
  use $$cursor

  function log $list.t $cursor.t : $cursor.t

  axiom log_def:
    forall co : $list.t, cu : $cursor.t [log co cu].
      log co cu = $Main.previous_ co cu

  val func:
	  co:$list.t -> cu:$cursor.t ->
	  { cu = $Main.no_element \/ $Main.has_element co cu }
	  $cursor.t
	  { result = $Main.previous_ co cu }

end

module $next
  use $Main
  use $$list
  use $$cursor

  function log $list.t $cursor.t : $cursor.t

  axiom log_def:
    forall co : $list.t, cu : $cursor.t [log co cu].
      log co cu = $Main.next_ co cu

  val func:
	  co:$list.t -> cu:$cursor.t ->
	  { cu = $Main.no_element \/ $Main.has_element co cu }
	  $cursor.t
	  { result = $Main.next_ co cu }

end

module $previous__2
  use $Main
  use $$list
  use $$cursor
  use import ref.Ref

  val func:
	  co:$list.t -> cu:ref $cursor.t ->
	  { !cu = $Main.no_element \/ $Main.has_element co !cu }
	  unit reads cu writes cu
	  { !cu = $Main.previous_ co (old !cu) }

end

module $next__2
  use $Main
  use $$list
  use $$cursor
  use import ref.Ref

  val func:
	  co:$list.t -> cu:ref $cursor.t ->
	  { !cu = $Main.no_element \/ $Main.has_element co !cu }
	  unit reads cu writes cu
	  { !cu = $Main.next_ co (old !cu) }

end

module $first
  use $Main
  use $$list
  use $$cursor

  function log $list.t : $cursor.t

  axiom log_def:
    forall co : $list.t [log co].
      log co = $Main.first co

  val func:
	  co:$list.t ->
	  {  }
	  $cursor.t
	  { result = $Main.first co }

end

module $last
  use $Main
  use $$list
  use $$cursor

  function log $list.t : $cursor.t

  axiom log_def:
    forall co : $list.t [log co ].
      log co = $Main.last co

  val func:
	  co:$list.t ->
	  { }
	  $cursor.t
	  { result = $Main.last co }

end

module $first_element
  use $Main
  use $$list
  use $$cursor
  use $$element_type

  function log $list.t : $element_type.t

  axiom log_def:
    forall co : $list.t [log co].
      log co = $Main.element_ co ($Main.first co)

  val func:
	  co:$list.t ->
	  { not ($Main.is_empty_ co) }
	  $element_type.t
	  { result = $Main.element_ co ($Main.first co) }

end

module $last_element
  use $Main
  use $$list
  use $$cursor
  use $$element_type

  function log $list.t : $element_type.t

  axiom log_def:
    forall co : $list.t [log co ].
      log co = $Main.element_ co ($Main.last co)

  val func:
	  co:$list.t ->
	  { not ($Main.is_empty_ co) }
	  $element_type.t
	  { result = $Main.element_ co ($Main.last co) }

end

module $is_empty
  use $Main
  use $$list

  function log $list.t : bool

  axiom log_def:
    forall co : $list.t [log co ].
      log co = True <-> $Main.is_empty_ co

  val func:
	  co:$list.t ->
	  { }
	  bool
	  { result = True <-> $Main.is_empty_ co }

end

module $find
  use $Main
  use $$list
  use $$cursor
  use $$element_type

  function log $list.t $element_type.t $cursor.t : $cursor.t

  axiom log_def:
    forall co : $list.t, e : $element_type.t, cu : $cursor.t [log co e cu].
      log co e cu = $Main.find co e cu

  val func:
	  co:$list.t -> e : $element_type.t -> cu : $cursor.t ->
	  {cu = $Main.no_element \/ $Main.has_element co cu }
	  $cursor.t
	  { result = $Main.find co e cu }

end

module $left
  use $Main
  use $$list
  use $$cursor

  function log $list.t $cursor.t : $list.t

  axiom log_def:
    forall co : $list.t, cu : $cursor.t [log co cu].
      log co cu = $Main.left_ co cu

  val func:
	  co:$list.t -> cu : $cursor.t ->
	  {cu = $Main.no_element \/ $Main.has_element co cu }
	  $list.t
	  { result = $Main.left_ co cu }
end

module $right
  use $Main
  use $$list
  use $$cursor

  function log $list.t $cursor.t : $list.t

  axiom log_def:
    forall co : $list.t, cu : $cursor.t [log co cu].
      log co cu = $Main.right_ co cu

  val func:
	  co:$list.t -> cu : $cursor.t ->
	  {cu = $Main.no_element \/ $Main.has_element co cu }
	  $list.t
	  { result = $Main.right_ co cu }
end

module $strict_equal
  use $Main
  use $$list
  use $$cursor

  function log $list.t $list.t : bool

  axiom log_def:
    forall co1 co2 : $list.t [log co1 co2].
      log co1 co2 = True <-> $Main.strict_equal co1 co2

  val func:
	  co1:$list.t -> co2 : $list.t ->
	  { }
	  bool
	  { result = True <-> $Main.strict_equal co1 co2 }
end


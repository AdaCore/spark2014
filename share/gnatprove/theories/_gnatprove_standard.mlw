module Main
  (* the module of references is the only compulsory module *)
  use export module ref.Ref

  (* exception used to simulate return statements *)
  exception Gnatprove_Exception___result_exc

  (* ignore blocks of code *)
  function ___ignore 'a : ()

  (* type of standard strings *)
  type __string

  (* special private type *)
  type __private

  (* The type for the heap, and the heap variable. This variable represents
     all effects that we cannot describe more precisely, and that do not
     interfere with other variables, i.e., writes through pointers, aliased
     variables etc. *)
  type __type_of_heap
  val __HEAP : ref __type_of_heap
end

module Integer
  use import int.Int
  use export int.Abs
  use export int.Power
  use int.MinMax
  use int.ComputerDivision
  use int.EuclideanDivision

  function int_max (x y : int) : int = MinMax.max x y

  function int_min (x y : int) : int = MinMax.min x y

  function computer_div (x y : int) : int = ComputerDivision.div x y

  function computer_mod (x y : int) : int = ComputerDivision.mod x y

  function math_div (x y : int) : int = EuclideanDivision.div x y

  function math_mod (x y : int) : int = EuclideanDivision.mod x y

  val computer_div_ : x:int -> y:int ->
    { y<>0 } int { result = computer_div x y }

  val computer_mod_ : x:int -> y:int ->
    { y<>0 } int { result = computer_mod x y }

  val math_mod_ : x:int -> y:int ->
    { y<>0 } int { result = math_mod x y }

  function bool_eq int int : bool
  function bool_ne int int : bool
  function bool_lt int int : bool
  function bool_le int int : bool
  function bool_gt int int : bool
  function bool_ge int int : bool

  axiom bool_eq_axiom:
    forall x:int.
    forall y:int.
      bool_eq x y = True <-> x = y

  axiom bool_ne_axiom:
    forall x:int.
    forall y:int.
      bool_ne x y = True <-> x <> y

  axiom bool_lt_axiom:
    forall x:int.
    forall y:int.
      bool_lt x y = True <-> x < y

  axiom Bool_int__le_axiom:
    forall x:int.
    forall y:int.
      bool_le x y = True <-> x <= y

  axiom bool_gt_axiom:
    forall x:int.
    forall y:int.
        bool_gt x y = True <-> x > y

  axiom bool_ge_axiom:
    forall x:int.
    forall y:int.
        bool_ge x y = True <-> x >= y
end

(* Define real exponentiation as a separate theory until problem with cloning
   in module is solved. *)
theory FloatingExp
  use real.Real
  use import real.RealInfix

  clone export
    int.Exponentiation with type t = real, constant one = Real.one, function (*) = ( *.)

end

module Floating
  use real.Real
  use import real.RealInfix
  use real.Abs as AbsReal
  use floating_point.Rounding
  use floating_point.Single
  use floating_point.Double

  use export FloatingExp

  use real.FromInt

  function real_of_int (x : int) : real = FromInt.from_int x

  (* Boolean comparison functions for reals *)

  function bool_lt real real : bool

  function bool_le real real : bool

  function bool_gt real real : bool

  function bool_ge real real : bool

  function bool_eq real real : bool

  function bool_neq real real : bool

  axiom Bool_real__lt_axiom:
    forall x:real.
    forall y:real.
      bool_lt x y = True <-> x <. y

  axiom Bool_real__le_axiom:
    forall x:real.
    forall y:real.
      bool_le x y = True <-> x <=. y

  axiom Bool_real__gt_axiom:
    forall x:real.
    forall y:real.
        bool_gt x y = True <-> x >. y

  axiom Bool_real__ge_axiom:
    forall x:real.
    forall y:real.
      bool_ge x y = True <-> x >=. y

  axiom Bool_real__eq_axiom:
    forall x:real.
    forall y:real.
      bool_eq x y = True <-> x = y

  axiom Bool_real__neq_axiom:
    forall x:real.
    forall y:real.
       bool_neq x y = True <-> x <> y

  function div_real (x : real) (y : real) : real = x /. y

  val div_real_ : x:real -> y:real ->
    { y<>0.0 } real { result = div_real x y }

end

module Boolean
  use import bool.Bool
  use export bool.Ite
  use import int.Int

  (* Boolean logical connectors, functions for conversion of booleans, etc *)

  function to_int (b : bool) : int =
   if b = True then 1 else 0

  function of_int (i : int) : bool =
   if i = 0 then False else True

  function attr__ATTRIBUTE_LAST : int = 1
  function attr__ATTRIBUTE_FIRST : int = 0

end

module Array__1
  (* The theory of Ada arrays of one dimension *)
  use import int.Int
  use import bool.Bool

  type t 'a

  function access int (t 'a) : 'a
  function update int (t 'a) 'a : (t 'a)

  function bool_eq (t 'a) (t 'a) : bool

  function attr__ATTRIBUTE_LENGTH (t 'a) : int
  function attr__ATTRIBUTE_FIRST (t 'a) : int
  function attr__ATTRIBUTE_LAST (t 'a) : int

   val access_ :
    i : int -> a : t 'a ->
   { (attr__ATTRIBUTE_FIRST a) <= i <= (attr__ATTRIBUTE_LAST a) }
   'a
    { result = access i a }

   val update_ :
    i : int -> a : t 'a -> v : 'a ->
   { attr__ATTRIBUTE_FIRST (a) <= i <= attr__ATTRIBUTE_LAST (a) }
   t 'a
   { result = update i a v }

   axiom accupd_eq:
     forall a:t 'a.
     forall i:int.
     forall v:'a [update i a v].
        access i (update i a v) = v

   axiom accupd_neq:
     forall a:t 'a.
     forall i:int.
     forall j:int.
     forall v:'a [access j (update i a v ) | update i a v, access j a].
       i <> j -> access j (update i a v ) = access j a

   axiom first_update:
     forall a:t 'a.
     forall i:int.
     forall v:'a.
       attr__ATTRIBUTE_FIRST a = attr__ATTRIBUTE_FIRST (update i a v)

   axiom last_update:
     forall a:t 'a.
     forall i:int.
     forall v:'a.
       attr__ATTRIBUTE_LAST a = attr__ATTRIBUTE_LAST (update i a v )

   axiom length_update:
     forall a:t 'a.
     forall i:int.
     forall v:'a.
        attr__ATTRIBUTE_LENGTH a = attr__ATTRIBUTE_LENGTH (update i a v)

   axiom length_non_zero:
     forall a:t 'a.
       attr__ATTRIBUTE_LAST a >= attr__ATTRIBUTE_FIRST a ->
        attr__ATTRIBUTE_LENGTH a =
        attr__ATTRIBUTE_LAST a - attr__ATTRIBUTE_FIRST a + 1

   axiom length_zero:
     forall a:t 'a.
       attr__ATTRIBUTE_LAST a < attr__ATTRIBUTE_FIRST a -> attr__ATTRIBUTE_LENGTH a = 0

   axiom T__ada_array___equal_def:
     forall a:t 'a.
     forall b:t 'a [bool_eq a b].
         ((attr__ATTRIBUTE_LENGTH a = attr__ATTRIBUTE_LENGTH b)
          /\ (forall i:int[access i a].
                (attr__ATTRIBUTE_FIRST a <= i <= attr__ATTRIBUTE_LAST a)
                 ->
                (access i a = access (attr__ATTRIBUTE_FIRST b - attr__ATTRIBUTE_FIRST a + i) b)))
         <-> bool_eq a b = True
end

module Array__2

  use import int.Int
  use import bool.Bool
  (* The theory of Ada arrays of two dimensions *)

  type t 'a

  function access int int (t 'a) : 'a

  function update int int (t 'a) 'a : (t 'a)

  function bool_eq (t 'a) (t 'a) : bool

  function attr__ATTRIBUTE_LENGTH (t 'a) : int
  function attr__ATTRIBUTE_LENGTH_2 (t 'a) : int

  function attr__ATTRIBUTE_FIRST (t 'a) : int
  function attr__ATTRIBUTE_FIRST_2 (t 'a) : int

  function attr__ATTRIBUTE_LAST (t 'a) : int
  function attr__ATTRIBUTE_LAST_2 (t 'a) : int

   val access_ :
    i : int -> j : int -> a : t 'a ->
    { attr__ATTRIBUTE_FIRST a <= i <= attr__ATTRIBUTE_LAST a /\
      attr__ATTRIBUTE_FIRST_2 a <= j <= attr__ATTRIBUTE_LAST_2 a }
    'a
    { result = access i j a }

   val update_ :
    i : int -> j : int -> a : t 'a -> v : 'a ->
    { attr__ATTRIBUTE_FIRST a <= i <= attr__ATTRIBUTE_LAST a /\
      attr__ATTRIBUTE_FIRST_2 a <= j <= attr__ATTRIBUTE_LAST_2 a }
    t 'a
    { result = update i j a v }

  axiom accupd_eq:
    forall a:t 'a.
    forall i:int. forall j :int.
    forall v:'a [update i j a v].
       access i j (update i j a v) = v

  axiom accupd_neq:
    forall a:t 'a.
    forall i1:int.
    forall i2:int.
    forall j1:int.
    forall j2:int.
    forall v:'a [access i2 j2 (update i1 j1 a v ) | update i1 j1 a v, access i2 j2 a].
      (i1 <> i2 \/ j1 <> j2) ->
       access i2 j2 (update i1 j1 a v ) = access i2 j2 a

  axiom first_update:
    forall a:t 'a.
    forall i:int. forall j : int.
    forall v:'a.
      attr__ATTRIBUTE_FIRST a = attr__ATTRIBUTE_FIRST (update i j a v)

  axiom first_update_2:
    forall a:t 'a.
    forall i:int. forall j : int.
    forall v:'a.
      attr__ATTRIBUTE_FIRST_2 a = attr__ATTRIBUTE_FIRST_2 (update i j a v)

  axiom last_update:
    forall a:t 'a.
    forall i:int. forall j : int.
    forall v:'a.
      attr__ATTRIBUTE_LAST a = attr__ATTRIBUTE_LAST (update i j a v )

  axiom last_update_2:
    forall a:t 'a.
    forall i:int. forall j : int.
    forall v:'a.
      attr__ATTRIBUTE_LAST_2 a = attr__ATTRIBUTE_LAST_2 (update i j a v )

  axiom length_update:
    forall a:t 'a.
    forall i:int. forall j : int.
    forall v:'a.
       attr__ATTRIBUTE_LENGTH a = attr__ATTRIBUTE_LENGTH (update i j a v)

  axiom length_update_2:
    forall a:t 'a.
    forall i:int. forall j : int.
    forall v:'a.
       attr__ATTRIBUTE_LENGTH_2 a = attr__ATTRIBUTE_LENGTH_2 (update i j a v)

  axiom length_non_zero:
    forall a:t 'a.
      attr__ATTRIBUTE_LAST a >= attr__ATTRIBUTE_FIRST a ->
       attr__ATTRIBUTE_LENGTH a = attr__ATTRIBUTE_LAST a - attr__ATTRIBUTE_FIRST a + 1

  axiom length_zero:
    forall a:t 'a.
      attr__ATTRIBUTE_LAST a < attr__ATTRIBUTE_FIRST a -> attr__ATTRIBUTE_LENGTH a = 0

  axiom length_non_zero_2:
    forall a:t 'a.
      attr__ATTRIBUTE_LAST_2 a >= attr__ATTRIBUTE_FIRST_2 a ->
       attr__ATTRIBUTE_LENGTH_2 a = attr__ATTRIBUTE_LAST_2 a - attr__ATTRIBUTE_FIRST_2 a + 1

  axiom length_zero_2:
    forall a:t 'a.
      attr__ATTRIBUTE_LAST_2 a < attr__ATTRIBUTE_FIRST_2 a ->
      attr__ATTRIBUTE_LENGTH_2 a = 0

  axiom T__ada_array_2___equal_def:
    forall a:t 'a.
    forall b:t 'a [bool_eq a b].
        ((attr__ATTRIBUTE_LENGTH a = attr__ATTRIBUTE_LENGTH b)
         /\ (attr__ATTRIBUTE_LENGTH_2 a = attr__ATTRIBUTE_LENGTH_2 b)
         /\
         (forall i:int. forall j : int [access i j a].
               (attr__ATTRIBUTE_FIRST a <= i <= attr__ATTRIBUTE_LAST a)
                ->
               (attr__ATTRIBUTE_FIRST_2 a <= j <= attr__ATTRIBUTE_LAST_2 a)
                ->
               (access i j a = access
                  (attr__ATTRIBUTE_FIRST b - attr__ATTRIBUTE_FIRST a + i)
                  (attr__ATTRIBUTE_FIRST_2 b - attr__ATTRIBUTE_FIRST_2 a + j)
                  b)))
        <-> bool_eq a b = True

end

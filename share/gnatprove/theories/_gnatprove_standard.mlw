module Main
  (* the module of references is needed in all modules *)
  use export ref.Ref
  (* dito for boolean functions *)
  use export bool.Bool
  use export "_gnatprove_standard_th".Main

  (* exception used to simulate return statements *)
  exception Return__exc

  (* The type for the heap, and the heap variable. This variable represents
     all effects that we cannot describe more precisely, and that do not
     interfere with other variables, i.e., writes through pointers, aliased
     variables etc. *)
  type __type_of_heap
  val __HEAP : ref __type_of_heap
end

module Integer
  use import int.Int
  use export int.Abs
  use export int.Power

  use export _gnatprove_standard_th.Integer_Func

  val computer_div_ (x:int) (y:int) : int
     requires { y<>0 }
     ensures { result = computer_div x y }

  val computer_mod_ (x:int) (y:int) : int
     requires { y<>0 }
     ensures{ result = computer_mod x y }

  val math_mod_ (x:int) (y:int) : int
     requires { y<>0 }
     ensures { result = math_mod x y }

end

(* Define real exponentiation as a separate theory until problem with cloning
   in module is solved. *)
theory FloatingExp
  use real.Real
  use import real.RealInfix

  clone export
    int.Exponentiation with type t = real, constant one = Real.one, function (*) = ( *.)

end

module Floating
  use real.Real
  use import real.RealInfix
  use real.Abs as AbsReal
  use export real.Truncate

  use export FloatingExp

  use real.FromInt

  function real_of_int (x : int) : real = FromInt.from_int x

  function round real : int

  axiom Round_down:
    forall x:real. x -. real_of_int (floor x) <. 0.5 -> round (x) = floor (x)

  axiom Round_up:
    forall x:real. real_of_int (ceil x) -. x <. 0.5 -> round (x) = ceil (x)

  axiom Round_neg_tie:
    forall x:real.
      x -. real_of_int (floor x) = 0.5 /\ x <. 0.0 -> round (x) = floor (x)

  axiom Round_pos_tie:
    forall x:real.
      real_of_int (ceil x) -. x = 0.5 /\ x >. 0.0 -> round (x) = ceil (x)

  (* Boolean comparison functions for reals *)

  function bool_lt real real : bool

  function bool_le real real : bool

  function bool_gt real real : bool

  function bool_ge real real : bool

  function bool_eq real real : bool

  function bool_neq real real : bool

  axiom Bool_real__lt_axiom:
    forall x:real.
    forall y:real.
      bool_lt x y = True <-> x <. y

  axiom Bool_real__le_axiom:
    forall x:real.
    forall y:real.
      bool_le x y = True <-> x <=. y

  axiom Bool_real__gt_axiom:
    forall x:real.
    forall y:real.
        bool_gt x y = True <-> x >. y

  axiom Bool_real__ge_axiom:
    forall x:real.
    forall y:real.
      bool_ge x y = True <-> x >=. y

  axiom Bool_real__eq_axiom:
    forall x:real.
    forall y:real.
      bool_eq x y = True <-> x = y

  axiom Bool_real__neq_axiom:
    forall x:real.
    forall y:real.
       bool_neq x y = True <-> x <> y

  function div_real (x : real) (y : real) : real = x /. y

  val div_real_ (x:real) (y:real) : real
    requires { y<>0.0 }
    ensures { result = div_real x y }

end

module Boolean
  use import bool.Bool
  use export bool.Ite
  use import int.Int

  (* Boolean logical connectors, functions for conversion of booleans, etc *)

  function to_int (b : bool) : int =
   if b = True then 1 else 0

  function of_int (i : int) : bool =
   if i = 0 then False else True

  function attr__ATTRIBUTE_LAST : int = 1
  function attr__ATTRIBUTE_FIRST : int = 0

end

module Array__1
  (* The theory of Ada arrays of one dimension *)
  use import int.Int
  use import bool.Bool

  use export _gnatprove_standard_th.Array__1__Func

   val access_ (i : int) (a : t 'a) : 'a
      requires { (attr__ATTRIBUTE_FIRST a) <= i <= (attr__ATTRIBUTE_LAST a) }
      ensures { result = access i a }

   val update_ (i : int) (a : t 'a) (v : 'a) : t 'a
      requires { attr__ATTRIBUTE_FIRST (a) <= i <= attr__ATTRIBUTE_LAST (a) }
      ensures { result = update i a v }

end

module Array__2

  use import int.Int
  use import bool.Bool
  (* The theory of Ada arrays of two dimensions *)

  use export _gnatprove_standard_th.Array__2__Func

   val access_ (i : int) (j : int) (a : t 'a) : 'a
    requires { attr__ATTRIBUTE_FIRST a <= i <= attr__ATTRIBUTE_LAST a /\
               attr__ATTRIBUTE_FIRST_2 a <= j <= attr__ATTRIBUTE_LAST_2 a }
    ensures  { result = access i j a }

   val update_ (i : int) (j : int) (a : t 'a) (v : 'a) : t 'a
    requires { attr__ATTRIBUTE_FIRST a <= i <= attr__ATTRIBUTE_LAST a /\
               attr__ATTRIBUTE_FIRST_2 a <= j <= attr__ATTRIBUTE_LAST_2 a }
    ensures { result = update i j a v }

end

module Array__3

  use import int.Int
  use import bool.Bool
  (* The theory of Ada arrays of three dimensions *)

  use export _gnatprove_standard_th.Array__3__Func

   val access_ (i : int) (j : int) (k : int) (a : t 'a) : 'a
    requires { attr__ATTRIBUTE_FIRST a <= i <= attr__ATTRIBUTE_LAST a /\
               attr__ATTRIBUTE_FIRST_2 a <= j <= attr__ATTRIBUTE_LAST_2 a /\
               attr__ATTRIBUTE_FIRST_3 a <= k <= attr__ATTRIBUTE_LAST_3 a
               }
    ensures  { result = access i j k a }

   val update_ (i : int) (j : int) (k : int) (a : t 'a) (v : 'a) : t 'a
    requires { attr__ATTRIBUTE_FIRST a <= i <= attr__ATTRIBUTE_LAST a /\
               attr__ATTRIBUTE_FIRST_2 a <= j <= attr__ATTRIBUTE_LAST_2 a /\
               attr__ATTRIBUTE_FIRST_3 a <= k <= attr__ATTRIBUTE_LAST_3 a
               }
    ensures  { result = update i j k a v }

end

module Array__4

  use import int.Int
  use import bool.Bool
  (* The theory of Ada arrays of four dimensions *)

  use export _gnatprove_standard_th.Array__4__Func

   val access_ (i : int) (j : int) (k : int) (l : int) (a : t 'a) : 'a
    requires { attr__ATTRIBUTE_FIRST a <= i <= attr__ATTRIBUTE_LAST a /\
               attr__ATTRIBUTE_FIRST_2 a <= j <= attr__ATTRIBUTE_LAST_2 a /\
               attr__ATTRIBUTE_FIRST_3 a <= k <= attr__ATTRIBUTE_LAST_3 a /\
               attr__ATTRIBUTE_FIRST_4 a <= l <= attr__ATTRIBUTE_LAST_4 a
               }
    ensures { result = access i j k l a }

   val update_ (i : int) (j : int) (k : int) (l : int) (a : t 'a) (v : 'a) : t 'a
    requires { attr__ATTRIBUTE_FIRST a <= i <= attr__ATTRIBUTE_LAST a /\
               attr__ATTRIBUTE_FIRST_2 a <= j <= attr__ATTRIBUTE_LAST_2 a /\
               attr__ATTRIBUTE_FIRST_3 a <= k <= attr__ATTRIBUTE_LAST_3 a /\
               attr__ATTRIBUTE_FIRST_4 a <= l <= attr__ATTRIBUTE_LAST_4 a
               }
    ensures  { result = update i j k l a v }

end

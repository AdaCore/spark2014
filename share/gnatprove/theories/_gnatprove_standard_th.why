theory Array__1__Type

  (* We need to define these types in a special theory, so that the string
  type can be defined as early as possible. We only define the type here,
  axioms and functions on that type are defined elsewhere. *)

  type map 'a

  type t 'a =
   { elts   : map 'a;
     offset : int;
     first  : int;
     last   : int }

end

theory Main

  use Array__1__Type

  (* ignore blocks of code *)
  function ___ignore 'a : ()

  (* type of standard characters *)
  type __character

  (* special private type *)
  type __private

  type range_type

  (* Here we define the string type *)
  type __string = 
  { elts : (Array__1__Type.map __character); offset : int; rt : range_type }

end

theory Integer_Func
  use import int.Int
  use import bool.Bool
  use int.MinMax
  use int.ComputerDivision
  use int.EuclideanDivision

  function bool_eq int int : bool
  function bool_ne int int : bool
  function bool_lt int int : bool
  function bool_le int int : bool
  function bool_gt int int : bool
  function bool_ge int int : bool

  function int_max (x y : int) : int = MinMax.max x y

  function int_min (x y : int) : int = MinMax.min x y

  function computer_div (x y : int) : int = ComputerDivision.div x y

  function computer_mod (x y : int) : int = ComputerDivision.mod x y

  function math_div (x y : int) : int = EuclideanDivision.div x y

  function math_mod (x y : int) : int = EuclideanDivision.mod x y

  axiom bool_eq_axiom:
    forall x:int.
    forall y:int.
      bool_eq x y = True <-> x = y

  axiom bool_ne_axiom:
    forall x:int.
    forall y:int.
      bool_ne x y = True <-> x <> y

  axiom bool_lt_axiom:
    forall x:int.
    forall y:int.
      bool_lt x y = True <-> x < y

  axiom Bool_int__le_axiom:
    forall x:int.
    forall y:int.
      bool_le x y = True <-> x <= y

  axiom bool_gt_axiom:
    forall x:int.
    forall y:int.
        bool_gt x y = True <-> x > y

  axiom bool_ge_axiom:
    forall x:int.
    forall y:int.
        bool_ge x y = True <-> x >= y

end

theory Array__1__Func
  use import int.Int
  use import bool.Bool
  use export Array__1__Type

  function get (map 'a) int : 'a
  function set (map 'a) int 'a : map 'a

  axiom Select_eq :
    forall m : map 'a. forall i j : int.
    forall a : 'a [get (set m i a) j].
    i = j -> get (set m i a) j = a

  axiom Select_neq :
    forall m : map 'a. forall i j : int.
    forall a : 'a [get (set m i a) j| set m i a, get m j].
    i <> j -> get (set m i a) j = get m j

  function attr__ATTRIBUTE_LENGTH (x : t 'a) : int =
      if x.last >= x.first then x.last - x.first + 1 else 0

  function attr__ATTRIBUTE_FIRST (x : t 'a) : int = x.first
  function attr__ATTRIBUTE_LAST (x : t 'a) : int = x.last

  function access "inline" (i : int) (x : t 'a) : 'a =
     get x.elts (i + x.offset - x.first)
  function update "inline" (i : int) (x : t 'a) (v : 'a) : (t 'a) =
   { x with elts = set x.elts (i + x.offset - x.first) v }

  function bool_eq (t 'a) (t 'a) : bool

   axiom T__ada_array___equal_def:
     forall a:t 'a.
     forall b:t 'a [bool_eq a b].
         ((attr__ATTRIBUTE_LENGTH a = attr__ATTRIBUTE_LENGTH b)
          /\ (forall i:int[access i a].
                (attr__ATTRIBUTE_FIRST a <= i <= attr__ATTRIBUTE_LAST a)
                 ->
                (access i a = access (attr__ATTRIBUTE_FIRST b - attr__ATTRIBUTE_FIRST a + i) b)))
         <-> bool_eq a b = True
end

theory Array__2__Func

  use import int.Int
  use import bool.Bool
  (* The theory of Ada arrays of two dimensions *)

  type map 'a

  function get int int (map 'a) : 'a

  function set int int (map 'a) 'a : (map 'a)

  axiom accupd_eq:
    forall a:map 'a.
    forall i:int. forall j :int.
    forall v:'a [set i j a v].
       get i j (set i j a v) = v

  axiom accupd_neq:
    forall a:map 'a.
    forall i1:int.
    forall i2:int.
    forall j1:int.
    forall j2:int.
    forall v:'a [get i2 j2 (set i1 j1 a v ) | set i1 j1 a v, get i2 j2 a].
      (i1 <> i2 \/ j1 <> j2) ->
       get i2 j2 (set i1 j1 a v ) = get i2 j2 a

  type t 'a =
   { elts     : map 'a;
     offset   : int;
     offset_2 : int;
     first    : int;
     last     : int;
     first_2  : int;
     last_2   : int;
   }

  function access (i : int) (j : int) (x : t 'a) : 'a =
     get (i + x.offset - x.first) (j + x.offset_2 - x.first_2) x.elts
  function update (i : int) (j : int) (x : t 'a) (v : 'a) : (t 'a) =
   { x with elts = set (i + x.offset - x.first) (j + x.offset_2 - x.first_2) x.elts v }

  function bool_eq (t 'a) (t 'a) : bool

  function attr__ATTRIBUTE_LENGTH (x : t 'a) : int =
      if x.last >= x.first then x.last - x.first + 1 else 0
  function attr__ATTRIBUTE_LENGTH_2 (x : t 'a) : int =
      if x.last_2 >= x.first_2 then x.last_2 - x.first_2 + 1 else 0

  function attr__ATTRIBUTE_FIRST (x : t 'a) : int = x.first
  function attr__ATTRIBUTE_FIRST_2 (x : t 'a) : int = x.first_2

  function attr__ATTRIBUTE_LAST (x : t 'a) : int = x.last
  function attr__ATTRIBUTE_LAST_2 (x : t 'a) : int = x.last_2

  axiom T__ada_array_2___equal_def:
    forall a:t 'a.
    forall b:t 'a [bool_eq a b].
        ((attr__ATTRIBUTE_LENGTH a = attr__ATTRIBUTE_LENGTH b)
         /\ (attr__ATTRIBUTE_LENGTH_2 a = attr__ATTRIBUTE_LENGTH_2 b)
         /\
         (forall i:int. forall j : int [access i j a].
               (attr__ATTRIBUTE_FIRST a <= i <= attr__ATTRIBUTE_LAST a)
                ->
               (attr__ATTRIBUTE_FIRST_2 a <= j <= attr__ATTRIBUTE_LAST_2 a)
                ->
               (access i j a = access
                  (attr__ATTRIBUTE_FIRST b - attr__ATTRIBUTE_FIRST a + i)
                  (attr__ATTRIBUTE_FIRST_2 b - attr__ATTRIBUTE_FIRST_2 a + j)
                  b)))
        <-> bool_eq a b = True
end

theory Array__3__Func

  use import int.Int
  use import bool.Bool
  (* The theory of Ada arrays of two dimensions *)

  type map 'a

  function get int int int (map 'a) : 'a

  function set int int int (map 'a) 'a : (map 'a)

  axiom accupd_eq:
    forall a:map 'a.
    forall i:int. forall j :int. forall k : int.
    forall v:'a [set i j k a v].
       get i j k (set i j k a v) = v

  axiom accupd_neq:
    forall a:map 'a.
    forall i1:int.
    forall i2:int.
    forall j1:int.
    forall j2:int.
    forall k1:int.
    forall k2:int.
    forall v:'a [get i2 j2 k2 (set i1 j1 k1 a v ) | set i1 j1 k1 a v, get i2 j2 k2 a].
      (i1 <> i2 \/ j1 <> j2 \/ k1 <> k2) ->
       get i2 j2 k2 (set i1 j1 k1 a v ) = get i2 j2 k2 a

  type t 'a =
   { elts     : map 'a;
     offset   : int;
     offset_2 : int;
     offset_3 : int;
     first    : int;
     last     : int;
     first_2  : int;
     last_2   : int;
     first_3  : int;
     last_3   : int;
   }

  function access (i : int) (j : int) (k : int) (x : t 'a) : 'a =
     get (i + x.offset - x.first) (j + x.offset_2 - x.first_2) (k + x.offset_3 - x.first_3) x.elts

  function update (i : int) (j : int) (k : int) (x : t 'a) (v : 'a) : (t 'a) =
   { x with elts = set (i + x.offset - x.first) (j + x.offset_2 - x.first_2) (k + x.offset_3 - x.first_3) x.elts v }

  function bool_eq (t 'a) (t 'a) : bool

  function attr__ATTRIBUTE_LENGTH (x : t 'a) : int =
      if x.last >= x.first then x.last - x.first + 1 else 0
  function attr__ATTRIBUTE_LENGTH_2 (x : t 'a) : int =
      if x.last_2 >= x.first_2 then x.last_2 - x.first_2 + 1 else 0
  function attr__ATTRIBUTE_LENGTH_3 (x : t 'a) : int =
      if x.last_3 >= x.first_3 then x.last_3 - x.first_3 + 1 else 0

  function attr__ATTRIBUTE_FIRST (x : t 'a) : int = x.first
  function attr__ATTRIBUTE_FIRST_2 (x : t 'a) : int = x.first_2
  function attr__ATTRIBUTE_FIRST_3 (x : t 'a) : int = x.first_3

  function attr__ATTRIBUTE_LAST (x : t 'a) : int = x.last
  function attr__ATTRIBUTE_LAST_2 (x : t 'a) : int = x.last_2
  function attr__ATTRIBUTE_LAST_3 (x : t 'a) : int = x.last_3

  axiom T__ada_array_2___equal_def:
    forall a:t 'a.
    forall b:t 'a [bool_eq a b].
        ((attr__ATTRIBUTE_LENGTH a = attr__ATTRIBUTE_LENGTH b)
         /\ (attr__ATTRIBUTE_LENGTH_2 a = attr__ATTRIBUTE_LENGTH_2 b)
         /\ (attr__ATTRIBUTE_LENGTH_3 a = attr__ATTRIBUTE_LENGTH_3 b)
         /\
         (forall i:int. forall j : int . forall k : int [access i j k a].
               (attr__ATTRIBUTE_FIRST a <= i <= attr__ATTRIBUTE_LAST a)
                ->
               (attr__ATTRIBUTE_FIRST_2 a <= j <= attr__ATTRIBUTE_LAST_2 a)
                ->
               (attr__ATTRIBUTE_FIRST_3 a <= k <= attr__ATTRIBUTE_LAST_3 a)
                ->
               (access i j k a = access
                  (attr__ATTRIBUTE_FIRST b - attr__ATTRIBUTE_FIRST a + i)
                  (attr__ATTRIBUTE_FIRST_2 b - attr__ATTRIBUTE_FIRST_2 a + j)
                  (attr__ATTRIBUTE_FIRST_3 b - attr__ATTRIBUTE_FIRST_3 a + k)
                  b)))
        <-> bool_eq a b = True
end

theory Array__4__Func

  use import int.Int
  use import bool.Bool
  (* The theory of Ada arrays of two dimensions *)

  type map 'a

  function get int int int int (map 'a) : 'a

  function set int int int int (map 'a) 'a : (map 'a)

  axiom accupd_eq:
    forall a:map 'a.
    forall i:int. forall j :int. forall k : int. forall l : int.
    forall v:'a [set i j k l a v].
       get i j k l (set i j k l a v) = v

  axiom accupd_neq:
    forall a:map 'a.
    forall i1:int.
    forall i2:int.
    forall j1:int.
    forall j2:int.
    forall k1:int.
    forall k2:int.
    forall l1:int.
    forall l2:int.
    forall v:'a [get i2 j2 k2 l2 (set i1 j1 k1 l1 a v ) | set i1 j1 k1 l1 a v, get i2 j2 k2 l2 a].
      (i1 <> i2 \/ j1 <> j2 \/ k1 <> k2 \/ l1 <> l2) ->
       get i2 j2 k2 l2 (set i1 j1 k1 l1 a v ) = get i2 j2 k2 l2 a

  type t 'a =
   { elts     : map 'a;
     offset   : int;
     offset_2 : int;
     offset_3 : int;
     offset_4 : int;
     first    : int;
     last     : int;
     first_2  : int;
     last_2   : int;
     first_3  : int;
     last_3   : int;
     first_4  : int;
     last_4   : int;
   }

  function access (i : int) (j : int) (k : int) (l : int) (x : t 'a) : 'a =
     get (i + x.offset - x.first) (j + x.offset_2 - x.first_2) (k + x.offset_3 - x.first_3) (l + x.offset_4 - x.first_4) x.elts

  function update (i : int) (j : int) (k : int) (l : int) (x : t 'a) (v : 'a) : (t 'a) =
   { x with elts = set (i + x.offset - x.first) (j + x.offset_2 - x.first_2) (k + x.offset_3 - x.first_3) (l + x.offset_4 - x.first_4) x.elts v }

  function bool_eq (t 'a) (t 'a) : bool

  function attr__ATTRIBUTE_LENGTH (x : t 'a) : int =
      if x.last >= x.first then x.last - x.first + 1 else 0
  function attr__ATTRIBUTE_LENGTH_2 (x : t 'a) : int =
      if x.last_2 >= x.first_2 then x.last_2 - x.first_2 + 1 else 0
  function attr__ATTRIBUTE_LENGTH_3 (x : t 'a) : int =
      if x.last_3 >= x.first_3 then x.last_3 - x.first_3 + 1 else 0
  function attr__ATTRIBUTE_LENGTH_4 (x : t 'a) : int =
      if x.last_4 >= x.first_4 then x.last_4 - x.first_4 + 1 else 0

  function attr__ATTRIBUTE_FIRST (x : t 'a) : int = x.first
  function attr__ATTRIBUTE_FIRST_2 (x : t 'a) : int = x.first_2
  function attr__ATTRIBUTE_FIRST_3 (x : t 'a) : int = x.first_3
  function attr__ATTRIBUTE_FIRST_4 (x : t 'a) : int = x.first_4

  function attr__ATTRIBUTE_LAST (x : t 'a) : int = x.last
  function attr__ATTRIBUTE_LAST_2 (x : t 'a) : int = x.last_2
  function attr__ATTRIBUTE_LAST_3 (x : t 'a) : int = x.last_3
  function attr__ATTRIBUTE_LAST_4 (x : t 'a) : int = x.last_4

  axiom T__ada_array_2___equal_def:
    forall a:t 'a.
    forall b:t 'a [bool_eq a b].
        ((attr__ATTRIBUTE_LENGTH a = attr__ATTRIBUTE_LENGTH b)
         /\ (attr__ATTRIBUTE_LENGTH_2 a = attr__ATTRIBUTE_LENGTH_2 b)
         /\ (attr__ATTRIBUTE_LENGTH_3 a = attr__ATTRIBUTE_LENGTH_3 b)
         /\ (attr__ATTRIBUTE_LENGTH_4 a = attr__ATTRIBUTE_LENGTH_4 b)
         /\
         (forall i:int. forall j : int . forall k : int. forall l : int [access i j k l a].
               (attr__ATTRIBUTE_FIRST a <= i <= attr__ATTRIBUTE_LAST a)
                ->
               (attr__ATTRIBUTE_FIRST_2 a <= j <= attr__ATTRIBUTE_LAST_2 a)
                ->
               (attr__ATTRIBUTE_FIRST_3 a <= k <= attr__ATTRIBUTE_LAST_3 a)
                ->
               (attr__ATTRIBUTE_FIRST_4 a <= l <= attr__ATTRIBUTE_LAST_4 a)
                ->
               (access i j k l a = access
                  (attr__ATTRIBUTE_FIRST b - attr__ATTRIBUTE_FIRST a + i)
                  (attr__ATTRIBUTE_FIRST_2 b - attr__ATTRIBUTE_FIRST_2 a + j)
                  (attr__ATTRIBUTE_FIRST_3 b - attr__ATTRIBUTE_FIRST_3 a + k)
                  (attr__ATTRIBUTE_FIRST_4 b - attr__ATTRIBUTE_FIRST_4 a + l)
                  b)))
        <-> bool_eq a b = True
end

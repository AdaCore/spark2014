module Ada__containers__formal_ordered_sets__witness
  use import real.Real
  use "ada__containers__formal_ordered_sets__args".Ada__containers__formal_ordered_sets__element_type
  use "ada__containers__formal_ordered_sets__args".Ada__containers__formal_ordered_sets__olt

  function witness Ada__containers__formal_ordered_sets__element_type.base_type : real

  axiom olt_witness :
    (forall k1  k2 : Ada__containers__formal_ordered_sets__element_type.base_type [Ada__containers__formal_ordered_sets__olt.olt k1 k2].
	Real.(<) (witness k1) (witness k2) <-> Ada__containers__formal_ordered_sets__olt.olt k1 k2 = True)
end

module Ada__containers__formal_ordered_sets__set
  use import int.Int
  use import "_gnatprove_standard".Main
  use "a-contai__types_in_spec".Ada__containers__hash_type
  use "a-contai__types_in_spec".Ada__containers__count_type

  type set

  function rec__capacity set : Ada__containers__count_type.count_type

   function capacity  (co : set) : int =
          Ada__containers__count_type.to_int (rec__capacity co)

  function to_base "inline" (co : set) : set = co

  function of_base "inline" (co : set) : set = co
end

module Ada__containers__formal_ordered_sets__length
  use import int.Int
  use import "_gnatprove_standard".Main
  use "a-contai__types_in_spec".Ada__containers__count_type
  use import Ada__containers__formal_ordered_sets__set

  function length set : Ada__containers__count_type.count_type

  function length_ "inline" (co : set) : int =
    Ada__containers__count_type.to_int (length co)

  axiom length_range:
    forall co:set [length co]. 0 <= length_ co <= capacity co

  val length (co : set) :  Ada__containers__count_type.count_type
     ensures { result = length co }
end

module Ada__containers__formal_ordered_sets__cursor
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_ordered_sets__args".Ada__containers__formal_ordered_sets__element_type
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length

  type cursor

  function position set cursor : int

  function position_inv set int : cursor

  axiom position_gte_zero:
    forall co:set, cu:cursor [position co cu].
        length_ co >= position co cu >= 0

  axiom position_eq1:
   forall co:set, i :int [position co (position_inv co i)]. 0 < i <= length_ co -> 
              position co (position_inv co i) = i

  axiom position_eq2:
    forall co:set, cu:cursor [position co cu].
          position co cu > 0 -> position_inv co (position co cu) = cu
end

module Ada__containers__formal_ordered_sets__no_element
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor

  function no_element : cursor

  axiom position_no_element:
    forall co:set [position co no_element]. position co no_element = 0
end

module Ada__containers__formal_ordered_sets__empty_set
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length

  function empty_set : set

  axiom Empty_is_empty: length_ empty_set = 0
end

module Ada__containers__formal_ordered_sets__is_empty
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length

  function is_empty set : bool

  axiom is_empty:
    forall co:set [is_empty (co)]. 
          is_empty (co) = True <-> length_ co = 0

  val is_empty (co:set) : bool
     ensures  { result = is_empty co }
end

module Ada__containers__formal_ordered_sets__element
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_ordered_sets__args".Ada__containers__formal_ordered_sets__element_type
  use import Ada__containers__formal_ordered_sets__witness
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor

  function element set cursor : Ada__containers__formal_ordered_sets__element_type.element_type

  axiom ordered:
    forall s:set, cu1 cu2:cursor [element s cu2, element s cu1].
       position s cu1 > 0 -> position s cu2 > 0 ->
         (position s cu1 > position s cu2 <-> Real.(>) (witness (Ada__containers__formal_ordered_sets__element_type.to_base (element s cu1))) (witness (Ada__containers__formal_ordered_sets__element_type.to_base (element s cu2))))

  val element (co:set) (cu:cursor) : Ada__containers__formal_ordered_sets__element_type.element_type
     requires { position co cu > 0 }
     ensures  { result = element co cu }
end

module Ada__containers__formal_ordered_sets__previous
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__no_element

  function previous set cursor : cursor

  axiom previous_in:
    forall co:set, cu:cursor [previous co cu].
	(position co cu > 1 \/ position co (previous co cu) > 0) ->
	position co (previous co cu) = position co cu - 1

  axiom previous_ext:
    forall co:set, cu:cursor [previous co cu].
        (position co cu = 1 \/ cu = no_element) -> previous co cu = no_element

  val previous (co:set) (cu:cursor) : cursor
     requires { cu = no_element \/ position co cu > 0 }
     ensures  { result = previous co cu }
end

module Ada__containers__formal_ordered_sets__previous__2
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__no_element
  use import Ada__containers__formal_ordered_sets__previous

  val previous__2 (co:set) (cu:ref cursor) : unit
     requires { !cu = no_element \/ position co !cu > 0 }
     writes     { cu }
     reads      { cu }
     ensures  { !cu = previous co (old !cu) }
end

module Ada__containers__formal_ordered_sets__next
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__no_element

  function next set cursor : cursor

  axiom next_in:
    forall co:set, cu:cursor [next co cu].
	(length_ co > position co cu > 0 \/ position co (next co cu) > 0) ->
	position co (next co cu) = position co cu + 1

  axiom next_ext:
    forall co:set, cu:cursor [next co cu].
        (position co cu = length_ co \/ cu = no_element) -> next co cu = no_element

  val next (co:set) (cu:cursor) : cursor
     requires { cu = no_element \/ position co cu > 0 }
     ensures  { result = next co cu }
end

module Ada__containers__formal_ordered_sets__next__2
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__no_element
  use import Ada__containers__formal_ordered_sets__next

  val next__2 (co:set) (cu:ref cursor) : unit
     requires { !cu = no_element \/ position co !cu > 0 }
     writes     { cu }
     reads      { cu }
     ensures  { !cu = next co (old !cu) }
end

module Ada__containers__formal_ordered_sets__last
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__no_element

  function last set : cursor

  axiom last_empty:
    forall co:set [last co]. length_ co = 0 <-> last co = no_element

  axiom last_gen:
    forall co:set [last co]. length_ co = position co (last co)

  val last (co:set) : cursor
     ensures  { result = last co }
end

module Ada__containers__formal_ordered_sets__first
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__no_element

  function first set : cursor

  axiom first_empty:
    forall co:set [first co]. length_ co = 0 <-> first co = no_element

  axiom first_gen:
    forall co:set [first co]. length_ co > 0 -> position co (first co) = 1

  val first (co:set) : cursor
     ensures  { result = first co }
end

module Ada__containers__formal_ordered_sets__first_element
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_ordered_sets__args".Ada__containers__formal_ordered_sets__element_type
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__first
  use import Ada__containers__formal_ordered_sets__element

  function first_element (co:set) : Ada__containers__formal_ordered_sets__element_type.element_type = element co (first co)

  val first_element (co:set) : Ada__containers__formal_ordered_sets__element_type.element_type
     requires { length_ co > 0 }
     ensures  { result = element co (first co) }
end

module Ada__containers__formal_ordered_sets__last_element
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_ordered_sets__args".Ada__containers__formal_ordered_sets__element_type
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__last
  use import Ada__containers__formal_ordered_sets__element

  function last_element (co:set) : Ada__containers__formal_ordered_sets__element_type.element_type = element co (last co)

  val last_element (co:set) : Ada__containers__formal_ordered_sets__element_type.element_type
     requires { length_ co > 0 }
     ensures  { result = element co (last co) }
end

module Ada__containers__formal_ordered_sets__find
  use import int.Int
  use import "_gnatprove_standard".Main
  use  "ada__containers__formal_ordered_sets__args".Ada__containers__formal_ordered_sets__element_type
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__witness
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__no_element
  use import Ada__containers__formal_ordered_sets__element

  function find_ set real : cursor
  
  predicate find__ (co : set) (i : real) (cu : cursor) =
    (cu = (no_element  : cursor) /\
      (forall cun:cursor.
        position co cun >  0 ->
         witness (Ada__containers__formal_ordered_sets__element_type.to_base (element co cun)) <> i)) \/
     (position co cu > 0 /\
      witness (Ada__containers__formal_ordered_sets__element_type.to_base (element co cu)) = i)
  
  axiom Find_find_val:
    (forall co:set.
      (forall i:real.
        ((find__ co i (find_ co i)) /\
         ((length_ co = 0) -> (find_ co i = no_element )))))

  function find "inline" (co : set) (e:Ada__containers__formal_ordered_sets__element_type.base_type) : cursor =
  find_ co (witness e)

  val find (co:set) (e:Ada__containers__formal_ordered_sets__element_type.base_type)  : cursor
     ensures  { result = find co e }
end

module Ada__containers__formal_ordered_sets__ceiling
  use import int.Int
  use import "_gnatprove_standard".Main
  use  "ada__containers__formal_ordered_sets__args".Ada__containers__formal_ordered_sets__element_type
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__witness
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__no_element
  use import Ada__containers__formal_ordered_sets__last
  use import Ada__containers__formal_ordered_sets__element
  
  function ceiling_ set real : cursor
  
  predicate is_ceiling (s : set) (i : real) (cu : cursor) =
     (cu = no_element  /\
       (length_ s = 0 \/ length_ s > 0 /\
        Real.(>) i (witness (Ada__containers__formal_ordered_sets__element_type.to_base (element s (last s)))))) \/
      (position s cu > 0 /\
       Real.(<=) i (witness (Ada__containers__formal_ordered_sets__element_type.to_base (element s cu))) /\
	(forall cun : cursor [element s cun]. 0 < position s cun < position s cu
	 -> Real.(>) i (witness (Ada__containers__formal_ordered_sets__element_type.to_base (element s cun)))))
  
  axiom ceiling_is_ceiling:
    forall s:set.
      forall i:real [(ceiling_ s i : cursor)].
        is_ceiling s i (ceiling_ s i : cursor)

  function ceiling  "inline" (co:set) (e:Ada__containers__formal_ordered_sets__element_type.base_type) : cursor =
 ceiling_ co (witness e)

  val ceiling (co:set) (e:Ada__containers__formal_ordered_sets__element_type.base_type) :cursor
     ensures { result = ceiling_ co (witness e) }
end

module Ada__containers__formal_ordered_sets__floor
  use import int.Int
  use import "_gnatprove_standard".Main
  use  "ada__containers__formal_ordered_sets__args".Ada__containers__formal_ordered_sets__element_type
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__witness
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__no_element
  use import Ada__containers__formal_ordered_sets__first
  use import Ada__containers__formal_ordered_sets__element
  
  function floor_ set real : cursor
  
  predicate is_floor (s : set) (i : real) (cu : cursor) =
     (cu = no_element  /\
       (length_ s = 0 \/ length_ s > 0 /\
         Real.(<) i (witness (Ada__containers__formal_ordered_sets__element_type.to_base (element s (first s)))))) \/
      (position s cu > 0 /\
       Real.(>=) i (witness (Ada__containers__formal_ordered_sets__element_type.to_base (element s cu))) /\
	(forall cun : cursor. position s cu < position s cun
	 ->  Real.(<) i (witness (Ada__containers__formal_ordered_sets__element_type.to_base (element s cun)))))
  
  axiom floor_is_floor:
    (forall s:set.
      (forall i:real [(floor_ s i : cursor)].
        (is_floor s i (floor_ s i : cursor))))

  function floor  "inline" (co:set) (e:Ada__containers__formal_ordered_sets__element_type.base_type) : cursor =
 floor_ co (witness e)

  val floor (co:set) (e:Ada__containers__formal_ordered_sets__element_type.base_type) :cursor
     ensures { result = floor_ co (witness e) }
end

module Ada__containers__formal_ordered_sets__left
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_sets__witness
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__no_element
  use import Ada__containers__formal_ordered_sets__element
  use import Ada__containers__formal_ordered_sets__find

  function left set cursor : set

  axiom left_no_element:
    forall co:set [left co no_element]. left co no_element = co

  axiom left_length_:
    forall co:set, cu:cursor [left co cu].
	position co cu > 0 -> length_ (left co cu) = position co cu - 1

  axiom left_position_in:
    forall co:set, cu cun:cursor [position (left co cu) cun | left co cu, position co cun].
	(position (left co cu) cun > 0 \/ position co cun < position co cu) ->
	position (left co cu) cun = position co cun

  axiom left_position_ext:
    forall co:set, cu cun:cursor [position (left co cu) cun].
	position co cun >= position co cu > 0 ->
	position (left co cu) cun = 0

  axiom left_element:
    forall co:set, cu cun:cursor [element (left co cu) cun | left co cu, element co cun].
	(position (left co cu) cun > 0 \/ 0 < position co cun < position co cu) ->
	element (left co cu) cun = element co cun

  axiom left_find :
    forall co:set, cu:cursor, w:real [find_ co w, left co cu|
     find_ (left co cu) w].
     ((position co cu > position co (find_ co w) > 0 \/
      position (left co cu) (find_ (left co cu) w) > 0) ->
      find_ co w = find_ (left co cu) w) /\
      (position co (find_ co w) >= position co cu -> find_ (left co cu) w = no_element)

  axiom left_find_elt :
    forall co:set, cu:cursor, w:real [element co cu, find_ co w, left co cu|
     element co cu, find_ (left co cu) w].
     (Real.(>) (witness (Ada__containers__formal_ordered_sets__element_type.to_base (element co cu))) w  ->
      find_ co w = find_ (left co cu) w) /\
     (Real.(<=) (witness (Ada__containers__formal_ordered_sets__element_type.to_base (element co cu))) w  ->
      find_ (left co cu) w = no_element) 
     
  val left (co:set) (cu:cursor) : set
     requires { cu = no_element \/ position co cu > 0 }
     ensures  { result = left co cu }
end

module Ada__containers__formal_ordered_sets__right
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_sets__witness
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__empty_set
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__no_element
  use import Ada__containers__formal_ordered_sets__element
  use import Ada__containers__formal_ordered_sets__find

  function right set cursor : set

  axiom right_no_element:
    forall co:set [right co no_element]. right co no_element = empty_set

  axiom right_length_:
    forall co:set, cu:cursor [length_ (right co cu) ].
	position co cu > 0 -> length_ (right co cu) = (length_ co) - (position co cu) + 1

  axiom right_position_in:
    forall co:set, cu cun:cursor [position (right co cu) cun | right co cu, position co cun].
	(position (right co cu) cun > 0 \/ position co cun >= position co cu > 0) ->
	position (right co cu) cun = (position co cun) - (position co cu) + 1

  axiom right_position_ext:
    forall co:set, cu cun:cursor [position (right co cu) cun].
	position co cun < position co cu -> position (right co cu) cun = 0

  axiom right_element:
    forall co:set, cu cun:cursor [element (right co cu) cun | right co cu, element co cun].
	(position (right co cu) cun > 0 \/ 0 < position co cu <= position co cun) ->
	element (right co cu) cun = element co cun

  axiom right_find :
    forall co:set, cu:cursor, w:real [find_ (right co cu) w| right co cu,
     find_ co w].
     ((0 < position co cu <= position co (find_ co w) \/
      position (right co cu) (find_ (right co cu) w) > 0) ->
      find_ co w = find_ (right co cu) w) /\
      (position co (find_ co w) < position co cu -> find_ (right co cu) w = no_element)

  axiom right_find_elt :
    forall co:set, cu:cursor, w:real [element co cu, find_ co w, right co cu|
     element co cu, find_ (right co cu) w].
     (Real.(<=) (witness (Ada__containers__formal_ordered_sets__element_type.to_base (element co cu))) w  ->
      find_ co w = find_ (right co cu) w) /\
     (Real.(>) (witness (Ada__containers__formal_ordered_sets__element_type.to_base (element co cu))) w  ->
      find_ (right co cu) w = no_element) 

  val right (co:set) (cu:cursor) : set
     requires { cu = no_element \/ position co cu > 0 }
     ensures  { result = right co cu }
end

module Ada__containers__formal_ordered_sets__replace
  use import int.Int
  use import "_gnatprove_standard".Main
  use  "ada__containers__formal_ordered_sets__args".Ada__containers__formal_ordered_sets__element_type
  use import Ada__containers__formal_ordered_sets__witness
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__empty_set
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__no_element
  use import Ada__containers__formal_ordered_sets__element
  use import Ada__containers__formal_ordered_sets__find  

  predicate replace (co1:set) (e:Ada__containers__formal_ordered_sets__element_type.base_type) (co2:set) =
    (position co1 (find_ co1 (witness e)) > 0 /\
      length_ co1 = length_ co2 /\
       Ada__containers__formal_ordered_sets__element_type.to_base (element co2 (find_ co1 (witness e))) = e /\
        (forall cun:cursor [position co2 cun | position co1 cun]. position co2 cun = position co1 cun) /\
         (forall cun:cursor [element co2 cun | element co1 cun].
           position co1 cun > 0 /\ not cun = find_ co1 (witness e) ->
            element co2 cun = element co1 cun) /\
          (forall w:real [find_ co1 w | find_ co2 w]. find_ co1 w = find_ co2 w)) /\
     capacity co1 = capacity co2

  val replace (co :ref set) (e:Ada__containers__formal_ordered_sets__element_type.base_type) : unit
     requires { find_ !co (witness e) <> no_element }
     writes { co }
     reads { co }
     ensures { replace (old !co) e !co }
end

module Ada__containers__formal_ordered_sets__replace_element
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_ordered_sets__args".Ada__containers__formal_ordered_sets__element_type
  use import Ada__containers__formal_ordered_sets__witness
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__no_element
  use import Ada__containers__formal_ordered_sets__element
  use import Ada__containers__formal_ordered_sets__find

  predicate replace_element set cursor Ada__containers__formal_ordered_sets__element_type.base_type set

  axiom replace_element_length_:
    forall co1 co2:set, cu:cursor, e:Ada__containers__formal_ordered_sets__element_type.base_type
      [replace_element co1 cu e co2].
      replace_element co1 cu e co2 -> length_ co1 = length_ co2

  axiom replace_element_capacity:
    forall co1 co2:set, cu:cursor, e:Ada__containers__formal_ordered_sets__element_type.base_type
      [replace_element co1 cu e co2, capacity co1|replace_element co1 cu e co2, capacity co2].
      replace_element co1 cu e co2 -> capacity co1 = capacity co2

  axiom replace_element_position:
    forall co1 co2:set, cu cun:cursor, e:Ada__containers__formal_ordered_sets__element_type.base_type
      [replace_element co1 cu e co2, position co2 cun
     | replace_element co1 cu e co2, position co1 cun].
      replace_element co1 cu e co2 -> (position co2 cun > 0 <-> position co1 cun > 0)

  axiom replace_element_element_in:
    forall co1 co2:set, cu:cursor, e:Ada__containers__formal_ordered_sets__element_type.base_type
      [replace_element co1 cu e co2].
      replace_element co1 cu e co2 -> Ada__containers__formal_ordered_sets__element_type.to_base (element co2 cu) = e /\ find_ co2 (witness  e) = cu

  axiom replace_element_element_ext:
    forall co1 co2:set, cu cun:cursor, e:Ada__containers__formal_ordered_sets__element_type.base_type
      [replace_element co1 cu e co2, element co2 cun
     | replace_element co1 cu e co2, element co1 cun].
      replace_element co1 cu e co2 -> cu <> cun -> position co1 cun > 0 ->
        element co2 cun = element co1 cun

  axiom replace_element_find:
    forall co1 co2:set, cu:cursor, w:real, e:Ada__containers__formal_ordered_sets__element_type.base_type
      [replace_element co1 cu e co2, find_ co2 w
     | replace_element co1 cu e co2, find_ co1 w].
       replace_element co1 cu e co2 -> not witness e = w ->
       find_ co1 w = find_ co2 w

  val replace_element (co:ref set) (cu:cursor) (e:Ada__containers__formal_ordered_sets__element_type.base_type) : unit
     requires { position !co cu > 0 /\ (find_ !co (witness e) = no_element \/ find_ !co (witness e) = cu) }
     writes     { co }
     reads      { co }
     ensures { replace_element (old !co) cu e !co }
end

module Ada__containers__formal_ordered_sets__insert
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_ordered_sets__args".Ada__containers__formal_ordered_sets__element_type
  use import Ada__containers__formal_ordered_sets__witness
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__no_element
  use import Ada__containers__formal_ordered_sets__last
  use import Ada__containers__formal_ordered_sets__element
  use import Ada__containers__formal_ordered_sets__find
  use import Ada__containers__formal_ordered_sets__ceiling

  predicate insert set Ada__containers__formal_ordered_sets__element_type.base_type set

  axiom insert_length_:
    forall co1 co2:set,  e:Ada__containers__formal_ordered_sets__element_type.base_type
      [insert co1 e co2].
      insert co1 e co2 -> length_ co1 + 1 = length_ co2 /\ find_ co1 (witness e) = no_element /\ Ada__containers__formal_ordered_sets__element_type.to_base (element co2 (find_ co2 (witness e))) = e

  axiom insert_capacity:
    forall co1 co2:set, e:Ada__containers__formal_ordered_sets__element_type.base_type
      [insert co1 e co2, capacity co1|insert co1 e co2, capacity co2].
      insert co1 e co2 -> capacity co1 = capacity co2

  axiom insert_new:
    forall co1 co2:set, e:Ada__containers__formal_ordered_sets__element_type.base_type [insert co1 e co2].
      insert co1 e co2 -> (ceiling_ co1 (witness e) <> no_element ->
      position co2 (find_ co2 (witness e)) = position co1 (ceiling_ co1 (witness e))) /\ (ceiling_ co1 (witness e) = no_element ->
      find_ co2 (witness e) = last co2)

  axiom insert_position_before:
    forall co1 co2:set, cun:cursor, e:Ada__containers__formal_ordered_sets__element_type.base_type
      [insert co1 e co2,  position co1 cun
     | insert co1 e co2,  position co2 cun].
    let i = position co2 (find_ co2 (witness e)) in
      insert co1 e co2 ->
      (i > position co1 cun > 0 \/ position co2 cun < i) ->
        position co1 cun = position co2 cun

  axiom insert_position_after:
    forall co1 co2:set, cun:cursor, e:Ada__containers__formal_ordered_sets__element_type.base_type
      [insert co1 e co2,  position co1 cun
     | insert co1 e co2,  position co2 cun].
    let i = position co2 (find_ co2 (witness e)) in
      insert co1 e co2 ->
      (position co1 cun >= i \/ position co2 cun > i) ->
        position co1 cun + 1 = position co2 cun

  axiom insert_element:
    forall co1 co2:set, cun:cursor, e:Ada__containers__formal_ordered_sets__element_type.base_type
      [insert co1 e co2,  element co1 cun
     | insert co1 e co2,  element co2 cun].
      insert co1 e co2 ->
      (position co1 cun > 0 \/ position co2 cun > 0 /\ find_ co2 (witness e) <> cun) ->
        element co1 cun = element co2 cun

  axiom insert_find :
    forall co1:set, co2:set, w:real, e:Ada__containers__formal_ordered_sets__element_type.base_type
     [insert co1 e co2, find_ co1 w| insert co1 e co2, find_ co2 w].
     insert co1 e co2 -> not witness e = w -> find_ co1 w = find_ co2 w

  val insert (co:ref set) (e:Ada__containers__formal_ordered_sets__element_type.base_type)  (p:ref cursor) (inserted : ref bool) : unit
     requires { length_ !co < capacity !co }
     writes     { co, p, inserted }
     reads      { co }
     ensures { (!inserted = True <-> find_(old  !co) (witness e) = no_element) /\ !p = find_ !co (witness e) /\
                          if !inserted = True then (insert (old !co) e !co)
                                                                 else (!co = old !co) }
end

module Ada__containers__formal_ordered_sets__insert__2
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_ordered_sets__args".Ada__containers__formal_ordered_sets__element_type
  use import Ada__containers__formal_ordered_sets__witness
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__no_element
  use import Ada__containers__formal_ordered_sets__insert
  use import Ada__containers__formal_ordered_sets__find

  val insert__2 (co:ref set) (e:Ada__containers__formal_ordered_sets__element_type.base_type) : unit
     requires { length_ !co < capacity !co /\ find_ !co (witness e) = no_element }
     writes     { co }
     reads      { co }
     ensures { insert (old !co) e !co }
end

module Ada__containers__formal_ordered_sets__delete
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_ordered_sets__args".Ada__containers__formal_ordered_sets__element_type
  use import Ada__containers__formal_ordered_sets__witness
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__no_element
  use import Ada__containers__formal_ordered_sets__next
  use import Ada__containers__formal_ordered_sets__element
  use import Ada__containers__formal_ordered_sets__find

  predicate delete set cursor set

  axiom delete_capacity:
    forall co1 co2:set, cu:cursor
      [delete co1 cu co2, capacity co1|delete co1 cu co2, capacity co2].
      delete co1 cu co2 -> capacity co1 = capacity co2

  axiom delete_length_:
    forall co1 co2:set, cu:cursor
      [delete co1 cu co2].
      delete co1 cu co2 -> length_ co1 = length_ co2 + 1

  axiom delete_position_before:
    forall co1 co2:set, cu cun:cursor
      [delete co1 cu co2,  position co1 cun
     | delete co1 cu co2,  position co2 cun].
      delete co1 cu co2 ->
      (position co1 cu > position co1 cun \/ 0 < position co2 cun < position co1 cu) ->
        position co1 cun = position co2 cun

  axiom delete_position_after:
    forall co1 co2:set, cu cun:cursor
      [delete co1 cu co2,  position co1 cun | delete co1 cu co2,  position co2 cun].
      delete co1 cu co2 ->
      (position co1 cun > position co1 cu \/ position co2 cun >= position co1 cu) ->
        position co1 cun = position co2 cun + 1

  axiom delete_position_range:
    forall co1 co2:set, cu:cursor [delete co1 cu co2].
      delete co1 cu co2 -> position co2 cu = 0 /\ 0 < position co1 cu /\ find_ co2 (witness (Ada__containers__formal_ordered_sets__element_type.to_base (element co1 cu))) = no_element

  axiom delete_position_next:
    forall co1 co2:set, cu:cursor [delete co1 cu co2].
      delete co1 cu co2 -> position co1 (next co1 cu) >= 0

  axiom delete_element:
    forall co1 co2:set, cu cun:cursor
      [delete co1 cu co2,  element co1 cun
     | delete co1 cu co2,  element co2 cun].
      delete co1 cu co2 ->
      0 < position co2 cun ->
        element co1 cun = element co2 cun  

  axiom delete_find :
    forall co1:set, co2:set, cu:cursor, w:real [delete co1 cu co2,
     find_ co1 w| delete co1 cu co2, find_ co2 w].
     delete co1 cu co2 -> not witness (Ada__containers__formal_ordered_sets__element_type.to_base (element co1 cu)) = w -> find_ co1 w = find_ co2 w

  val delete (co:ref set) (e : Ada__containers__formal_ordered_sets__element_type.base_type) : unit
     requires { find_ !co (witness e) <> no_element }
     writes     { co }
     reads      { co }
     ensures { delete (old !co) (find_ (old !co) (witness e)) !co }
end

module Ada__containers__formal_ordered_sets__delete__2
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__no_element
  use import Ada__containers__formal_ordered_sets__delete

  val delete__2 (co:ref set) (cu:ref cursor) : unit
     requires { position !co !cu > 0 }
     writes     { co, cu }
     reads      { co }
     ensures { delete (old !co) (old !cu) !co /\ !cu = no_element}
 end

module Ada__containers__formal_ordered_sets__delete_first
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__no_element
  use import Ada__containers__formal_ordered_sets__first
  use import Ada__containers__formal_ordered_sets__delete

  val delete__first (co:ref set) : unit
     writes     { co }
     reads      { co }
     ensures { if length_ (old !co) = 0 then !co = (old !co) else delete (old !co) (first (old !co)) !co }
 end

module Ada__containers__formal_ordered_sets__delete_last
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__no_element
  use import Ada__containers__formal_ordered_sets__last
  use import Ada__containers__formal_ordered_sets__delete

  val delete__last (co:ref set) : unit
     writes     { co }
     reads      { co }
     ensures { if length_ (old !co) = 0 then !co = (old !co) else delete (old !co) (last (old !co)) !co }
 end

module Ada__containers__formal_ordered_sets__include
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_ordered_sets__args".Ada__containers__formal_ordered_sets__element_type
  use import Ada__containers__formal_ordered_sets__witness
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__no_element
  use import Ada__containers__formal_ordered_sets__replace
  use import Ada__containers__formal_ordered_sets__insert
  use import Ada__containers__formal_ordered_sets__find

  val include (co:ref set) (e :Ada__containers__formal_ordered_sets__element_type.base_type) : unit
     requires {  length_ !co  < capacity !co}
     writes     { co }
     reads      { co }
     ensures { if find_ (old !co) (witness e) <> no_element then replace (old !co) e !co
                         else insert (old !co) e !co  }
end

module Ada__containers__formal_ordered_sets__exclude
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_ordered_sets__args".Ada__containers__formal_ordered_sets__element_type
  use import Ada__containers__formal_ordered_sets__witness
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__no_element
  use import Ada__containers__formal_ordered_sets__delete
  use import Ada__containers__formal_ordered_sets__find

  val exclude (co:ref set) (e :Ada__containers__formal_ordered_sets__element_type.base_type) : unit
     writes     { co }
     reads      { co }
     ensures { if find_ (old !co) (witness e) = no_element then  old !co = !co
                         else delete (old !co) (find_ (old !co) (witness e)) !co  }
end

module Ada__containers__formal_ordered_sets__to_set
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_ordered_sets__args".Ada__containers__formal_ordered_sets__element_type
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__first
  use import Ada__containers__formal_ordered_sets__element

  function to_set Ada__containers__formal_ordered_sets__element_type.base_type : set

  axiom to_set__def:
  forall e : Ada__containers__formal_ordered_sets__element_type.base_type [to_set e].
    length_ (to_set e) = 1 /\ Ada__containers__formal_ordered_sets__element_type.to_base (element (to_set e) (first (to_set e))) = e 

 val  to_set  (e: Ada__containers__formal_ordered_sets__element_type.base_type) : set
     ensures { result = to_set e }
end

module Ada__containers__formal_ordered_sets__has_element
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor

  function has_element set cursor : bool

  axiom has_element_pos:
    forall co:set, cu:cursor [has_element co cu].
    has_element co cu = True -> 0 < position co cu

  axiom has_element_neg:
    forall co:set, cu:cursor [has_element co cu].
    has_element co cu <> True -> position co cu = 0

  val has_element (co:set) (cu:cursor) : bool
     ensures { has_element co cu = result }
end

module Ada__containers__formal_ordered_sets__contains
  use import int.Int
  use import "_gnatprove_standard".Main
  use "ada__containers__formal_ordered_sets__args".Ada__containers__formal_ordered_sets__element_type
  use import Ada__containers__formal_ordered_sets__witness
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__find

  function contains set Ada__containers__formal_ordered_sets__element_type.base_type : bool

  axiom contains_c:
  forall co : set, e : Ada__containers__formal_ordered_sets__element_type.base_type [contains co e].
    contains co e = True <-> 0 < position co (find_ co (witness e))

  val contains (co:set) (e:Ada__containers__formal_ordered_sets__element_type.base_type) : bool
     ensures { contains co e = result }
end

module Ada__containers__formal_ordered_sets__strict_equal
  use import int.Int
  use import "_gnatprove_standard".Main
  use  "ada__containers__formal_ordered_sets__args".Ada__containers__formal_ordered_sets__element_type
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__element

  function strict_equal set set : bool

  axiom strict_equal__def:
    forall co1 co2 : set [strict_equal co1 co2].
    ((forall cu:cursor [position co1 cu | position co2 cu].
       position co1 cu = position co2 cu) /\
     (forall cu:cursor [element co1 cu | element co2 cu]. position co1 cu > 0 ->
        Ada__containers__formal_ordered_sets__element_type.to_base (element co1 cu) = Ada__containers__formal_ordered_sets__element_type.to_base (element co2 cu))) <->  strict_equal co1 co2 = True

  lemma strict_equal_length_:
    forall co1 co2 : set [strict_equal co1 co2].
     strict_equal co1 co2 = True -> length_ co1 = length_ co2

    val strict_equal (co1:set) (co2:set) : bool
     ensures  { result  = strict_equal co1 co2 }
end

module Ada__containers__formal_ordered_sets__Oeq__2
  use import int.Int
  use  "ada__containers__formal_ordered_sets__args".Ada__containers__formal_ordered_sets__element_type
  use "ada__containers__formal_ordered_sets__args".Ada__containers__formal_ordered_sets__oeq
  use import Ada__containers__formal_ordered_sets__witness
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__no_element
  use import Ada__containers__formal_ordered_sets__element
  use import Ada__containers__formal_ordered_sets__find

  function oeq__2 set set : bool

  axiom oeq__2_length_:
   forall co1 co2 : set [oeq__2 co1 co2].
   oeq__2 co1 co2 = True -> length_ co1 = length_ co2

  axiom oeq__2_element:
   forall co1 co2 : set [oeq__2 co1 co2]. oeq__2 co1 co2 = True ->
   forall cu1 : cursor [element co1 cu1]. position co1 cu1 > 0 ->
	let cu2 = find_ co2 (witness (Ada__containers__formal_ordered_sets__element_type.to_base (element co1 cu1))) in
          Ada__containers__formal_ordered_sets__oeq.oeq (Ada__containers__formal_ordered_sets__element_type.to_base (element co2 cu2)) (Ada__containers__formal_ordered_sets__element_type.to_base (element co1 cu1)) = True

  axiom oeq__2_inv:
   forall co1 co2 : set [oeq__2 co1 co2]. oeq__2 co1 co2 <> True ->
   (length_ co1 <> length_ co2 \/
   exists e : real. position co1 (find_ co1 e) > 0 /\
         (find_ co2 e = no_element \/ position co2 (find_ co2 e) > 0 /\ 
          Ada__containers__formal_ordered_sets__oeq.oeq (Ada__containers__formal_ordered_sets__element_type.to_base (element co2 (find_ co2 e))) (Ada__containers__formal_ordered_sets__element_type.to_base (element co1 (find_ co1 e))) <> True))

  lemma oeq__2_sym :
  forall e1 e2 : set [oeq__2 e1 e2].
	oeq__2 e1 e2 = True -> oeq__2 e2 e1 = True

  lemma oeq__2_trans :
  forall e1 e2 e3 : set [oeq__2 e1 e2, oeq__2 e1 e3 | oeq__2 e1 e2, oeq__2 e2 e3].
	oeq__2 e1 e2 = True -> oeq__2 e2 e3 = True -> oeq__2 e1 e3 = True

  val oeq__2 (co1:set) (co2:set) : bool
     ensures  { result  = oeq__2 co1 co2 }
end

module Ada__containers__formal_ordered_sets__equivalent_sets
  use import int.Int
  use import "_gnatprove_standard".Main
  use  "ada__containers__formal_ordered_sets__args".Ada__containers__formal_ordered_sets__element_type
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__no_element
  use import Ada__containers__formal_ordered_sets__find
  
  function equivalent_sets set set : bool 

  axiom equivalent_sets__def :
    forall co1:set, co2:set [equivalent_sets co1 co2].
     (forall i:real.
       not find_ co1 i = no_element -> not find_ co2 i = no_element) /\
      length co1 = length co2 <-> equivalent_sets co1 co2 = True
  
  axiom equivalent_sym :
    forall co1:set.
     forall co2:set [equivalent_sets co2 co1| equivalent_sets co1 co2].
      equivalent_sets co1 co2 = True -> equivalent_sets co2 co1 = True

  val equivalent_sets (co1:set) (co2:set) : bool
  ensures { result  = equivalent_sets co1 co2 }
end

module Ada__containers__formal_ordered_sets__intersection
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__no_element
  use import Ada__containers__formal_ordered_sets__find
  
  function intersection set set : set 

  predicate is_inter (s1:set) (s2:set) (i:set) =
    forall j:real [find_ s1 j, find_ s2 j| find_ i j].
     (not find_ s1 j = no_element /\ not find_ s2 j = no_element ->
       not find_ i j = no_element) /\
      (find_ s1 j = no_element \/ find_ s2 j = no_element ->
        find_ i j = no_element)
  
  axiom Inter_is_inter :
    forall s1:set.
     forall s2:set [intersection s1 s2].
      is_inter s1 s2 (intersection s1 s2) /\
       length_ (intersection s1 s2) = length_ (intersection s2 s1)
  
  val intersection (co1: ref set) (co2:set) :unit
     reads { co1 }
     writes { co1 }
     ensures { !co1 = intersection (old !co1) co2 /\ capacity !co1 = capacity (old !co1) }
end

module Ada__containers__formal_ordered_sets__intersection__2
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__intersection

  function intersection__2 "inline" (co1 co2 : set) : set = intersection co1 co2

  val intersection__2 (co1 co2 : set) : set
    ensures { result = intersection co1 co2 }
end

module Ada__containers__formal_ordered_sets__union
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__no_element
  use import Ada__containers__formal_ordered_sets__find
  use import Ada__containers__formal_ordered_sets__intersection
  
  function union set set : set  

  predicate is_union (s1:set) (s2:set) (u:set) =
    (forall i:real [find_ s1 i, find_ s2 i| find_ u i].
      (not find_ s1 i = no_element \/ not find_ s2 i = no_element ->
        not find_ u i = no_element) /\
       (find_ s1 i = no_element /\ find_ s2 i = no_element ->
         find_ u i = no_element)) /\
     length_ u = ((length_ s1 + length_ s2) - length_ (intersection s1 s2))
  
  axiom union_is_union :
    forall s1:set. forall s2:set [union s1 s2]. is_union s1 s2 (union s1 s2)
  
  val union (co1: ref set) (co2:set) :unit
     requires { length_ (union !co1 co2) <= capacity !co1}
     reads { co1 }
     writes { co1 }
     ensures { !co1 = union (old !co1) co2 /\ capacity !co1 = capacity (old !co1) }
end

module Ada__containers__formal_ordered_sets__union__2
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__union

  function union__2 set set : set

  axiom union__2__def :
     forall co1 co2 : set [union__2 co1 co2].
	  length_ (union co1 co2) <=  Ada__containers__count_type.attr__ATTRIBUTE_LAST ->
          union__2 co1 co2 = union co1 co2

  val union__2 (co1 co2 : set) : set
    requires { length_ (union co1 co2) <=  Ada__containers__count_type.attr__ATTRIBUTE_LAST }
    ensures { result = union co1 co2 }
end

module Ada__containers__formal_ordered_sets__difference
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__no_element
  use import Ada__containers__formal_ordered_sets__find
  use import Ada__containers__formal_ordered_sets__intersection
  
  function difference set set : set 

  predicate is_diff (s1:set) (s2:set) (d:set) =
    (forall i:real [find_ s1 i, find_ s2 i| find_ d i].
      (not find_ s1 i = no_element /\ find_ s2 i = no_element ->
        not find_ d i = no_element) /\
       (find_ s1 i = no_element \/ not find_ s2 i = no_element ->
         find_ d i = no_element)) /\
     length_ d = (length_ s1 - length_ (intersection s1 s2))
  
  axiom diff_is_diff :
    forall s1:set.
     forall s2:set [difference s1 s2]. is_diff s1 s2 (difference s1 s2)

  val difference (co1: ref set) (co2:set) :unit
     reads { co1 }
     writes { co1 }
     ensures { !co1 = difference (old !co1) co2 /\ capacity !co1 = capacity (old !co1) }
end

module Ada__containers__formal_ordered_sets__difference__2
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__difference

  function difference__2 "inline" (co1 co2 : set) : set = difference co1 co2

  val difference__2 (co1 co2 : set) : set
    ensures { result = difference co1 co2 }
end

module Ada__containers__formal_ordered_sets__symmetric_difference
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__no_element
  use import Ada__containers__formal_ordered_sets__find
  use import Ada__containers__formal_ordered_sets__intersection
  
  function symmetric_difference set set : set 

  predicate is_sdiff (s1:set) (s2:set) (d:set) =
    (forall i:real [find_ s1 i, find_ s2 i| find_ d i].
      (not find_ s1 i = no_element /\ find_ s2 i = no_element ->
        not find_ d i = no_element) /\
       (not find_ s2 i = no_element /\ find_ s1 i = no_element ->
         not find_ d i = no_element) /\
        (find_ s2 i = no_element /\ find_ s1 i = no_element ->
          find_ d i = no_element) /\
         (not find_ s2 i = no_element /\ not find_ s1 i = no_element ->
           find_ d i = no_element)) /\
     length_ d =
      ((length_ s1 + length_ s2) - (2 * length_ (intersection s1 s2)))
  
  axiom sdiff_is_sdiff :
    forall s1:set.
     forall s2:set [symmetric_difference s1 s2].
      is_sdiff s1 s2 (symmetric_difference s1 s2)
  
  val symmetric_difference (co1: ref set) (co2:set) :unit
     requires { length_ (symmetric_difference !co1 co2) <= capacity !co1}
     reads { co1 }
     writes { co1 }
     ensures { !co1 = symmetric_difference (old !co1) co2 /\ capacity !co1 = capacity (old !co1) }
end

module Ada__containers__formal_ordered_sets__symmetric_difference__2
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__symmetric_difference

  function symmetric_difference__2 set set : set

  axiom symmetric_difference__2__def :
     forall co1 co2 : set [symmetric_difference__2 co1 co2].
	  length_ (symmetric_difference co1 co2) <=  Ada__containers__count_type.attr__ATTRIBUTE_LAST ->
          symmetric_difference__2 co1 co2 = symmetric_difference co1 co2

  val symmetric_difference__2 (co1 co2 : set) : set
    requires { length_ (symmetric_difference co1 co2) <=  Ada__containers__count_type.attr__ATTRIBUTE_LAST }
    ensures { result = symmetric_difference co1 co2 }
end

module Ada__containers__formal_ordered_sets__is_subset
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__no_element
  use import Ada__containers__formal_ordered_sets__find
  
  function is_subset set set : bool 

  axiom is_subset__def :
    forall s1:set, s2:set [is_subset s1 s2].
     is_subset s1 s2 = True <->
      (forall i:real [find_ s1 i | find_ s2 i]. find_ s1 i = no_element -> find_ s2 i = no_element)

  val is_subset (co1 co2:set) : bool
     ensures { result = is_subset co1 co2 }
end

module Ada__containers__formal_ordered_sets__overlap
  use import int.Int
  use import "_gnatprove_standard".Main
  use  "ada__containers__formal_ordered_sets__args".Ada__containers__formal_ordered_sets__element_type
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__no_element
  use import Ada__containers__formal_ordered_sets__find

  function overlap set set : bool  

  axiom overlap__def :
    forall s1:set, s2:set [overlap s1 s2].
     overlap s1 s2 <> True <->
      (forall i:real [find_ s1 i| find_ s2 i].
        find_ s1 i = no_element \/ find_ s2 i = no_element)

  val overlap (co1 co2:set) : bool
     ensures { result = overlap co1 co2 }
end

module Ada__containers__formal_ordered_sets__capacity
  use import int.Int
  use import "_gnatprove_standard".Main
  use "a-contai__types_in_spec".Ada__containers__count_type
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length

  function capacity (co : set) : Ada__containers__count_type.count_type = rec__capacity co

  val capacity (co : set) : Ada__containers__count_type.count_type
    ensures { result = rec__capacity co }
end

module Ada__containers__formal_ordered_sets__reserve_capacity
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_sets__set

  val reserve_capacity (co : ref set) (c :  int) : unit
    requires { capacity !co >= c }
    ensures { !co = old !co }
end

module Ada__containers__formal_ordered_sets__equivalent_elements
  use "ada__containers__formal_ordered_sets__args".Ada__containers__formal_ordered_sets__element_type
  use import Ada__containers__formal_ordered_sets__witness
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__cursor
  use import Ada__containers__formal_ordered_sets__element

  function equivalent_elements (co1:set) (e1:Ada__containers__formal_ordered_sets__element_type.base_type) (co2:set) (e2:Ada__containers__formal_ordered_sets__element_type.base_type) : bool =
  if witness e1 = witness e2 then True else False

 val equivalent_elements__2  (co1:set) (e1:Ada__containers__formal_ordered_sets__element_type.base_type) (co2:set) (e2:Ada__containers__formal_ordered_sets__element_type.base_type) : bool
	ensures {  result = equivalent_elements co1 e1 co2 e2 }
end

module Ada__containers__formal_ordered_sets__clear
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  
  val clear (co:ref set) : unit
     writes     { co }
     ensures { length_ !co = 0 /\ capacity !co = capacity (old !co) }
end

module Ada__containers__formal_ordered_sets__assign
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__Oeq__2

  val assign (target:ref set) (source:set) : unit
     requires { capacity !target >= length_ source }
     writes     { target }
     reads      { target }
     ensures { oeq__2 !target source = True }
end

module Ada__containers__formal_ordered_sets__move
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__Oeq__2

  val move (target:ref set) (source:ref set) : unit
     requires { capacity !target >= length_ !source }
     writes     { target, source }
     reads      { target, source }
     ensures { oeq__2 !target (old !source) = True /\ length_ !source = 0 }
end

module Ada__containers__formal_ordered_sets__copy
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Ada__containers__formal_ordered_sets__set
  use import Ada__containers__formal_ordered_sets__length
  use import Ada__containers__formal_ordered_sets__strict_equal

  predicate cap_is_max set set int

 axiom cap_is_max_def:
   forall co1 co2:set, max:int 
                  [cap_is_max co1 co2 max].
   if capacity co1 > max then capacity co2 = capacity co1 else capacity co2 = max

  function copy set int : set

  val copy (co: set) (cap:int) : set
     ensures { strict_equal co (result) = True /\ 
                      cap_is_max co result cap /\ result = copy co cap }
end
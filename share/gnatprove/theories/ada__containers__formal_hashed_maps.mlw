module Main
  use import real.Real
  use "a-contai__types_in_spec".Ada__containers__count_type
  use "a-contai__types_in_spec".Ada__containers__hash_type
  use import int.Int
  use import ref.Ref
  
  (*** TO BE INSTANTIATED ***)
  
  type key_type

  type element_type

  function oeq element_type element_type : bool

  axiom equal_refl :
  forall e : element_type [oeq e e].
	oeq e e = True

  axiom equal_sym :
  forall e1 : element_type, e2 : element_type [oeq e1 e2].
	oeq e1 e2 = oeq e2 e1

  axiom equal_trans :
  forall e1 : element_type, e2 : element_type, e3 : element_type [oeq e1 e2, oeq e1 e3 | oeq e1 e2, oeq e2 e3].
	oeq e1 e2 = True -> oeq e2 e3 = True -> oeq e1 e3 = True

  function equivalent_keys key_type key_type : bool

  function hash key_type : Ada__containers__hash_type.hash_type

  (**************************)
  
  type cursor
  
  type map
  
  function no_element  : cursor
  
  function empty_  : map

  function capacity map : int
  
  function length map : int
  
  axiom Length_gte_zero:
    forall co:map [length co]. 0 <= length co <= capacity co
  
  function witness key_type : real

  axiom eq_witness :
    (forall k1 : key_type, k2 : key_type [equivalent_keys k1 k2].
	witness k1 = witness k2 -> equivalent_keys k1 k2 = True) /\
    (forall k1 : key_type, k2 : key_type [equivalent_keys k1 k2].
	equivalent_keys k1 k2 = True -> witness k1 = witness k2)
  
  function position_ map cursor : int
  
  axiom Position_gte_zero:
    (forall co:map.
      (forall cu:cursor.
        ((Int.(<=) 0 (position_ co cu : int)) /\
         (Int.(<=) (position_ co cu : int) (length co : int)))))
  
  axiom Position_no_element:
    (forall co:map. ((position_ co (no_element  : cursor) : int) = 0))
  
  axiom Position_eq:
    (forall co:map.
      (forall cu1:cursor.
        (forall cu2:cursor.
          (((position_ co cu1 : int) = (position_ co cu2 : int)) ->
           ((Int.(>) (position_ co cu1 : int) 0) -> (cu1 = cu2))))))
  
  predicate is_empty_ (co : map) =
    (forall cu:cursor. ((position_ co cu : int) = 0))
  
  axiom Length_is_empty:
    (forall co:map. ((is_empty_ co) -> ((length co : int) = 0)))
  
  axiom Empty_is_empty: (is_empty_ (empty_  : map))
  
  predicate next__ (co : map) (cu1 : cursor) (cu2 : cursor) =
    (length co > position_ co cu1 > 0 -> position_ co cu2 = position_ co cu1 + 1 ) /\
    (position_ co cu2 > 0 -> position_ co cu1 > 0 /\ position_ co cu2 = position_ co cu1 + 1 ) /\
        ((position_ co cu1 = length co \/ cu1 = no_element) -> cu2 = no_element)
  
  function next_ map cursor : cursor
  
  axiom Next_next:
    (forall co:map.
      (forall cu:cursor [(next_ co cu : cursor)].
        (next__ co cu (next_ co cu : cursor))))
  
  function first map : cursor
  
  axiom First_first:
    (forall co:map [(first co : cursor)].
      (((not (is_empty_ co)) ->
        ((position_ co (first co : cursor) : int) = 1)) /\
       ((is_empty_ co) -> ((first co : cursor) = (no_element  : cursor)))))
  
  function key_ map cursor : key_type
  
  function find_ map real : cursor
  
  predicate find__ (co : map) (i : real) (cu : cursor) =
    (((cu = (no_element  : cursor)) /\
      (forall cun:cursor.
        ((Int.(>) (position_ co cun : int) 0) ->
         ((witness (key_ co cun : key_type) : real) <> i)))) \/
     ((Int.(>) (position_ co cu : int) 0) /\
      (((witness (key_ co cu : key_type) : real) = i) /\
       (forall cun:cursor.
         ((Int.(>) (position_ co cun : int) 0) ->
          ((cu <> cun) -> ((witness (key_ co cun : key_type) : real) <> i)))))))
  
  axiom Find_find_val:
    (forall co:map.
      (forall i:real.
        ((find__ co i (find_ co i : cursor)) /\
         ((is_empty_ co) -> ((find_ co i : cursor) = (no_element  : cursor))))))
  
  function element_ map cursor : element_type
  
  function element__ (m : map) (i : real) : element_type =
    (element_ m (find_ m i : cursor) : element_type)
  
  predicate left_pos (co : map) (i : int) (col : map) =
    (forall cu:cursor [(position_ co cu : int)| (position_ col cu : int)].
       Int.(<=) i (position_ co cu : int) ->
         (position_ col cu : int) = 0) /\
    (forall cu:cursor [(position_ co cu : int)| (position_ col cu : int)].
       Int.(>) i (position_ co cu : int) ->
          (position_ col cu : int) = (position_ co cu : int)) /\
    (forall cu:cursor [position_ co cu, position_ col cu | key_ col cu | key_ co cu | element_ col cu | element_ co cu].
         Int.(>) (position_ col cu : int) 0 ->
          (position_ co cu : int) = (position_ col cu : int) /\
         (key_ col cu : key_type) = (key_ co cu : key_type) /\
         (element_ col cu : element_type) = (element_ co cu : element_type))
  
  predicate left_find (co : map) (i : int) (col : map) =
	(forall w:real [find_ col w | find_ co w].
		position_ col (find_ col w) > 0 -> find_ col w = find_ co w) /\
	(forall w:real [find_ col w | find_ co w]. 
	 	position_ co (find_ co w) >= i -> find_ col w = no_element)/\
	(forall w:real [find_ col w | find_ co w]. 
	 	position_ co (find_ co w) < i -> find_ col w = find_ co w)
  
  predicate left__ (co : map) (cu : cursor) (col : map) =
    (((cu = (no_element  : cursor)) -> (col = co)) /\
     ((Int.(>) (position_ co cu : int) 0) ->
      (((length col : int) = (Int.(-) (position_ co cu : int) 1 : int)) /\
       ((left_pos co (position_ co cu : int) col) /\
        (left_find co (position_ co cu : int) col)))))
  
  function left_ map cursor : map
  
  axiom Left_left:
    (forall co:map.
      (forall cu:cursor [(left_ co cu : map)].
        (left__ co cu (left_ co cu : map))))
  
  predicate right_pos (co : map) (i : int) (cor : map) =
    ((forall cu:cursor [(position_ co cu : int), (position_ cor cu : int)].
       (((Int.(>) i (position_ co cu : int)) ->
         ((position_ cor cu : int) = 0)) /\
        (((Int.(<=) i (position_ co cu : int)) ->
          ((position_ cor cu : int) = (Int.(+) (Int.(-) (position_ co cu : int) i : int) 1 : int))) /\
         ((Int.(>) (position_ cor cu : int) 0) ->
          ((position_ co cu : int) = (Int.(-) (Int.(+) (position_ cor cu : int) i : int) 1 : int)))))) /\
     ((forall cu:cursor.
        ((Int.(<=) i (position_ co cu : int)) ->
         ((key_ cor cu : key_type) = (key_ co cu : key_type)))) /\
      (forall cu:cursor.
        ((Int.(<=) i (position_ co cu : int)) ->
         ((element_ cor cu : element_type) = (element_ co cu : element_type))))))
  
  predicate right_find (co : map) (i : int) (cor : map) =
    (forall w:real.
      ((((Int.(<=) i (position_ co (find_ co w : cursor) : int)) /\
         (Int.(>) i 0)) \/
        (Int.(>) (position_ cor (find_ cor w : cursor) : int) 0)) ->
       ((find_ co w : cursor) = (find_ cor w : cursor))))
  
  predicate right__ (co : map) (cu : cursor) (cor : map) =
    (((cu = (no_element  : cursor)) -> (cor = (empty_  : map))) /\
     (((Int.(>) (position_ co cu : int) 0) ->
       (((length cor : int) = (Int.(+) (Int.(-) (length co : int) (position_ co cu : int) : int) 1 : int)) /\
        ((right_pos co (position_ co cu : int) cor) /\
         (right_find co (position_ co cu : int) cor)))) /\
      (forall cun:cursor.
        ((Int.(>) (position_ cor cun : int) 0) ->
         (Int.(>) (position_ co cun : int) 0)))))
  
  function right_ map cursor : map
  
  axiom Right_right:
    (forall co:map.
      (forall cu:cursor [(right_ co cu : map)].
        (right__ co cu (right_ co cu : map))))
  
  predicate replace_ (co1 : map) (k : key_type) (e : element_type) (co2 : map) =
    ((Int.(>) (position_ co1 (find_ co1 (witness k : real) : cursor) : int) 0) /\
     (((length co1 : int) = (length co2 : int)) /\
      (((key_ co2 (find_ co1 (witness k : real) : cursor) : key_type) = k) /\
       (((element_ co2 (find_ co1 (witness k : real) : cursor) : element_type) = e) /\
        ((forall cun:cursor.
           ((position_ co2 cun : int) = (position_ co1 cun : int))) /\
         ((forall cun:cursor [(key_ co2 cun : key_type)|
            (key_ co1 cun : key_type)].
            (((Int.(>) (position_ co1 cun : int) 0) /\
              (not (cun = (find_ co1 (witness k : real) : cursor)))) ->
             ((key_ co2 cun : key_type) = (key_ co1 cun : key_type)))) /\
          ((forall cun:cursor [(element_ co2 cun : element_type)|
             (element_ co1 cun : element_type)].
             (((Int.(>) (position_ co1 cun : int) 0) /\
               (not (cun = (find_ co1 (witness k : real) : cursor)))) ->
              ((element_ co2 cun : element_type) = (element_ co1 cun : element_type)))) /\
           (forall w:real. ((find_ co1 w : cursor) = (find_ co2 w : cursor))))))))))/\
     capacity co1 = capacity co2
  
  predicate replace_element_ (co1 : map) (cu : cursor) (e : element_type) (co2 : map) =
    ((Int.(>) (position_ co1 cu : int) 0) /\
     (((element_ co2 cu : element_type) = e) /\
      (((length co1 : int) = (length co2 : int)) /\
       ((forall cun:cursor.
          ((position_ co1 cun : int) = (position_ co2 cun : int))) /\
        ((forall cun:cursor.
           ((Int.(>) (position_ co1 cun : int) 0) ->
            ((key_ co2 cun : key_type) = (key_ co1 cun : key_type)))) /\
         ((forall cun:cursor.
            ((Int.(>) (position_ co1 cun : int) 0) ->
             ((cu <> cun) ->
              ((element_ co2 cun : element_type) = (element_ co1 cun : element_type))))) /\
          (forall w:real. ((find_ co1 w : cursor) = (find_ co2 w : cursor)))))))))/\
     capacity co1 = capacity co2
  
  predicate insert_find (co1 : map) (k : key_type) (e : element_type) (co2 : map) =
    (forall w:real [(find_ co1 w : cursor)| (find_ co2 w : cursor)].
      ((((witness k : real) <> w) ->
        ((find_ co1 w : cursor) = (find_ co2 w : cursor))) /\
       (((witness k : real) = w) ->
        (((find_ co1 w : cursor) = (no_element  : cursor)) /\
         (Int.(>) (position_ co2 (find_ co2 w : cursor) : int) 0)))))
  
  predicate insert_pos (co1 : map) (k : key_type) (e : element_type) (co2 : map) =
    ((forall cun:cursor [(position_ co1 cun : int),
       (position_ co2 cun : int)].
       ((Int.(>) (position_ co1 cun : int) 0) ->
        (Int.(>) (position_ co2 cun : int) 0))) /\
     ((forall cun:cursor [(element_ co2 cun : element_type)].
        ((((position_ co1 cun : int) = 0) /\
          (Int.(>) (position_ co2 cun : int) 0)) ->
         ((element_ co2 cun : element_type) = e))) /\
      ((forall cun:cursor.
         ((((position_ co1 cun : int) = 0) /\
           (Int.(>) (position_ co2 cun : int) 0)) ->
          ((key_ co2 cun : key_type) = k))) /\
       ((forall cun:cursor [(key_ co2 cun : key_type)| (key_ co1 cun : key_type)].
          ((Int.(>) (position_ co1 cun : int) 0) ->
           ((key_ co1 cun : key_type) = (key_ co2 cun : key_type)))) /\
        (forall cun:cursor [(element_ co2 cun : element_type)|
          (element_ co1 cun : element_type)].
          ((Int.(>) (position_ co1 cun : int) 0) ->
           ((element_ co1 cun : element_type) = (element_ co2 cun : element_type))))))))
  
  predicate insert_ (co1 : map) (k : key_type) (e : element_type) (co2 : map) =
    (((find_ co1 (witness k : real) : cursor) = (no_element  : cursor)) /\
     ((Int.(>) (position_ co2 (find_ co2 (witness k : real) : cursor) : int) 0) /\
      (((length co2 : int) = (Int.(+) (length co1 : int) 1 : int)) /\
       ((insert_pos co1 k e co2) /\ (insert_find co1 k e co2)))))/\
     capacity co1 = capacity co2

  predicate first_inserted (co1:map) (k : key_type) (e : element_type) (co2:map) (p:cursor) =
	    position_ co1 p = 0 /\ position_ co2 p > 0 /\ key_ co2 p = k /\ element_ co2 p = e
  
  predicate delete_find (co1 : map) (k : key_type) (co2 : map) =
    ((forall w:real.
       (((witness k : real) <> w) ->
        ((find_ co1 w : cursor) = (find_ co2 w : cursor)))) /\
     (forall w:real.
       (((witness k : real) = w) ->
        ((find_ co2 w : cursor) = (no_element  : cursor)))))
  
  predicate delete_pos (co1 : map) (i : int) (co2 : map) =
    ((Int.(>) i 0) /\
     ((forall cun:cursor [(position_ co1 cun : int),
        (position_ co2 cun : int)].
        ((((position_ co1 cun : int) = i) -> ((position_ co2 cun : int) = 0)) /\
         (((Int.(>) (position_ co1 cun : int) 0) /\
           ((position_ co1 cun : int) <> i)) ->
          (Int.(>) (position_ co2 cun : int) 0)))) /\
      ((forall cun:cursor.
         (((Int.(>) (position_ co1 cun : int) 0) /\
           ((position_ co1 cun : int) <> i)) ->
          ((element_ co2 cun : element_type) = (element_ co1 cun : element_type)))) /\
       (forall cun:cursor.
         (((Int.(>) (position_ co1 cun : int) 0) /\
           ((position_ co1 cun : int) <> i)) ->
          ((key_ co2 cun : key_type) = (key_ co1 cun : key_type)))))))
  
  predicate delete_inv (co1 : map) (i : int) (co2 : map) =
    ((Int.(>) i 0) /\
     (forall cun:cursor [(position_ co1 cun : int),
       (position_ co2 cun : int)].
       ((Int.(>) (position_ co2 cun : int) 0) ->
        ((Int.(>) (position_ co1 cun : int) 0) /\
         ((position_ co1 cun : int) <> i)))))
  
  predicate delete_ (co1 : map) (cu : cursor) (co2 : map) =
    (((find_ co2 (witness (key_ co1 cu : key_type) : real) : cursor) = (no_element  : cursor)) /\
     ((Int.(>) (position_ co1 cu : int) 0) /\
      (((length co2 : int) = (Int.(-) (length co1 : int) 1 : int)) /\
       ((delete_pos co1 (position_ co1 cu : int) co2) /\
        ((delete_inv co1 (position_ co1 cu : int) co2) /\
         (delete_find co1 (key_ co1 cu : key_type) co2))))))/\
     capacity co1 = capacity co2
  
  predicate include__ (co1 : map) (k : key_type) (e : element_type) (co2 : map) =
    (((Int.(>) (position_ co1 (find_ co1 (witness k : real) : cursor) : int) 0) ->
      (replace_ co1 k e co2)) /\
     (((find_ co1 (witness k : real) : cursor) = (no_element  : cursor)) ->
      (insert_ co1 k e co2)))
  
  predicate exclude_ (co1 : map) (k : key_type) (co2 : map) =
    (((Int.(>) (position_ co1 (find_ co1 (witness k : real) : cursor) : int) 0) ->
      (delete_ co1 (find_ co1 (witness k : real) : cursor) co2)) /\
     (((find_ co1 (witness k : real) : cursor) = (no_element  : cursor)) ->
      (co1 = co2)))
  
  predicate has_element (co : map) (cu : cursor) =
    (Int.(>) (position_ co cu : int) 0)
  
  predicate contains (co : map) (i : real) =
    (Int.(>) (position_ co (find_ co i : cursor) : int) 0)
  
  axiom Empty_contains:
    (forall s:map [(is_empty_ s)].
      ((forall i:real. (not (contains s i))) -> (is_empty_ s)))
  
  predicate strict_equal (co1 : map) (co2 : map) =
    ((forall cu:cursor.
       ((position_ co1 cu : int) = (position_ co2 cu : int))) /\
     ((forall cu:cursor.
        ((Int.(>) (position_ co1 cu : int) 0) ->
         ((key_ co1 cu : key_type) = (key_ co2 cu : key_type)))) /\
      (forall cu:cursor.
        ((Int.(>) (position_ co1 cu : int) 0) ->
         ((element_ co2 cu : element_type) = (element_ co1 cu : element_type))))))
  
  predicate equal_ (co1 : map) (co2 : map) =
    (forall i:real. (contains co1 i) -> (contains co2 i)) /\
     (forall i:real [contains co1 i | element__ co2 i, element__ co1 i].
        (contains co1 i) ->
         (oeq (element__ co1 i : element_type) (element__ co2 i : element_type) = True)) /\
      (length co1 : int) = (length co2 : int)
  
  axiom equal_sym_:
    (forall co1:map.
      (forall co2:map [equal_ co1 co2]. ((equal_ co1 co2) -> (equal_ co2 co1))))
  
  predicate no_overlaping (co1 : map) (co2 : map) =
    (forall i:real. ((not (contains co1 i)) \/ (not (contains co2 i))))

  predicate cap_is_max map map int

 axiom cap_is_max_def:
   forall co1 co2:map, max:int 
                  [cap_is_max co1 co2 max, capacity co1 | cap_is_max co1 co2 max, capacity co2].
   if capacity co1 > max then capacity co2 = capacity co1 else capacity co2 = max

 
(*******************************  API  ********************************)
 function empty_map__object : map = empty_

 function no_element__object : cursor = no_element

 function map__capacity__record (co : map) : Ada__containers__count_type.count_type = 
    Ada__containers__count_type.of_int (capacity co)

 function capacity__logic (co : map) : Ada__containers__count_type.count_type = 
    Ada__containers__count_type.of_int (capacity co)
 predicate capacity__pre  (co:map) = true
 predicate capacity__post (co:map) (result : Ada__containers__count_type.count_type) =
	result = Ada__containers__count_type.of_int (capacity co)

 predicate reserve_capacity__pre  (co:map) 
                                                                      (cap:Ada__containers__count_type.count_type) =
     Ada__containers__count_type.to_int cap <= capacity co
 predicate reserve_capacity__post (co oldco:map) 
                                                       (cap : Ada__containers__count_type.count_type) =
	oldco = co

 function map__modulus__record (co : map) : Ada__containers__hash_type.hash_type

 function default_modulus__logic (cap : Ada__containers__count_type.count_type):
     Ada__containers__hash_type.hash_type
 predicate default_modulus__pre  (cap:Ada__containers__count_type.count_type) =
     true
 predicate default_modulus__post (cap : Ada__containers__count_type.count_type) (result : Ada__containers__hash_type.hash_type) = result = default_modulus__logic cap

 function equivalent_keys__logic (k1 k2 : key_type) : bool =
  if witness k1 = witness k2 then True else False

 predicate equivalent_keys__pre  (k1 k2 : key_type) = true
 predicate equivalent_keys__post (k1 k2 : key_type) (result : bool) =
	result = True <-> witness k1 = witness k2

 function equivalent_keys__2__logic (co1:map) (cu1:cursor) (co2:map) (cu2:cursor) : bool =
  if witness (key_ co1 cu1) = witness (key_ co2 cu2) then True else False

 predicate equivalent_keys__2__pre  (co1:map) (cu1:cursor) (co2:map) (cu2:cursor) = true
 predicate equivalent_keys__2__post (co1:map) (cu1:cursor) (co2:map) (cu2:cursor) (result : bool) =
	result = True <-> witness (key_ co1 cu1) = witness (key_ co2 cu2)

function equivalent_keys__3__logic (co1:map) (cu1:cursor) (k2:key_type) : bool =
  if witness (key_ co1 cu1) = witness k2 then True else False

 predicate equivalent_keys__3__pre  (co1:map) (cu1:cursor) (k2:key_type) = true
 predicate equivalent_keys__3__post (co1:map) (cu1:cursor) (k2:key_type) (result : bool) =
	result = True <-> witness (key_ co1 cu1) = witness k2

function equivalent_keys__4__logic (k1 : key_type) (co2:map) (cu2:cursor) : bool =
  if witness k1 = witness (key_ co2 cu2) then True else False

 predicate equivalent_keys__4__pre  (k1 : key_type) (co2:map) (cu2:cursor) = true
 predicate equivalent_keys__4__post (k1 : key_type) (co2:map) (cu2:cursor) (result : bool) =
	result = True <-> witness k1 = witness (key_ co2 cu2)

 function oeq__2__logic (co1:map) (co2:map) : bool =
    if equal_ co1 co2 then True else False

  predicate oeq__2__pre (co1:map) (co2:map) = true
  predicate oeq__2__post (co1:map) (co2:map) (result:bool) = 
         result  = True <-> equal_ co1 co2

  function length__logic (co : map) : Ada__containers__count_type.count_type = Ada__containers__count_type.of_int (length co)

  predicate length__pre (co : map) = true
  predicate length__post (co : map) (result :  Ada__containers__count_type.count_type) =
     result = Ada__containers__count_type.of_int (length co)

  function is_empty__logic map : bool 

  axiom is_empty__logic_def:
    forall co : map [is_empty__logic co ].
      is_empty__logic co = True <-> is_empty_ co

  predicate is_empty__pre (co:map) = true
  predicate is_empty__post (co:map) (result:bool)=
     result = True <-> is_empty_ co

  predicate clear__pre (co:map) = true
  predicate clear__post (co oldco: map) =
     is_empty_ co /\ capacity co = capacity oldco

  predicate assign__pre (target:map) (source:map) =
     capacity target >= length source
  predicate assign__post (target oldtarget:map) (source:map) =
     equal_ target source /\ capacity target = capacity oldtarget 

  function copy__logic map Ada__containers__count_type.count_type : map

  axiom copy__logic_def:
    forall co:map, cap:Ada__containers__count_type.count_type [copy__logic co cap].
          strict_equal co (copy__logic co cap) 
                       /\ cap_is_max co (copy__logic co cap) (Ada__containers__count_type.to_int cap)

  predicate copy__pre (co:map) (cap:Ada__containers__count_type.count_type) = true
  predicate copy__post (co:map) (cap:Ada__containers__count_type.count_type) 
              (result: map) =
     strict_equal co (result) /\ cap_is_max co result (Ada__containers__count_type.to_int cap)

  function key__logic (co:map) (cu:cursor) : key_type = key_ co cu

  predicate key__pre (co:map) (cu:cursor) =
     has_element co cu
  predicate key__post (co:map) (cu:cursor) (result : key_type) =
     result = key_ co cu

  function element__logic (co:map) (cu:cursor) : element_type = element_ co cu

  predicate element__pre (co:map) (cu:cursor) =
     has_element co cu
  predicate element__post (co:map) (cu:cursor) (result : element_type) =
     result = element_ co cu

  function element__2__logic (co:map) (k:key_type) : element_type = element__ co (witness k)

  predicate element__2__pre (co:map) (k:key_type) =
     contains co (witness k)
  predicate element__2__post (co:map) (k:key_type) (result : element_type) =
     result = element__ co (witness k)

  predicate replace_element__pre (co: map) (cu:cursor) (e:element_type)=
     has_element co cu
  predicate replace_element__post (co oldco: map) (cu:cursor) (e:element_type)=
     replace_element_ oldco cu e co

  predicate move__pre (target:map) (source:map) =
     capacity target >= length source
  predicate move__post (target oldtarget:map) (source oldsource:map) =
     equal_ target oldsource /\ is_empty_ source /\ capacity target = capacity oldtarget

  predicate insert__pre (co :map) (k:key_type) (e:element_type) 
                                             (p : cursor) (inserted : bool)=
     length co  < capacity co \/ contains co (witness k)
  predicate insert__post (co oldco: map) (k:key_type) (e:element_type) 
                                             (p oldp : cursor) (inserted oldinserted : bool) =
     (if inserted = False then contains oldco (witness k) 
      else not (contains oldco (witness k))) /\ 
       (if contains oldco (witness k) then 
      (p = find_ oldco (witness k) /\ co = oldco /\ inserted = False)
       else (first_inserted oldco k e co p /\ insert_ oldco k e co /\ inserted = True))

  predicate insert__2__pre (co :map) (k:key_type) (e:element_type) =
     length co  < capacity co /\ not contains co (witness k)
  predicate insert__2__post (co oldco: map) (k:key_type) (e:element_type) =
     insert_ oldco k e co

  predicate include__pre (co :map) (k:key_type) (e:element_type) =
     length co  < capacity co \/ contains co (witness k)
  predicate include__post (co oldco: map) (k:key_type) (e:element_type) =
     include__ oldco k e co

  predicate replace__pre (co :map) (k:key_type) (e:element_type) =
     contains co (witness k)
  predicate replace__post (co oldco: map) (k:key_type) (e:element_type) =
     replace_ oldco k e co

  predicate exclude__pre (co :map) (k:key_type) = true
  predicate exclude__post (co oldco: map) (k:key_type) =
     exclude_ oldco k co

  predicate delete__pre (co :map) (k:key_type) = contains co (witness k)
  predicate delete__post (co oldco: map) (k:key_type) =
     delete_ oldco (find_ oldco (witness k)) co

  predicate delete__2__pre (co :map) (cu:cursor) = has_element co cu
  predicate delete__2__post (co oldco: map) (cu oldcu:cursor) =
     delete_ oldco oldcu co /\ cu = no_element

  predicate delete_first__pre (co :map) = length co > 0
  predicate delete_first__post (co oldco: map) =
     delete_ oldco (first oldco) co

  function next__logic (co:map) (cu:cursor) : cursor = next_ co cu

  predicate next__pre (co:map) (cu:cursor)= cu = no_element \/ has_element co cu 
  predicate next__post (co:map) (cu:cursor) (result : cursor) =
     result = next_ co cu

  predicate next__2__pre (co:map) (cu:cursor) =
     cu = no_element \/ has_element co cu
  predicate next__2__post (co:map) (cu oldcu:cursor) =
     cu = next_ co oldcu

  function first__logic (co:map) : cursor = first co

  predicate first__pre (co:map) = true
  predicate first__post (co:map) (result:cursor) =
     result = first co

  function first_element__logic (co:map) : element_type = element_ co (first co)

  predicate first_element__pre (co:map) = length co > 0
  predicate first_element__post (co:map) (result:element_type) =
     result = element_ co (first co)

  function first_key__logic (co:map) : key_type = key_ co (first co)

  predicate first_key__pre (co:map) = length co > 0
  predicate first_key__post (co:map) (result:key_type) =
     result = key_ co (first co)

  function find__logic (co:map) (e:key_type) : cursor = find_ co (witness e)

  predicate find__pre (co:map) (e:key_type) = true
  predicate find__post (co:map) (e:key_type) (result:cursor) =
     result = find_ co (witness e)

  function contains__logic map key_type: bool

  axiom contains__logic_def:
    forall co : map, e : key_type [contains__logic co e].
      contains co (witness e) <-> contains__logic co e = True

  predicate contains__pre (co:map) (e:key_type) = true
  predicate contains__post (co:map) (e:key_type) (result: bool) =
     contains co (witness e) <-> result = True

  function has_element__logic map cursor : bool

  axiom has_element__logic_def:
    forall co : map, cu : cursor [has_element__logic co cu].
      has_element co cu <-> has_element__logic co cu = True

  predicate has_element__pre (co:map) (cu:cursor) = true
  predicate has_element__post (co:map) (cu:cursor) (result: bool) =
     has_element co cu <-> result = True

  function strict_equal__logic (co1 co2 : map) : bool =
    if strict_equal co1 co2 then True else False

  predicate strict_equal__pre (co1:map) (co2:map) = true
  predicate strict_equal__post (co1:map) (co2:map) (result:bool) =
     result  = True <-> strict_equal co1 co2

  function left__logic (co:map) (cu:cursor) : map = left_ co cu

  predicate left__pre (co:map) (cu:cursor) =
     cu = no_element \/ has_element co cu
  predicate left__post (co:map) (cu:cursor) (result:map) =
     result = left_ co cu

  function right__logic (co:map) (cu:cursor) : map = right_ co cu

  predicate right__pre (co:map) (cu:cursor) =
     cu = no_element \/ has_element co cu
  predicate right__post (co:map) (cu:cursor)(result : map) =
     result = right_ co cu

  function overlap__logic (co1 co2:map) : bool = 
   if no_overlaping co1 co2 then False else True

  predicate overlap__pre (co1 co2:map) = true
  predicate overlap__post (co1 co2:map)(result : bool) =
     result = False <-> no_overlaping co1 co2
     
end


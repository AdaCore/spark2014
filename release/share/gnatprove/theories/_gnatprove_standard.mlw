module Main
  use import int.Int
  use int.Abs as AbsInt
  use int.ComputerDivision
  use int.EuclideanDivision
  use real.Real
  use export real.RealInfix
  use real.Abs as AbsReal
  use real.Square as SquareReal
  use real.Trigonometry
  use import bool.Bool
  use export bool.Ite
  use floating_point.Rounding
  use floating_point.Single
  use floating_point.Double
  use import module ref.Ref

  (* This exception is used to simulate return statements *)

  exception Gnatprove_Exception___result_exc


  (* The theory of Ada arrays of one dimension *)

  type t__ada_array 'a

  function t__ada_array___access int (t__ada_array 'a) : 'a

  function t__ada_array___update int (t__ada_array 'a) 'a : (t__ada_array 'a)

  function t__ada_array___equal (t__ada_array 'a) (t__ada_array 'a) : bool

  function t__ada_array___attr___ATTRIBUTE_LENGTH (t__ada_array 'a) : int

  function t__ada_array___attr___ATTRIBUTE_FIRST (t__ada_array 'a) : int

  function t__ada_array___attr___ATTRIBUTE_LAST (t__ada_array 'a) : int

val t__ada_array___access_ :
 i : int -> a : t__ada_array 'a ->
{ (t__ada_array___attr___ATTRIBUTE_FIRST a) <= i <= (t__ada_array___attr___ATTRIBUTE_LAST a) }'a
 { result = t__ada_array___access i a }

val t__ada_array___update_ :
 i : int -> a : t__ada_array 'a -> v : 'a ->
{ t__ada_array___attr___ATTRIBUTE_FIRST (a) <= i <= t__ada_array___attr___ATTRIBUTE_LAST (a) } t__ada_array 'a
 { result = t__ada_array___update i a v }

  axiom T__ada_array___accupd_eq:
    forall a:t__ada_array 'a.
    forall i:int.
    forall v:'a [t__ada_array___update i a v].
       t__ada_array___access i (t__ada_array___update i a v) = v

  axiom T__ada_array___accupd_neq:
    forall a:t__ada_array 'a.
    forall i:int.
    forall j:int.
    forall v:'a [t__ada_array___access j (t__ada_array___update i a v ) |
                  t__ada_array___update i a v,
                  t__ada_array___access j a].
      i <> j ->
       t__ada_array___access j (t__ada_array___update i a v ) = t__ada_array___access j a

  axiom T__ada_array___first_update:
    forall a:t__ada_array 'a.
    forall i:int.
    forall v:'a.
      t__ada_array___attr___ATTRIBUTE_FIRST a =
      t__ada_array___attr___ATTRIBUTE_FIRST (t__ada_array___update i a v)

  axiom T__ada_array___last_update:
    forall a:t__ada_array 'a.
    forall i:int.
    forall v:'a.
      t__ada_array___attr___ATTRIBUTE_LAST a =
      t__ada_array___attr___ATTRIBUTE_LAST (t__ada_array___update i a v )

  axiom T__ada_array___length_update:
    forall a:t__ada_array 'a.
    forall i:int.
    forall v:'a.
       t__ada_array___attr___ATTRIBUTE_LENGTH a =
       t__ada_array___attr___ATTRIBUTE_LENGTH (t__ada_array___update i a v)

  axiom T__ada_array___length_non_zero:
    forall a:t__ada_array 'a.
      t__ada_array___attr___ATTRIBUTE_LAST a >= t__ada_array___attr___ATTRIBUTE_FIRST a ->
       t__ada_array___attr___ATTRIBUTE_LENGTH a =
       t__ada_array___attr___ATTRIBUTE_LAST a -
       t__ada_array___attr___ATTRIBUTE_FIRST a + 1

  axiom T__ada_array___length_zero:
    forall a:t__ada_array 'a.
      t__ada_array___attr___ATTRIBUTE_LAST a < t__ada_array___attr___ATTRIBUTE_FIRST a ->
      t__ada_array___attr___ATTRIBUTE_LENGTH a = 0

  axiom T__ada_array___equal_def:
    forall a:t__ada_array 'a.
    forall b:t__ada_array 'a.
        ((t__ada_array___attr___ATTRIBUTE_LENGTH a =
           t__ada_array___attr___ATTRIBUTE_LENGTH b)
         /\ (forall i:int.
               (t__ada_array___attr___ATTRIBUTE_FIRST a <= i <=
                  t__ada_array___attr___ATTRIBUTE_LAST a)
                ->
               (t__ada_array___access i a =
                  t__ada_array___access (t__ada_array___attr___ATTRIBUTE_FIRST b - t__ada_array___attr___ATTRIBUTE_FIRST a + i) b)))
        <-> t__ada_array___equal a b = True

  (* The theory of Ada arrays of two dimensions *)

  type t__ada_array_2 'a

  function t__ada_array_2___access int int (t__ada_array_2 'a) : 'a

  function t__ada_array_2___update int int (t__ada_array_2 'a) 'a
     : (t__ada_array_2 'a)

  function t__ada_array_2___equal (t__ada_array_2 'a) (t__ada_array_2 'a) : bool

  function t__ada_array_2___attr___ATTRIBUTE_LENGTH (t__ada_array_2 'a) : int
  function t__ada_array_2___attr___ATTRIBUTE_LENGTH_2 (t__ada_array_2 'a) : int

  function t__ada_array_2___attr___ATTRIBUTE_FIRST (t__ada_array_2 'a) : int
  function t__ada_array_2___attr___ATTRIBUTE_FIRST_2 (t__ada_array_2 'a) : int

  function t__ada_array_2___attr___ATTRIBUTE_LAST (t__ada_array_2 'a) : int
  function t__ada_array_2___attr___ATTRIBUTE_LAST_2 (t__ada_array_2 'a) : int

val t__ada_array_2___access_ :
 i : int -> j : int -> a : t__ada_array_2 'a ->
 { t__ada_array_2___attr___ATTRIBUTE_FIRST a <= i <= t__ada_array_2___attr___ATTRIBUTE_LAST a /\
   t__ada_array_2___attr___ATTRIBUTE_FIRST_2 a <= j <= t__ada_array_2___attr___ATTRIBUTE_LAST_2 a
 }
 'a
 { result = t__ada_array_2___access i j a }

val t__ada_array_2___update_ :
 i : int -> j : int -> a : t__ada_array_2 'a -> v : 'a ->
 { t__ada_array_2___attr___ATTRIBUTE_FIRST a <= i <= t__ada_array_2___attr___ATTRIBUTE_LAST a /\
   t__ada_array_2___attr___ATTRIBUTE_FIRST_2 a <= j <= t__ada_array_2___attr___ATTRIBUTE_LAST_2 a
 }
 t__ada_array_2 'a
 { result = t__ada_array_2___update i j a v }

  axiom T__ada_array_2___accupd_eq:
    forall a:t__ada_array_2 'a.
    forall i:int. forall j :int.
    forall v:'a [t__ada_array_2___update i j a v].
       t__ada_array_2___access i j (t__ada_array_2___update i j a v) = v

  axiom T__ada_array_2___accupd_neq:
    forall a:t__ada_array_2 'a.
    forall i1:int.
    forall i2:int.
    forall j1:int.
    forall j2:int.
    forall v:'a [t__ada_array_2___access i2 j2 (t__ada_array_2___update i1 j1 a v ) |
                  t__ada_array_2___update i1 j1 a v,
                  t__ada_array_2___access i2 j2 a].
      (i1 <> i2 \/ j1 <> j2) ->
       t__ada_array_2___access i2 j2 (t__ada_array_2___update i1 j1 a v ) =
       t__ada_array_2___access i2 j2 a

  axiom T__ada_array_2___first_update:
    forall a:t__ada_array_2 'a.
    forall i:int. forall j : int.
    forall v:'a.
      t__ada_array_2___attr___ATTRIBUTE_FIRST a =
      t__ada_array_2___attr___ATTRIBUTE_FIRST (t__ada_array_2___update i j a v)

  axiom T__ada_array_2___first_update_2:
    forall a:t__ada_array_2 'a.
    forall i:int. forall j : int.
    forall v:'a.
      t__ada_array_2___attr___ATTRIBUTE_FIRST_2 a =
      t__ada_array_2___attr___ATTRIBUTE_FIRST_2 (t__ada_array_2___update i j a v)

  axiom T__ada_array_2___last_update:
    forall a:t__ada_array_2 'a.
    forall i:int. forall j : int.
    forall v:'a.
      t__ada_array_2___attr___ATTRIBUTE_LAST a =
      t__ada_array_2___attr___ATTRIBUTE_LAST (t__ada_array_2___update i j a v )

  axiom T__ada_array_2___last_update_2:
    forall a:t__ada_array_2 'a.
    forall i:int. forall j : int.
    forall v:'a.
      t__ada_array_2___attr___ATTRIBUTE_LAST_2 a =
      t__ada_array_2___attr___ATTRIBUTE_LAST_2 (t__ada_array_2___update i j a v )

  axiom T__ada_array_2___length_update:
    forall a:t__ada_array_2 'a.
    forall i:int. forall j : int.
    forall v:'a.
       t__ada_array_2___attr___ATTRIBUTE_LENGTH a =
       t__ada_array_2___attr___ATTRIBUTE_LENGTH (t__ada_array_2___update i j a v)

  axiom T__ada_array_2___length_update_2:
    forall a:t__ada_array_2 'a.
    forall i:int. forall j : int.
    forall v:'a.
       t__ada_array_2___attr___ATTRIBUTE_LENGTH_2 a =
       t__ada_array_2___attr___ATTRIBUTE_LENGTH_2 (t__ada_array_2___update i j a v)

  axiom T__ada_array_2___length_non_zero:
    forall a:t__ada_array_2 'a.
      t__ada_array_2___attr___ATTRIBUTE_LAST a >= t__ada_array_2___attr___ATTRIBUTE_FIRST a ->
       t__ada_array_2___attr___ATTRIBUTE_LENGTH a =
       t__ada_array_2___attr___ATTRIBUTE_LAST a -
       t__ada_array_2___attr___ATTRIBUTE_FIRST a + 1

  axiom T__ada_array_2___length_zero:
    forall a:t__ada_array_2 'a.
      t__ada_array_2___attr___ATTRIBUTE_LAST a < t__ada_array_2___attr___ATTRIBUTE_FIRST a ->
      t__ada_array_2___attr___ATTRIBUTE_LENGTH a = 0

  axiom T__ada_array_2___length_non_zero_2:
    forall a:t__ada_array_2 'a.
      t__ada_array_2___attr___ATTRIBUTE_LAST_2 a >=
      t__ada_array_2___attr___ATTRIBUTE_FIRST_2 a ->
       t__ada_array_2___attr___ATTRIBUTE_LENGTH_2 a =
       t__ada_array_2___attr___ATTRIBUTE_LAST_2 a -
       t__ada_array_2___attr___ATTRIBUTE_FIRST_2 a + 1

  axiom T__ada_array_2___length_zero_2:
    forall a:t__ada_array_2 'a.
      t__ada_array_2___attr___ATTRIBUTE_LAST_2 a <
      t__ada_array_2___attr___ATTRIBUTE_FIRST_2 a ->
      t__ada_array_2___attr___ATTRIBUTE_LENGTH_2 a = 0

  axiom T__ada_array_2___equal_def:
    forall a:t__ada_array_2 'a.
    forall b:t__ada_array_2 'a.
        ((t__ada_array_2___attr___ATTRIBUTE_LENGTH a = t__ada_array_2___attr___ATTRIBUTE_LENGTH b)
         /\
         (t__ada_array_2___attr___ATTRIBUTE_LENGTH_2 a = t__ada_array_2___attr___ATTRIBUTE_LENGTH_2 b)
         /\
         (forall i:int. forall j : int.
               (t__ada_array_2___attr___ATTRIBUTE_FIRST a <= i <=
                  t__ada_array_2___attr___ATTRIBUTE_LAST a)
                ->
               (t__ada_array_2___attr___ATTRIBUTE_FIRST_2 a <= j <=
                  t__ada_array_2___attr___ATTRIBUTE_LAST_2 a)
                ->
               (t__ada_array_2___access i j a =
                  t__ada_array_2___access
                  (t__ada_array_2___attr___ATTRIBUTE_FIRST b - t__ada_array_2___attr___ATTRIBUTE_FIRST a + i)
                  (t__ada_array_2___attr___ATTRIBUTE_FIRST_2 b - t__ada_array_2___attr___ATTRIBUTE_FIRST_2 a + j)
                  b)))
        <-> t__ada_array_2___equal a b = True

  (* The type for the heap, and the heap variable. This variable represents
     all effects that we cannot describe more precisely, and that do not
     interfere with other variables, i.e., writes through pointers, aliased
     variables etc. *)

  type _type_of______HEAP

  val __HEAP : ref _type_of______HEAP


  (* Boolean logical connectors, functions for conversion of booleans, etc *)

  function int_of_bool (b : bool) : int =
   if b = True then 1 else 0

  function bool_of_int (i : int) : bool =
   if i = 0 then False else True

  function bool_int__eq int int : bool

  axiom Bool_int__eq_axiom:
    forall x:int.
    forall y:int.
      bool_int__eq x y = True <-> x = y

  function bool_int__ne int int : bool

  axiom Bool_int__ne_axiom:
    forall x:int.
      forall y:int.
        bool_int__ne x y = True <-> x <> y

  function bool_int__lt int int : bool

  axiom Bool_int__lt_axiom:
    forall x:int.
    forall y:int.
        bool_int__lt x y = True <-> x < y

  function bool_int__le int int : bool

  axiom Bool_int__le_axiom:
    forall x:int.  forall y:int.  bool_int__le x y = True <-> x <= y

  function bool_int__gt int int : bool

  axiom Bool_int__gt_axiom:
    forall x:int.
    forall y:int.
        bool_int__gt x y = True <-> x > y

  function bool_int__ge int int : bool

  axiom Bool_int__ge_axiom:
    forall x:int.
    forall y:int.
        bool_int__ge x y = True <-> x >= y

  function ___ignore 'a : ()

  axiom Abs_int_pos:
    forall x:int. x >= 0 -> AbsInt.abs x = x

  axiom Abs_int_neg:
    forall x:int.
      x <= 0 -> AbsInt.abs x = - x

  function int_max int int : int

  function int_min int int : int

  axiom Int_max_is_ge:
    forall x:int.
    forall y:int.
      int_max x y >= x /\ int_max x y >= y

  axiom Int_max_is_some:
    forall x:int.
    forall y:int.
        int_max x y = x \/ int_max x y = y

  axiom Int_min_is_le:
    forall x:int.
    forall y:int.
        int_min x y <= x /\
        int_min x y <= y

  axiom Int_min_is_some:
    forall x:int.
    forall y:int.
        int_min x y = x \/ int_min x y = y

  function computer_div (x y : int) : int = ComputerDivision.div x y

  function computer_mod (x y : int) : int = ComputerDivision.mod x y

  function math_div (x y : int) : int = EuclideanDivision.div x y

  function math_mod (x y : int) : int = EuclideanDivision.mod x y

  function div_real (x : real) (y : real) : real = x /. y

  val computer_div_ : x:int -> y:int ->
    { y<>0 } int { result = computer_div x y }

  val computer_mod_ : x:int -> y:int ->
    { y<>0 } int { result = computer_mod x y }

  val math_mod_ : x:int -> y:int ->
    { y<>0 } int { result = math_mod x y }

  val div_real_ : x:real -> y:real ->
    { y<>0.0 } real { result = div_real x y }

  use real.FromInt

  function real_of_int (x : int) : real = FromInt.from_int x

  (* Boolean comparison functions for reals *)

  function bool_real__lt real real : bool

  function bool_real__le real real : bool

  function bool_real__gt real real : bool

  function bool_real__ge real real : bool

  function bool_real__eq real real : bool

  function bool_real__neq real real : bool

  axiom Bool_real__lt_axiom:
    forall x:real.
    forall y:real.
      bool_real__lt x y = True <-> x <. y

  axiom Bool_real__le_axiom:
    forall x:real.
    forall y:real.
      bool_real__le x y = True <-> x <=. y

  axiom Bool_real__gt_axiom:
    forall x:real.
    forall y:real.
        bool_real__gt x y = True <-> x >. y

  axiom Bool_real__ge_axiom:
    forall x:real.
    forall y:real.
      bool_real__ge x y = True <-> x >=. y

  axiom Bool_real__eq_axiom:
    forall x:real.
    forall y:real.
      bool_real__eq x y = True <-> x = y

  axiom Bool_real__neq_axiom:
    forall x:real.
    forall y:real.
       bool_real__neq x y = True <-> x <> y

end


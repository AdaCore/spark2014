module Main
  use import int.Int
  use int.Abs as AbsInt
  use int.ComputerDivision
  use real.Real
  use export real.RealInfix
  use real.Abs as AbsReal
  use real.Square as SquareReal
  use real.Trigonometry
  use import bool.Bool
  use floating_point.Rounding
  use floating_point.Single
  use floating_point.Double
  use import module ref.Ref

  (* This exception is used to simulate return statements *)

  exception Gnatprove_Exception___result_exc


  (* The theory of Ada arrays of one dimension *)

  type t__ada_array 'a

  function t__ada_array___access int (t__ada_array 'a) : 'a

  function t__ada_array___update int (t__ada_array 'a) 'a : (t__ada_array 'a)

  function t__ada_array___equal (t__ada_array 'a) (t__ada_array 'a) : bool

  function t__ada_array___attr___ATTRIBUTE_LENGTH (t__ada_array 'a) : int

  function t__ada_array___attr___ATTRIBUTE_FIRST (t__ada_array 'a) : int

  function t__ada_array___attr___ATTRIBUTE_LAST (t__ada_array 'a) : int

val t__ada_array___access_ :
 i : int -> a : t__ada_array 'a ->
{ (t__ada_array___attr___ATTRIBUTE_FIRST a) <= i <= (t__ada_array___attr___ATTRIBUTE_LAST a) }'a
 { result = t__ada_array___access i a }

val t__ada_array___update_ :
 i : int -> a : t__ada_array 'a -> v : 'a ->
{ t__ada_array___attr___ATTRIBUTE_FIRST (a) <= i <= t__ada_array___attr___ATTRIBUTE_LAST (a) } t__ada_array 'a
 { result = t__ada_array___update i a v }

  axiom T__ada_array___accupd_eq:
    forall a:t__ada_array 'a.
    forall i:int.
    forall v:'a [t__ada_array___update i a v].
       t__ada_array___access i (t__ada_array___update i a v) = v

  axiom T__ada_array___accupd_neq:
    forall a:t__ada_array 'a.
    forall i:int.
    forall j:int.
    forall v:'a [t__ada_array___access j (t__ada_array___update i a v ) |
                  t__ada_array___update i a v,
                  t__ada_array___access j a].
      i <> j ->
       t__ada_array___access j (t__ada_array___update i a v ) = t__ada_array___access j a

  axiom T__ada_array___first_update:
    forall a:t__ada_array 'a.
    forall i:int.
    forall v:'a.
      t__ada_array___attr___ATTRIBUTE_FIRST a =
      t__ada_array___attr___ATTRIBUTE_FIRST (t__ada_array___update i a v)

  axiom T__ada_array___last_update:
    forall a:t__ada_array 'a.
    forall i:int.
    forall v:'a.
      t__ada_array___attr___ATTRIBUTE_LAST a =
      t__ada_array___attr___ATTRIBUTE_LAST (t__ada_array___update i a v )

  axiom T__ada_array___length_update:
    forall a:t__ada_array 'a.
    forall i:int.
    forall v:'a.
       t__ada_array___attr___ATTRIBUTE_LENGTH a =
       t__ada_array___attr___ATTRIBUTE_LENGTH (t__ada_array___update i a v)

  axiom T__ada_array___length_non_zero:
    forall a:t__ada_array 'a.
      t__ada_array___attr___ATTRIBUTE_LAST a >= t__ada_array___attr___ATTRIBUTE_FIRST a ->
       t__ada_array___attr___ATTRIBUTE_LENGTH a =
       t__ada_array___attr___ATTRIBUTE_LAST a -
       t__ada_array___attr___ATTRIBUTE_FIRST a + 1

  axiom T__ada_array___length_zero:
    forall a:t__ada_array 'a.
      t__ada_array___attr___ATTRIBUTE_LAST a < t__ada_array___attr___ATTRIBUTE_FIRST a ->
      t__ada_array___attr___ATTRIBUTE_LENGTH a = 0

  axiom T__ada_array___equal_def:
    forall a:t__ada_array 'a.
    forall b:t__ada_array 'a.
        ((t__ada_array___attr___ATTRIBUTE_LENGTH a =
           t__ada_array___attr___ATTRIBUTE_LENGTH b)
         /\ (forall i:int.
               (t__ada_array___attr___ATTRIBUTE_FIRST a <= i <=
                  t__ada_array___attr___ATTRIBUTE_LAST a)
                ->
               (t__ada_array___access i a =
                  t__ada_array___access (t__ada_array___attr___ATTRIBUTE_FIRST b - t__ada_array___attr___ATTRIBUTE_FIRST a + i) b)))
        <-> t__ada_array___equal a b = True


  (* The type for the heap, and the heap variable. This variable represents
     all effects that we cannot describe more precisely, and that do not
     interfere with other variables, i.e., writes through pointers, aliased
     variables etc. *)

  type _type_of______HEAP

  val __HEAP : ref _type_of______HEAP


  (* Boolean logical connectors, functions for conversion of booleans, etc *)

  function bool_and bool bool : bool

  function bool_or bool bool : bool

  function bool_xor bool bool : bool

  function bool_not bool : bool

  axiom Bool_and_def:
    forall a:bool.
    forall b:bool.
     bool_and a b = True <-> (a = True /\ b = True)

  axiom Bool_or_def:
    forall a:bool.
    forall b:bool.
      bool_or a b = True <-> (a = True \/ b = True)

  axiom Bool_xor_def:
    forall a:bool.
    forall b:bool.
      bool_xor a b = True <-> a <> b

  axiom Bool_not_def:
    forall a:bool.  bool_not a = True <-> a = Bool.False

  function ite bool 'a 'a : 'a

  axiom Ite_true:
    forall x:'a. forall y:'a. ite True x y = x

  axiom Ite_false:
    forall x:'a. forall y:'a. ite Bool.False x y = y

  function int_of_bool (b : bool) : int =
   if b = True then 1 else 0

  function bool_of_int (i : int) : bool =
   if i = 0 then False else True

  function bool_int__eq int int : bool

  axiom Bool_int__eq_axiom:
    forall x:int.
    forall y:int.
      bool_int__eq x y = True <-> x = y

  function bool_int__ne int int : bool

  axiom Bool_int__ne_axiom:
    forall x:int.
      forall y:int.
        bool_int__ne x y = True <-> x <> y

  function bool_int__lt int int : bool

  axiom Bool_int__lt_axiom:
    forall x:int.
    forall y:int.
        bool_int__lt x y = True <-> x < y

  function bool_int__le int int : bool

  axiom Bool_int__le_axiom:
    forall x:int.  forall y:int.  bool_int__le x y = True <-> x <= y

  function bool_int__gt int int : bool

  axiom Bool_int__gt_axiom:
    forall x:int.
    forall y:int.
        bool_int__gt x y = True <-> x > y

  function bool_int__ge int int : bool

  axiom Bool_int__ge_axiom:
    forall x:int.
    forall y:int.
        bool_int__ge x y = True <-> x >= y

  function ___ignore 'a : ()

  axiom Abs_int_pos:
    forall x:int. x >= 0 -> AbsInt.abs x = x

  axiom Abs_int_neg:
    forall x:int.
      x <= 0 -> AbsInt.abs x = - x

  function int_max int int : int

  function int_min int int : int

  axiom Int_max_is_ge:
    forall x:int.
    forall y:int.
      int_max x y >= x /\ int_max x y >= y

  axiom Int_max_is_some:
    forall x:int.
    forall y:int.
        int_max x y = x \/ int_max x y = y

  axiom Int_min_is_le:
    forall x:int.
    forall y:int.
        int_min x y : int <= x /\
        int_min x y : int <= y

  axiom Int_min_is_some:
    forall x:int.
    forall y:int.
        int_min x y = x \/ int_min x y = y

  function computer_div int int : int

  function computer_mod int int : int

  function math_div int int : int

  function math_mod int int : int

  axiom Math_div_mod:
    (forall x:int.
      (forall y:int.
        ((y <> 0) ->
         (x = (Int.(+) (Int.(*) y (math_div x y : int) : int) (math_mod x y : int) : int)))))

  axiom Math_mod_bound:
    (forall x:int.
      (forall y:int.
        ((y <> 0) ->
         ((Int.(<=) 0 (math_mod x y : int)) /\
          (Int.(<) (math_mod x y : int) (AbsInt.abs y : int))))))

  axiom Computer_div_mod:
    (forall x:int.
      (forall y:int [(ComputerDivision.div x y : int),
        (ComputerDivision.mod x y : int)].
        ((y <> 0) ->
         (x = (Int.(+) (Int.(*) y (ComputerDivision.div x y : int) : int) (ComputerDivision.mod x y : int) : int)))))

  axiom Computer_div_bound:
    (forall x:int.
      (forall y:int.
        (((Int.(>=) x 0) /\ (Int.(>) y 0)) ->
         ((Int.(<=) 0 (ComputerDivision.div x y : int)) /\
          (Int.(<=) (ComputerDivision.div x y : int) x)))))

  axiom Computer_mod_bound:
    (forall x:int.
      (forall y:int.
        ((y <> 0) ->
         (Int.(<) (AbsInt.abs (ComputerDivision.mod x y : int) : int) (AbsInt.abs y : int)))))

  axiom Computer_mod_sign_pos:
    (forall x:int.
      (forall y:int.
        (((Int.(>=) x 0) /\ (y <> 0)) ->
         (Int.(>=) (ComputerDivision.mod x y : int) 0))))

  axiom Computer_mod_sign_neg:
    (forall x:int.
      (forall y:int.
        (((Int.(<=) x 0) /\ (y <> 0)) ->
         (Int.(<=) (ComputerDivision.mod x y : int) 0))))

  axiom Computer_rounds_toward_zero:
    (forall x:int.
      (forall y:int.
        ((y <> 0) ->
         (Int.(<=) (AbsInt.abs (Int.(*) (ComputerDivision.div x y : int) y : int) : int) (AbsInt.abs x : int)))))

  function div_real (x : real) (y : real) : real = x /. y

  val computer_div_ : x:int -> y:int ->
    { y<>0 } int { result = computer_div x y }

  val computer_mod_ : x:int -> y:int ->
    { y<>0 } int { result = computer_mod x y }

  val math_mod_ : x:int -> y:int ->
    { y<>0 } int { result = math_mod x y }

  val div_real_ : x:real -> y:real ->
    { y<>0.0 } real { result = div_real x y }

  use real.FromInt

  function real_of_int (x : int) : real = FromInt.from_int x

  (* Boolean comparison functions for reals *)  

  function lt_real_bool real real : bool

  function le_real_bool real real : bool

  function gt_real_bool real real : bool

  function ge_real_bool real real : bool

  function eq_real_bool real real : bool

  function neq_real_bool real real : bool

  axiom Lt_real_bool_axiom:
    (forall x:real.
      (forall y:real.
        (((lt_real_bool x y : bool) = True) <-> (Real.(<) x y))))

  axiom Le_real_bool_axiom:
    (forall x:real.
      (forall y:real.
        (((le_real_bool x y : bool) = True) <-> (Real.(<=) x y))))

  axiom Gt_real_bool_axiom:
    (forall x:real.
      (forall y:real.
        (((gt_real_bool x y : bool) = True) <-> (Real.(>) x y))))

  axiom Ge_real_bool_axiom:
    (forall x:real.
      (forall y:real.
        (((ge_real_bool x y : bool) = True) <-> (Real.(>=) x y))))

  axiom Eq_real_bool_axiom:
    (forall x:real.
      (forall y:real.
        (((eq_real_bool x y : bool) = True) <-> (x = y))))

  axiom Neq_real_bool_axiom:
    (forall x:real.
      (forall y:real.
        (((neq_real_bool x y : bool) = True) <-> (x <> y))))

end


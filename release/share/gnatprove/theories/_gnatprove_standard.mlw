module Main
  use import int.Int
  use int.Abs as AbsInt
  use int.ComputerDivision
  use real.Real
  use export real.RealInfix
  use real.Abs as AbsReal
  use real.Square as SquareReal
  use real.Trigonometry
  use bool.Bool
  use floating_point.Rounding
  use floating_point.Single
  use floating_point.Double
  use import module ref.Ref

  exception Gnatprove_Exception___result_exc

  type t__ada_array 'a

  function t__ada_array___access int (t__ada_array 'a) : 'a

  function t__ada_array___update int (t__ada_array 'a) 'a : (t__ada_array 'a)

  function t__ada_array___equal (t__ada_array 'a) (t__ada_array 'a) : bool

  function t__ada_array___attr___ATTRIBUTE_LENGTH (t__ada_array 'a) : int

  function t__ada_array___attr___ATTRIBUTE_FIRST (t__ada_array 'a) : int

  function t__ada_array___attr___ATTRIBUTE_LAST (t__ada_array 'a) : int

val t__ada_array___access_ :
 i : int -> a : t__ada_array 'a ->
{ (t__ada_array___attr___ATTRIBUTE_FIRST a) <= i <= (t__ada_array___attr___ATTRIBUTE_LAST a) }'a
 { result = t__ada_array___access i a }

val t__ada_array___update_ :
 i : int -> a : t__ada_array 'a -> v : 'a ->
{ t__ada_array___attr___ATTRIBUTE_FIRST (a) <= i <= t__ada_array___attr___ATTRIBUTE_LAST (a) } t__ada_array 'a
 { result = t__ada_array___update i a v }

  axiom T__ada_array___accupd_eq:
    forall a:t__ada_array 'a.
    forall i:int.
    forall v:'a [t__ada_array___update i a v].
       t__ada_array___access i (t__ada_array___update i a v) = v

  axiom T__ada_array___accupd_neq:
    forall a:t__ada_array 'a.
    forall i:int.
    forall j:int.
    forall v:'a [t__ada_array___access j (t__ada_array___update i a v ) |
                  t__ada_array___update i a v,
                  t__ada_array___access j a].
      i <> j ->
       t__ada_array___access j (t__ada_array___update i a v ) = t__ada_array___access j a

  axiom T__ada_array___first_update:
    forall a:t__ada_array 'a.
    forall i:int.
    forall v:'a.
      t__ada_array___attr___ATTRIBUTE_FIRST a =
      t__ada_array___attr___ATTRIBUTE_FIRST (t__ada_array___update i a v)

  axiom T__ada_array___last_update:
    forall a:t__ada_array 'a.
    forall i:int.
    forall v:'a.
      t__ada_array___attr___ATTRIBUTE_LAST a =
      t__ada_array___attr___ATTRIBUTE_LAST (t__ada_array___update i a v )

  axiom T__ada_array___length_update:
    forall a:t__ada_array 'a.
    forall i:int.
    forall v:'a.
       t__ada_array___attr___ATTRIBUTE_LENGTH a =
       t__ada_array___attr___ATTRIBUTE_LENGTH (t__ada_array___update i a v)

  axiom T__ada_array___length_non_zero:
    forall a:t__ada_array 'a.
      t__ada_array___attr___ATTRIBUTE_LAST a >= t__ada_array___attr___ATTRIBUTE_FIRST a ->
       t__ada_array___attr___ATTRIBUTE_LENGTH a =
       t__ada_array___attr___ATTRIBUTE_LAST a -
       t__ada_array___attr___ATTRIBUTE_FIRST a + 1

  axiom T__ada_array___length_zero:
    forall a:t__ada_array 'a.
      t__ada_array___attr___ATTRIBUTE_LAST a < t__ada_array___attr___ATTRIBUTE_FIRST a ->
      t__ada_array___attr___ATTRIBUTE_LENGTH a = 0

  axiom T__ada_array___equal_def:
    forall a:t__ada_array 'a.
    forall b:t__ada_array 'a.
        ((t__ada_array___attr___ATTRIBUTE_LENGTH a =
           t__ada_array___attr___ATTRIBUTE_LENGTH b)
         /\ (forall i:int.
               (t__ada_array___attr___ATTRIBUTE_FIRST a <= i <=
                  t__ada_array___attr___ATTRIBUTE_LAST a)
                ->
               (t__ada_array___access i a =
                  t__ada_array___access (t__ada_array___attr___ATTRIBUTE_FIRST b - t__ada_array___attr___ATTRIBUTE_FIRST a + i) b)))
        <-> t__ada_array___equal a b = Bool.True

  type _type_of______HEAP

  val __HEAP : ref _type_of______HEAP

  function bool_int__eq int int : Bool.bool

  axiom Bool_int__eq_axiom:
    (forall x:int.
      (forall y:int.
        ((((bool_int__eq x y : Bool.bool) = Bool.True) -> (x = y)) /\
         (((bool_int__eq x y : Bool.bool) = Bool.False) -> (not (x = y))))))

  function bool_int__ne int int : Bool.bool

  axiom Bool_int__ne_axiom:
    (forall x:int.
      (forall y:int.
        ((((bool_int__ne x y : Bool.bool) = Bool.True) -> (x <> y)) /\
         (((bool_int__ne x y : Bool.bool) = Bool.False) -> (not (x <> y))))))

  function bool_int__lt int int : Bool.bool

  axiom Bool_int__lt_axiom:
    (forall x:int.
      (forall y:int.
        ((((bool_int__lt x y : Bool.bool) = Bool.True) -> (Int.(<) x y)) /\
         (((bool_int__lt x y : Bool.bool) = Bool.False) ->
          (not (Int.(<) x y))))))

  function bool_int__le int int : Bool.bool

  axiom Bool_int__le_axiom:
    (forall x:int.
      (forall y:int.
        ((((bool_int__le x y : Bool.bool) = Bool.True) -> (Int.(<=) x y)) /\
         (((bool_int__le x y : Bool.bool) = Bool.False) ->
          (not (Int.(<=) x y))))))

  function bool_int__gt int int : Bool.bool

  axiom Bool_int__gt_axiom:
    (forall x:int.
      (forall y:int.
        ((((bool_int__gt x y : Bool.bool) = Bool.True) -> (Int.(>) x y)) /\
         (((bool_int__gt x y : Bool.bool) = Bool.False) ->
          (not (Int.(>) x y))))))

  function bool_int__ge int int : Bool.bool

  axiom Bool_int__ge_axiom:
    (forall x:int.
      (forall y:int.
        ((((bool_int__ge x y : Bool.bool) = Bool.True) -> (Int.(>=) x y)) /\
         (((bool_int__ge x y : Bool.bool) = Bool.False) ->
          (not (Int.(>=) x y))))))

  function ___ignore 'a1 : ()

  function lt_int_bool int int : Bool.bool

  function le_int_bool int int : Bool.bool

  function gt_int_bool int int : Bool.bool

  function ge_int_bool int int : Bool.bool

  function eq_int_bool int int : Bool.bool

  function neq_int_bool int int : Bool.bool

  axiom Lt_int_bool_axiom:
    (forall x:int.
      (forall y:int.
        (((lt_int_bool x y : Bool.bool) = Bool.True) <-> (Int.(<) x y))))

  axiom Le_int_bool_axiom:
    (forall x:int.
      (forall y:int.
        (((le_int_bool x y : Bool.bool) = Bool.True) <-> (Int.(<=) x y))))

  axiom Gt_int_bool_axiom:
    (forall x:int.
      (forall y:int.
        (((gt_int_bool x y : Bool.bool) = Bool.True) <-> (Int.(>) x y))))

  axiom Ge_int_bool_axiom:
    (forall x:int.
      (forall y:int.
        (((ge_int_bool x y : Bool.bool) = Bool.True) <-> (Int.(>=) x y))))

  axiom Eq_int_bool_axiom:
    (forall x:int.
      (forall y:int.
        (((eq_int_bool x y : Bool.bool) = Bool.True) <-> (x = y))))

  axiom Neq_int_bool_axiom:
    (forall x:int.
      (forall y:int.
        (((neq_int_bool x y : Bool.bool) = Bool.True) <-> (x <> y))))

  function abs_int int : int

  axiom Abs_int_pos:
    (forall x:int. ((Int.(>=) x 0) -> ((AbsInt.abs x : int) = x)))

  axiom Abs_int_neg:
    (forall x:int.
      ((Int.(<=) x 0) -> ((AbsInt.abs x : int) = (Int.(-_) x : int))))

  function int_max int int : int

  function int_min int int : int

  axiom Int_max_is_ge:
    (forall x:int.
      (forall y:int.
        ((Int.(>=) (int_max x y : int) x) /\
         (Int.(>=) (int_max x y : int) y))))

  axiom Int_max_is_some:
    (forall x:int.
      (forall y:int.
        (((int_max x y : int) = x) \/ ((int_max x y : int) = y))))

  axiom Int_min_is_le:
    (forall x:int.
      (forall y:int.
        ((Int.(<=) (int_min x y : int) x) /\
         (Int.(<=) (int_min x y : int) y))))

  axiom Int_min_is_some:
    (forall x:int.
      (forall y:int.
        (((int_min x y : int) = x) \/ ((int_min x y : int) = y))))

  function computer_div int int : int

  function computer_mod int int : int

  function math_div int int : int

  function math_mod int int : int

  axiom Math_div_mod:
    (forall x:int.
      (forall y:int.
        ((y <> 0) ->
         (x = (Int.(+) (Int.(*) y (math_div x y : int) : int) (math_mod x y : int) : int)))))

  axiom Math_mod_bound:
    (forall x:int.
      (forall y:int.
        ((y <> 0) ->
         ((Int.(<=) 0 (math_mod x y : int)) /\
          (Int.(<) (math_mod x y : int) (AbsInt.abs y : int))))))

  axiom Computer_div_mod:
    (forall x:int.
      (forall y:int [(ComputerDivision.div x y : int),
        (ComputerDivision.mod x y : int)].
        ((y <> 0) ->
         (x = (Int.(+) (Int.(*) y (ComputerDivision.div x y : int) : int) (ComputerDivision.mod x y : int) : int)))))

  axiom Computer_div_bound:
    (forall x:int.
      (forall y:int.
        (((Int.(>=) x 0) /\ (Int.(>) y 0)) ->
         ((Int.(<=) 0 (ComputerDivision.div x y : int)) /\
          (Int.(<=) (ComputerDivision.div x y : int) x)))))

  axiom Computer_mod_bound:
    (forall x:int.
      (forall y:int.
        ((y <> 0) ->
         (Int.(<) (AbsInt.abs (ComputerDivision.mod x y : int) : int) (AbsInt.abs y : int)))))

  axiom Computer_mod_sign_pos:
    (forall x:int.
      (forall y:int.
        (((Int.(>=) x 0) /\ (y <> 0)) ->
         (Int.(>=) (ComputerDivision.mod x y : int) 0))))

  axiom Computer_mod_sign_neg:
    (forall x:int.
      (forall y:int.
        (((Int.(<=) x 0) /\ (y <> 0)) ->
         (Int.(<=) (ComputerDivision.mod x y : int) 0))))

  axiom Computer_rounds_toward_zero:
    (forall x:int.
      (forall y:int.
        ((y <> 0) ->
         (Int.(<=) (AbsInt.abs (Int.(*) (ComputerDivision.div x y : int) y : int) : int) (AbsInt.abs x : int)))))

  function bool_and Bool.bool Bool.bool : Bool.bool

  function bool_or Bool.bool Bool.bool : Bool.bool

  function bool_xor Bool.bool Bool.bool : Bool.bool

  function bool_not Bool.bool : Bool.bool

  axiom Bool_and_def:
    (forall a:Bool.bool.
      (forall b:Bool.bool.
        (((bool_and a b : Bool.bool) = Bool.True) <->
         ((a = Bool.True) /\ (b = Bool.True)))))

  axiom Bool_or_def:
    (forall a:Bool.bool.
      (forall b:Bool.bool.
        (((bool_or a b : Bool.bool) = Bool.True) <->
         ((a = Bool.True) \/ (b = Bool.True)))))

  axiom Bool_xor_def:
    (forall a:Bool.bool.
      (forall b:Bool.bool.
        (((bool_xor a b : Bool.bool) = Bool.True) <-> (a <> b))))

  axiom Bool_not_def:
    (forall a:Bool.bool.
      (((bool_not a : Bool.bool) = Bool.True) <-> (a = Bool.False)))

  function ite Bool.bool 'a1 'a1 : 'a1

  axiom Ite_true:
    (forall x:'a1. (forall y:'a1. ((ite Bool.True x y : 'a1) = x)))

  axiom Ite_false:
    (forall x:'a1. (forall y:'a1. ((ite Bool.False x y : 'a1) = y)))

  function int_of_bool (b : Bool.bool) : int =
   if b = True then 1 else 0

  function bool_of_int (i : int) : Bool.bool =
   if i = 0 then False else True

  function div_real (x : real) (y : real) : real = x /. y

  val computer_div_ : x:int -> y:int ->
    { y<>0 } int { result = computer_div x y }

  val computer_mod_ : x:int -> y:int ->
    { y<>0 } int { result = computer_mod x y }

  val math_mod_ : x:int -> y:int ->
    { y<>0 } int { result = math_mod x y }

  val div_real_ : x:real -> y:real ->
    { y<>0.0 } real { result = div_real x y }

  use real.FromInt

  function real_of_int (x : int) : real = FromInt.from_int x

  (* Boolean comparison functions for reals *)  

  function lt_real_bool real real : Bool.bool

  function le_real_bool real real : Bool.bool

  function gt_real_bool real real : Bool.bool

  function ge_real_bool real real : Bool.bool

  function eq_real_bool real real : Bool.bool

  function neq_real_bool real real : Bool.bool

  axiom Lt_real_bool_axiom:
    (forall x:real.
      (forall y:real.
        (((lt_real_bool x y : Bool.bool) = Bool.True) <-> (Real.(<) x y))))

  axiom Le_real_bool_axiom:
    (forall x:real.
      (forall y:real.
        (((le_real_bool x y : Bool.bool) = Bool.True) <-> (Real.(<=) x y))))

  axiom Gt_real_bool_axiom:
    (forall x:real.
      (forall y:real.
        (((gt_real_bool x y : Bool.bool) = Bool.True) <-> (Real.(>) x y))))

  axiom Ge_real_bool_axiom:
    (forall x:real.
      (forall y:real.
        (((ge_real_bool x y : Bool.bool) = Bool.True) <-> (Real.(>=) x y))))

  axiom Eq_real_bool_axiom:
    (forall x:real.
      (forall y:real.
        (((eq_real_bool x y : Bool.bool) = Bool.True) <-> (x = y))))

  axiom Neq_real_bool_axiom:
    (forall x:real.
      (forall y:real.
        (((neq_real_bool x y : Bool.bool) = Bool.True) <-> (x <> y))))

end


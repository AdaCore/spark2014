\documentclass[sttt,draft]{svjour}
% relevant options: draft, referee, final
%
%\usepackage{latexsym}
%\usepackage{graphics}
%\usepackage{amssymb}
%\usepackage{amsfonts,amsmath}
\usepackage[T1]{fontenc}
\usepackage{listings}
\usepackage{xspace}
\lstset{language=Ada}

%
\newcommand{\DO}{\textsc{do-178}}
\newcommand{\DOB}{\textsc{do-178b}}
\newcommand{\DOC}{\textsc{do-178c}}
\newcommand{\hilite}{Hi-Lite}
\newcommand{\gnatprove}{GNATprove\xspace}
\newcommand{\oldspark}{SPARK~2005\xspace}
\newcommand{\newspark}{SPARK~2014\xspace}
\newcommand{\ada}{Ada\xspace}
\newcommand{\adatwtw}{Ada~2012\xspace}

\newcommand{\etc}{\textit{etc.}\xspace}
\newcommand{\ie}{\textit{i.e.,}\xspace}
\newcommand{\adhoc}{\textit{ad hoc}\xspace}
\newcommand{\Eg}{\textit{E.g.,}\xspace}
\newcommand{\eg}{\textit{e.g.,}\xspace}
\newcommand{\etal}{\textit{et al.}\xspace}
\newcommand{\wrt}{w.r.t.\xspace}
\newcommand{\aka}{a.k.a.\xspace}
\newcommand{\resp}{resp.\xspace}

\begin{document}
%
\title{\newspark\ and \gnatprove}
\subtitle{A Competition Report from Builders of an Industrial-Strength Verifying Compiler}
\author{Duc Hoang\inst{1} \and Yannick Moy\inst{1} \and Angela Wallenburg\inst{2}
}                     % Do not remove
\institute{AdaCore, \email{\{duc.hoang, yannick.moy\}@adacore.com}
  \and Altran, \email{angela.wallenburg@altran.com}}

\date{Received: date / Revised version: date}
% The correct dates will be entered by Springer
%
\maketitle
%
\begin{abstract}
Insert your abstract here.
\end{abstract}
%
\section{Introduction}
\label{intro}
High quality software, or low defect software, is often costly to
develop. This is a common experience in safety critical systems
development, whether the development is driven by standards such as
\DO, or by any other need to create highly reliable and long-lived
software. Today, extensive and expensive testing is the primary method
used to gain confidence in such software.

The computing research community has been occupied for decades with
the grand challenge of (building) \emph{the verifying compiler}
\cite{Hoare03theverifying}:
%
\begin{quote} A verifying compiler uses mathematical and logical reasoning
  to check the correctness of the programs that it compiles. The
  criterion of correctness is specified by types, assertions, and
  other redundant annotations associated with the code of the
  program. The compiler will work in combination with other program
  development and testing tools, to achieve any desired degree of
  confidence in the structural soundness of the system and the total
  correctness of its more critical components.
\end{quote}

As predicted in \cite{Hoare03theverifying} this grand challenge has
called for for co-operation among research teams and it has encouraged
and benefitted from competition. An example of such beneficial
competition is the VerifyThis competition, which is the context of
this very report.

Great strides have been made in proof automation. At present, static
so called ``push-button'' program verification is achieveable for some
substantial classes of industrial programs. New programming language
features for program verification have been explored and theoretical
models of complex existing language features have been devised to
increase the reasoning capabilities for mainstream programming
languages. See \cite{HatcliffLLMP12} for many insights in the
programming language approach to program verification. However, there
are still some remaining challenges before we can expect verifying
compilers to be as widely used as testing.

There are some notable exceptions where formal software verification
has been succesfully used and scaled to large industrial projects. For
example the \oldspark\ language and toolset for static verification
has been applied for many years in on-board aircraft systems, control
systems, cryptographic systems, and rail systems
\cite{sparkbook2012,oneill2012}.

We would like to identify two main hurdles currently in the take-up of
verifying compiler technology:
%
\begin{enumerate}
\item difficulty to reach non-expert users, and
\item lack of convincing cost-benefit argument.
\end{enumerate}
%
In this paper we will describe our approach to solve those two
problems in the design of the \newspark\ language and the associated
formal verification tool \gnatprove. We will use running examples from
the VerifiThis 2012 competition and discuss the results of using our
tools on those problems.

This paper is organised as follows: First we describe the key language
features of \newspark, which is a complete update of the
\oldspark\ language and tools designed with many lessons learned from
the programming language and verification community, and naturally
from experiences in industrial use of \oldspark. Then in
Sect. \ref{hilite} we describe our unique integration of testing and
proving. This was developed in the collaborative research project
\hilite\ \cite{hiliteERTS2012} with Altran, AdaCore, and INRIA, to
create a new tool architecture compiler and verifier based on same the
same front-end \cite{ksd2012}. In Sect. \ref{overflowsemantics} we
describe specific language features to be able to allow naturally
writing specifications. We present in Sect. \ref{automation}
GNATprove, our formal verification tool, that is currently a
prototype, and in Sect \ref{verifythis} its results in the VerifyThis
2012 competition. We conclude with future work.

\section{Key Language Features for Verification}
\label{langfeatures}
Using LCP as running example.

in Ada 2012 (which was inspired by SPARK 2005):
\begin{itemize}
\item preconditions and postconditions
\item Old and Result attributes
\item new expressions (if/case/quantified)
\item expression functions
\end{itemize}

\noindent
added in SPARK 2014 based on SPARK 2005:
\begin{itemize}
\item pragmas Loop\_Invariant
\item attribute Update
\end{itemize}

\noindent
new in SPARK 2014:
\begin{itemize}
\item attribute Loop\_Entry
\item pragmas Loop\_Variant
\item aspect Contract\_Cases
\end{itemize}

\section{Integrated Testing and Proving}
\label{hilite}

\begin{itemize}
\item execution semantics for functional properties $\rightarrow$ debug
  annotations like code
\item contracts can be tested
\item same semantics for test and proof (Chalin's work)
\item methodology for mixing test and proof. compiler inserts additional needed
  checks to verify at run time assumptions made during proof.
\end{itemize}

\section{Choosing the Right Semantics for Integers}
\label{overflowsemantics}

example of problem:
\begin{itemize}
\item user wants to add two numbers: \verb|X + Y|
\item user wants to assert that addition cannot overflow:\\
  \verb|with Pre => X + Y in Integer|
\item but this expression may overflow itself!
\end{itemize}

3 overflow checking modes:
\begin{itemize}
\item strict mode: normal overflow checks
\item minimized mode: larger base type (64bits) used when needed
\item eliminated mode: use bignum library in the remaining cases
\end{itemize}

flexible solution:
\begin{itemize}
\item user chooses between 3 modes
\item independent choice for assertions and code
\item same choice for execution and formal verification
\end{itemize}

\section{Making Automatic Verification Work}
\label{automation}

\begin{itemize}
\item bulk parallelism
\item use of dependencies and signatures to minimize rework
\item generation of small contexts in VCs (modularity, abstraction in Why3)
\item fast-WP generation (Leino's work)
\item portfolio approach (various provers, allowed with Why3)
\item selection of hypotheses
\item manual axiomatization of critical data structures (e.g. containers)
\item axiomatization as decision procedures (Claire's work as well as Fran√ßois
  Bobot)
\end{itemize}

\section{VerifyThis Competition}
\label{verifythis}

\subsection{Solution to Challenge 1}

The longest common prefix solution can be readily coded in Ada as follows:

\begin{footnotesize}
\begin{verbatim}
subtype Index is Positive range 1 .. 1_000_000;
type Text is array (Index range <>) of Integer;

function LCP (A : Text; X, Y : Integer) return Natural with
  Pre  => X in A'Range and then Y in A'Range,
  Post =>
    (for all K in 0 .. LCP'Result - 1 => A (X + K) = A (Y + K))
      and then
    (X + LCP'Result = A'Last + 1
      or else Y + LCP'Result = A'Last + 1
      or else A (X + LCP'Result) /= A (Y + LCP'Result));

function LCP (A : Text; X, Y : Integer) return Natural is
   L : Natural;
begin
   L := 0;
   while X + L <= A'Last
     and then Y + L <= A'Last
     and then A (X + L) = A (Y + L)
   loop
      pragma Loop_Invariant
        (for all K in 0 .. L - 1 => A (X + K) = A (Y + K));
      pragma Loop_Variant (Increases => L);
      L := L + 1;
   end loop;
   return L;
end LCP;
\end{verbatim}
\end{footnotesize}

The type \verb|Text| is an array of integers with unknown bounds. The input
specification that parameters \verb|X| and \verb|Y| are indices in the array
parameter \verb|A| can be expressed as a precondition involving the Ada
attribute \verb|'Range|, and membership tests \verb|X in ...| The output
specification that the result is the length of the longest common prefix
starting at \verb|X| and \verb|Y| can be expressed as a postcondition in two
parts, using the Ada attribute \verb|'Result| to express the function result:
\begin{itemize}
\item A quantification stating that the subarrays of \verb|A| of length
  \verb|LCP'Result| starting at \verb|X| and \verb|Y| are equal.
\item A disjunction of cases stating that either one of the two subarrays
  reaches the end of array \verb|A|, or the elements following the two
  subarrays in \verb|A| are different.
\end{itemize}

Running \gnatprove on this code without loop invariant or loop variant results
in the generation of 13 VCs: 1 VC for the postcondition, and 12 VCs for all
run-time checks (6 array index checks, 5 numeric overflow checks, 1 subtype
range check). All VCs related to run-time checks are proved. These VCs
represent both checks in the code and checks in assertions for the array
accesses in the postcondition. The VC for the postcondition is not proved, due
to the presence of a loop in the body of \verb|LCP|.

Proving the postcondition requires the insertion of a loop invariant in the
body of \verb|LCP|, which expresses that the subarrays of \verb|A| of length
\verb|L| starting at \verb|X| and \verb|Y| are equal. Since \verb|L| is the
value returned by \verb|LCP|, this loop invariant matches the first part of the
postcondition when the loop terminates. As expected, the postcondition is
proved with this additional loop invariant. \gnatprove generates 4 additional
VCs to prove that the loop invariant initially holds at the first iteration
through the loop, that it is maintained by subsequent iterations, and that the
two array accesses in the loop invariant expression are within bounds. All 4
additional VCs are also proved.

Finally, proving termination of \verb|LCP| requires the insertion of a loop
variant in the body of \verb|LCP|, which expresses that the value of \verb|L|
always increases between two consecutive iterations through the loop. Since
\verb|L| is of a bounded type (the scalar type \verb|Natural| of natural
numbers), it cannot be infinitely incremented without failing a run-time
check. Since we have already proved that no run-time check fails in \verb|LCP|,
proving the variant proves the termination of \verb|LCP|. The corresponding VC
is proved by \gnatprove.

The final version of \verb|LCP| is proved in 6s on a DELL laptop with 4G RAM
and 3GHz processor.

\subsection{Solution to Challenge 2}

We have chosen to implement an imperative version of prefix sum instead of a
recursive one, which better matches the constraints commonly found in critical
embedded software where recursion is usually not allowed. In order to make
automatic proof possible, we fix the length of the array to 8. The complete
solution is quite long (186 loc, not counting empty lines), so we only show
here selected parts. The initial solution without annotations is
straighforward, and only 50 lines long. As an example, here is the
implementation of procedure \verb|Upsweep|:

\begin{footnotesize}
\begin{verbatim}
procedure Upsweep (A : in out Input; Output_Space : out Positive) is
   Space : Positive := 1;
   Left  : Natural;
   Right : Natural;
begin
   while Space < A'Length loop
      Left := Space - 1;
      while Left < A'Length loop
         Right     := Left + Space;
         A (Right) := A (Left) + A (Right);
         Left      := Left + Space * 2;
      end loop;
      Space := Space * 2;
   end loop;
   Output_Space := Space;
end Upsweep;
\end{verbatim}
\end{footnotesize}

The postcondition of procedure \verb|Upsweep| states that
the array parameter \verb|A| is put in an intermediate form \wrt its initial
value (denoted \verb|A'Old|). The contract of procedure \verb|Downsweep| states
it takes as input an array parameter \verb|A| in an intermediate form \wrt a
\verb|Ghost| array parameter, and that it outputs in the same parameter
\verb|A| the desired prefix sums of array \verb|Ghost|. By calling in sequence
\verb|Upsweep| and \verb|Downsweep| on an array \verb|A|, with the initial
value of \verb|A| passed as \verb|Ghost| parameter, a caller performs the
desired in-place modification of \verb|A|. Although SPARK does not support yet
ghost parameters, which are only used for proofs, this is here the role of
parameter \verb|Ghost|, hence its name.

\begin{footnotesize}
\begin{verbatim}
procedure Upsweep (A : in out Input; Output_Space : out Positive) with
  Pre  => All_Elements_In (A, Maximum),
  Post => All_Elements_In (A, 8 * Maximum)
    and then Output_Space = 8
    and then Intermediate_Form (A, A'Old);

procedure Downsweep
  (Ghost : Input; A : in out Input; Input_Space : in Positive)
with
  Pre => All_Elements_In (Ghost, Maximum)
    and then All_Elements_In (A, 8 * Maximum)
    and then Input_Space = 8
    and then Intermediate_Form (A, Ghost),
  Post =>
    A (0) = 0
      and then
    A (1) = Ghost (0)
      and then
    A (2) = Ghost (0) + Ghost (1)
      and then
    A (3) = Ghost (0) + Ghost (1) + Ghost (2)
      and then
    A (4) = Ghost (0) + Ghost (1) + Ghost (2) + Ghost (3)
      and then
    A (5) = Ghost (0) + Ghost (1) + Ghost (2) + Ghost (3) + Ghost (4)
      and then
    A (6) = Ghost (0) + Ghost (1) + Ghost (2) + Ghost (3) + Ghost (4)
          + Ghost (5)
      and then
    A (7) = Ghost (0) + Ghost (1) + Ghost (2) + Ghost (3) + Ghost (4)
          + Ghost (5) + Ghost (6);
\end{verbatim}
\end{footnotesize}

The function \verb|Intermediate_Form| gives the exact relationship between the
initial value of the array (parameter \verb|B| below) and its intermediate
value between the calls to \verb|Upsweep| and \verb|Downsweep| (parameter
\verb|A| below). We define it as an expression function in Ada, which has the
benefit that \gnatprove automatically generates a postcondition for
\verb|Intermediate_Form| equivalent to its body. We also give a precondition to
\verb|Intermediate_Form| to prove that its evaluation cannot fail run-time
checks (overflow checks and index checks here).

\begin{footnotesize}
\begin{verbatim}
function Intermediate_Form (A, B : Input) return Boolean with
  Pre => All_Elements_In (A, Maximum * 8)
    and then All_Elements_In (B, Maximum);

function Intermediate_Form (A, B : Input) return Boolean is
  (for all K in A'Range =>
     (if (K + 1) mod 8 = 0 then
        A (K) = B (0) + B (1) + B (2) + B (3) +
                B (4) + B (5) + B (6) + B (7)
     elsif (K + 1) mod 4 = 0 then
        A (K) = B (K) + B (K-1) + B (K-2) + B (K-3)
     elsif (K + 1) mod 2 = 0 then
        A (K) = B (K) + B (K-1)
     else
        A (K) = B (K)));
\end{verbatim}
\end{footnotesize}

Note that the contracts of all previous procedure and functions contain calls
to function \verb|All_Elements_In|, which returns \verb|True| if all elements
of an array are bounded in absolute value, which we also define as an
expression function:

\begin{footnotesize}
\begin{verbatim}
function All_Elements_In (A : Input; Max : Positive) return Boolean is
   (for all K in A'Range => A (K) in -Max .. Max);
\end{verbatim}
\end{footnotesize}

These specifications add 62 lines to the initial 50 lines for the solution. To
prove them with \gnatprove, we add 84 more lines for loop invariants and loop
variants. As an example, here are the loop invariant and loop variant for the
inner loop of procedure \verb|Upsweep|. Inside the loop invariant,
\verb|A'Loop_Entry| denotes the value of \verb|A| on entry to the loop.

\begin{footnotesize}
\begin{verbatim}
pragma Loop_Invariant (
  (Left + 1) mod Space = 0
    and then
  All_Left_Elements_In (A, Left, Space * 2 * Maximum)
    and then
  All_Right_Elements_In (A, Left - 1, Space * Maximum)
    and then
  (Left + 1) mod (Space * 2) = Space
    and then
  (if Left >= A'Length then Left = 8 or Left = 9)
    and then
  (for all K in A'Range =>
    (if K in A'First .. Left - Space
       and then (K + 1) mod (2 * Space) = 0
     then
        A (K) = A'Loop_Entry (K) + A'Loop_Entry (K - Space)
     else
        A (K) = A'Loop_Entry (K))));
pragma Loop_Variant (Increases => Left);
\end{verbatim}
\end{footnotesize}

The final version of prefix sum is partially proved (78 VCs proved, 8 VCs
unproved) in 138s on a DELL laptop with 24G RAM and 24 processors at 2.4GHz.
These 8 unproved VCs are either loop invariants or postconditions, which are
not proved automatically due to the use of the \verb|mod| operator, currently
not well handled in the underlying automatic prover. We have checked all of
them manually.

\begin{itemize}
\item use of execution to debug annotations during competition $\rightarrow$
  prize of user-assistance tool feature
\item snapshot of GNATprove results in GPS
\end{itemize}

\section{Ongoing Work}
\label{ongoing}

\begin{itemize}
\item IDE integration (analyze line/file, show path)
\item dataflow and information flow verification (in particular initialization)
\item proof of code containing containers
\item visualization of assumptions made for proof
\item counterexample generation and visualization for unproved VCs
\item Coq formalization of AST produced by frontend. possible verification of
  the consistency of the generated AST with checks.
\item target parametrization
\item adaptation for non-executable annotations and proof assistants
\end{itemize}

%
\bibliographystyle{alpha}
\bibliography{sttt_2013}

\end{document}



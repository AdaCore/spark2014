\documentclass[sttt,draft]{svjour}
% relevant options: draft, referee, final
%
%\usepackage{latexsym}
%\usepackage{graphics}
%\usepackage{amssymb}
%\usepackage{amsfonts,amsmath}
\usepackage[T1]{fontenc}
\usepackage{url}
\usepackage{xspace}
\usepackage{listings}
\lstset{language=Ada}

%
\newcommand{\DO}{\textsc{do-178}}
\newcommand{\DOB}{\textsc{do-178b}}
\newcommand{\DOC}{\textsc{do-178c}}
\newcommand{\hilite}{Hi-Lite}
\newcommand{\gnatprove}{GNATprove\xspace}
\newcommand{\oldspark}{SPARK~2005\xspace}
\newcommand{\newspark}{SPARK~2014\xspace}
\newcommand{\ada}{Ada\xspace}
\newcommand{\adatwtw}{Ada~2012\xspace}

\newcommand{\etc}{\textit{etc.}\xspace}
\newcommand{\ie}{\textit{i.e.,}\xspace}
\newcommand{\adhoc}{\textit{ad hoc}\xspace}
\newcommand{\Eg}{\textit{E.g.,}\xspace}
\newcommand{\eg}{\textit{e.g.,}\xspace}
\newcommand{\etal}{\textit{et al.}\xspace}
\newcommand{\wrt}{w.r.t.\xspace}
\newcommand{\aka}{a.k.a.\xspace}
\newcommand{\resp}{resp.\xspace}

\begin{document}
%
\title{\newspark\ and \gnatprove}
\subtitle{A Competition Report from Builders of an Industrial-Strength Verifying Compiler}
\author{Duc Hoang\inst{1} \and Yannick Moy\inst{1} \and Angela Wallenburg\inst{2}
}                     % Do not remove
\institute{AdaCore, \email{\{duc.hoang, yannick.moy\}@adacore.com}
  \and Altran, \email{angela.wallenburg@altran.com}}

\date{Received: date / Revised version: date}
% The correct dates will be entered by Springer
%
\maketitle
%
\begin{abstract}
Insert your abstract here.
\end{abstract}
%
\section{Introduction}
\label{intro}
High quality software, or low defect software, is often costly to
develop. This is a common experience in safety critical systems
development, whether the development is driven by standards such as
\DO, or by any other need to create highly reliable and long-lived
software. Today, extensive and expensive testing is the primary method
used to gain confidence in such software.

The computing research community has been occupied for decades with
the grand challenge of (building) \emph{the verifying compiler}
\cite{Hoare03theverifying}:
%
\begin{quote} A verifying compiler uses mathematical and logical reasoning
  to check the correctness of the programs that it compiles. The
  criterion of correctness is specified by types, assertions, and
  other redundant annotations associated with the code of the
  program. The compiler will work in combination with other program
  development and testing tools, to achieve any desired degree of
  confidence in the structural soundness of the system and the total
  correctness of its more critical components.
\end{quote}

As predicted in \cite{Hoare03theverifying} this grand challenge has
called for for co-operation among research teams and it has encouraged
and benefitted from competition. An example of such beneficial
competition is the VerifyThis competition, which is the context of
this very report.

Great strides have been made in proof automation. At present, static
so called ``push-button'' program verification is achieveable for some
substantial classes of industrial programs. New programming language
features for program verification have been explored and theoretical
models of complex existing language features have been devised to
increase the reasoning capabilities for mainstream programming
languages. See \cite{HatcliffLLMP12} for many insights in the
programming language approach to program verification. However, there
are still some remaining challenges before we can expect verifying
compilers to be as widely used as testing.

There are some notable exceptions where formal software verification
has been succesfully used and scaled to large industrial projects. For
example the \oldspark\ language and toolset for static verification
has been applied for many years in on-board aircraft systems, control
systems, cryptographic systems, and rail systems
\cite{sparkbook2012,oneill2012}.

We would like to identify two main hurdles currently in the take-up of
verifying compiler technology:
%
\begin{enumerate}
\item difficulty to reach non-expert users, and
\item lack of convincing cost-benefit argument.
\end{enumerate}
%
In this paper we will describe our approach to solve those two
problems in the design of the \newspark\ language and the associated
formal verification tool \gnatprove. We will use running examples from
the VerifyThis 2012 competition and discuss the results of using our
tools on those problems.

This paper is organised as follows: First we describe the key language
features of \newspark, which is a complete update of the
\oldspark\ language and tools designed with many lessons learned from
the programming language and verification community, and naturally
from experiences in industrial use of \oldspark. Then in
Sect. \ref{hilite} we describe our unique integration of testing and
proving. This was developed in the collaborative research project
\hilite\ \cite{hiliteERTS2012} with Altran, AdaCore, and INRIA, to
create a new tool architecture compiler and verifier based on same the
same front-end \cite{ksd2012}. In Sect. \ref{overflowsemantics} we
describe specific language features to be able to allow naturally
writing specifications. We present in Sect. \ref{automation}
GNATprove, our formal verification tool, that is currently a
prototype, and in Sect \ref{verifythis} its results in the VerifyThis
2012 competition. We conclude with future work.

\section{Key Language Features for Verification}
\label{langfeatures}
Using LCP as running example.

in Ada 2012 (which was inspired by SPARK 2005):
\begin{itemize}
\item preconditions and postconditions
\item Old and Result attributes
\item new expressions (if/case/quantified)
\item expression functions
\end{itemize}

\noindent
added in SPARK 2014 based on SPARK 2005:
\begin{itemize}
\item pragmas Loop\_Invariant
\item attribute Update
\end{itemize}

\noindent
new in SPARK 2014:
\begin{itemize}
\item attribute Loop\_Entry
\item pragmas Loop\_Variant
\item aspect Contract\_Cases
\end{itemize}

\section{Integrated Testing and Proving}
\label{hilite}

\begin{itemize}
\item execution semantics for functional properties $\rightarrow$ debug
  annotations like code
\item contracts can be tested
\item same semantics for test and proof (Chalin's work)
\item methodology for mixing test and proof. compiler inserts additional needed
  checks to verify at run time assumptions made during proof.
\item target parametrization
\end{itemize}

\section{Choosing the Right Semantics for Integers}
\label{overflowsemantics}

example of problem:
\begin{itemize}
\item user wants to add two numbers: \verb|X + Y|
\item user wants to assert that addition cannot overflow:\\
  \verb|with Pre => X + Y in Integer|
\item but this expression may overflow itself!
\end{itemize}

3 overflow checking modes:
\begin{itemize}
\item strict mode: normal overflow checks
\item minimized mode: larger base type (64bits) used when needed
\item eliminated mode: use bignum library in the remaining cases
\end{itemize}

flexible solution:
\begin{itemize}
\item user chooses between 3 modes
\item independent choice for assertions and code
\item same choice for execution and formal verification
\end{itemize}

\section{Making Automatic Verification Work}
\label{automation}

As \gnatprove uses the Why3 platform~\cite{why3} to generate VCs and call
provers, it can target as many output formats and automatic or manual provers
as the Why3 platform allows (many!), but we focus on the automatic proof of VCs
through the use of the SMT prover Alt-Ergo~\cite{altergo} which is included in
\gnatprove distribution. There are two steps to make automatic verification
work: first make it possible, then make it efficient.

The choice of programming language is essential to make automatic verification
possible. On the one hand, it should proscribe those features which render
automatic verification impossible or very hard, and on the other hand, it
should contain enough features which facilitate the expression of
specifications. The former is obtained by restricting \newspark to a subset of
\adatwtw without pointers and exceptions. The later is obtained by the features
introduced in \adatwtw and \newspark. \adatwtw was specifically designed to
include preconditions, postcondition, type invariants, \etc so that a user can
specify arbitrarily complex invariant properties on the data and control of her
program, and test these properties at run time. \newspark further adds loop
invariants, loop variants, \etc so that a user can formally prove these
properties.

Efficient formal verification relies on a subtle coordination between the VC
generator and the prover, so that the VCs produced can be efficiently
proved. \gnatprove relies heavily on the features of the Why3
language~\cite{guitton2011boogie} to produce provable VCs. For example, the VCs
are kept small by translating the semantic dependencies between entities at the
Ada source code level into syntactic inclusions between modules at the Why3
intermediate code level, and by using the abstraction feature in Why3 for the
intermediate code that checks for absence of run-time errors. This ensures that
the generated VCs only contain relevant definitions and axioms. As another
example, one can choose to produce fewer but more complex VCs: the default in
\gnatprove is that a VC accounts for all paths leading to an assertion, using
an efficient computation~\cite{leino2005ipl}, instead of generating one VC for
each path leading to an assertion (also available in \gnatprove on option). The
choice of axiomatization of Ada data types (integer types, enumeration types,
record types, array types, \etc) in Why3 also has a determinant effect on the
provability of VCs. We have changed various times these axiomatizations to
better suit the mechanisms inside SMT provers like Alt-Ergo. Similarly, we have
tailored the axiomatization for a generic library of
containers~\cite{dross:2011:tap} to SMT provers.

Finally, modular verification based on pre- and postconditions can very easily
exploit multicore architectures, as the generation of VCs for different units,
or the proof of different VCs, can both be run in parallel. Typically, project
contain hundreds of units, and lead to the generation of thousands of VCs,
which can be run by \gnatprove on as many cores as available. Note also that
\gnatprove uses file timestamps to avoid re-generating VCs for units which have
not been updated, and file hashes to avoid re-proving VCs that have already
been proved. This is crucial when developing either the code or the associated
annotations, to avoid useless rework.

\section{VerifyThis Competition}
\label{verifythis}

\subsection{Solution to Challenge 1}

The longest common prefix solution can be readily coded in \adatwtw as follows:

\begin{footnotesize}
\begin{verbatim}
subtype Index is Positive range 1 .. 1_000_000;
type Text is array (Index range <>) of Integer;

function LCP (A : Text; X, Y : Integer) return Natural with
  Pre  => X in A'Range and then Y in A'Range,
  Post =>
    (for all K in 0 .. LCP'Result - 1 => A (X + K) = A (Y + K))
      and then
    (X + LCP'Result = A'Last + 1
      or else Y + LCP'Result = A'Last + 1
      or else A (X + LCP'Result) /= A (Y + LCP'Result));

function LCP (A : Text; X, Y : Integer) return Natural is
   L : Natural;
begin
   L := 0;
   while X + L <= A'Last
     and then Y + L <= A'Last
     and then A (X + L) = A (Y + L)
   loop
      pragma Loop_Invariant
        (for all K in 0 .. L - 1 => A (X + K) = A (Y + K));
      pragma Loop_Variant (Increases => L);
      L := L + 1;
   end loop;
   return L;
end LCP;
\end{verbatim}
\end{footnotesize}

The type \verb|Text| is an array of integers with unknown bounds. The input
specification that parameters \verb|X| and \verb|Y| are indices in the array
parameter \verb|A| can be expressed as a precondition involving the Ada
attribute \verb|'Range|, and membership tests \verb|X in ...| The output
specification that the result is the length of the longest common prefix
starting at \verb|X| and \verb|Y| can be expressed as a postcondition in two
parts, using the \adatwtw attribute \verb|'Result| to express the function
result:
\begin{itemize}
\item A quantification stating that the subarrays of \verb|A| of length
  \verb|LCP'Result| starting at \verb|X| and \verb|Y| are equal.
\item A disjunction of cases stating that either one of the two subarrays
  reaches the end of array \verb|A|, or the elements following the two
  subarrays in \verb|A| are different. Note here that the use of the lazy
  boolean connective \verb|or else| is compulsory to make sure that
  \verb|X + LCP'Result| and \verb|Y + LCP'Result| are without bounds when
  accessing \verb|A| in the last line of the postcondition.
\end{itemize}

Running \gnatprove on this code without loop invariant or loop variant results
in the generation of 13 VCs: 1 VC for the postcondition, and 12 VCs for all
run-time checks (6 array index checks, 5 numeric overflow checks, 1 subtype
range check). All VCs related to run-time checks are proved. These VCs
represent both checks in the code and checks in assertions for the array
accesses in the postcondition. The VC for the postcondition is not proved, due
to the presence of a loop in the body of \verb|LCP|.

Proving the postcondition requires the insertion of a loop invariant in the
body of \verb|LCP|, which expresses that the subarrays of \verb|A| of length
\verb|L| starting at \verb|X| and \verb|Y| are equal. Since \verb|L| is the
value returned by \verb|LCP|, this loop invariant matches the first part of the
postcondition when the loop terminates. As expected, the postcondition is
proved with this additional loop invariant. \gnatprove generates 4 additional
VCs to prove that the loop invariant initially holds at the first iteration
through the loop, that it is maintained by subsequent iterations, and that the
two array accesses in the loop invariant expression are within bounds. All 4
additional VCs are also proved.

Finally, proving termination of \verb|LCP| requires the insertion of a loop
variant in the body of \verb|LCP|, which expresses that the value of \verb|L|
always increases between two consecutive iterations through the loop. Since
\verb|L| is of a bounded type (the scalar type \verb|Natural| of natural
numbers), it cannot be infinitely incremented without failing a run-time
check. Since we have already proved that no run-time check fails in \verb|LCP|,
proving the variant proves the termination of \verb|LCP|. The corresponding VC
is proved by \gnatprove.

The final version of \verb|LCP| is proved in 6s on a DELL laptop with 4G RAM
and 3GHz processor.

\subsection{Solution to Challenge 2}

We have chosen to implement an imperative version of prefix sum instead of a
recursive one, which better matches the constraints commonly found in critical
embedded software where recursion is usually not allowed. In order to make
automatic proof possible, we fix the length of the array to 8. The complete
solution is quite long (186 loc, not counting empty lines), so we only show
here selected parts. The initial solution without annotations is
straighforward, and only 50 lines long. As an example, here is the
implementation of procedure \verb|Upsweep|:

\begin{footnotesize}
\begin{verbatim}
procedure Upsweep (A : in out Input; Output_Space : out Positive) is
   Space : Positive := 1;
   Left  : Natural;
   Right : Natural;
begin
   while Space < A'Length loop
      Left := Space - 1;
      while Left < A'Length loop
         Right     := Left + Space;
         A (Right) := A (Left) + A (Right);
         Left      := Left + Space * 2;
      end loop;
      Space := Space * 2;
   end loop;
   Output_Space := Space;
end Upsweep;
\end{verbatim}
\end{footnotesize}

The postcondition of procedure \verb|Upsweep| states that the array parameter
\verb|A| is put in an intermediate form \wrt its initial value (denoted
\verb|A'Old|). The contract of procedure \verb|Downsweep| states it takes as
input an array parameter \verb|A| in an intermediate form \wrt a \verb|Ghost|
array parameter, and that it outputs in the same parameter \verb|A| the desired
prefix sums of array \verb|Ghost|. By calling in sequence \verb|Upsweep| and
\verb|Downsweep| on an array \verb|A|, with the initial value of \verb|A|
passed as \verb|Ghost| parameter, a caller performs the desired in-place
modification of \verb|A|. Although \newspark does not support yet ghost
parameters, which are only used for proofs, this is here the role of parameter
\verb|Ghost|, hence its name.

\begin{footnotesize}
\begin{verbatim}
procedure Upsweep (A : in out Input; Output_Space : out Positive) with
  Pre  => All_Elements_In (A, Maximum),
  Post => All_Elements_In (A, 8 * Maximum)
    and then Output_Space = 8
    and then Intermediate_Form (A, A'Old);

procedure Downsweep
  (Ghost : Input; A : in out Input; Input_Space : in Positive)
with
  Pre => All_Elements_In (Ghost, Maximum)
    and then All_Elements_In (A, 8 * Maximum)
    and then Input_Space = 8
    and then Intermediate_Form (A, Ghost),
  Post =>
    A (0) = 0
      and then
    A (1) = Ghost (0)
      and then
    A (2) = Ghost (0) + Ghost (1)
      and then
    A (3) = Ghost (0) + Ghost (1) + Ghost (2)
      and then
    A (4) = Ghost (0) + Ghost (1) + Ghost (2) + Ghost (3)
      and then
    A (5) = Ghost (0) + Ghost (1) + Ghost (2) + Ghost (3) + Ghost (4)
      and then
    A (6) = Ghost (0) + Ghost (1) + Ghost (2) + Ghost (3) + Ghost (4)
          + Ghost (5)
      and then
    A (7) = Ghost (0) + Ghost (1) + Ghost (2) + Ghost (3) + Ghost (4)
          + Ghost (5) + Ghost (6);
\end{verbatim}
\end{footnotesize}

The function \verb|Intermediate_Form| gives the exact relationship between the
initial value of the array (parameter \verb|B| below) and its intermediate
value between the calls to \verb|Upsweep| and \verb|Downsweep| (parameter
\verb|A| below). We define it as an expression function in \adatwtw, which has
the benefit that \gnatprove automatically generates a postcondition for
\verb|Intermediate_Form| equivalent to its body. We also give a precondition to
\verb|Intermediate_Form| to prove that its evaluation cannot fail run-time
checks (overflow checks and index checks here).

\begin{footnotesize}
\begin{verbatim}
function Intermediate_Form (A, B : Input) return Boolean with
  Pre => All_Elements_In (A, Maximum * 8)
    and then All_Elements_In (B, Maximum);

function Intermediate_Form (A, B : Input) return Boolean is
  (for all K in A'Range =>
     (if (K + 1) mod 8 = 0 then
        A (K) = B (0) + B (1) + B (2) + B (3) +
                B (4) + B (5) + B (6) + B (7)
     elsif (K + 1) mod 4 = 0 then
        A (K) = B (K) + B (K-1) + B (K-2) + B (K-3)
     elsif (K + 1) mod 2 = 0 then
        A (K) = B (K) + B (K-1)
     else
        A (K) = B (K)));
\end{verbatim}
\end{footnotesize}

Note that the contracts of all previous procedure and functions contain calls
to function \verb|All_Elements_In|, which returns \verb|True| if all elements
of an array are bounded in absolute value, which we also define as an
expression function:

\begin{footnotesize}
\begin{verbatim}
function All_Elements_In (A : Input; Max : Positive) return Boolean is
   (for all K in A'Range => A (K) in -Max .. Max);
\end{verbatim}
\end{footnotesize}

These specifications add 62 lines to the initial 50 lines for the solution. To
prove them with \gnatprove, we add 84 more lines for loop invariants and loop
variants. As an example, here are the loop invariant and loop variant for the
inner loop of procedure \verb|Upsweep|. Inside the loop invariant,
\verb|A'Loop_Entry| denotes the value of \verb|A| on entry to the loop.

\begin{footnotesize}
\begin{verbatim}
pragma Loop_Invariant (
  (Left + 1) mod Space = 0
    and then
  All_Left_Elements_In (A, Left, Space * 2 * Maximum)
    and then
  All_Right_Elements_In (A, Left - 1, Space * Maximum)
    and then
  (Left + 1) mod (Space * 2) = Space
    and then
  (if Left >= A'Length then Left = 8 or Left = 9)
    and then
  (for all K in A'Range =>
    (if K in A'First .. Left - Space
       and then (K + 1) mod (2 * Space) = 0
     then
        A (K) = A'Loop_Entry (K) + A'Loop_Entry (K - Space)
     else
        A (K) = A'Loop_Entry (K))));
pragma Loop_Variant (Increases => Left);
\end{verbatim}
\end{footnotesize}

The final version of prefix sum is partially proved (78 VCs proved, 8 VCs
unproved) in 138s on a DELL laptop with 24G RAM and 24 processors at 2.4GHz.
These 8 unproved VCs are either loop invariants or postconditions, which are
not proved automatically due to the use of the \verb|mod| operator, currently
not well handled in the underlying automatic prover. We have checked all of
them manually.

\subsection{Useful Tool Features}

The format of the competition exercized useful features of \gnatprove, which
helped finding errors early in the code or in the annotations. The most useful
of these features is certainly the ability to execute annotations, which allows
testing and debugging annotations as if they were code. It was used during the
competition to quickly locate the reason for an unprovable VC on challenge 1:
the loop test was using a strict comparison operator instead of the correct
non-strict one. To locate the problem, the participating author simply wrote a
test exercizing \verb|LCP| on an input, compiled it with run-time checks, and
run it. The run-time error raised precisely located the failing loop
invariant. Although this example was simple enough to immediately understand
the underlying problem, it would have been possible to use the debugger to
further investigate the issue, which can be extremely useful on real industrial
code. The ability to execute annotations was also useful for challenge 2, which
requires the development of complex loop invariants, to quickly correct
erroneous ones. This feature won the prize of user-assistance tool feature
awarded by the jury of the VerifyThis competition.

Another very useful feature for these challenges was the ability to eliminate
completely all possibilities of numeric overflows in annotations, as described
in Section~\ref{???}. While using this feature results in only 10 more overflow
VCs in challenge 1, which are all proved with the current annotations, it adds
60 overflow VCs in challenge 2, most of which require modifications of
annotations, or addition of new annotations, to be proved. Note that this
feature is compatible with the execution of annotations, as compilation also
takes into account the overflow mode when compiling arithmetic expressions.

Various features of \gnatprove make it very convenient to use inside an
Integrated Development Environment (currently GPS, the GNAT Programming
Studio). The user can choose to call \gnatprove on a selected file, an
individual subprogram, or even a single line of code. This was key to speed up
the modify/verify loop during the competition. When a VC is not proved, the IDE
can also display the corresponding statements in the code, to help figure out
why some assertions do not hold on some paths.

More generally, these small challenges already make use of numerous language
features in \adatwtw and \newspark that facilitate the expression of
specifications: preconditions and postconditions, loop invariants and loop
variants, expression functions, quantified expressions and if expressions,
special attributes \verb|'Result|, \verb|'Old| and \verb|'Loop_Entry|.

\begin{itemize}
\item snapshot of GNATprove results in GPS
\end{itemize}

\section{Ongoing Work}
\label{ongoing}

\gnatprove is the result of a complete redesign of the SPARK language and
associated tools, which started in 2010 with project \hilite.\cite{Hi-Lite}
Altran and AdaCore are collaborating to complete this new version of SPARK by
the start of 2014. On the tool side, current work focuses on flow analysis,
support for investigating unproved VCs, and improvements of the SMT prover.

Flow analysis is the verification of the data dependences of subprograms. This
analysis which has always been a component of SPARK verification is currently
redeveloped for \newspark, based on program dependence
graphs~\cite{horwitz:1988:pldi}. An important novelty is that, while \oldspark
requires that the user annotates programs with data dependence contracts, they
are optional in \newspark, and \gnatprove generates them when not present. A
minimal flow analysis is always required for the soundness of proofs, while a
more complete flow analysis is optional. The minimal flow analysis ensures that
all variables are initialized prior to being read.

Facilitating the investigation of unproved VCs is key to making formal program
verification cost-effective in industry. \gnatprove currently provides various
solutions to that problem: the ability to execute annotations to detect errors
in code and/or annotations; the display of program paths to detect errors or
locate missing annotations; the possibility to call alternate provers to
identify prover shortcomings. In the future, we would like to add the display
of counterexamples generated by the prover, as already provided by some SMT
provers~\cite{CVC3,Z3model}.

We have been exploring two promising ways to improve the results of the
Alt-Ergo SMT prover on the VCs generated in \gnatprove: handling selected
axiomatizations as decision procedures~\cite{dross:2012:smt}, and incrementally
selecting axioms~\cite{cgs09:ipo,kuhlwein:2012:ijcar}. More work is needed to
make these modes the default inside \gnatprove.

mention the following?

\begin{itemize}
\item proof of code containing containers
\item visualization of assumptions made for proof
\item Coq formalization of AST produced by frontend. possible verification of
  the consistency of the generated AST with checks.
\item adaptation for non-executable annotations and proof assistants
\end{itemize}

%
\bibliographystyle{alpha}
\bibliography{sttt_2013}

\end{document}



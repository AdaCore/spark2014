\documentclass[sttt,draft]{svjour}
% relevant options: draft, referee, final
%
%\usepackage{latexsym}
%\usepackage{graphics}
%\usepackage{amssymb}
%\usepackage{amsfonts,amsmath}
\usepackage[T1]{fontenc}
\usepackage{url}
\usepackage{xspace}
\usepackage{listings}
\lstset{language=Ada}

%
\newcommand{\DO}{\textsc{do-178}}
\newcommand{\DOB}{\textsc{do-178b}}
\newcommand{\DOC}{\textsc{do-178c}}
\newcommand{\hilite}{Hi-Lite}
\newcommand{\gnatprove}{GNATprove\xspace}
\newcommand{\oldspark}{SPARK~2005\xspace}
\newcommand{\newspark}{SPARK~2014\xspace}
\newcommand{\ada}{Ada\xspace}
\newcommand{\adatwtw}{Ada~2012\xspace}

\newcommand{\etc}{\textit{etc.}\xspace}
\newcommand{\ie}{\textit{i.e.,}\xspace}
\newcommand{\adhoc}{\textit{ad hoc}\xspace}
\newcommand{\Eg}{\textit{E.g.,}\xspace}
\newcommand{\eg}{\textit{e.g.,}\xspace}
\newcommand{\etal}{\textit{et al.}\xspace}
\newcommand{\wrt}{w.r.t.\xspace}
\newcommand{\aka}{a.k.a.\xspace}
\newcommand{\resp}{resp.\xspace}

\begin{document}
%
\title{\newspark\ and \gnatprove}
\subtitle{A Competition Report from Builders of an Industrial-Strength Verifying Compiler}
\author{Duc Hoang\inst{1} \and Yannick Moy\inst{1} \and Angela Wallenburg\inst{2}
}                     % Do not remove
\institute{AdaCore, \email{\{duc.hoang, yannick.moy\}@adacore.com}
  \and Altran, \email{angela.wallenburg@altran.com}}

\date{Received: date / Revised version: date}
% The correct dates will be entered by Springer
%
\maketitle
%
\begin{abstract}
Insert your abstract here.
\end{abstract}
%
\section{Introduction}
\label{intro}
High quality software, or low defect software, is often costly to
develop. This is a common experience in safety critical systems
development, whether the development is driven by standards such as
\DO, or by any other need to create highly reliable and long-lived
software. Today, extensive and expensive testing is the primary method
used to gain confidence in such software.

The computing research community has been occupied for decades with
the grand challenge of (building) \emph{the verifying compiler}
\cite{Hoare03theverifying}:
%
\begin{quote} A verifying compiler uses mathematical and logical reasoning
  to check the correctness of the programs that it compiles. The
  criterion of correctness is specified by types, assertions, and
  other redundant annotations associated with the code of the
  program. The compiler will work in combination with other program
  development and testing tools, to achieve any desired degree of
  confidence in the structural soundness of the system and the total
  correctness of its more critical components.
\end{quote}

As predicted in \cite{Hoare03theverifying} this grand challenge has
called for for co-operation among research teams and it has encouraged
and benefitted from competition. An example of such beneficial
competition is the VerifyThis competition, which is the context of
this very report.

Great strides have been made in proof automation. At present, static
so called ``push-button'' program verification is achieveable for some
substantial classes of industrial programs. New programming language
features for program verification have been explored and theoretical
models of complex existing language features have been devised to
increase the reasoning capabilities for mainstream programming
languages. See \cite{HatcliffLLMP12} for many insights in the
programming language approach to program verification. However, there
are still some remaining challenges before we can expect verifying
compilers to be as widely used as testing.

There are some notable exceptions where formal software verification
has been succesfully used and scaled to large industrial projects. For
example the \oldspark\ language and toolset for static verification
has been applied for many years in on-board aircraft systems, control
systems, cryptographic systems, and rail systems
\cite{sparkbook2012,oneill2012}.

We would like to identify two main hurdles currently in the take-up of
verifying compiler technology:
%
\begin{enumerate}
\item difficulty to reach non-expert users, and
\item lack of convincing cost-benefit argument.
\end{enumerate}
%
In this paper we will describe our approach to solve those two
problems in the design of the \newspark\ language and the associated
formal verification tool \gnatprove. We will use running examples from
the VerifyThis 2012 competition and discuss the results of using our
tools on those problems.

This paper is organised as follows: First we describe the key language
features of \newspark, which is a complete update of the
\oldspark\ language and tools designed with many lessons learned from
the programming language and verification community, and naturally
from experiences in industrial use of \oldspark. Then in
Sect. \ref{hilite} we describe our unique integration of testing and
proving. This was developed in the collaborative research project
\hilite\ \cite{hiliteERTS2012} with Altran, AdaCore, and INRIA, to
create a new tool architecture compiler and verifier based on same the
same front-end \cite{ksd2012}. In Sect. \ref{overflowsemantics} we
describe specific language features to be able to allow naturally
writing specifications. We present in Sect. \ref{automation}
GNATprove, our formal verification tool, that is currently a
prototype, and in Sect \ref{verifythis} its results in the VerifyThis
2012 competition. We conclude with future work.

\section{Key Language Features for Verification}
\label{langfeatures}

explain more the dynamic semantics of these features???

\subsection{Ada 2012}

Ada 2012 introduced new language features for facilitating the specification of
programs, many of which were inspired from the corresponding features in SPARK
(ref to John Barnes rational). In the following, we describe some of these that
we used in the solutions for challenge 1 and challenge 2.

The most useful of these new features is without the preconditions and
postconditions popularized by the Design-by-Contract approach (ref to
Meyer). In challenge 1, we can for example specify that function \verb|LCP|
expects arguments within bounds, and that it returns a bounded result. Note the
use of the new \textit{aspect} syntax in Ada 2012, in which the declaration of
\verb|LCP| is followed by keyword \verb|with| and a list of aspects.

\begin{footnotesize}
\begin{verbatim}
function LCP (A : Text; X, Y : Integer) return Natural with
  Pre  => X in A'Range and then Y in A'Range,
  Post => LCP'Result in 0 .. Index'Last;
\end{verbatim}
\end{footnotesize}

In the postcondition of a function, the new attribute \verb|Result| is used to
refer to the result of the function. Another attribute \verb|Old| is used to
refer to the value of some variables on entry to a subprogram, and we used it
in challenge 2.

The expression of specifications is facilitated by new expression forms in Ada
2012. If-expressions and case-expressions are the expression forms which
correspond to the usual if-statements and case-statements. Note that an
if-expression without else-part \verb|(if A then B)| expresses a logical
implication of \verb|B| by \verb|A|. Quantified expressions
\verb|(for all X in A)| and \verb|(for some X in A)| correspond to the
mathematical universal and existential quantifications, only on a bounded
domain. Expression functions define a function with a single expression, like
in functional programming languages. As expression functions can be part of the
specification of programs (contrary to regular function bodies), they are a
preferred way to abstract complex parts of specifications.

\subsection{SPARK 2014}

The new version of SPARK is based on the features of Ada 2012, to which it adds
new ones, some of which inspired from the SPARK 2005.

Like preconditions and postconditions are the most useful new features of Ada
2012 for specification, the loop invariant pragma is the most useful one in
SPARK 2014. A loop invariant can be expressed anywhere in the main list of
statements in a loop, and it expresses the cumulated effect of the loop up to
that point. For example, here is the loop invariant used in challenge 1:

\begin{footnotesize}
\begin{verbatim}
pragma Loop_Invariant (for all K in 0 .. L - 1 => A (X + K) = A (Y + K));
\end{verbatim}
\end{footnotesize}

Note that a loop invariant in SPARK does not have the same semantics as the
loop invariant introduces by Hoare (ref?). The latter has to hold when reaching
the loop, at each start of iteration of the loop, and when exiting the
loop. The former only has to hold when execution reaches the corresponding
program point. The SPARK semantics is much easier to work with for programmers.

In formal verification, it is very common that loop invariants compare the
value of a variable at loop entry and at the n$^{th}$ iteration of the loop. To
facilitate such specifications, SPARK 2014 introduces the \verb|Loop_Entry|
attribute, which can be applied to such a variable. We've used that feature in
challenge 2.

A loop variant pragma has also been defined in SPARK 2014, to express a
quantity varying monotonically at each iteration of the loop. Like loop
invariants, a loop variant can appear anywhere in the main list of statements
in a loop. For example, here is the loop variant used in challenge 1:

\begin{footnotesize}
\begin{verbatim}
pragma Loop_Variant (Increases => L);
\end{verbatim}
\end{footnotesize}

Note that this variant does not take the usual non-negative decreasing
argument. Instead, it takes a list of increasing or decreasing integer values,
bounded by their type in Ada, and the overall order over this list is the
lexicographic order combined with individual directions. In the example below,
there is only one element in the lists, so it should increase at each run
through the loop. Like for loop invariants, the point where this increase
matters is the program point where the loop variant appears in the code.

Subprogram contracts can become quite large, even with the use of (expression)
functions to abstract common parts of contracts. Therefore, SPARK 2014 allows
the definition of contracts by cases, similar to behaviors in JML (ref?). For
example, the contract of \verb|LCP| can state separately sub-contracts for the
cases where the array is of length zero, or the elements at \verb|X| and
\verb|Y| are different, or \verb|X| and \verb|Y| are equal. This contract may
be used instead of or in addition to a precondition and a postcondition.

\begin{footnotesize}
\begin{verbatim}
function LCP (A : Text; X, Y : Integer) return Natural with
  Contract_Cases =>
    (A (X) /= A (Y) => LCP'Result = 0,
     X = Y          => LCP'Result = A'Last - X + 1,
     others         => LCP'Result > 0);
\end{verbatim}
\end{footnotesize}

Note that the cases above are disjoint and complete, as expected in SPARK: one
and only one case should be applicable at every call. The presence of the
\verb|others| case ensures the completness here.

\section{Integrated Testing and Proving}
\label{hilite}
As mentioned, in the development of the new generation language and
toolset \newspark, we have targeted the issues of lacking good
cost-benefit arguments and of reaching non-expert users. The ground
work of the solution presented here was done in the collaborative
research project \hilite\ \cite{hiliteERTS2012}. In order to provide a
good cost-benefit argument we need to understand something about what
drives the current practises in the industry, and where the main
problems and costs are. Furthermore, we will incorporate in our
language design those lessons learned in the programming languages and
program verification research community.

\subsection{Motivation: Industry Safety Standards}
\DOB\ is a document that is used as a basis for certification of
airborne software by institutions such as Federal Aviation
Administration (FAA) and European Aviation Safety Agency
(EASA). Though \DOB\ is for avionics, it is often used by other
industries too and it can be seen as typical for safety verification
objectives. \DOB\ is regarded as very successful within the avionitcs
industry itself. Since its introduction in 1992 there has been no
fatalitites attributed to software faults. 

The standard is non-prescriptive with regards to procedure to be
followed and template to be used for a certain...

In \DOC\ there is a formal methods supplement. 

\subsection{Executable Contracts}

\begin{itemize}
\item execution semantics for functional properties $\rightarrow$ debug
  annotations like code
\item contracts can be tested
\end{itemize}

\subsection{Mixing Test and Proof}
\begin{itemize}
\item same semantics for test and proof (Chalin's work)
\item methodology for mixing test and proof. compiler inserts additional needed
  checks to verify at run time assumptions made during proof.
\item target parametrization
\end{itemize}

\subsection{Compiler Implementation}

\subsection{Benefits of Hybrid Verification}


\section{Choosing the Right Semantics for Integers}
\label{overflowsemantics}

example of problem:
\begin{itemize}
\item user wants to add two numbers: \verb|X + Y|
\item user wants to assert that addition cannot overflow:\\
  \verb|with Pre => X + Y in Integer|
\item but this expression may overflow itself!
\end{itemize}

3 overflow checking modes:
\begin{itemize}
\item strict mode: normal overflow checks
\item minimized mode: larger base type (64bits) used when needed
\item eliminated mode: use bignum library in the remaining cases
\end{itemize}

flexible solution:
\begin{itemize}
\item user chooses between 3 modes
\item independent choice for assertions and code
\item same choice for execution and formal verification
\end{itemize}

\section{Making Automatic Verification Work}
\label{automation}

As \gnatprove uses the Why3 platform~\cite{why3} to generate VCs and call
provers, it can target as many output formats and automatic or manual provers
as the Why3 platform allows (many!), but we focus on the automatic proof of VCs
through the use of the SMT prover Alt-Ergo~\cite{altergo} which is included in
\gnatprove distribution. There are two steps to make automatic verification
work: first make it possible, then make it efficient.

The choice of programming language is essential to make automatic verification
possible. On the one hand, it should proscribe those features which render
automatic verification impossible or very hard, and on the other hand, it
should contain enough features which facilitate the expression of
specifications. The former is obtained by restricting \newspark to a subset of
\adatwtw without pointers and exceptions. The later is obtained by the features
introduced in \adatwtw and \newspark. \adatwtw was specifically designed to
include preconditions, postcondition, type invariants, \etc so that a user can
specify arbitrarily complex invariant properties on the data and control of her
program, and test these properties at run time. \newspark further adds loop
invariants, loop variants, \etc so that a user can formally prove these
properties.

Efficient formal verification relies on a subtle coordination between the VC
generator and the prover, so that the VCs produced can be efficiently
proved. \gnatprove relies heavily on the features of the Why3
language~\cite{guitton2011boogie} to produce provable VCs. For example, the VCs
are kept small by translating the semantic dependencies between entities at the
Ada source code level into syntactic inclusions between modules at the Why3
intermediate code level, and by using the abstraction feature in Why3 for the
intermediate code that checks for absence of run-time errors. This ensures that
the generated VCs only contain relevant definitions and axioms. As another
example, one can choose to produce fewer but more complex VCs: the default in
\gnatprove is that a VC accounts for all paths leading to an assertion, using
an efficient computation~\cite{leino2005ipl}, instead of generating one VC for
each path leading to an assertion (also available in \gnatprove on option). The
choice of axiomatization of Ada data types (integer types, enumeration types,
record types, array types, \etc) in Why3 also has a determinant effect on the
provability of VCs. We have changed various times these axiomatizations to
better suit the mechanisms inside SMT provers like Alt-Ergo. Similarly, we have
tailored the axiomatization for a generic library of
containers~\cite{dross:2011:tap} to SMT provers.

Finally, modular verification based on pre- and postconditions can very easily
exploit multicore architectures, as the generation of VCs for different units,
or the proof of different VCs, can both be run in parallel. Typically, project
contain hundreds of units, and lead to the generation of thousands of VCs,
which can be run by \gnatprove on as many cores as available. Note also that
\gnatprove uses file timestamps to avoid re-generating VCs for units which have
not been updated, and file hashes to avoid re-proving VCs that have already
been proved. This is crucial when developing either the code or the associated
annotations, to avoid useless rework.

\section{VerifyThis Competition}
\label{verifythis}

\subsection{Solution to Challenge 1}

The longest common prefix solution can be readily coded in \adatwtw as follows:

\begin{footnotesize}
\begin{verbatim}
subtype Index is Positive range 1 .. 1_000_000;
type Text is array (Index range <>) of Integer;

function LCP (A : Text; X, Y : Integer) return Natural with
  Pre  => X in A'Range and then Y in A'Range,
  Post =>
    (for all K in 0 .. LCP'Result - 1 => A (X + K) = A (Y + K))
      and then
    (X + LCP'Result = A'Last + 1
      or else Y + LCP'Result = A'Last + 1
      or else A (X + LCP'Result) /= A (Y + LCP'Result));

function LCP (A : Text; X, Y : Integer) return Natural is
   L : Natural;
begin
   L := 0;
   while X + L <= A'Last
     and then Y + L <= A'Last
     and then A (X + L) = A (Y + L)
   loop
      pragma Loop_Invariant
        (for all K in 0 .. L - 1 => A (X + K) = A (Y + K));
      pragma Loop_Variant (Increases => L);
      L := L + 1;
   end loop;
   return L;
end LCP;
\end{verbatim}
\end{footnotesize}

The type \verb|Text| is an array of integers with unknown bounds. The input
specification that parameters \verb|X| and \verb|Y| are indices in the array
parameter \verb|A| can be expressed as a precondition involving the Ada
attribute \verb|'Range|, and membership tests \verb|X in ...| The output
specification that the result is the length of the longest common prefix
starting at \verb|X| and \verb|Y| can be expressed as a postcondition in two
parts, using the \adatwtw attribute \verb|'Result| to express the function
result:
\begin{itemize}
\item A quantification stating that the subarrays of \verb|A| of length
  \verb|LCP'Result| starting at \verb|X| and \verb|Y| are equal.
\item A disjunction of cases stating that either one of the two subarrays
  reaches the end of array \verb|A|, or the elements following the two
  subarrays in \verb|A| are different. Note here that the use of the lazy
  boolean connective \verb|or else| is compulsory to make sure that
  \verb|X + LCP'Result| and \verb|Y + LCP'Result| are without bounds when
  accessing \verb|A| in the last line of the postcondition.
\end{itemize}

Running \gnatprove on this code without loop invariant or loop variant results
in the generation of 13 VCs: 1 VC for the postcondition, and 12 VCs for all
run-time checks (6 array index checks, 5 numeric overflow checks, 1 subtype
range check). All VCs related to run-time checks are proved. These VCs
represent both checks in the code and checks in assertions for the array
accesses in the postcondition. The VC for the postcondition is not proved, due
to the presence of a loop in the body of \verb|LCP|.

Proving the postcondition requires the insertion of a loop invariant in the
body of \verb|LCP|, which expresses that the subarrays of \verb|A| of length
\verb|L| starting at \verb|X| and \verb|Y| are equal. Since \verb|L| is the
value returned by \verb|LCP|, this loop invariant matches the first part of the
postcondition when the loop terminates. As expected, the postcondition is
proved with this additional loop invariant. \gnatprove generates 4 additional
VCs to prove that the loop invariant initially holds at the first iteration
through the loop, that it is maintained by subsequent iterations, and that the
two array accesses in the loop invariant expression are within bounds. All 4
additional VCs are also proved.

Finally, proving termination of \verb|LCP| requires the insertion of a loop
variant in the body of \verb|LCP|, which expresses that the value of \verb|L|
always increases between two consecutive iterations through the loop. Since
\verb|L| is of a bounded type (the scalar type \verb|Natural| of natural
numbers), it cannot be infinitely incremented without failing a run-time
check. Since we have already proved that no run-time check fails in \verb|LCP|,
proving the variant proves the termination of \verb|LCP|. The corresponding VC
is proved by \gnatprove.

The final version of \verb|LCP| is proved in 6s on a DELL laptop with 4G RAM
and 3GHz processor.

\subsection{Solution to Challenge 2}

We have chosen to implement an imperative version of prefix sum instead of a
recursive one, which better matches the constraints commonly found in critical
embedded software where recursion is usually not allowed. In order to make
automatic proof possible, we fix the length of the array to 8. The complete
solution is quite long (186 loc, not counting empty lines), so we only show
here selected parts. The initial solution without annotations is
straighforward, and only 50 lines long. As an example, here is the
implementation of procedure \verb|Upsweep|:

\begin{footnotesize}
\begin{verbatim}
procedure Upsweep (A : in out Input; Output_Space : out Positive) is
   Space : Positive := 1;
   Left  : Natural;
   Right : Natural;
begin
   while Space < A'Length loop
      Left := Space - 1;
      while Left < A'Length loop
         Right     := Left + Space;
         A (Right) := A (Left) + A (Right);
         Left      := Left + Space * 2;
      end loop;
      Space := Space * 2;
   end loop;
   Output_Space := Space;
end Upsweep;
\end{verbatim}
\end{footnotesize}

The postcondition of procedure \verb|Upsweep| states that the array parameter
\verb|A| is put in an intermediate form \wrt its initial value (denoted
\verb|A'Old|). The contract of procedure \verb|Downsweep| states it takes as
input an array parameter \verb|A| in an intermediate form \wrt a \verb|Ghost|
array parameter, and that it outputs in the same parameter \verb|A| the desired
prefix sums of array \verb|Ghost|. By calling in sequence \verb|Upsweep| and
\verb|Downsweep| on an array \verb|A|, with the initial value of \verb|A|
passed as \verb|Ghost| parameter, a caller performs the desired in-place
modification of \verb|A|. Although \newspark does not support yet ghost
parameters, which are only used for proofs, this is here the role of parameter
\verb|Ghost|, hence its name.

\begin{footnotesize}
\begin{verbatim}
procedure Upsweep (A : in out Input; Output_Space : out Positive) with
  Pre  => All_Elements_In (A, Maximum),
  Post => All_Elements_In (A, 8 * Maximum)
    and then Output_Space = 8
    and then Intermediate_Form (A, A'Old);

procedure Downsweep
  (Ghost : Input; A : in out Input; Input_Space : in Positive)
with
  Pre => All_Elements_In (Ghost, Maximum)
    and then All_Elements_In (A, 8 * Maximum)
    and then Input_Space = 8
    and then Intermediate_Form (A, Ghost),
  Post =>
    A (0) = 0
      and then
    A (1) = Ghost (0)
      and then
    A (2) = Ghost (0) + Ghost (1)
      and then
    A (3) = Ghost (0) + Ghost (1) + Ghost (2)
      and then
    A (4) = Ghost (0) + Ghost (1) + Ghost (2) + Ghost (3)
      and then
    A (5) = Ghost (0) + Ghost (1) + Ghost (2) + Ghost (3) + Ghost (4)
      and then
    A (6) = Ghost (0) + Ghost (1) + Ghost (2) + Ghost (3) + Ghost (4)
          + Ghost (5)
      and then
    A (7) = Ghost (0) + Ghost (1) + Ghost (2) + Ghost (3) + Ghost (4)
          + Ghost (5) + Ghost (6);
\end{verbatim}
\end{footnotesize}

The function \verb|Intermediate_Form| gives the exact relationship between the
initial value of the array (parameter \verb|B| below) and its intermediate
value between the calls to \verb|Upsweep| and \verb|Downsweep| (parameter
\verb|A| below). We define it as an expression function in \adatwtw, which has
the benefit that \gnatprove automatically generates a postcondition for
\verb|Intermediate_Form| equivalent to its body. We also give a precondition to
\verb|Intermediate_Form| to prove that its evaluation cannot fail run-time
checks (overflow checks and index checks here).

\begin{footnotesize}
\begin{verbatim}
function Intermediate_Form (A, B : Input) return Boolean with
  Pre => All_Elements_In (A, Maximum * 8)
    and then All_Elements_In (B, Maximum);

function Intermediate_Form (A, B : Input) return Boolean is
  (for all K in A'Range =>
     (if (K + 1) mod 8 = 0 then
        A (K) = B (0) + B (1) + B (2) + B (3) +
                B (4) + B (5) + B (6) + B (7)
     elsif (K + 1) mod 4 = 0 then
        A (K) = B (K) + B (K-1) + B (K-2) + B (K-3)
     elsif (K + 1) mod 2 = 0 then
        A (K) = B (K) + B (K-1)
     else
        A (K) = B (K)));
\end{verbatim}
\end{footnotesize}

Note that the contracts of all previous procedure and functions contain calls
to function \verb|All_Elements_In|, which returns \verb|True| if all elements
of an array are bounded in absolute value, which we also define as an
expression function:

\begin{footnotesize}
\begin{verbatim}
function All_Elements_In (A : Input; Max : Positive) return Boolean is
   (for all K in A'Range => A (K) in -Max .. Max);
\end{verbatim}
\end{footnotesize}

These specifications add 62 lines to the initial 50 lines for the solution. To
prove them with \gnatprove, we add 84 more lines for loop invariants and loop
variants. As an example, here are the loop invariant and loop variant for the
inner loop of procedure \verb|Upsweep|. Inside the loop invariant,
\verb|A'Loop_Entry| denotes the value of \verb|A| on entry to the loop.

\begin{footnotesize}
\begin{verbatim}
pragma Loop_Invariant (
  (Left + 1) mod Space = 0
    and then
  All_Left_Elements_In (A, Left, Space * 2 * Maximum)
    and then
  All_Right_Elements_In (A, Left - 1, Space * Maximum)
    and then
  (Left + 1) mod (Space * 2) = Space
    and then
  (if Left >= A'Length then Left = 8 or Left = 9)
    and then
  (for all K in A'Range =>
    (if K in A'First .. Left - Space
       and then (K + 1) mod (2 * Space) = 0
     then
        A (K) = A'Loop_Entry (K) + A'Loop_Entry (K - Space)
     else
        A (K) = A'Loop_Entry (K))));
pragma Loop_Variant (Increases => Left);
\end{verbatim}
\end{footnotesize}

The final version of prefix sum is partially proved (78 VCs proved, 8 VCs
unproved) in 138s on a DELL laptop with 24G RAM and 24 processors at 2.4GHz.
These 8 unproved VCs are either loop invariants or postconditions, which are
not proved automatically due to the use of the \verb|mod| operator, currently
not well handled in the underlying automatic prover. We have checked all of
them manually.

\subsection{Useful Tool Features}

The format of the competition exercized useful features of \gnatprove, which
helped finding errors early in the code or in the annotations. The most useful
of these features is certainly the ability to execute annotations, which allows
testing and debugging annotations as if they were code. It was used during the
competition to quickly locate the reason for an unprovable VC on challenge 1:
the loop test was using a strict comparison operator instead of the correct
non-strict one. To locate the problem, the participating author simply wrote a
test exercizing \verb|LCP| on an input, compiled it with run-time checks, and
run it. The run-time error raised precisely located the failing loop
invariant. Although this example was simple enough to immediately understand
the underlying problem, it would have been possible to use the debugger to
further investigate the issue, which can be extremely useful on real industrial
code. The ability to execute annotations was also useful for challenge 2, which
requires the development of complex loop invariants, to quickly correct
erroneous ones. This feature won the prize of user-assistance tool feature
awarded by the jury of the VerifyThis competition.

Another very useful feature for these challenges was the ability to eliminate
completely all possibilities of numeric overflows in annotations, as described
in Section~\ref{???}. While using this feature results in only 10 more overflow
VCs in challenge 1, which are all proved with the current annotations, it adds
60 overflow VCs in challenge 2, most of which require modifications of
annotations, or addition of new annotations, to be proved. Note that this
feature is compatible with the execution of annotations, as compilation also
takes into account the overflow mode when compiling arithmetic expressions.

Various features of \gnatprove make it very convenient to use inside an
Integrated Development Environment (currently GPS, the GNAT Programming
Studio). The user can choose to call \gnatprove on a selected file, an
individual subprogram, or even a single line of code. This was key to speed up
the modify/verify loop during the competition. When a VC is not proved, the IDE
can also display the corresponding statements in the code, to help figure out
why some assertions do not hold on some paths.

More generally, these small challenges already make use of numerous language
features in \adatwtw and \newspark that facilitate the expression of
specifications: preconditions and postconditions, loop invariants and loop
variants, expression functions, quantified expressions and if expressions,
special attributes \verb|'Result|, \verb|'Old| and \verb|'Loop_Entry|.

\begin{itemize}
\item snapshot of GNATprove results in GPS
\end{itemize}

\section{Ongoing Work}
\label{ongoing}

\gnatprove is the result of a complete redesign of the SPARK language and
associated tools, which started in 2010 with project \hilite.\cite{Hi-Lite}
Altran and AdaCore are collaborating to complete this new version of SPARK by
the start of 2014. On the tool side, current work focuses on flow analysis,
support for investigating unproved VCs, and improvements of the SMT prover.

Flow analysis is the verification of the data dependences of subprograms. This
analysis which has always been a component of SPARK verification is currently
redeveloped for \newspark, based on program dependence
graphs~\cite{horwitz:1988:pldi}. An important novelty is that, while \oldspark
requires that the user annotates programs with data dependence contracts, they
are optional in \newspark, and \gnatprove generates them when not present. A
minimal flow analysis is always required for the soundness of proofs, while a
more complete flow analysis is optional. The minimal flow analysis ensures that
all variables are initialized prior to being read.

Facilitating the investigation of unproved VCs is key to making formal program
verification cost-effective in industry. \gnatprove currently provides various
solutions to that problem: the ability to execute annotations to detect errors
in code and/or annotations; the display of program paths to detect errors or
locate missing annotations; the possibility to call alternate provers to
identify prover shortcomings. In the future, we would like to add the display
of counterexamples generated by the prover, as already provided by some SMT
provers~\cite{CVC3,Z3model}.

We have been exploring two promising ways to improve the results of the
Alt-Ergo SMT prover on the VCs generated in \gnatprove: handling selected
axiomatizations as decision procedures~\cite{dross:2012:smt}, and incrementally
selecting axioms~\cite{cgs09:ipo,kuhlwein:2012:ijcar}. More work is needed to
make these modes the default inside \gnatprove.

mention the following?

\begin{itemize}
\item proof of code containing containers
\item visualization of assumptions made for proof
\item Coq formalization of AST produced by frontend. possible verification of
  the consistency of the generated AST with checks.
\item adaptation for non-executable annotations and proof assistants
\end{itemize}

%
\bibliographystyle{alpha}
\bibliography{sttt_2013}

\end{document}



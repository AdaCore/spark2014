\documentclass[runningheads]{llncs}
\usepackage{graphicx}
\usepackage[usenames,dvipsnames]{color}
\usepackage{multirow}
\usepackage{listings}
\newcommand{\CodeSymbol}[1]{\textcolor{Bittersweet}{#1}}
\lstset{
   language=Ada,
   keywordstyle=\color{RedViolet}\textbf,
   showspaces=false,
   basicstyle={\ttfamily\scriptsize},
   commentstyle=\color{red}\textit,
   stringstyle=\color{MidnightBlue},
   string=[b]",  % remove ' from string delimiter as it interfers with attributes
   showtabs=false,
   keepspaces=true,
   showstringspaces=false,
   morekeywords=[1]Pre,
   morekeywords=[1]Post,
   morekeywords=[1]Test\_Case,
   morekeywords=[1]Contract\_Cases,
   morekeywords=[1]some,
   morekeywords=[1]Old,
   morekeywords=[1]Global,
   morekeywords=[1]Depends,
   morekeywords=[1]Loop\_Invariant,
   morekeywords=[1]Loop\_Variant,
   morekeywords=[1]Loop\_Entry,
   morekeywords=[1]Increases,
   literate={(}{{\CodeSymbol{(}}}1
            {)}{{\CodeSymbol{)}}}1
            {>}{{\CodeSymbol{$>$}}}1
            {>=}{{\CodeSymbol{$\ge$}}}1
            {<}{{\CodeSymbol{$<$}}}1
            {<=}{{\CodeSymbol{$\le$}}}1
            {:=}{{\CodeSymbol{:=}}}1
            {=}{{\CodeSymbol{=}}}1
            {:}{{\CodeSymbol{:}}}1
            {.}{{\CodeSymbol{.}}}1
            {;}{{\CodeSymbol{;}}}1
            {/=}{{\CodeSymbol{$\ne$}}}1
            {=>}{{\CodeSymbol{$\Rightarrow$}}}1
            {->}{{\CodeSymbol{$\rightarrow$}}}1
            {<->}{{\CodeSymbol{$\leftrightarrow$}}}1
            {\\l}{{\CodeSymbol{$\lambda$}}}1
            {/\\}{{\CodeSymbol{$\wedge$}}}1
}
%
% If you use the hyperref package, please uncomment the following line
% to display URLs in blue roman font according to Springer's eBook style:
% \renewcommand\UrlFont{\color{blue}\rmfamily}

\begin{document}
%
\title{Recursive Data-Structures in SPARK}
%
\author{Claire Dross \and Johannes Kanig}
%
% \authorrunning{F. Author et al.}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
\institute{AdaCore, 75009 Paris}
%
\maketitle              % typeset the header of the contribution
%
\begin{abstract}
SPARK is both a deductive verification tool for the Ada language and the subset of Ada on which it operates. In this paper, we present a recent extension of the SPARK language and toolset to support pointers. This extension is based on an ownership policy inspired by Rust to enforce non-aliasing through a move semantics of assignment. In particular, we consider pointer-based recursive data structures, and discuss how they are supported in SPARK. We explain how iteration over these structures can be handled using a restricted form of aliasing called local borrowing. To avoid introducing a memory model and to stay in the first-order logic background of SPARK, the relation between the iterator and the underlying structure is encoded as a predicate which is maintained throughout the program control flow. Special first-order contracts, called pledges, can be used to describe this relation. Finally, we give examples of programs that can be verified using this framework.

\keywords{Deductive Verification  \and Recursive Structures \and Ownership.}
\end{abstract}
%
%
%
\section{Introduction}
The programming language SPARK has been designed to be amenable to formal verification, and one of the most impactful design choices was the exclusion of aliasing. While this choice vastly simplified the tool design and improved the expected proof performance, it also meant that pointers, as a major source of aliasing, were excluded from the language. While SPARK over the years had seen the addition of many language features, adding pointers just seemed impossible without violating the non-aliasing property. % The workaround was to replace pointers by indices into arrays - we developed some non-trivial examples using this approach, including an implementation of red-black trees~\cite{dross2017auto}.
Then came Rust and its type system based on ownership~\cite{rust}. %Finally there seemed to be a way to add pointers to the language in a way that would still exclude aliasing. Simplifying and adapting the rules to fit to SPARK were hard work, but in the end it worked out.
Taking inspiration from it, it was possible to add pointers to the language in a way that still excludes aliasing.
We will give an overview over the rules in this paper.

However, it was unclear if programs traversing recursive data structures such as lists and trees %, which are after all one of the main use cases for pointers,
could be supported in this setting. In particular, iteration using a loop requires an alias between the traversed structure and the iterator.
% The problem with such structures is that proof annotations must account not only for local modifications under some pointer, but also how this modification affects the larger data structure that contains this pointer, and so on.
In this paper, we detail an approach, inspired by recent work by Astrauskas et al.~\cite{astrauskas2019leveraging}, that enables proofs about recursive pointer-based data structures in SPARK. We have implemented this approach in the industrial formal verification tool SPARK, and, using this tool, developed a number of examples. Some important restrictions remain - we will also discuss them in this paper.

%\subsection{Ada and SPARK}
Ada is a general-purpose procedural programming language. %, which has been developed in the 70ies for the US Department of Defence, and was standardised first in 1983. Since then, the language has continued to evolve via the major revisions Ada 95, 2005 and 2012, and a new standard is expected in the next few years.
The design of the Ada language puts great emphasis on the safety and correctness of the program. This objective is realized by using a readable (if verbose) syntax that uses keywords instead of symbols where reasonable. The type system %, while not as expressive as more modern type systems such as Haskell,
is strong and strict % It is also quite rich, in particular allowing the definition of user-defined numerical ranges, array sizes and so on.
and many potential violations of type constraints can be detected statically by the compiler. If not, a run-time check is inserted into the program, to guarantee the detection of incorrect situations. %If a performance impact is feared, the runtime checks can also be disabled.
\begin{lstlisting}
declare             --  Block introducing new declarations
  type My_Int is range -100 .. 100;
  -- User-defined integer type ranging from -100 to 100
  subtype My_Nat is My_Int range 0 .. My_Int'Last;
  -- Subtype of My_Int with additional constraints

  X : My_Int := 50; --  Static check that 50 is in the bounds of My_Int
  Y : My_Nat;
begin               --  Part of the block containing statements
  ...
  Y := X;           --  Dynamic check that X is in the bounds of My_Nat
end;                --  End of scope of the entities declared in the block
\end{lstlisting}
Ada 2012 %, inspired by Eiffel,
introduced contract based programming to Ada. In particular, it is possible to attach pre- and postconditions to subprograms\footnote{In Ada, a distinction is made between functions that return a value, and procedures, which do not. \emph{Subprogram} is the term that designates both.}. %In Ada, these conditions are just boolean expressions which should hold respectively before and after the subprogram execution.
These conditions can be checked during the execution of the program, just like assertions.
%The user can decide that these expressions be checked during the execution of the program, just like assertions. In reference to the term \emph{contract-based programming}, we use the term \emph{contracts} to refer to pre- and postconditions in this paper.

%Ada is a quite large language. Besides the procedural core and the already mentioned contract-based programming, Ada also supports generics, object-oriented programming and tasking. Today, Ada is mainly used in safety-critical and embedded environments.

%\subsection{SPARK}
SPARK is the name of a tool that provides formal verification for Ada. It uses the user-provided contracts and attempts to prove that the runtime checks cannot fail and that postconditions are established by the corresponding subprograms.
As formal verification for the whole Ada language would be intractable, SPARK is also the name of the subset of the Ada language that is supported by the SPARK tool%. This subset is defined in a separate document
\footnote{\url{http://docs.adacore.com/spark2014-docs/html/ug/}}.
This subset contains almost all features of Ada, though sometimes in a restricted form. %For example, generics are fully supported, tasking is supported but only with static tasks, and global side effects are restricted to procedures and not allowed in functions - this makes it easier to reason about expressions that include function calls, in particular if they appear in contracts.
%Another restriction, which has already been mentioned in the introduction, is the absence of aliasing.
In particular, expressions should be free from side effects, and aliasing is forbidden (no two variables should share the same memory location or overlap in memory).
This restriction greatly simplifies the memory model used in the SPARK tool: any program variables%, including arrays and other structured data,
can be reasoned about independently from other variables.
%In the absence of pointers, aliasing can only be created via some forms of parameter passing, so this restriction is not very severe. Pointers are discussed in section~\ref{sec-pointers}.

%\subsection{The SPARK tool}
The SPARK tool %that implements the actual verification
uses the Why3 platform to generate verification conditions for SMT solvers via a weakest-precondition calculus~\cite{bobot2011why3}.
%is separated into two parts. A first part translates the SPARK program to the intermediate verification language Why3. The second layer translates the Why3 program to verification conditions for SMT solvers via a weakest-precondition calculus. For this part, the SPARK tool uses the Why3 platform developed at Inria~\cite{bobot2011why3}.

\section{Support for Pointers\label{sec-pointers}}
%\subsection{Pointers in Ada}
Pointers in Ada are called \emph{access types}. It is possible to declare an access type using the \texttt{access} keyword.
Objects of an access type are \texttt{null} if no initial values are supplied.
It is possible to allocate an object on the heap using the keyword \texttt{new}. An initial value can be supplied for the allocated object.
A dereference to a pointer is written as a record component access, but using the keyword \texttt{all}.
\begin{lstlisting}
declare
  type Int_Acc is access Integer; --  Declare a new access type
  X : Int_Acc;                    --  Declare an object of this type
  pragma Assert (X = null);       --  No initial values provided, X is null
  Y : Integer;
begin
  X := new Integer;            --  Allocation of data on the heap
  X := new Integer'(3);        --  The allocated memory is initialized to 3
  Y := X.all;                  --  Dereference the access
end;
\end{lstlisting}
When a pointer is dereferenced, a runtime check is introduced to make sure that it is not null.
Ada does not mandate garbage collection. Memory allocated on the heap can be reclaimed manually by the user using a generic function named \texttt{Unchecked\_Deallocation}, which also sets its argument pointer to null.
There are several kinds of access types. The basic access types, like \texttt{Int\_Acc} defined above, are called pool specific access types. They can only designate objects allocated on the heap. General access types, introduced by the keyword \texttt{all}, can also be used to designate objects allocated on the stack.
%An access to an object can be created through the \texttt{`Access} attribute.
%\begin{lstlisting}
%type Gen_Int_Acc is access all Integer;
%Y : Get_Int_Acc := Y'Access;
%\end{lstlisting}
%Note that an access is not an integer type, so it is not possible to do pointer arithmetics on access types in Ada. Users can still do pointer arithmetic if they first convert the pointer to a special Address type which allows arithmetic operations.

%\subsection{Pointers in SPARK}
Pointers were excluded from the SPARK subset until recently. Indeed, allowing pointers in a straightforward way would break the absence of aliasing in SPARK. In addition, pointers are associated to a list of classes of bugs. A subset of them is memory leaks, use-after-free and dereferencing a null-pointer.% We use the term memory corruption to indicate any dereference of a pointer that points to “invalid” data - use-after-free is actually a special case of memory corruption.

To support pointers in SPARK, we designed a subset of Ada's access types which does not introduce aliasing and avoids some pointer-specific issues, while retaining as much expressivity as possible. The first restriction we selected is the exclusion of general access types. This means that SPARK can only create pointers designating memory allocated on the heap, and not on the stack. As a result, pointers can only be made invalid by explicit deallocation, and deallocation of a valid pointer is always legal. % This rule also excludes aliasing between pointers and stack values.
To eliminate aliasing between (heap) pointers, ownership rules inspired by Rust have been added on top of Ada's legality rules. These rules enforce a single writer/multiple readers policy. They ensure that, when a value designated by a pointer is modified, all other objects can be considered to be preserved.
% Note that ownership rules, together with the restriction to pointer designating values in the heap, are enough to avoid memory corruption as defined above. For example, it rules out cases of use-after-free. Indeed, in Ada, when a value designated by a pointer is deallocated using \texttt{Unchecked\_Deallocation}, the variable containing the pointer is reset to null. Since the variable was the only way to access the value designated by the pointer, the deallocated memory can no longer be accessed afterward.

%\subsection{Ownership Policy}
The basis of the ownership policy of SPARK is the move semantics of assignments. When a pointer is assigned to a variable, both the source and the target of the assignment designate the same memory region: assigning an object containing a pointer creates an alias.
%\begin{lstlisting}
%Y : Int_Acc := X; -- Y is an alias of X, modifying Y.all also impacts X.all
%\end{lstlisting}
To alleviate this problem, when an object containing a pointer is assigned, the memory region designated by the pointer is said to be \emph{moved}. The source of the assignment loses the ownership of the designated data while the target of the assignment gains it. The tool makes sure that the designated data is not accessed again through the source of the assignment.
\begin{lstlisting}
Y : Int_Acc := X;   -- Ownership of the data designated by X is moved to Y
Y.all := Y.all + 1; -- The data can be read and modified through Y
Z := X.all;         -- Illegal: Reading or modifying X.all is not allowed
\end{lstlisting}
% Note that a variable which has been moved is not lost forever. It is not possible for it to regain ownership of the value it used to designate, but it can be made to designate another value, or the same, through another assignment.
% \begin{lstlisting}
% Y : Int_Acc := X;   -- Ownership of the data designated by X is moved to Y
% X := Y;             -- X regains ownership of the data designated by Y
% X.all := X.all + 1; -- The data can again be read and modified through X
% \end{lstlisting}
%\subsection{Proof Support}
As the ownership policy ensures that no aliasing can occur between access objects, it is possible to reason about the program almost as if the pointer was replaced by the data it points to. When an object containing a pointer is assigned to another variable, it is safe to consider that the designated data is copied by the assignment. Indeed, any effects that could occur because variables are sharing a substructure cannot be observed because of the ownership rules.

Pointers are handled in SPARK as \emph{maybe}, or \emph{option} types: access objects are either null, or they contain a value. In addition, access objects also contain an address, which can be used to handle comparison (two pointers may not be equal even if the values they designate are equal). When a pointer is dereferenced, a verification condition is generated to make sure that the pointer is not null, so that its value can be accessed.
\begin{lstlisting}
X : Int_Acc;          --  X is null
X := new Integer'(3); --  X has a value which is 3
Y := X;               --  Y has a value which is 3
Z := Y.all;           --  Check that Y is not null, Z is 3
\end{lstlisting}
Note that the ownership policy is key for this translation to be correct, as it prevents the program from observing side-effects caused by the modification of a shared reference, which would not be accounted for in the verification model.
% \begin{lstlisting}
% X := new Integer'(3);      --  X has a value which is 3
% Y := X;                    --  Y has a value which is 3
% Y.all := 4;                --  Y has a value which is 4, X is not modified
% pragma Assert (X.all = 3); --  Rejected by ownership rules
% \end{lstlisting}
\section{Recursive Data-Structures}
%\subsection{Recursive Data-Structures in Ada}
In Ada, it is not possible to declare a recursive data structure directly. Recursivity can only be introduced through pointers. The idea is to first declare a type, but without giving its definition. This declaration, called \emph{incomplete declaration}, introduces a place-holder for the type, which can only be used in restricted circumstances. In particular, this place-holder can be used to declare an access type designating pointers to values of this type. %To allocate such an object, we will need to wait until after the incomplete declaration is completed by a type definition.
Using this mechanism, it is possible to declare a recursive data structure, since the access type can be used in the type definition as it comes afterward.
\begin{lstlisting}
type List_Cell;
type List is access List_Cell;
type List_Cell is record
  Data : Integer;
  Next : List;
end record;
\end{lstlisting}
% Other types, such as incomplete declarations, access types, arrays\dots can be interleaved between the incomplete type declaration and its completion to create more complex structures.
% \begin{lstlisting}
% type Tree_Cell;
% type Tree is access Tree_Cell;
% type Tree_Array is array (Positive range <>) of Tree;
% type Tree_Array_Acc is not null access Tree_Array;
% type Tree_Cell is record
%   Data     : Integer;
%   Children : Tree_Array_Acc;
% end record;
% \end{lstlisting}
%\subsection{Recursive Data-Structures in SPARK}
There are no specific restrictions concerning recursive types in SPARK. However, the ownership policy of SPARK implies that it will not be possible to create a structure which has either cycles (e.g. doubly linked lists) or shared substructures (e.g. DAGs) in it.
% \begin{lstlisting}
% type DLL_Cell;
% type Doubly_Linked_List is access DLL_Cell;
% type DLL_Cell is record
%   Data       : Integer;
%   Prev, Next : Doubly_Linked_List;
% end record;       --  OK, no particular restrictions
% X : Doubly_Linked_List := new DLL_Cell'(Data => 1, others => null);
% Y : Doubly_Linked_List := new DLL_Cell'(Data => 2, others => null);
% X.Next := Y;      --  Y is moved
% X.Next.Prev := X; --  Assignment is not allowed, object was moved during
%                   --  evaluation of the right-hand side.
% \end{lstlisting}
The ownership policy may also impact how recursive structures can be manipulated. In general, working with such structures involves a traversal, which can be done either recursively, or iteratively using a loop. Algorithms working in a recursive way are generally compliant with the ownership policy of SPARK. Indeed, the recursive calls will allow reading or modifying the structure in depth without having to deconstruct it\footnote{In \texttt{Length} and \texttt{Nth}, addition on \texttt{My\_Nat} and \texttt{My\_Pos} has been redefined to saturate so as to avoid the overflow checking mandated by Ada.}.
\begin{lstlisting}
function Length (L : access constant List_Cell) return My_Nat is
  (if L = null then 0 else Length (L.Next) + 1);
function Nth (L : access constant List_Cell; N : My_Pos) return Integer is
  (if N = 1 then L.Data else Nth (L.Next, N - 1))
with Pre => N <= Length (L);
\end{lstlisting}
Algorithms involving loops are trickier. The declaration of the iterator used for the loop creates an alias of the traversed data structure. As per SPARK's ownership policy, this is considered to be a move, so it makes it illegal to access the initial structure. Further assignments to the iterator during the traversal contribute to losing definitively one by one the ownership of every node in the structure, making it impossible to restore the ownership at the end.
\begin{lstlisting}
procedure Set_All_To_Zero (X : in out List) is
   Y : List := X;    -- The ownership of X is transferred to Y
begin
   while Y /= null loop
      Y.Data := 0;
      Y := Y.Next;   --  Ownership of the first cell of Y is lost for good
   end loop;         --  The ownership of X cannot be restored
end Set_All_To_Zero; --  Illegal, cannot exit subprogram while X is moved
\end{lstlisting}
To traverse recursive data structures, a move is not what we want. Here we need a way to lend the ownership of a memory region for a period of time and automatically restore it at the end. A similar mechanism, called \emph{borrowing}, is available in the Rust language. We have adapted it to SPARK.
\section{Borrowing Ownership}
%\subsection{Local Borrowers}

As Ada is an imperative language, losing the possibility to traverse a linked data structure using a loop was deemed too restrictive. To alleviate this problem, a notion of ownership borrowing was introduced in SPARK. It allows the users to declare a variable, called a borrower, which is initialized with a reference to a part of an existing data structure. To state that this initialization should not be considered a move, an \emph{anonymous access type} is used for the borrower. During the scope of the borrower, the borrowed part of the underlying structure is frozen, meaning that it is illegal to both read and modify it. %, like if it was moved, but also that we cannot make it designate something else.
Once the borrower has gone out of scope, the ownership automatically returns to the borrowed object, so that it is again fully accessible.
\begin{lstlisting}
X := ...;                      --  X is initialized to the list {1,2,3,4}
declare
  Y : access List_Cell := X;   --  Y has an anonymous access type.
  --  Ownership of X is transferred to Y for the duration of its lifetime.
begin
  Y.Data := Y.Data + 1;        --  Y can be used to read or modify X
  pragma Assert (X.Data = 2);  --  Illegal, during the lifetime of Y, X
                               --  cannot be read or modified directly
end;
pragma Assert (X.Data = 2);    --  Afterwards, the ownership returns to X
\end{lstlisting}
A borrower can be used to modify the underlying structure. This makes it effectively an alias of the borrowed object. To allow the tool to statically determine the cases of aliasing, SPARK restricts the initial value of a local borrower to be the name of a part of an existing object. This forbids for example borrowing one of two structures depending on a condition.

%\subsection{Reborrows}
It is possible to update a borrower to change the part of the object it designates (as opposed to modifying the designated object). This is called a reborrow. In SPARK, the value assigned to the borrower in a reborrow should be rooted at the borrower. This means that reborrows only go deeper into the structure.
\begin{lstlisting}
declare
  Y : access List_Cell := X;  --  Y is X
begin
  Y := Y.Next;                --  This is a reborrow, Y is now X.Next
end;
\end{lstlisting}
% For ownership checking, reborrows are handled as borrows of the borrower, and not as direct borrows of the borrowed object. Indeed, as reborrows can be nested in value-dependent control flows such as conditionals, the actual part of an object which is designated by a borrower is not statically known. As a result, it is illegal to try to access a part of an object which was borrowed, even if this part is not accessible from the borrower anymore.
% \begin{lstlisting}
% declare
%   Y : access List_Cell := X.Next;   --  Y is X.Next
% begin
%   pragma Assert (X.Data = 1);       --  Legal, X.Data was not borrowed
%   Y := Y.Next;                      --  Y is X.Next.Next
%   pragma Assert (X.Next.Data = 1);  --  Illegal, X.Next was borrowed
% end;
% \end{lstlisting}
Borrowing can be used to allow simple iterative traversals of a recursive data structure like the loop of \texttt{Set\_All\_To\_Zero}. More complex traversals, involving stacks for example, cannot be written iteratively in SPARK.
\begin{lstlisting}
procedure Set_All_To_Zero (X : in out List) is
   Y : access List_Cell := X;
   -- The ownership of X is transferred to Y for the duration of its lifetime
begin
   while Y /= null loop
      Y.Data := 0;
      Y := Y.Next;   --  Reborrow: Y designates something deeper
   end loop;
end Set_All_To_Zero; --  The ownership of X is restored
\end{lstlisting}
%\subsection{Proof Support: Borrow Relation}
Using reborrows, local borrowers allow to indirectly modify a data structure at an arbitrarily-deep, not statically-known position. While in the scope of the borrower, these indirect modifications can be ignored by the analysis, as the ownership policy makes them impossible to observe. However, after the end of the borrow, ownership is transferred back to the borrowed object, and SPARK needs to take into account whatever modifications may have occurred through the borrower.
\begin{lstlisting}
X := ...; --  X is initialized to the list {1,2,3,4}
declare
  Y : access List_Cell := X;            --  Y is X
begin
  Y := Y.Next.Next;
  --  Through reborrows, Y designates an arbitrarily-deep part of X
  Y.Data := 42;                         --  Y is used to indirectly modify X
end;
pragma Assert (X.Next.Next.Data = 42);  --  The assertion should hold
\end{lstlisting}
To be able to reconstruct the borrowed object from the value of the borrower, we must track the relation between them. As this relation cannot be statically determined because of reborrows, SPARK handles it as an additional object in the program. This allows us to take advantage of the normal mechanism for handling value dependent control-flow in SPARK (the weakest-precondition calculus of Why3).
The idea is the following. When a borrower is declared in Ada, we create two objects: the borrower itself, which is considered as a stand-alone structure, independent of the borrowed object, and a predicate. The predicate, which we call the borrow relation, encodes the most precise relation between the borrower and the borrowed object which does not depend on the actual value designated by the borrower. The value of the \emph{borrow relation} is computed by the tool from the definition of the borrower, and is updated at each reborrow. Modifications of the underlying data structure don't impact this relation. At the end of the borrow, the borrowed object is reconstructed using both the borrow relation and the current value of the borrower.
\begin{lstlisting}
X := ...; --  X is initialized to the list {1,2,3,4}
declare
  Y : access List_Cell := X; --  Create borrow relation to relate X and Y
  --  b_rel := \l new_x, new_y. new_x /= null /\ new_x = new_y
begin
  Y := Y.Next.Next; --  Update the predicate to model the new relation
  --  b_rel := \l new_x, new_y. new_x /= null /\ new_x.data = 1 /\
  --    new_x.next /= null /\ new_x.next.data = 2 /\ new_x.next.next /= null
  --    /\ new_x.next.next = new_y
  Y.Data := 42; --  The borrow relation is not modified
end;
pragma Assert (X.Next.Next.Data = 42);
--  Follows from the fact that X.Next.Next = Y and Y.Data = 42
\end{lstlisting}
% Note that the above has been simplified for clarity to mention the numerical values of the list. The borrow relation is in fact updated without having to analyze previous statements by using its old value and the old value of the borrower as follows:
% \begin{lstlisting}
%   Y := Y.Next.Next;
%   --  b_rel := \l new_x, new_y. b_rel (new_x, { y with next.next -> new_y })
%   --    /\ (new_y = null <-> y.next.next = null)
%   --  The new value of b_rel is computed from the current value of b_rel
%   --  and the current value of Y.
% \end{lstlisting}
\section{Describing the Borrow Relation}
% \subsection{Motivation: Loop Invariants}
% The previous section presents how local borrowers can be used to iterate through a recursive data structure without destroying it, and how they can be modeled precisely using a predicate named the borrow relation. However, we are still missing something in order to be able to verify a program using a loop to modify a recursive data structure like \texttt{Set\_All\_To\_Zero}. Indeed, SPARK is performing deductive verification, and applying deductive verification to a program involving a loop generally requires coming up with a loop invariant.

% In SPARK, a loop invariant is a special assertion which can be placed anywhere in a loop. Like any assertion, the tool will try to establish that it holds at the given program point. Loop invariants are special because they act as a cut point. They should summarize all that was established during the previous iterations of the loop. The tool verify them in an inductive way - they should hold at the first iteration of the loop, and knowing that the invariant holds at a given iteration should be enough to prove that it holds at the next.
% \begin{lstlisting}
% --  Version of Set_All_To-Zero over arrays of integers
% procedure Set_All_To_Zero (X : in out Int_Array) with
%   Post => (for all K in X'Range => X (K) = 0);
%   --  All elements of X are 0 after the call
%
% procedure Set_All_To_Zero (X : in out Int_Array) is
% begin
%    for J in X'Range loop
%       pragma Loop_Invariant
%          (for all K in X'First .. J - 1 => X (K) = 0);
%       --  All elements of X up to J are 0
%   	X (J) := 0;
%    end loop;
% end Set_All_To_Zero;
% \end{lstlisting}
SPARK performs deductive verification, which relies on user-specified invariants to handle loops. When traversing a linked data structure, the loop body contains a reborrow, which means that the borrow relation is modified in the loop. As a general rule, if a variable is modified in a loop, it should be described in the loop invariant, lest nothing is known about its value afterward. Thus, we need a way to describe the borrow relation in the loop invariant.

%\subsection{Introduction to Pledges}
As part of their work on the Prusti proof tool for Rust, Astrauskas et al. found the need for a similar annotation that they call \emph{pledges}~\cite{astrauskas2019leveraging}. In Rust, a pledge is an assertion associated to a borrower which is guaranteed to hold at the time when the borrow expires, no matter what may happen in between. In SPARK, a property guaranteed to hold at the end of the borrow must be a consequence of the borrow relation, since the borrow relation is the most precise relation which does not depend on the actual value of the borrower. Therefore, the user-visible notion of a pledge is suitable to approximate the internally computed borrow relation. Similar to user-provided preconditions, which must imply the weakest precondition computed by a verifying tool, the user-provided pledge should follow from the borrow relation.

Since the Ada language has no support for pledges, we have resorted in SPARK to introducing special functions (dedicated to each deep type) called pledge functions, which mark expressions which should be considered as pledge expressions by the tool. A pledge function is a ghost function (meaning that it is not allowed to have any effect on the output of the program) which has two parameters. The first one is used to identify the borrower on which the pledge should apply, while the second holds the assertion.
Note that a call to a pledge function isn't really a call for the SPARK analyzer. It is simply a marker that the expression in argument is a pledge. As assertions in SPARK are executable, we need to give an implementation to the pledge function: the function simply returns its second parameter.
\begin{lstlisting}
function Pledge
  (L : access constant Cell; --  The borrower to which the pledge applies
   P : Boolean)              --  The property we want to assert in the pledge
     return Boolean
is (P)  --  For execution, the function evaluates the property
with Ghost,
  Annotate => (GNATprove, Pledge); --  Identifies a pledge function for SPARK
\end{lstlisting}
When a pledge function is called in an assertion, SPARK recognizes it and identifies its parameter as a pledge. It therefore attempts to show that the property is implied by the borrow relation (as opposed to implied by the current value of the borrower).
\begin{lstlisting}
X := ...; --  X is initialized to the list {1,2,3,4}
declare
  Y : access List_Cell := X;
begin
  Y := Y.Next.Next;
  pragma Assert (Pledge (Y, Y = X.Next.Next));
  --  True as this is implied by borrow relation
  pragma Assert (Pledge (Y, X.Data = 1 and X.Next.Data = 2));
  --  True again as the first 2 elements of X are frozen
  pragma Assert (Pledge (Y, X.Next.Next.Data = 3));
  --  False, though this is true at the current program point, as it is not
  --  guaranteed to hold at the end of the borrow.
  ...
end;
\end{lstlisting}
%\subsection{Verification of \texttt{Set\_All\_To\_Zero}}
Using pledges, we can formally verify the \texttt{Set\_All\_To\_Zero} procedure. Its postcondition states that all elements of the list have been set to 0 using the Nth function. To be able to express the loop invariant in a similar way, we have introduced a ghost variable C to count the number of iterations. Its value is maintained by the first loop invariant. The second and third invariants are pledges, describing how the value of X can be reconstructed from the value of the iterator Y. The second invariant gives the length of the list, while the third describes the value of its elements using the Nth function. Elements which have already been processed are frozen by the borrow. Their value is known to be 0. Other elements can be linked to the corresponding position in the iterator Y.
\begin{lstlisting}
procedure Set_All_To_Zero (X : List) with
  Pre  => Length (X) < My_Nat'Last,
  Post => Length (X) = Length (X)'Old
    and (for all I in 1 .. Length (X) => Nth (X, I) = 0);
  --  All elements of X are 0 after the call

procedure Set_All_To_Zero (X : List) is
   C : My_Nat := 0 with Ghost;
   Y : access List_Cell := X;
begin
   while Y /= null loop
      pragma Loop_Invariant (C = Length (Y)'Loop_Entry - Length (Y));
      --  C elements have been traversed
      pragma Loop_Invariant
        (Pledge (Y, Length (X) = Length (Y) + C));
      pragma Loop_Invariant
        (Pledge (Y, (for all I in 1 .. Length (X) =>
           Nth (X, I) = (if I <= C then 0 else Nth (Y, I - C)))));
      --  All elements are 0 up to C, others are elements of Y
      Y.Data := 0;
      Y := Y.Next;
      C := C + 1;
   end loop;
end Set_All_To_Zero;
\end{lstlisting}
Note that, in general, it is not necessary to write a pledge to verify a program using a local borrower. Indeed, the analysis tool is able to precisely track the borrow relation through successive reborrows. Pledges need only be provided when the borrow relation itself cannot be tracked by the tool, for example because of a loop, like in our example.

% Pledges are also useful when specifying traversal functions, that is, functions returning an access inside a part of a structure. Traversal functions are identified in SPARK by they return type, which must be an anonymous access type (a borrower). As Ada does not have annotations that can be used to link the life-time of the borrower to a specific object, traversal functions are restricted to borrow their first parameter.
% \begin{lstlisting}
% function Nxt2 (L : access List_Cell) return access List_Cell is
% begin
%    return L.Next.Next;  --  Nxt2 must return a part of L
% end Nxt2;
% \end{lstlisting}
% Since SPARK works modularly on a per-subprogram basis, the body of the traversal function cannot be used to compute the borrow relation of its result when analyzing a call. The postcondition should describe this relation using a pledge.
% \begin{lstlisting}
% function Nxt2 (L : access List_Cell) return access List_Cell with
%   Pre  => Length (L) >= 2,
%   Post => Pledge (Nxt2'Result, Length (L) >= 2 and Nxt2'Result = L.Next.Next);
% --  The pledge describes the borrow relation of the returned object
% \end{lstlisting}
\section{Evaluation}
We could not try the tool on any pre-existing benchmark since SPARK codebases do not have pointers, and Ada codebases usually violate some SPARK rules. In particular, Ada codebases have no reason to abide by the ownership policy of SPARK. So instead, we mostly had to write new tests to assess the correctness and performance of our implementation.
The public testsuite of SPARK contains more than 150 tests mentioning access types, be they supported cases or not.

%\subsection{Description of the Examples}
To assess expressivity and provability on programs dealing with recursive data structures, we have written 6 examples, none of them very big, but ranging over various levels of complexity.
%
% In addition to the running example \emph{set all to zero}, we have a second program, \emph{linear search}, featuring linked lists of integers. Another two work on linked lists. \emph{Pointer based maps} defines a map as a list of pairs of a key and an element. \emph{Route shift} is the translation of the running example used by Astrauskas et all in their article~\cite{astrauskas2019leveraging}. It represents a route as a list of points with two coordinates. The last two examples feature binary trees, search trees for \emph{binary search}, and self balancing search trees for \emph{red black trees}.
%
% All of these examples are pretty small, providing between 1 and 3 functionalities. The longest, \emph{red black trees}, fits in a little more than 100 loc, not counting contracts ang ghost code. They are all designed in a similar way. Specification functions are defined recursively, as it is the natural way to reason about recursive data structures. The functionalities themselves are generally encoded using loops. The only exception is insertion inside a red black tree, which uses recursive calls. Indeed, because of the ownership policy of SPARK, it is not possible to store a backward link to the parent node in the tree structure. As a result, we could not use a loop to climb up the tree to rebalance it after the insertion.
%
On all of these examples, we have shown that the runtime checks imposed by the Ada language are guaranteed to pass and that no uninitialized value can be read.
% In general, SPARK is not concerned with termination, though loops can be annotated with variants. However, to ensure soundness in case of incorrect usage, the tool may limit the information available about functions called in the specification if they are not known to terminate. Though such functions are not that common in general usage of SPARK, in our examples nearly all our specification functions were limited, due to them being recursive. To alleviate this problem, we have annotated these functions to instruct the tool that they must terminate. Since termination of recursive functions cannot be verified in SPARK, we have resorted to manually reviewing and justifying the associated checks.
%
In addition, we have manually supplied functional properties.
% In most of our examples, we attempted to specify full functional correctness, meaning that the outputs of the subprograms are fully defined in terms of their inputs (except for addresses of pointers which cannot be referred to in SPARK). This is not the case for \emph{pointer-based maps}, which was designed to be a simple example used to demonstrate local borrowers in the user guide. \emph{Route shift} is not fully specified either, as we only translated the contracts present in the Rust version.

Fig.~\ref{table-examples} gives some metrics over these examples.
% Whereas for \emph{set all to zero}, we have around 20 lines of specifications, counting the contracts and the specification functions, and 8 lines of ghost code to help proof (the three loop-invariants and the declaration and update of the ghost variable), for \emph{red black trees} we are up to around 100 lines of specifications and nearly 400 lines of additional ghost code (contracts of local subprograms, lemmas, invariants…).
Under the tab Loc are listed the total number of lines of code in the example, the number of lines of specification (including contracts and specification functions), and the number of additional ghost annotations (assertions, loop invariants, ghost variables…). The \#Checks column stores the number of checks generated by the tool (contracts, assertions, invariants, language defined checks...). In the last three columns, we can see the total running time of SPARK, both from scratch using its default strategy and only replaying the proofs through the replay facility, as well as the maximal time needed to prove a single verification condition.

\begin{figure}
\vspace{-5mm}
\setlength{\tabcolsep}{3pt}
\renewcommand{\arraystretch}{1.5}
\begin{center}
\scriptsize
\begin{tabular}{ c c ccc c ccc }
 \hline
\multirow{2}{*}{Example} &
\multirow{2}{*}{\#Subp} &
\multicolumn{3}{c}{LOC}&
\multirow{2}{*}{\#Checks} &
\multicolumn{3}{c}{Analysis time (s)}\\
& & All & Spec & Ghost & &
Default & Replay & Max VC\\
\hline
set all to zero
& 5
& 57
& 19 (33\%)
& 8 (14\%)
& 25
& 4
& 3
& $<$ 1\\
linear search
& 7
& 136
& 67 (49\%)
& 24 (17\%)
& 109
& 10
& 9
& $<$ 1\\
pointer-based maps
& 7
& 130
& 38 (29\%)
& 12 (9\%)
& 64
& 6
& 5
& $<$ 1\\
route shift
& 8
& 99
& 50 (50\%)
& 3 (3\%)
& 64
& 9
& 6
& $<$ 1\\
binary search
& 13
& 239
& 99 (41\%)
& 42 (17\%)
& 129
& 24
& 17
& 4\\
red black trees
& 37
& 611
& 107 (17\%)
& 384 (63\%)
& 920
& 258
& 152
& 16\\
\hline
\end{tabular}
\end{center}
\caption {\label{table-examples}Overview of the examples involving recursive data structures}
\vspace{-5mm}
\end{figure}

%\subsection{Results and Discussions}
Though these examples are small, we think they demonstrate that it is possible to define recursive data structures in SPARK, and to verify iterative programs using them. When writing the algorithms, we found that the limitations mostly come from the ownership policy of SPARK. Some data structures are not supported, requiring either to switch to full Ada for their implementations, or to change the algorithm to work around the missing links. % (like we did for insertion in a red black tree).
%
% Regarding the specification of these algorithms, we were often missing a way to speak about previous values of a pointer-based data structure. Indeed, SPARK contracts are generally executable. Therefore, the \texttt{'Old} attribute used to refer to the pre state in a postcondition involves a copy. On pointer based data structures, this copy is forbidden, as it would create an alias. To alleviate this problem, we resorted in our examples to storing values of the data structure in a model (a mathematical sequence or an array for example). In particular, this is the main difference between our translation of \emph{route shift} and the original Rust example. This causes the amount of ghost code for contracts to rise because of the model definition. Another possibility would have been to define a proof-only copy function returning an alias of its parameter. This would allow to simplify the writing of the annotations, at the cost of the executability of the contracts.
%
In general, we found that the annotation effort required to describe the borrow relations, though non-negligible, was acceptable.
%For example, we see that the verification of \texttt{Set\_All\_To\_Zero} on lists requires three loop invariants instead of one for arrays. Basically, the additional properties that are maintained are the length of the list, which is expected since lists, unlike arrays, are not of fixed size, and the link between the borrower and the borrowed object. This last property is not significantly more complicated to express than the one giving the values of the processed elements.
In particular, it uses the standard SPARK expressions, with no mentions of memory separation or permission.

% As far as provability is concerned, we found that the underlying complexity of the recursive data structures was relatively well handled by the provers. The recursive definitions of specification functions were sometimes causing loss in efficiency due to unnecessary unfolding, especially when complex proofs where required, like in \emph{red black trees}. To alleviate this problem, we resorted to isolating the proofs of complex properties inside lemmas so that the definition of recursive predicates would not be pulled. On average, we found that the tool needed little additional user guidance even on rather complex properties, like on binary search, where only two additional assertions are required to prove \texttt{Insert}. The amount of user annotations necessary to prove \emph{red black trees} may look frightening, but it needs to be balanced with the inherent complexity of the algorithm. As a comparison, the proof of the pointer free version attempted previously in SPARK was 2115 lines of code with 22\% of contracts and 64\% of ghost code.

\section{Related Work}
Because in mainstream languages like C or Java the concept of pointer or reference is more central, other program verification tools generally support aliasing. They deal with it by modeling the heap. The WP plugin of Frama-C uses by default a \emph{typed memory model} where different arrays are used for the basic types of C~\cite{kirchner2015frama}. The VerCors~\cite{blom2017vercors} toolset handles high-level programming languages, such as Java, by extending the annotation language with separation logic with permission~\cite{reynolds2002separation}. In SPARK we have chosen a different approach, as we avoid modeling the heap completely by using ownership rules to enforce non-aliasing.

The ownership rules introduced in SPARK are largely inspired by the Rust language~\cite{rust}. The differences are mostly motivated by the need to comply with the preexisting Ada semantics of pointers. In addition, SPARK was aiming at coming up with a subset as easy to verify as possible. The resulting model is simpler, in particular, it does not make lifetime of borrowers explicit, and aliases created through borrows are always statically known. %Just like the ownership checking of Rust can be by-passed by using unsafe features of the language, it is possible to use full Ada to work-around SPARK restrictions. It has been done for example in containers libraries.

The Prusti verification tool for Rust~\cite{astrauskas2019leveraging} allows users to verify that a Rust program annotated with pre- and postconditions complies with its specification. From a user perspective, both tools are close. They provide similar guaranties and induce a similar annotation burden. However, they differ in their implementation. Indeed, Prusti works by translating both the user provided annotations and separation constraints enforced by the Rust type system to the intermediate verification language of the Viper tool~\cite{muller2016viper}. %Viper works on a logic close to separation logic called implicit dynamic frames~\cite{smans2009implicit}.
So even if the input Rust program does not contain annotations related to the memory model, these annotations are present in the generated Viper program, and the verification process (here symbolic execution) takes them into account. Our work differs here, as we use the ownership system to abstract away memory related concerns, so that the verification process does not need to be aware of them.

%Rust paper: https://www.research-collection.ethz.ch/bitstream/handle/20.500.11850/311092/paper.pdf?sequence=21&isAllowed=y
\section{Conclusion}
We have presented a recent extension of the SPARK language and toolset to support pointers. It is based on an ownership policy enforcing non-aliasing. To support pointer based recursive data structures, a restricted form of aliasing is introduced in SPARK through local borrowers, which can be used to iterate through a linked data structure in an imperative way. We have described how local borrowers can be supported by the verification tool without introducing a memory model by using a mutable predicate, named the borrow relation. This borrow relation can be described when necessary using special annotations named pledges, which solely consist of SPARK standard expressions, and do not expose the underlying verification technique. Our work is available in the 20.1 release of SPARK Pro and will be part of the next community release.

As for future work, we would like to extend the subset of Ada pointers supported in SPARK. In particular, we would like to introduce function pointers to model callbacks, pointers to constants with a more permissive ownership policy, and local borrowing of objects allocated on the stack.

%
% ---- Bibliography ----
%
% BibTeX users should specify bibliography style 'splncs04'.
% References will then be sorted and formatted in the correct style.
%
% \bibliographystyle{splncs04}
% \bibliography{mybibliography}
%
\begin{thebibliography}{8}
\bibitem{rust}
  The Rust Programming Language: References and Borrowing. https://doc.
rust-lang.org/1.8.0/book/references-and-borrowing.html (2019)
\bibitem{bobot2011why3}
  Bobot, F., Filli{\^a}tre, J.-C., March{\'e}, C., Paskevich, A.:Why3: Shepherd your herd of provers. (2011)
\bibitem{kirchner2015frama}
  Kirchner, F., Kosmatov, N., Prevosto, V., Signoles, J., Yakobowski, B.:Frama-C: A software analysis perspective. In: Formal Aspects of Computing, 573-609 (2015).
\bibitem{blom2017vercors}
Blom, S., Darabi, S., Huisman, M., Oortwijn., W.: The VerCors Tool Set: Verification of Parallel and Concurrent Software. In:  International Conference on Integrated Formal Methods, Vol. 10510. Springer, 102 - 110 (2017)
\bibitem{astrauskas2019leveraging}
  Astrauskas, V., M\"uller, P., Poli, F., Summers, A. J.: Leveraging rust types for modular specification and verification.
  In: Proceedings of the ACM on Programming Languages 3 (OOPSLA):147:1-147:30 (2019)
\bibitem{dross2017auto}
  Dross, C. Moy, Y.: Auto-active proof of red-black trees in SPARK.
  In: NASA Formal Methods Symposium: 68--83 (2017)
\bibitem{muller2016viper}
Müller, P., Schwerhoff, M., Summers, A. J.: Viper: A verification infrastructure for permission-based reasoning. In: International Conference on Verification, Model Checking, and Abstract Interpretation, 41-62, Springer (2016)
% \bibitem{smans2009implicit}
% Smans, J., Jacobs, B., Piessens, F.: Implicit dynamic frames: Combining dynamic frames and separation logic. In: European Conference on Object-Oriented Programming, 148-172, Springer (2009)
\bibitem{reynolds2002separation}
J. C. Reynolds: Separation logic: a logic for shared mutable data structures. In: 17h Annual IEEE
Symposium on Logic in Computer Science (2002)
\end{thebibliography}
\end{document}

\documentclass[10pt,a4paper,twocolumn]{article}
\usepackage[utf8]{inputenc}
\usepackage{url}
\usepackage{xspace}
\usepackage{hyperref}
\usepackage[usenames,dvipsnames]{color}
\usepackage{listings}
\newcommand{\CodeSymbol}[1]{\textcolor{Bittersweet}{#1}}
\lstset{
   language=Ada,
   keywordstyle=\color{RedViolet}\ttfamily\bf,
   showspaces=false,
   basicstyle=\ttfamily,
   commentstyle=\color{red}\textit,
   stringstyle=\color{MidnightBlue}\ttfamily,
   showtabs=false,
   showstringspaces=false,
   morekeywords=[1]Pre,
   morekeywords=[2]Post,
   morekeywords=[3]Test\_Case,
   morekeywords=[4]Contract\_Cases,
   literate={(}{{\CodeSymbol{(}}}1
            {)}{{\CodeSymbol{)}}}1
            {>}{{\CodeSymbol{$>$}}}1
            {<}{{\CodeSymbol{$<$}}}1
            {=}{{\CodeSymbol{$=$}}}1
            {:}{{\CodeSymbol{$:$}}}1
            {.}{{\CodeSymbol{$.$}}}1
            {;}{{\CodeSymbol{$;$}}}1
}

\newcommand{\DO}{\textsc{do-178}\xspace}
\newcommand{\DOB}{\textsc{do-178b}\xspace}
\newcommand{\DOC}{\textsc{do-178c}\xspace}
\newcommand{\hilite}{Hi-Lite\xspace}
\newcommand{\gnatprove}{GNATprove\xspace}
\newcommand{\oldspark}{SPARK~2005\xspace}
\newcommand{\newspark}{SPARK~2014\xspace}
\newcommand{\spark}{SPARK\xspace}
\newcommand{\ada}{Ada\xspace}
\newcommand{\adatwtw}{Ada~2012\xspace}
\newcommand{\altergo}{Alt-Ergo\xspace}

\newcommand{\etc}{\textit{etc.}\xspace}
\newcommand{\ie}{\textit{i.e.,}\xspace}
\newcommand{\adhoc}{\textit{ad hoc}\xspace}
\newcommand{\Eg}{\textit{E.g.,}\xspace}
\newcommand{\eg}{\textit{e.g.,}\xspace}
\newcommand{\etal}{\textit{et al.}\xspace}
\newcommand{\wrt}{w.r.t.\xspace}
\newcommand{\aka}{a.k.a.\xspace}
\newcommand{\resp}{resp.\xspace}

\lstset{basicstyle={\scriptsize \sffamily}}
\newcommand{\SPARK}[1]{\lstinline[language=Ada,basicstyle={\footnotesize
      \sffamily},framesep=0pt]$#1$}

\begin{document}

\title{Rail, Space, Security: Three Case Studies for SPARK 2014}

\author{%
\large Claire Dross$^4$, Pavlos Efstathopoulos$^1$, David Lesens$^2$, David Mentré$^3$ and Yannick Moy$^4$\\
\normalsize 1: Altran Praxis, 20 Manvers Street, Bath BA1 1PX (United Kingdom),\\
\normalsize 2: Astrium Space Transportation, 51-61 route de Verneuil F-78130 Les Mureaux (France),\\
\normalsize 3: Mitsubishi Electric R\&D Centre Europe, 1 allée de
Beaulieu, CS 10806, F-35708 Rennes (France),\\
\normalsize 4: AdaCore, 46 rue d'Amsterdam, F-75009 Paris (France)}

\date{}

\maketitle

\paragraph{Abstract}
SPARK is a subset of the Ada programming language targeted at safety and
security critical applications. \newspark is a major evolution of the SPARK
language and toolset, that integrates formal program verification in the
existing development and verification processes, in order to decrease the cost
of verification for software submitted to certification constraints. We present
industrial case studies in three different certification domains that show the
benefits of using formal verification with \newspark.

\paragraph{Keywords}
System formal development, Verification and validation,
Certification and dependability

\section{Introduction}

\newspark is a major evolution of the SPARK language and toolset with two main objectives for improving the take-up of formal verification technology:
%
\begin{enumerate}
\item lowering the hurdle for non-expert users, and
\item improving the cost-benefit argument.
\end{enumerate}

In this paper, we describe how \newspark achieves these objectives, based on
practical use of the language and associated formal verification tool
\gnatprove on three industrial case studies developed in the context of the
\hilite project.

\section{SPARK 2014}

%%\subsection{SPARK: Past and Present}

SPARK is a programming language subset targeted at safety and security critical
applications. It is a subset of the Ada programming language, thus building on
the strengths of Ada for creating highly reliable and long-lived
software. SPARK restrictions ensure that the behavior of a SPARK program is
unambiguously defined, and simple enough that formal verification tools can
perform an automatic diagnostic of conformance between a program specification
and its implementation. The SPARK language and toolset for static verification
has been applied for many years in on-board aircraft systems, control systems,
cryptographic systems, and rail systems~\cite{sparkbook2012,oneill2012}.

SPARK evolution has followed the evolutions of Ada, with a new version of SPARK
for each new version of Ada: SPARK 83, SPARK 95, SPARK 2005, and now SPARK
2014. Up to the version \oldspark, the specification of the intended behavior
of a program was written in special comments, that were ignored by the usual
development tools (compiler, debugger), but interpreted by the formal
verification tools. The new version \newspark builds on the new specification
features added in \adatwtw, so formal specifications are now understood by the
usual development tools and can be executed.

\subsection{Key Features for Formal Verification}

\adatwtw introduced new language features for facilitating the specification of
programs~\cite{ada2012rationale}, many of which were inspired from the
corresponding features in \oldspark. The most useful of these new features is
without doubts the preconditions and postconditions (which together are
referred to as a contract) popularised by the Design-by-Contract
approach~\cite{meyer:1988:OSC}.
%% \newspark is based on the features of \adatwtw,
%% to which it adds new ones, some of which inspired from \oldspark.
We will
describe shortly in this subsection the key features defined in \newspark for
formal verification.

FIXME: introduce \gnatprove and \altergo.

\subsection{Benefits of Executable Contracts}

Traditionally, contracts have been interpreted quite differently depending on
whether used for formal program verification or for run-time assertion
checking. For formal program verification, assertions have typically been
interpreted as formulae in classical first-order logic. This was the situation
with SPARK until version \oldspark. Practitioners have struggled with this
interpretation, which was not consistent with the run-time assertion checking
semantics.\cite{tseChalin10}

\newspark reconciles the logic semantics and executable semantics of contracts,
so users can now execute contracts, debug them like code, and test them when
formal verification is too difficult to achieve. Furthermore, there is an
advantage in keeping the annotation language the same as the programming
language: users don't have to learn one more language.

\subsection{Integrating Testing and Formal Verification}

\ifdefined\abstractonly

We will present how \newspark supports a combination of formal verification and
testing~\cite{hiliteERTS2012}.

\else
Formal methods are complementary to testing, and may find faults that
are not detected by testing, but they cannot establish verification
evidence for the target hardware. Therefore testing on the target is
still required. However, formal analysis of source code can be used to
show compliance with the low-level requirements. \DOC requires an
argument for property preservation between the source code and the
object code for those properties that have been verified formally at
the source level. Since formal program verification and testing are
complementary, we would like to use each method where it is most
efficient. For this we need to make sure that the combination is at
least as strong as testing alone.
\fi

\section{Train Control Systems}

% openETCS case study

The openETCS\footnote{\url{http://openetcs.org/}} European project
aims at making an open-sourced, open-proofs reference model of ETCS
(European Train Control System). ETCS is a radio-based train control
system aiming at unifying train signaling and control over all
European countries. Organized in several levels, ETCS can range from,
at Level 0, a simple ATP (Automatic Train Protection) system
monitoring train speed to, at Level 3, a fully featured radio-based
train control system where trains inform a Radio Block Centre about
their location and receive Movement Authorities, using cab signaling
instead of track-side signaling.

We made some experiments with \newspark to see if one could formalize
the ETCS System Requirement Specification (SRS, ERA UNISIG
SUBSET-026).

We should acknowledge that using \newspark for formalizing
\emph{system} requirements (and not only software requirements) is a
bit excessive and out of scope for the language. We made nonetheless
this formalization attempt for two reasons. Firstly we wanted to give
a formal semantics to this system specification and \newspark
first-order logic used for contract annotation should be suitable for
this task. This formalization would allow us to formally verify some
properties at the specification level.  Secondly, the ETCS'
specifications are quite low-level in some of its content, therefore
not as far from software requirements as one would have expected.

\subsection{Description of the Software}

We made several experiments but due to space constraints we will only
detail two of them.

Our first example is partial modeling of SRS mode transition table
(SRS §4.6). It is a big table that describes, for each of the 17
modes, under which conditions the ETCS on-board can change from one
mode to another one. Those conditions are specific state of the
on-board, actions of the driver and an explicit priority. For example,
transition from mode Stand By (SB) mode to Full Supervision (FS) mode
is conditioned by fulfilling condition 10, at priority 7. Condition 10
states that ``(valid Train Data is stored on board) AND (MA + SSP +
gradient on-board) AND (no specific mode is required by a Mode
Profile)''.

We have converted above conditions into \newspark Boolean variables,
with an explicit priority variable. Above condition thus becomes:
\begin{lstlisting}
type priority_t is range 1..7;
priority : priority_t;

valid_train_data_is_stored_on_board : Boolean;
[...]

function condition_10 return Boolean is
  (valid_train_data_is_stored_on_board
   AND ma_ssp_gardient_on_board
   AND no_specific_mode_required_by_a_mode_profile);
[...]

function condition_transition_SB_to_FS
  return Boolean is
  (condition_10 AND priority = 7);
[...]
\end{lstlisting}

We can thus model all possible transitions of the transition table.

Our second example is the coding of step functions, \aka functions
constant by interval, used in ``Speed and distance monitoring''
section (SRS §3.13). Such functions are used to model for example
speed restrictions along distance. One of our main goal is to model
the merge of two speed restrictions, taking at each point the most
restrictive (\ie smaller) one.

To encode step functions, we used the following data structure:
\begin{lstlisting}
package Step_Function is pragma SPARK_Mode (On);
   type Num_Delimiters_Range is range 0 .. 10;

   type Function_Range is new Natural;

   type Delimiter_Entry is record
      Delimiter : Function_Range;
      Value : Float;
   end record;

   type Delimiter_Values is array
     (Num_Delimiters_Range) of Delimiter_Entry;

   type Step_Function_t is record
      Num_Delim : Num_Delimiters_Range;
      Step : Delimiter_Values;
   end record;
[...]
\end{lstlisting}

A step function can have up to 11 steps separated by 10 ``delimiters''
stored in \SPARK{Step_Function_t.Step} array. Each delimiter of type
\SPARK{Delimiter_Entry} contains the delimiter position
(\SPARK{Delimiter} field) and the associated function constant value
(\SPARK{Value} field). \SPARK{Num_Delim} stores the number
of delimiters currently used for this step function.

On this data structure, we build several functions like
\SPARK{Get_Value(SFun : Step_Function_t; X: Function_Range)}
\SPARK{return Float} that returns the value of step function
\SPARK{SFun} at point \SPARK{X} or \SPARK{Minimum_Until_Point(SFun :
  Step_Function_t;} \SPARK{X: Function_Range)} \SPARK{return Float}
that returns the minimum of the step function \SPARK{SFun} until point
\SPARK{X}. But probably the most interesting function is function
\SPARK{Restrictive_Merge} whose contract is given in the following
section.

\subsection{Formalization of Properties}

Regarding mode transition table, we wanted to check requirement
§4.6.1.5 of SRS that states that all transitions are exclusive, even
at the same priority. We thus used the \SPARK{Contract_Cases} of
\newspark to check that all conditions are indeed disjoint. In
practice, we wrote the following function specification:

\begin{lstlisting}
function transition(mode : etcs_mode_t)
  return etcs_mode_t
with Contract_Cases =>
    (condition_transition_SB_to_SH => True,
     condition_transition_SB_to_FS => True,
     condition_transition_SB_to_IS => True);
\end{lstlisting}

\gnatprove tool generates the Verification Conditions that must be
checked.

Regarding the step functions, we wrote a formal \emph{functional}
specification for all functions. For example procedure
\SPARK{Restrictive_Merge} has following contract:

\begin{lstlisting}
procedure
 Restrictive_Merge(SFun1, SFun2 : in Step_Function_t;
                   Merge : out Step_Function_t)
with Pre => Is_Valid(SFun1) and Is_Valid(SFun2)
  and
 SFun1.Num_Delim + SFun2.Num_Delim <=
    Num_Delimiters_Range'Last,
Post =>
-- (1) Output is valid step function
Is_Valid(Merge)
-- (2) All SFun1 delimiters are valid in Merge
and
 (for all i in
       Num_Delimiters_Range'First..SFun1.Num_Delim =>
   (for some j in
     Num_Delimiters_Range'First..Merge.Num_Delim =>
      (Merge.Step(j).Delimiter = SFun1.Step(i).Delimiter)))
-- (3) All SFun2 delimiters are valid in Merge
and
 (for all i in
      Num_Delimiters_Range'First..SFun2.Num_Delim =>
   (for some j in
     Num_Delimiters_Range'First..Merge.Num_Delim =>
      (Merge.Step(j).Delimiter = SFun2.Step(i).Delimiter)))
-- (4) For all delimiters of Merge, its value is the
-- minimum of SFun1 and SFun2
and
 (for all i in
     Num_Delimiters_Range'First..Merge.Num_Delim =>
   (Merge.Step(i).Value
    = Min(Get_Value(SFun1, Merge.Step(i).Delimiter),
          Get_Value(SFun2, Merge.Step(i).Delimiter))));
\end{lstlisting}

This contract formally states that, given two valid (\ie with strictly
increasing delimiters) step functions \SPARK{SFun1} and \SPARK{SFun2}
without too many delimiters, the resulting step function is a valid
one (1), it contains all the delimiters of \SPARK{SFun1} (2) and
\SPARK{SFun2} (3) and for each of those delimiters, the value of the
step function is the minimum of both initial step functions (4).


\subsection{Formal Verification Results}

The first goal of this experiment was to check if \newspark was
expressive enough to describe the objects of the requirements:
requirement text, transition tables, breaking curve equations, \etc
Overall, we were quite satisfied to be able express most of the
requirements in a formal way. The very expressive data structure of
\newspark (type definition, records, arrays, enumerations, ...) were
very helpful and we found it leads to quite readable specifications.

The second goal was to evaluate the proving capabilities of \newspark
on some parts of the specification.

Regarding mode transition table, we were not able to prove the shown
contract of function \SPARK{transition}... because the contract cannot
be proved! In fact, this experiment shown that the transitions given
in the specification table lack details to determine if the transition
are exclusive or not. Those details are given in other parts of the
specification and it would be a major work to formalize it.

Regarding the step functions, we were able to prove all function
contracts except \SPARK{Restrictive_Merge}. In this procedure, the
post-condition and a main loop invariant could not be automatically
proved by \altergo. The main reason is that the proof context is too
big and \altergo gets lost in all possible quantification
instantiations. We have checked that some parts of the loop invariant
could be automatically proved if the proof context was manually pruned
of irrelevant hypotheses.

\subsection{Lessons Learned}

As said previously, we were rather pleased by the expression
capabilities of \newspark, making specification and code writing
rather easy and, more important, clearer for the reader. The ability
to define new data types for specific ranges and incompatible with
other types is crucial in this regard.

Another important finding is that the code should be written with
proof in mind. For example, in one of the step function procedure, we
wrote a loop with an early exit. However \altergo is unable to prove
this loop because it lacks induction reasoning, even if all elements
of the induction could be easily pointed out to the prover. We had to
change the code with a loop without early exit, the proof then
becoming trivial.

A third finding is that contracts that can be automatically proved are
not the most natural contracts, \ie contracts a reviewer would
understand more easily. For example, for \SPARK{Restrictive_Merge}
procedure, we would have prefer to write that the resulting function
is the minimum of both input functions for all possible input
values. It would have been impossible to prove this contract. Other
formal approaches with formal refinement like B~Method would probably
be able to formalize such contract, at the expense of manual proofs.

Our last finding, not entirely surprising, is that writing the correct
invariant for a complex loop is not an easy task, as we experimented
it for \SPARK{Restrictive_Merge} procedure. It can necessitate several
hours of work of skilled people, trained in the proof environment and
the reaction of the automatic prover. In such case, the ability to
compile and test the loop invariant is very useful to help ``debug''
the invariant.

Overall, we think that the programmer should be trained to exploit the
feedback provided by the proof environment, much like a programmer
exploits feedback of debuggers and tests to debug his/her program.
Moreover, as complete code proof can become very costly, a proof
methodology must be defined to avoid spending to much time on proofs
that would be broken afterward due to other code changes.

\section{Flight Control and Vehicle Management in Space}

% Astrium case study


\subsection{Description of the Software}

A typical space applicative flight program is made up of two parts:
\ifdefined\abstractonly
Flight control or more generally numerical control / command algorithm, and Mission and Vehicle Management.

\else

\begin{itemize}
\item Flight control or more generally numerical control / command algorithm
\item Mission and Vehicle Management
\end{itemize}
\fi

\subsubsection{Numerical control / command algorithms}

\ifdefined\abstractonly
\else
Numerical control / command algorithms take as inputs floating point values, perform some numerical computations (with the classical basic mathematical operators such as additions, subtractions, multiplications, divisions, absolute values, trigonometry or operations on vectors and arrays, \etc) and return floating point results. Such algorithms have generally a retroaction loop, \ie internal states.

It is generally not possible to define interesting functional contracts for such code. Indeed, the functional contract of the equation:

\begin{verbatim}
   X := A * Y + Cos(Z)
\end{verbatim}

\noindent
is just itself (\ie it is not possible to specify in a more abstract way this equation). Then, instead of defining functional contracts, the objective on this kind of software is the proof of absence of run-time errors (such as division by zero) and the correctness of variable ranges (such as, for instance, a velocity shall always be between 0 and 25 km/s).
\fi

\newspark has been first experimented on a solar wing management software (for a spacecraft such as the ATV / Automated Transfer Vehicle).
This piece of code uses a mathematical library which implementation is not in \newspark, implying that it could not be formally proved, but only tested. However, the interface of this mathematical library is in \newspark. The contracts defined on the mathematical library can then be used to prove the application code.

\ifdefined\abstractonly
\else
\paragraph{Example of contract in the mathematical library:}

\begin{verbatim}
   function Sin32 (X : T_Float32) return T_Float32
   with
     Pre => ( X >= - C_2Pi32 ) and then
     ( X <= C_2Pi32 ),
     Post => ( Sin32'Result >= -1.0 ) and then
     ( Sin32'Result <= 1.0);
\end{verbatim}
\fi

\subsubsection{Mission and Vehicle Management}

The Mission and Vehicle Management of a spacecraft is described by an ECSS (European Cooperation for Space Standardization) standard:

\begin{center}
{\bf ECSS-E-ST-70-01C Space engineering - Spacecraft on-board control procedures}
\end{center}

This standard defines the general principles of a On Board Control Procedure (OBCP). An OBCP is in practice represented by a simplified programming language interpreted onboard the spacecraft. This interpreter is generally at the highest level of criticality of the spacecraft. The implementation of this interpreter in \newspark is table driven and relies greatly
\ifdefined\abstractonly
on: generic packages and discriminants.
\else
on:
\begin{itemize}
\item Generic packages

	The generic packages allow an easy customization of the code:

	\begin{verbatim}
     generic
        -- the list of events
        type T_Event_Id is (<>);

     package Mvm.Events is
	\end{verbatim}

\item Discriminant

	The discriminants ensures a string typing of the code, even in case of heterogeneous communication between components of the system:

	\begin{verbatim}
   type T_Monitoring is (No_Window, Window);

   type T_Event_Status (Monitoring : T_Monitoring := No_Window)
   is record
         case Monitoring is
         when No_Window => null;
         when Window =>
            Start_Window : T_Float32;
            End_Window : T_Float32;
         end case;
      end record;
	\end{verbatim}
\end{itemize}
\fi

\subsection{Formalization of Properties}

The contracts defined on algorithmic code are mainly related to the ranges of variables.

\ifdefined\abstractonly
\else
\paragraph{Example of contract in algorithmic code:}

\begin{verbatim}
   subtype T_Angle_180 is T_Float32 range -180 .. 180;

   function Normalise (X : in T_Float32) return T_Angle_180
   with Pre =>
     ( X >= -720.0 ) and
        ( X <= 720.0 );
\end{verbatim}
\fi

The contracts defined on mission and vehicle management code code have (among others) the following objectives:

\begin{itemize}
\item Ensuring the permanent consistency of the software tables
\item Ensuring the permanent consistency between the Mission and Vehicle Management function and the other functionalities (such as, for instance, the solar wing management)
\item Ensuring the respect of some functional properties such as the mutual exclusion of execution of some automated procedures
\item Ensuring the absence of run-time errors
\end{itemize}

\ifdefined\abstractonly
\else
\paragraph{Example of contract in mission and vehicle management code:}

\begin{verbatim}
   procedure Reset_Event (Event_Id :        T_Event_Id;
                          Events   : in out T_Events)
   with
     Post =>
        Get_Status (Event_Id, Events) = Inactive) and then
          (for all Other_Event_Id in T_Event_Id =>
             (if Other_Event_Id /= Event_Id then
              Get_Status (Other_Event_Id, Events) =
                Get_Status (Other_Event_Id, Events'Old))));
\end{verbatim}
\fi

\subsection{Formal Verification Results}

All the contracts have been checked by dynamic testing. This phase is quite classical, except for the fact that the testing includes the preconditions and the postconditions defined in the software. Then, \gnatprove has been applied.

\ifdefined\abstractonly
\else
\subsubsection{Subprograms not in \newspark}

The origins of subprograms not yet in \newspark are mainly the following:

\begin{itemize}
\item unchecked conversion

The unchecked conversion are used in a library allowing reading external inputs.
All the concerned subprograms are very small and shall be validated by intensive testin because there are out of the perimeter of HiLite and of \newspark.
\item tagged type

Tagged type are related to Object Oriented Programming. The analysis of Object Oriented software is foreseen but has not yet been implemented.
\item access

Accesses are used in the software to store objects in a table.
This kind of design can not be proved by \gnatprove.
\end{itemize}

\subsubsection{Analysis of the non proved VCs}

Some algorithmic functions are not completely known by \gnatprove.

\paragraph{Example:}

\begin{verbatim}
   function Arctan (X : T_Float32) return T_Float32
   with
     Post => (Arctan'Result >= -C_Halfpi32) and then
     (Arctan'Result <= C_Halfpi32);

   function Arctan (X : T_Float32) return T_Float32
   is (Num32.Arctan (X));
\end{verbatim}

The postcondition is not proved by \gnatprove.
The exact behaviour of algorithmic functions depending of the implementation, this behaviour is acceptable.
Algorithmic functions and their contracts are preferably validated by intensive testing.

\gnatprove has some difficulties to take into account rounding.
In the following example, the second assertion is not proved.

\paragraph{Example:}

\begin{verbatim}
   function Round_Closest (X : T_Float32) return T_Float32
   is (T_Float32'Rounding (X));

   pragma Assert(( Y >= -11160.002 ) and (Y <= 11160.002 ));
   Round_Y := Ml.Round_Closest (Y);
   pragma Assert(( Round_Y >= -11160.0 ) and (Round_Y <= 11160.0 ));
\end{verbatim}

\gnatprove currently does not prove non linear equation.
In the following example, the last assertion is not proved.

\paragraph{Example:}

\begin{verbatim}
   pragma Assert(X >= 0.0 and the x <= 180.0);
   pragma Assert(Y >= -180.0 and then Y <= 0.0);
   pragma Assert(Z >= 0.0 and then Z <= 1.0);
   pragma Assert(X + Y >= 0.0);
   Result := X + Y * Z;
   pragma Assert (Result >= 0.0 and then Result <= 360.0);
\end{verbatim}

\gnatprove is not yet able to verify the index of an array which dimension is defined by a type descriminant

\paragraph{Example:}

\begin{verbatim}
   subtype R is Integer range 1 .. 100;
   type T_Array is array (R range <>) of Boolean;

   type T_Record (L : R) is
      record
         A : T_Array (1 .. L);
      end record;

   function G (X : T_Record) return Boolean is
     (for all I in X.A'Range => X.A (I));
\end{verbatim}

In function "G", the index check "X.A (I)" is not proved even if "I" is defined in the range of "X.A"
An improvement of \gnatprove is in progress in order to deal with such case.

The remaining non proved VCs are due to too complex subprograms.
These subprograms shall be split in several smaller subprograms to be proved.
\fi

\subsection{Lessons Learned}

\ifdefined\abstractonly
We will present how \newspark fulfilled the initial objectives that we set:
capability to formalize the test cases, verification that all test procedures
cover all the test cases, support to the verification / validation of the
absence of run-time errors, support to the verification / validation of
functional properties, verification of the correctness of the access of all
global variables, verification of the absence of out of range values, internal
consistency of software unit, capability to assess the commandability and
observability, help proving that numerical protection mechanisms are correctly
implemented, prove the correctness of a generic code in a specific context.

\else
Our initial objectives were that \newspark should fulfill the following requirements:

\begin{itemize}
\item Capability to formalize the test cases

Current assessment: Very good
\item Verification that all test procedures cover all the test cases

Current assessment: Not implemented. This implies that the formalization of the test cases is today not really interesting
\item Support to the verification / validation of the absence of run-time errors

Current assessment: Very good
\item Support to the verification / validation of functional properties

Current assessment: Good. In order to be efficient, it requires some works (definition of contracts, definition of assertions, spliting of complex subprograms in smaller ones)
\item Verification of the correctness of the access of all global variables

Current assessment: Not yet implemented
\item Verification of the absence of out of range values

Current assessment: Very good. As for functional properties, it requires some manual works
\item Internal consistency of software unit. The HiLite tools shall help ensuring that each aggregate satisfies the requirements of the software item. In other words, each caller of a subprogram shall ensures that the pre-conditions of the callee are respected and that the post-condition of the callee is compatible with the caller

Current assessment: Very good
\item Capability to assess the commandability and observability. In other words, the HiLite tools shall help detecting dead code

Current assessment: No
\item Help proving that numerical protection mechanisms are correctly implemented

Current assessment: Very good
\item Prove the correctness of a generic code in a specific context

Current assessment: Very good
\end{itemize}
\fi

\section{Biometric Access to a Secure Enclave}

% Tokeneer case study

\subsection{Description of the Software}

Tokeneer is a highly secure biometric software system that was originally
developed by Altran in \oldspark. The system provides protection to secure
information held on a network of workstations situated in a physically
secure enclave. The Tokeneer project was commissioned by the US National
Security Agency (NSA) to demonstrate the feasibility of developing systems
to the level of rigour required by the higher assurance levels of the
Common Criteria. The original development artefacts, including all source code,
are publicly available. For more details see
\url{www.adacore.com/sparkpro/tokeneer}.

During this study, the source code for Tokeneer has been translated into \newspark.
The core system now consists of approximately \emph{10,000} lines of \newspark code
(declarations and executable lines, excluding blank lines, comments and
SPARK annotations). There are also approximately 3,700 lines of supporting
code written in Ada which mimicked the drivers to peripherals connected
to the core system.


\subsection{Formalization of Properties}

The contracts defined in the Tokeneer source code consist of information flow contracts (expressed as Depends aspects) and functional behavioral contracts (expressed as Pre and Post aspects).

The verification objectives supported by these contracts are as follows:

%\begin{itemize}
 Detecting improper initialization;
 Identifying innefective assignments;
 Showing the code is free from any run time exceptions, such as buffer overflow or divide-by-zero;
 Ensuring secure infomration flow;
 Proving that key security properties are guaranteed by the implementation.
%\end{itemize}

%%\emph{Examples of the various types of contract will be added here.}

\subsection{Formal Verification Results}

The source code of Tokeneer was proven to be free of runtime exceptions
and some key security properties were proven to hold but full functional
proof was not performed on the entirety of the code. This study will
focus on proving the biggest possible subset of the aforementioned
attributes using the \newspark toolset.

\subsection{Lessons Learned}

Some additional aims of this study are the following:
   Evaluate how easy is it to convert programs from \oldspark to \newspark;
   Investigate how executable semantics affect the way code has to be written
        and what advantages/disadvantages they introduce;
   Discover the percentage of the code that can be automatically proven;
        and the combination of options/provers that achieve the best results
        for this specific test case;
   Provide feedback and suggest features or changes that could improve future versions of the \newspark toolset.

\section{Common Findings and Dissimilarities}

We will discuss the common findings between the three case studies, denoting
instrinsic properties of \newspark, and the dissimilarities, which may be
explained by differences in domains, backgrounds, processes, \etc

\section{Conclusion}

We will summarize the three case studies, and present the planned future
evolutions of \newspark.

\bibliographystyle{plain}
\bibliography{erts_2014}

\end{document}


% LocalWords:  openETCS ETCS UNISIG Centre SRS

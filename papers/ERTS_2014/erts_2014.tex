\documentclass[10pt,a4paper,twocolumn]{article}
\usepackage[utf8]{inputenc}
\usepackage{url}
\usepackage{xspace}
\usepackage{hyperref}

\newcommand{\DO}{\textsc{do-178}\xspace}
\newcommand{\DOB}{\textsc{do-178b}\xspace}
\newcommand{\DOC}{\textsc{do-178c}\xspace}
\newcommand{\hilite}{Hi-Lite\xspace}
\newcommand{\gnatprove}{GNATprove\xspace}
\newcommand{\oldspark}{SPARK~2005\xspace}
\newcommand{\newspark}{SPARK~2014\xspace}
\newcommand{\spark}{SPARK\xspace}
\newcommand{\ada}{Ada\xspace}
\newcommand{\adatwtw}{Ada~2012\xspace}

\newcommand{\etc}{\textit{etc.}\xspace}
\newcommand{\ie}{\textit{i.e.,}\xspace}
\newcommand{\adhoc}{\textit{ad hoc}\xspace}
\newcommand{\Eg}{\textit{E.g.,}\xspace}
\newcommand{\eg}{\textit{e.g.,}\xspace}
\newcommand{\etal}{\textit{et al.}\xspace}
\newcommand{\wrt}{w.r.t.\xspace}
\newcommand{\aka}{a.k.a.\xspace}
\newcommand{\resp}{resp.\xspace}

\begin{document}

\title{Rail, Space, Security: Three Case Studies for SPARK 2014}

\author{%
\large Pavlos Efstathopoulos$^1$, David Lesens$^2$, David Mentr√©$^3$ and Yannick Moy$^4$\\
\normalsize 1: Altran Praxis, 20 Manvers Street, Bath BA1 1PX (United Kingdom),\\
\normalsize 2: Astrium Space Transportation, 51-61 route de Verneuil F-78130 Les Mureaux (France),\\
\normalsize 3: Mitsubishi Electric R\&D Centre Europe, F-35708 Rennes (France),\\
\normalsize 4: AdaCore, 46 rue d'Amsterdam, F-75009 Paris (France)}

\date{}

\maketitle

\paragraph{Abstract}
SPARK is a subset of the Ada programming language targeted at safety and
security critical applications. \newspark is a major evolution of the SPARK
language and toolset, that integrates formal program verification in the
existing development and verification processes, in order to decrease the cost
of verification for software submitted to certification constraints. We present
industrial case studies in three different certification domains that show the
benefits of using formal verification with \newspark.

\paragraph{Keywords}
System formal development, Verification and validation,
Certification and dependability

\section{Introduction}

\newspark is a major evolution of the SPARK language and toolset to address two
main hurdles previously identified in the take-up of formal verification
technology:
%
\begin{enumerate}
\item difficulty to reach non-expert users, and
\item lack of convincing cost-benefit argument.
\end{enumerate}

In this paper, we describe how \newspark addresses these issues, based on
practical use of the language and associated formal verification tool
\gnatprove on three industrial case studies developed in the context of the
\hilite project.

\section{SPARK 2014}

\subsection{SPARK: Past and Present}

SPARK is a programming language subset targeted at safety and security critical
applications. It is a subset of the Ada programming language, thus building on
the strengths of Ada for creating highly reliable and long-lived
software. SPARK restrictions ensure that the behavior of a SPARK program is
unambiguously defined, and simple enough that formal verification tools can
perform an automatic diagnostic of conformance between a program specification
and its implementation. The SPARK language and toolset for static verification
has been applied for many years in on-board aircraft systems, control systems,
cryptographic systems, and rail systems~\cite{sparkbook2012,oneill2012}.

SPARK evolution has followed the evolutions of Ada, with a new version of SPARK
for each new version of Ada: SPARK 83, SPARK 95, SPARK 2005, and now SPARK
2014. Up to the version \oldspark, the specification of the intended behavior
of a program was written in special comments, that were ignored by the usual
development tools (compiler, debugger), but interpreted by the formal
verification tools. The new version \newspark builds on the new specification
features added in \adatwtw, so formal specifications are now understood by the
usual development tools and can be executed.

\subsection{Key Features for Formal Verification}

\adatwtw introduced new language features for facilitating the specification of
programs~\cite{ada2012rationale}, many of which were inspired from the
corresponding features in \oldspark. The most useful of these new features is
without doubts the preconditions and postconditions (which together are
referred to as a contract) popularised by the Design-by-Contract
approach~\cite{meyer:1988:OSC}.
%% \newspark is based on the features of \adatwtw,
%% to which it adds new ones, some of which inspired from \oldspark.
We will
describe shortly in this subsection the key features defined in \newspark for
formal verification.

\subsection{Benefits of Executable Contracts}

Traditionally, contracts have been interpreted quite differently depending on
whether used for formal program verification or for run-time assertion
checking. For formal program verification, assertions have typically been
interpreted as formulae in classical first-order logic. This was the situation
with SPARK until version \oldspark. Practitioners have struggled with this
interpretation, which was not consistent with the run-time assertion checking
semantics.\cite{tseChalin10}

\newspark reconciles the logic semantics and executable semantics of contracts,
so users can now execute contracts, debug them like code, and test them when
formal verification is too difficult to achieve. Furthermore, there is an
advantage in keeping the annotation language the same as the programming
language: users don't have to learn one more language.

\subsection{Integrating Testing and Formal Verification}

\ifdefined\abstractonly

We will present how \newspark supports a combination of formal verification and
testing~\cite{hiliteERTS2012}.

\else
Formal methods are complementary to testing, and may find faults that
are not detected by testing, but they cannot establish verification
evidence for the target hardware. Therefore testing on the target is
still required. However, formal analysis of source code can be used to
show compliance with the low-level requirements. \DOC requires an
argument for property preservation between the source code and the
object code for those properties that have been verified formally at
the source level. Since formal program verification and testing are
complementary, we would like to use each method where it is most
efficient. For this we need to make sure that the combination is at
least as strong as testing alone.
\fi

\section{Train Control Systems}

% openETCS case study

The openETCS\footnote{\url{http://openetcs.org/}} European project
aims at making an open-sourced, open-proofs reference model of ETCS
(European Train Control System). ETCS is a radio-based train control
system aiming at unifying train signaling and control over all
European countries. Organized in several levels, ETCS can range from,
at Level 0, a simple ATP (Automatic Train Protection) system
monitoring train speed to, at Level 3, a fully featured radio-based
train control system where trains inform a Radio Block Centre about
their location and receive Movement Authorities, using cab signaling
instead of track-side signaling.

\subsection{Description of the Software}

We will describe the establishment of communication, the mode transition table
and the step functions.

\subsection{Formalization of Properties}

We made some experiments with \newspark to see if one could formalize the
System Requirement Specification (ERA UNISIG SUBSET-026).

We should acknowledge that using \newspark for formalizing \emph{system
  requirements} (and not only software requirements) is a bit excessive and out
of scope for the language. We made nonetheless this formalization for two
reasons. Firstly we wanted to give a formal semantics to this system
specification and \newspark first-order logic used for contract annotation
should be suitable for this task. This formalization would allow us to formally
verify some properties at the specification level.  Secondly, the ETCS'
specifications are quite low-level in some of its content, therefore not as far
from software requirements as one would have expected.

We will present SRS excerpts and corresponding \newspark contracts.

\subsection{Formal Verification Results}

Our main results is that it is possible to express most of the requirements,
which can then be checked during testing. We will probably present partial
proof of results, due to the time needed to achieve full proof.

\subsection{Lessons Learned}

The first goal of this experiment was to check if \newspark was expressive
enough to describe the objects of the requirements: requirement text,
transition tables, breaking curve equations, \etc The second goal was to
evaluate the proving capabilities of \newspark on some parts of the
specification.

Our findings are the following. Support for rich types in \newspark is useful
for clarity of contracts and helps with automatic proofs. The code needs to be
designed with proof in mind (\eg avoid early exit). Verifiable contracts are
not always the most natural contracts. It is essential to use feedback from the
tool and to define a proof methodology.

\section{Flight Control and Vehicle Management in Space}

% Astrium case study


\subsection{Description of the Software}

A typical space applicative flight program is made up of two parts:
\ifdefined\abstractonly
Flight control or more generally numerical control / command algorithm, and Mission and Vehicle Management.

\else

\begin{itemize}
\item Flight control or more generally numerical control / command algorithm
\item Mission and Vehicle Management
\end{itemize}
\fi

\subsubsection{Numerical control / command algorithms}

\ifdefined\abstractonly
\else
Numerical control / command algorithms take as inputs floating point values, perform some numerical computations (with the classical basic mathematical operators such as additions, subtractions, multiplications, divisions, absolute values, trigonometry or operations on vectors and arrays, \etc) and return floating point results. Such algorithms have generally a retroaction loop, \ie internal states.

It is generally not possible to define interesting functional contracts for such code. Indeed, the functional contract of the equation:

\begin{verbatim}
   X := A * Y + Cos(Z)
\end{verbatim}

\noindent
is just itself (\ie it is not possible to specify in a more abstract way this equation). Then, instead of defining functional contracts, the objective on this kind of software is the proof of absence of run-time errors (such as division by zero) and the correctness of variable ranges (such as, for instance, a velocity shall always be between 0 and 25 km/s).
\fi

\newspark has been first experimented on a solar wing management software (for a spacecraft such as the ATV / Automated Transfer Vehicle).
This piece of code uses a mathematical library which implementation is not in \newspark, implying that it could not be formally proved, but only tested. However, the interface of this mathematical library is in \newspark. The contracts defined on the mathematical library can then be used to prove the application code.

\ifdefined\abstractonly
\else
\paragraph{Example of contract in the mathematical library:}

\begin{verbatim}
   function Sin32 (X : T_Float32) return T_Float32
   with
     Pre => ( X >= - C_2Pi32 ) and then
     ( X <= C_2Pi32 ),
     Post => ( Sin32'Result >= -1.0 ) and then
     ( Sin32'Result <= 1.0);
\end{verbatim}
\fi

\subsubsection{Mission and Vehicle Management}

The Mission and Vehicle Management of a spacecraft is described by an ECSS (European Cooperation for Space Standardization) standard:

\begin{center}
{\bf ECSS-E-ST-70-01C Space engineering - Spacecraft on-board control procedures}
\end{center}

This standard defines the general principles of a On Board Control Procedure (OBCP). An OBCP is in practice represented by a simplified programming language interpreted onboard the spacecraft. This interpreter is generally at the highest level of criticality of the spacecraft. The implementation of this interpreter in \newspark is table driven and relies greatly
\ifdefined\abstractonly
on: generic packages and discriminants.
\else
on:
\begin{itemize}
\item Generic packages

	The generic packages allow an easy customization of the code:

	\begin{verbatim}
     generic
        -- the list of events
        type T_Event_Id is (<>);

     package Mvm.Events is
	\end{verbatim}

\item Discriminant

	The discriminants ensures a string typing of the code, even in case of heterogeneous communication between components of the system:

	\begin{verbatim}
   type T_Monitoring is (No_Window, Window);

   type T_Event_Status (Monitoring : T_Monitoring := No_Window)
   is record
         case Monitoring is
         when No_Window => null;
         when Window =>
            Start_Window : T_Float32;
            End_Window : T_Float32;
         end case;
      end record;
	\end{verbatim}
\end{itemize}
\fi

\subsection{Formalization of Properties}

The contracts defined on algorithmic code are mainly related to the ranges of variables.

\ifdefined\abstractonly
\else
\paragraph{Example of contract in algorithmic code:}

\begin{verbatim}
   subtype T_Angle_180 is T_Float32 range -180 .. 180;

   function Normalise (X : in T_Float32) return T_Angle_180
   with Pre =>
     ( X >= -720.0 ) and
        ( X <= 720.0 );
\end{verbatim}
\fi

The contracts defined on mission and vehicle management code code have (among others) the following objectives:

\begin{itemize}
\item Ensuring the permanent consistency of the software tables
\item Ensuring the permanent consistency between the Mission and Vehicle Management function and the other functionalities (such as, for instance, the solar wing management)
\item Ensuring the respect of some functional properties such as the mutual exclusion of execution of some automated procedures
\item Ensuring the absence of run-time errors
\end{itemize}

\ifdefined\abstractonly
\else
\paragraph{Example of contract in mission and vehicle management code:}

\begin{verbatim}
   procedure Reset_Event (Event_Id :        T_Event_Id;
                          Events   : in out T_Events)
   with
     Post =>
        Get_Status (Event_Id, Events) = Inactive) and then
          (for all Other_Event_Id in T_Event_Id =>
             (if Other_Event_Id /= Event_Id then
              Get_Status (Other_Event_Id, Events) =
                Get_Status (Other_Event_Id, Events'Old))));
\end{verbatim}
\fi

\subsection{Formal Verification Results}

All the contracts have been checked by dynamic testing. This phase is quite classical, except for the fact that the testing includes the preconditions and the postconditions defined in the software. Then, \gnatprove has been applied.

\ifdefined\abstractonly
\else
\subsubsection{Subprograms not in \newspark}

The origins of subprograms not yet in \newspark are mainly the following:

\begin{itemize}
\item unchecked conversion

The unchecked conversion are used in a library allowing reading external inputs.
All the concerned subprograms are very small and shall be validated by intensive testin because there are out of the perimeter of HiLite and of \newspark.
\item tagged type

Tagged type are related to Object Oriented Programming. The analysis of Object Oriented software is foreseen but has not yet been implemented.
\item access

Accesses are used in the software to store objects in a table.
This kind of design can not be proved by \gnatprove.
\end{itemize}

\subsubsection{Analysis of the non proved VCs}

Some algorithmic functions are not completely known by \gnatprove.

\paragraph{Example:}

\begin{verbatim}
   function Arctan (X : T_Float32) return T_Float32
   with
     Post => (Arctan'Result >= -C_Halfpi32) and then
     (Arctan'Result <= C_Halfpi32);

   function Arctan (X : T_Float32) return T_Float32
   is (Num32.Arctan (X));
\end{verbatim}

The postcondition is not proved by \gnatprove.
The exact behaviour of algorithmic functions depending of the implementation, this behaviour is acceptable.
Algorithmic functions and their contracts are preferably validated by intensive testing.

\gnatprove has some difficulties to take into account rounding.
In the following example, the second assertion is not proved.

\paragraph{Example:}

\begin{verbatim}
   function Round_Closest (X : T_Float32) return T_Float32
   is (T_Float32'Rounding (X));

   pragma Assert(( Y >= -11160.002 ) and (Y <= 11160.002 ));
   Round_Y := Ml.Round_Closest (Y);
   pragma Assert(( Round_Y >= -11160.0 ) and (Round_Y <= 11160.0 ));
\end{verbatim}

\gnatprove currently does not prove non linear equation.
In the following example, the last assertion is not proved.

\paragraph{Example:}

\begin{verbatim}
   pragma Assert(X >= 0.0 and the x <= 180.0);
   pragma Assert(Y >= -180.0 and then Y <= 0.0);
   pragma Assert(Z >= 0.0 and then Z <= 1.0);
   pragma Assert(X + Y >= 0.0);
   Result := X + Y * Z;
   pragma Assert (Result >= 0.0 and then Result <= 360.0);
\end{verbatim}

\gnatprove is not yet able to verify the index of an array which dimension is defined by a type descriminant

\paragraph{Example:}

\begin{verbatim}
   subtype R is Integer range 1 .. 100;
   type T_Array is array (R range <>) of Boolean;

   type T_Record (L : R) is
      record
         A : T_Array (1 .. L);
      end record;

   function G (X : T_Record) return Boolean is
     (for all I in X.A'Range => X.A (I));
\end{verbatim}

In function "G", the index check "X.A (I)" is not proved even if "I" is defined in the range of "X.A"
An improvement of \gnatprove is in progress in order to deal with such case.

The remaining non proved VCs are due to too complex subprograms.
These subprograms shall be split in several smaller subprograms to be proved.
\fi

\subsection{Lessons Learned}

\ifdefined\abstractonly
We will present how \newspark fulfilled the initial objectives that we set:
capability to formalize the test cases, verification that all test procedures
cover all the test cases, support to the verification / validation of the
absence of run-time errors, support to the verification / validation of
functional properties, verification of the correctness of the access of all
global variables, verification of the absence of out of range values, internal
consistency of software unit, capability to assess the commandability and
observability, help proving that numerical protection mechanisms are correctly
implemented, prove the correctness of a generic code in a specific context.

\else
Our initial objectives were that \newspark should fulfill the following requirements:

\begin{itemize}
\item Capability to formalize the test cases

Current assessment: Very good
\item Verification that all test procedures cover all the test cases

Current assessment: Not implemented. This implies that the formalization of the test cases is today not really interesting
\item Support to the verification / validation of the absence of run-time errors

Current assessment: Very good
\item Support to the verification / validation of functional properties

Current assessment: Good. In order to be efficient, it requires some works (definition of contracts, definition of assertions, spliting of complex subprograms in smaller ones)
\item Verification of the correctness of the access of all global variables

Current assessment: Not yet implemented
\item Verification of the absence of out of range values

Current assessment: Very good. As for functional properties, it requires some manual works
\item Internal consistency of software unit. The HiLite tools shall help ensuring that each aggregate satisfies the requirements of the software item. In other words, each caller of a subprogram shall ensures that the pre-conditions of the callee are respected and that the post-condition of the callee is compatible with the caller

Current assessment: Very good
\item Capability to assess the commandability and observability. In other words, the HiLite tools shall help detecting dead code

Current assessment: No
\item Help proving that numerical protection mechanisms are correctly implemented

Current assessment: Very good
\item Prove the correctness of a generic code in a specific context

Current assessment: Very good
\end{itemize}
\fi

\section{Biometric Access to a Secure Enclave}

% Tokeneer case study

\subsection{Description of the Software}

Tokeneer is a highly secure biometric software system that was originally
developed by Altran in \oldspark. The system provides protection to secure
information held on a network of workstations situated in a physically
secure enclave. The Tokeneer project was commissioned by the US National
Security Agency (NSA) to demonstrate the feasibility of developing systems
to the level of rigour required by the higher assurance levels of the
Common Criteria. The original development artefacts, including all source code,
are publicly available. For more details see
\url{www.adacore.com/sparkpro/tokeneer}.

During this study, the source code for Tokeneer has been translated into \newspark.
The core system now consists of approximately \emph{10,000} lines of \newspark code
(declarations and executable lines, excluding blank lines, comments and
SPARK annotations). There are also approximately 3,700 lines of supporting
code written in Ada which mimicked the drivers to peripherals connected
to the core system.


\subsection{Formalization of Properties}

The contracts defined in the Tokeneer source code consist of information flow contracts (expressed as Depends aspects) and functional behavioral contracts (expressed as Pre and Post aspects).

The verification objectives supported by these contracts are as follows:

\begin{itemize}
\item Detecting improper initialization
\item Identifying innefective assignments
\item Showing the code is free from any run time exceptions, such as buffer overflow or divide-by-zero
\item Ensuring secure infomration flow
\item Proving that key security properties are guaranteed by the implementation
\end{itemize}

\emph{Examples of the various types contracts will be added here.}

\subsection{Formal Verification Results}

The source code of Tokeneer was proven to be free of runtime exceptions
and some key security properties were proven to hold but full functional
proof was not performed on the entirety of the code. This study will
focus on proving the biggest possible subset of the aforementioned
attributes using the \newspark toolset.

\subsection{Lessons Learned}

Some additional aims of this study are the following:
\begin {itemize}
  \item Evaluate how easy is it to convert programs from \oldspark to \newspark.
  \item Investigate how executable semantics affect the way code has to be written
        and what advantages/disadvantages they introduce.
  \item Discover the percentage of the code that can be automatically proven
        and the combination of options/provers that achieve the best results
        for this specific test case.
  \item Provide feedback and suggest features or changes that could improve future versions of the \newspark toolset.
\end {itemize}

\section{Common Findings and Dissimilarities}

We will discuss the common findings between the three case studies, denoting
instrinsic properties of \newspark, and the dissimilarities, which may be
explained by differences in domains, backgrounds, processes, \etc

\section{Conclusion}

We will summarize the three case studies, and present the planned future
evolutions of \newspark.

\bibliographystyle{plain}
\bibliography{erts_2014}

\end{document}


% LocalWords:  openETCS ETCS UNISIG Centre SRS

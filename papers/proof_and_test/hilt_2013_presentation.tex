\documentclass{beamer}
\input{altran-beamer}
\usepackage{listings}
\usepackage{setspace}
\usepackage{tikz}
\usepackage{lcd}
\usepackage{pgflibraryshapes}
\usetikzlibrary{calc,fit,shapes,arrows}
\usetikzlibrary{backgrounds,shadows}

\setbeamertemplate{note page}[plain]
\setbeameroption{show notes}


\lstdefinestyle{tinystyle} {basicstyle=\scriptsize\tt,
  keywordstyle=\bf, commentstyle=\rmfamily\it, escapeinside={(*}{*)}}
\lstset{style=tinystyle}

\lstdefinelanguage{SPARK}{ language = [95]Ada, morekeywords = {pre,
    post, assert, assume, check, derives, hide, global, inherit, from,
    own, initializes, main_program, input, output, in_out,
    refined_pre, refined_post, some, depends}, comment=[l][commentstyle]{--\ },
  showstringspaces=false }

\lstset{language=SPARK}

\title{Optimising Verification Effort\\with SPARK 2014}
\author{Andrew Hawthorn}
\hypersetup{colorlinks=true}
\begin{document}

\begin{altrantitle}
  \titleprismlabela{Formally Specify}
  \titleprismlabelb{Test and Prove}
  \titleprismlabelc{Reduce Cost}
\end{altrantitle}

%\begin{frame}[fragile]{Contents}
%  \tableofcontents
%\end{frame}

\makeatletter
\newenvironment{btHighlight}[1][]
{\begingroup\tikzset{bt@Highlight@par/.style={#1}}\begin{lrbox}{\@tempboxa}}
{\end{lrbox}\bt@HL@box[bt@Highlight@par]{\@tempboxa}\endgroup}

\newcommand\btHL[1][]{%
  \begin{btHighlight}[#1]\bgroup\aftergroup\bt@HL@endenv%
}
\def\bt@HL@endenv{%
  \end{btHighlight}%
  \egroup
}
\newcommand{\bt@HL@box}[2][]{%
  \tikz[remember picture]{%
    \pgfpathrectangle{\pgfpoint{1pt}{0pt}}{\pgfpoint{\wd #2}{\ht #2}}%
    \pgfusepath{use as bounding box}%
    \node[anchor=base west,%
          outer sep=0pt,%
          inner xsep=1pt,%
          inner ysep=0pt,%
          rounded corners=2pt,%
          minimum height=\ht\strutbox+1pt,%
          #1]%
          {%
            \raisebox{1pt}{\strut}\strut\usebox{#2}%
          };%
  }%
}
\makeatother

\section{Introduction}

\begin{frame}[fragile]{Key messages}
  \begin{itemize}
  \item Precision of contracts can be tailored to project need
  \item Proof can be free
  \item Test and proof can be easily combined

  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Agenda}
  \begin{itemize}
     \item Setting the foundations for proof and test
     \item Incremental analysis - the verification spectrum
     \item How proof supports test
     \item Proof and test scenarios
     \item Only prove
     \item Only test
     \item Prove and test
     \item Test to debug contracts
     \item Test to prove contracts (state machine example)
     \item Conclusions
  \end{itemize}
\note[item]{Test Note.}
\end{frame}

\begin{frame}{Setting the foundations for proof and test}
  \note[item]{Key messages: If you are thinking about combining proof and test, ake sure you consider it at the start of your project}
  \note[item]{SPARK often seen as just a coding language}
  \note[item]{Proof means SPARK also covers unit verification}
  \note[item]{Proof implies formal specification which brings SPARK into LLRs}
  \note[item]{NB review of Tokeneer Z suggests writing spec in SPARK isn't any more challenging than writing in Z but provides plenty of benefits (eg don't need to respecify to prove properties, rapid prototyping options available etc)}
  \note[item]{Modular verification means SPARK can be applied at architecture and architecture can be verified statically}
  \begin{changemargin}{-0.75cm}{-0.75cm}
    \begin{center}
      \begin{tikzpicture}[font=\tiny,y=0.95cm]

        % Create the Boundary Variable nodes
        \node[rectangle, draw] (sys_reqs) at (-4cm,-0cm) {System Requirements};
        \node<-2>[rectangle, draw] (arch) at (-3cm,-1.5cm) {Software Architecture};
        \node<3->[rectangle, draw, fill, fill=AnSecondaryGreen] (arch) at (-3cm,-1.5cm) {Software Architecture};
        \node<-3>[rectangle, draw] (arch_ver) at (3cm,-1.5cm) {Architecture Verification};
        \node<4->[rectangle, draw, fill, fill=AnSecondaryYellow] (arch_ver) at (3cm,-1.5cm) {Architecture Verification};
        \node<-4>[rectangle, draw] (sw_reqs) at (-2cm,-3cm) {SW Requirements};
        \node<5->[rectangle, draw, fill, fill=AnSecondaryGreen] (sw_reqs) at (-2cm,-3cm) {SW Requirements};
        \node<-5>[rectangle, draw] (code) at (-1cm,-4.5cm) {Source Code};
        \node<6->[rectangle, draw, fill, fill=AnSecondaryGreen] (code) at (-1cm,-4.5cm) {Source Code};
        \node<-6>[rectangle, draw] (aorte) at (1cm,-4.5cm) {AoRTE};
        \node<7->[rectangle, draw, fill, fill=AnSecondaryGreen] (aorte) at (1cm,-4.5cm) {AoRTE};
        \node<-7>[rectangle, draw] (unit_ver) at (2cm,-3cm) {Unit Verification};
        \node<8->[rectangle, draw, fill, fill=AnSecondaryGreen] (unit_ver) at (2cm,-3cm) {Unit Verification};
        \node[rectangle, draw] (sys_test) at (4cm,-0cm) {System Test};


        % Draw the system boundary using containers (more maintainable than using draw)
        \node<2>[ellipse, draw, red, ultra thick,fit=(arch)] (circle_arc) {};
        \node<3>[ellipse, draw, red, ultra thick,fit=(arch_ver)] (circle_arch_ver) {};
        \node<4>[ellipse, draw, red, ultra thick,fit=(sw_reqs)] (circle_sw_reqs) {};
        \node<5>[ellipse, draw, red, ultra thick,fit=(code)] (circle_code) {};
        \node<6>[ellipse, draw, red, ultra thick,fit=(aorte)] (circle_aorte) {};
        \node<7>[ellipse, draw, red, ultra thick,fit=(unit_ver)] (circle_unit_ver) {};

        % Draw the downward arrows
        \draw[ultra thick][->] ([xshift=0.2 cm]sys_reqs.south) to ([xshift=-0.2cm]arch.north) ;
        \draw[ultra thick][->] ([xshift=0.2 cm]arch.south) to ([xshift=-0.2cm]sw_reqs.north) ;
        \draw[ultra thick][->] ([xshift=0.2 cm]sw_reqs.south) to ([xshift=-0.2cm]code.north) ;

        % Draw the dashed arrows
        \draw[dashed, thick][->] (sys_reqs.east) to (sys_test.west) ;
        \draw[dashed, thick][->] (arch.east) to (arch_ver.west) ;
        \draw[dashed, thick][->] (sw_reqs.east) to (unit_ver.west) ;
        \draw[dashed, thick][->] (code.east) to (aorte.west) ;

        % Draw the upward arrows
        \draw[ultra thick][<-] ([xshift=-0.2 cm]sys_test.south) to ([xshift=0.2cm]arch_ver.north) ;
        \draw[ultra thick][<-] ([xshift=-0.2 cm]arch_ver.south) to ([xshift=0.2cm]unit_ver.north) ;
        \draw[ultra thick][<-] ([xshift=-0.2 cm]unit_ver.south) to ([xshift=0.2cm]aorte.north) ;
       

      \end{tikzpicture}
    \end{center}
  \end{changemargin}
\end{frame}

\section{What?}

\begin{frame}[fragile]{Verification Spectrum}
  \note[item]{The following slides will walk through the verification spectrum with code examples.}
  \note[item]{ask audience to id faults? Give them a 10-second count=down timer.}

  \lstdefinestyle{magic}{
    basicstyle=\tiny\tt,
    keywordstyle=\color{AnColour02},
    moredelim=**[is][{\btHL[fill=AnSecondaryYellow!50,name=error]}]{`}{`},
  }

  \begin{columns}
    \begin{column}{2cm}
      \begin{tikzpicture}[x=1cm,y=1.2cm]
        \tikzstyle{legend}=[font=\scriptsize,text badly centered,text width=1.6cm]
        \tikzstyle{unused}=[fill=white]
        \tikzstyle{error}=[fill=AnSecondaryRed]
        \tikzstyle{ok}=[fill=AnSecondaryGreen]

        \foreach \y in {1, 2, 3, 4, 5, 6} {
          \draw[fill=AnGrey01] (0, \y) -- (2, \y) -- (2, \y + 1) -- (0, \y + 1) -- (0, \y);
          \draw[white,thick]   (0, \y) -- (2, \y) -- (2, \y + 1) -- (0, \y + 1) -- (0, \y);
        }

        \node[legend] at (0.8, 6.5) {In \spark\ subset};
        \node[legend] at (0.8, 5.5) {Globals satisfied};
        \node[legend] at (0.8, 4.5) {Variables initialised};
        \node[legend] at (0.8, 3.5) {No RT errors};
        \node[legend] at (0.8, 2.5) {Partially proven};
        \node[legend] at (0.8, 1.5) {Fully\\proven};

         % In SPARK subset
        \draw<1>[unused] (1.7, 6.5) circle (0.1cm);
        \draw<2>[error]   (1.7, 6.5) circle (0.1cm);
        \draw<3->[ok]     (1.7, 6.5) circle (0.1cm);

         % Globals satisfied
        \draw<-3>[unused]  (1.7, 5.5) circle (0.1cm);
        \draw<4>[error]    (1.7, 5.5) circle (0.1cm);
        \draw<5->[ok]      (1.7, 5.5) circle (0.1cm);

         % Variables initialised
        \draw<-5>[unused] (1.7, 4.5) circle (0.1cm);
        \draw<6>[error]   (1.7, 4.5) circle (0.1cm);
        \draw<7->[ok]     (1.7, 4.5) circle (0.1cm);

         % No RT errors
        \draw<-7>[unused] (1.7, 3.5) circle (0.1cm);
        \draw<8>[error]   (1.7, 3.5) circle (0.1cm);
        \draw<9->[ok]     (1.7, 3.5) circle (0.1cm);

         % Partially proven
        \draw<-9>[unused] (1.7, 2.5) circle (0.1cm);
        \draw<10>[error]   (1.7, 2.5) circle (0.1cm);
        \draw<11->[ok]     (1.7, 2.5) circle (0.1cm);

         % Fully proven
        \draw<-11>[unused] (1.7, 1.5) circle (0.1cm);
        \draw<12>[error]   (1.7, 1.5) circle (0.1cm);
        \draw<13->[ok]     (1.7, 1.5) circle (0.1cm);
      \end{tikzpicture}
    \end{column}

    \begin{column}{9cm}
      %\hrule

      \begin{onlyenv}<2>
      \begin{pxcode}[language=SPARK,style=magic,gobble=8]
        package Conference_Attendance
        is
           Max_Attendance : constant := 1000;
           type Count_T is range 0 .. Max_Attendance;
           type Counter_Access is access Count_T;

           procedure Inc_Counter (Counter : `Counter_Access`);

        end Conference_Attendance;

        package body Conference_Attendance
        is
           procedure Inc_Counter (Counter : `Counter_Access`)
           is
           begin
              Counter.all := Counter.all + 1;
           end Inc_Counter;

        end Conference_Attendance;

      \end{pxcode}
      \end{onlyenv}

      \begin{onlyenv}<3>
      \begin{pxcode}[language=SPARK,style=magic,gobble=8]
        package Conference_Attendance
        is
           Audience_Count, P_Count : Integer;

           procedure Inc_Audience (N : Integer)

        end Conference_Attendance;

        package body Conference_Attendance
        is

           procedure Inc_Audience (N : Integer)
           is
           begin
              Audience_Count := Audience_Count + N;
           end Inc_Audience;

        end Conference_Attendance;
      \end{pxcode}
      \end{onlyenv}


      \begin{onlyenv}<4>
      \begin{pxcode}[language=SPARK,style=magic,gobble=8]
        package Conference_Attendance
        is
           Audience_Count, P_Count : Integer;

           procedure Inc_Audience (N : Integer)
           with Global => (`Out => Audience_Count`);

        end Conference_Attendance;

        package body Conference_Attendance
        is

           procedure Inc_Audience (N : Integer)
           is
           begin
              Audience_Count := Audience_Count + N;
           end Inc_Audience;

        end Conference_Attendance;
      \end{pxcode}
      \end{onlyenv}

      \begin{onlyenv}<5>
      \begin{pxcode}[language=SPARK,style=magic,gobble=8]
        package Conference_Attendance
        is
           Audience_Count, P_Count : Integer;

           procedure Inc_Audience (N : Integer)
           with Global => (`In_Out => Audience_Count`);

        end Conference_Attendance;

        package body Conference_Attendance
        is
           procedure Inc_Audience (N : Integer)
           is
           begin
              Audience_Count := Audience_Count + N;
           end Inc_Audience;
        end Conference_Attendance;
      \end{pxcode}
      \end{onlyenv}


      \begin{onlyenv}<6>
      \begin{pxcode}[language=SPARK,style=magic,gobble=8]
        package Conference_Attendance
        is
           Audience_Count, P_Count : Integer;

           procedure Inc_Audience (N : Integer)
           with Global => (In_Out => Audience_Count);

        end Conference_Attendance;

        package body Conference_Attendance
        is
           procedure Inc_Audience (N : Integer)
           is
           begin
              Audience_Count := `Audience_Count` + N;
           end Inc_Audience;
        end Conference_Attendance;
      \end{pxcode}
      \end{onlyenv}

      \begin{onlyenv}<7>
      \begin{pxcode}[language=SPARK,style=magic,gobble=8]
        package Conference_Attendance
        is
           Audience_Count, P_Count : Integer := `0`;

           procedure Inc_Audience (N : Integer)
           with Global => (In_Out => Audience_Count);

        end Conference_Attendance;

        package body Conference_Attendance
        is
           procedure Inc_Audience (N : Integer)
           is
           begin
              Audience_Count := Audience_Count + N;
           end Inc_Audience;
        end Conference_Attendance;
      \end{pxcode}
      \end{onlyenv}

      \begin{onlyenv}<8>
      \begin{pxcode}[language=SPARK,style=magic,gobble=8]
        package Conference_Attendance
        is
           Audience_Count, P_Count : Integer := 0;

           procedure Inc_Audience (N : Integer)
           with Global => (In_Out => Audience_Count);

        end Conference_Attendance;

        package body Conference_Attendance
        is
           procedure Inc_Audience (N : Integer)
           is
           begin
              Audience_Count := `Audience_Count + N`;
           end Inc_Audience;
        end Conference_Attendance;
      \end{pxcode}
      \end{onlyenv}

      \begin{onlyenv}<9>
      \begin{pxcode}[language=SPARK,style=magic,gobble=8]
        package Conference_Attendance
        is
           `Max_Attendance : constant := 1000;`
           `type Count_T is range 0 .. Max_Attendance;`

           Audience_Count, Presenter_Count : Count_T := 0;

           procedure Inc_Audience (N : Integer)
           with Global => (In_Out => Audience_Count),
                `Pre    => (N >= 0, Audience_Count + N <= Max_Attendance);`

        end Conference_Attendance;

        package body Conference_Attendance
        is
           procedure Inc_Audience (N : Integer)
           is
           begin
              Audience_Count := Audience_Count + N;
           end Inc_Audience;
        end Conference_Attendance;
      \end{pxcode}
      \end{onlyenv}

      \begin{onlyenv}<10>
      \begin{pxcode}[language=SPARK,style=magic,gobble=8]
        package Conference_Attendance
        is
           Max_Attendance : constant := 1000;
           type Count_T is range 0 .. Max_Attendance;

           Audience_Count, Presenter_Count : Count_T := 0;

           procedure Inc_Audience (N : Integer)
           with Global => (In_Out => Audience_Count),
                Pre    => (N >= 0, Audience_Count + N <= Max_Attendance),
                `Post   => (Audience_Count > Audience_Count'Old);`

        end Conference_Attendance;

        package body Conference_Attendance
        is
           procedure Inc_Audience (N : Integer)
           is
           begin
              Audience_Count := Audience_Count `-` N;
           end Inc_Audience;
        end Conference_Attendance;
      \end{pxcode}
      \end{onlyenv}

      \begin{onlyenv}<11>
      \begin{pxcode}[language=SPARK,style=magic,gobble=8]
        package Conference_Attendance
        is
           Max_Attendance : constant := 1000;
           type Count_T is range 0 .. Max_Attendance;

           Audience_Count, Presenter_Count : Count_T := 0;

           procedure Inc_Audience (N : Integer)
           with Global => (In_Out => Audience_Count),
                Pre    => (N >= 0, Audience_Count + N <= Max_Attendance),
                Post   => (Audience_Count > Audience_Count'Old);

        end Conference_Attendance;

        package body Conference_Attendance
        is
           procedure Inc_Audience (N : Integer)
           is
           begin
              Audience_Count := Audience_Count `+` N;
           end Inc_Audience;
        end Conference_Attendance;
      \end{pxcode}
      \end{onlyenv}


      \begin{onlyenv}<12>
      \begin{pxcode}[language=SPARK,style=magic,gobble=8]
        package Conference_Attendance
        is
           Max_Attendance : constant := 1000;
           type Count_T is range 0 .. Max_Attendance;
           Audience_Count, Presenter_Count : Count_T := 0;
           Presenter_Set : Name_Sets.Set;

           procedure Inc_Audience (N : Integer)
           with Global => (In_Out => Audience_Count),
                Pre    => (N >= 0, Audience_Count + N <= Max_Attendance),
                Post   => (`Audience_Count = Audience_Count'Old + N`);

        end Conference_Attendance;

        package body Conference_Attendance
        is
           procedure Inc_Audience (N : Integer)
           is
           begin
              Audience_Count := `Audience_Count - N`;
           end Inc_Audience;

        end Conference_Attendance;
      \end{pxcode}
      \end{onlyenv}

      \begin{onlyenv}<13>
      \begin{pxcode}[language=SPARK,style=magic,gobble=8]
        package Conference_Attendance
        is
           Max_Attendance : constant := 1000;
           type Count_T is range 0 .. Max_Attendance;
           Audience_Count, Presenter_Count : Count_T := 0;
           Presenter_Set : Name_Sets.Set;

           procedure Inc_Audience (N : Integer)
           with Global => (In_Out => Audience_Count),
                Pre    => (N >= 0, Audience_Count + N <= Max_Attendance),
                Post   => (`Audience_Count = Audience_Count'Old + N`);

        end Conference_Attendance;

        package body Conference_Attendance
        is
           procedure Inc_Audience (N : Integer)
           is
           begin
              Audience_Count := Audience_Count `+` N;
           end Inc_Audience;

        end Conference_Attendance;
      \end{pxcode}
      \end{onlyenv}


%           procedure Inc_Presenter(Name : String)
%           with Global => (In_Out => Presenter_Count, Presenter_List),
%                Pre    => (Presenter_Count < Max_Attendance);
%                Post   => (Presenters_Set.Insert(Name) and 
%                           Presenter_Count = Presenters_Set.Count);
%           ...



      %\hrule
    \end{column}
  \end{columns}

\end{frame}

\begin{frame}[fragile]{Combining proof and test overview}
  \note[item]{Key message: neither full proof, nor full test is sufficient}
  \note[item]{item talk about system test as out of scope}
  \begin{changemargin}{-0.75cm}{-0.75cm}
    \begin{center}
      \begin{tikzpicture}[font=\tiny,y=0.95cm]

        % Create the test only nodes
        \node[rectangle, draw] (spec_val) at (4.0cm, -0.5cm) {Specification Validation};
        \node[rectangle, draw] (sys_test) at (4cm,-1.5cm) {System Test};
        \node[rectangle, draw] (hw_int) at (4.0cm,-2.5cm) {HW integration};

        % Create the proof only nodes
        \node[rectangle, draw] (state_coverage) at (-4.0cm,-0.5cm) {Full state space coverage};
        \node[rectangle, draw] (rte) at (-4cm,-1.5cm) {AoRTE};
        \node[rectangle, draw] (term) at (-4.0cm,-2.5cm) {Loop Termination};

        % Create the proof and test nodes
        \node[rectangle, draw] (part) at (-0cm, -0.0cm) {Partial Correctness};
        \node[rectangle, draw] (sw_int) at (-1cm,-1.5cm) {SW Integration};
        \node[rectangle, draw] (unit_ver) at (1cm,-1.5cm) {Unit Verification};
        \node[rectangle, draw] (arch_ver) at (0cm,-3.0cm) {Architecture Verification};


        % Draw the system boundary using containers (more maintainable than using draw)
        \node<2,4>[circle, draw, red, ultra thick,inner sep=0pt,fit=(unit_ver) (state_coverage) (term)(rte) (arch_ver) (part)] (circle_proof) {};
        \node<3->[circle, draw, red, ultra thick,inner sep=0pt, fit=(sw_int) (spec_val) (sys_test)(hw_int) (arch_ver) (part)] (circle_test) {};

      \end{tikzpicture}
    \end{center}
  \end{changemargin}
\end{frame}


\begin{frame}[fragile]{Proof and Test Scenario Summary}
\note[item]{Explain that we are considering full functional proof/test, not just RTE proof.}
\begin{center}
\begin{tabular}{p{3.8cm} | c | c | c }
    & Fully & Partially & Can't \\
    & specify & specify & specify \\
  \hline
  Only prove & R & NA & NA \\
  \hline
  Only test & O & O & R \\
  \hline
  \raggedright Prove some and test some & O & O & O \\
  \hline
  Test to debug contracts & O & O & NA \\
\end{tabular}

\vspace{1cm}
R - Required; O - Optional; NA - Not applicable
\end{center}

\end{frame}


\begin{frame}[fragile]{Only prove - specification}
  \note[item]{Key message: Proof isn't just possible, it is often easier than test!}
  \note[item]{This is an example generated for a client. The message is, we put this specification together and then wrote an implementation and the tools fully proved consistency without any strengthen of preconditions, addition of asserts and the VCs didn't even need to be inspected.}
  \begin{pxcode}[language=SPARK,style=magic,gobble=3]
   function My_SM(State : in States_T; Trigger: in Triggers_T)
                  return States_T is
     (case State is
         when Start =>
         (if    Trigger = Btn_Start    then Start
          elsif Trigger = Btn_Finish   then Finish
          elsif Trigger = Btn_Pressed  then Progress
          elsif Trigger = Btn_Released then Start
          else                              Invalid_State),
         when Progress =>
         (if    Trigger = Btn_Start    then Start
          elsif Trigger = Btn_Finish   then Finish
          elsif Trigger = Btn_Pressed  then Finish
          elsif Trigger = Btn_Released then Progress
          else                              Invalid_State),
         when Finish =>
         (if    Trigger = Btn_Start    then Start
          elsif Trigger = Btn_Finish   then Finish
          elsif Trigger = Btn_Pressed  then Finish
          elsif Trigger = Btn_Released then Finish
          else                              Invalid_State),
         when Invalid_State =>
         (if    Trigger = Btn_Start    then Start
          elsif Trigger = Btn_Finish   then Finish
          else                              Invalid_State));

  \end{pxcode}
\end{frame}
\begin{frame}[fragile]{Only prove - implementation}
  \begin{pxcode}[language=SPARK,style=magic,gobble=3]
   procedure Progress_SM(Trigger : in Triggers_T)
     with Refined_Global => (in_out => State)
   is
   begin

      if Trigger = Btn_Pressed then
         if State = Start then
            Set_State(Progress);
         elsif State = Progress or State = Finish then
            Set_State(Finish);
         else
            Set_State(Invalid_State);
         end if;

      elsif Trigger = Btn_Start then
         Set_State(Start);

      elsif Trigger = Btn_Finish then
         Set_State(Finish);

      elsif Trigger = Invalid_Trigger then
         Set_State(Invalid_State);

      end if;

   end Progress_SM;
  \end{pxcode}
\end{frame}

\begin{frame}[fragile]{Only prove - quick tips for improving provability}
  \note{Describe when proof is easy/hard (linear/non-linear arithmetic) (logic vs computations?)}
  \note[item]{should we remove the bullet about cyclomatic complexity?}
  \begin{itemize}
        \item Re-use expression functions in implementation
        \item Reduce cyclomatic complexity
        \item Strengthen pre-conditions
        \item Add assertions to the code
        \item Increase prover time out
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Only test}
  \begin{itemize}
     \item Contracts could be hard to formalise eg:
     \begin{itemize}
        \item Interface with hardware
        \item Timing properties
     \end{itemize}
     \item Implementation may rely on obtuse minimalist algorithms
  \end{itemize}
  \begin{pxcode}[language=SPARK,style=magic,gobble=0]
package Mergesort is

  subtype Index_Range_T is Integer range 1 .. 5;
  type    Int_Array_T   is array (Index_Range_T) of Integer;

  --  Sorts the elements of array A into ascending order.
  procedure Merge_Sort (A : in out Int_Array_T);
  with Post => (for all I in 1 .. 4 => (A(I) <= A(I+1)))

end Mergesort;     
  \end{pxcode}
\end{frame}
\begin{frame}[fragile]{Example unit testing tool}
  \note{Using modern unit test tools makes it easier to put together harnesses but users still need to define the test inputs and expected outcomes. Also, unit testing will often not cover the entire state space.}
  \includegraphics[width=\textwidth]{Mergesort_Same_Values_small.jpg}
\end{frame}

\begin{frame}[fragile]{Prove and test}
  \note{Key message: Mixing of proof and test most effective method}
  \begin{itemize}
     \item Lowest-level operations often prove automatically
     \item Best to concentrating test effort on high-level ops is better value
     \item Start by attempting to prove, give up then
     \item resort to testing
     \item prove a subset of the properties (eg RTE, safety properties)
     
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Test to debug contracts}
  \note{Key message: Executing contracts is a great way of checking them}
  \begin{itemize}
     \item Execute precondition to check it isn't too strong
     \item Execute postcondition to check it holds under expected conditions
     \item Use pragma assert like a "debug" statement for contracts
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Test to debug contracts - using assert to debug}
  \begin{pxcode}[language=SPARK,style=magic,gobble=3]
   procedure Progress_SM(Trigger : in Triggers_T)
     with Refined_Global => (in_out => State)
   is
   begin

      if Trigger = Btn_Pressed then
         if State = Start then
            Set_State(Progress);
         elsif State = Progress or State = Finish then
            Set_State(Finish);
         else
            Set_State(Invalid_State);
         end if;

         `pragma Assert (if Trigger = Btn_Pressed then Get_State = My_SM(Old_State, Trigger));`

      elsif Trigger = Btn_Start then
         Set_State(Start);

      elsif Trigger = Btn_Finish then
         Set_State(Finish);

      elsif Trigger = Invalid_Trigger then
         Set_State(Invalid_State);

      end if;

   end Progress_SM;
  \end{pxcode}
  \note[item]{Assert statements can be used to check specific paths through the code.}
  \note[item]{The Show Path functionality would be better for this specific example.}
\end{frame}


\begin{frame}[fragile]{Test to prove contracts}
  \note[item]{Key message: When provers aren't capable, execute contract over all cases}
  \note[item]{We plan to be able to automatically prove this specific type of contract}
  \begin{itemize}
     \item Some contracts are difficult to prove ...
     \item ... but easy to test.
  \end{itemize}

  \begin{pxcode}[language=SPARK,style=magic,gobble=3]
   procedure Progress_SM(Trigger : in Triggers_T)
   is
   begin

      -- Check that all states are reachable
      pragma Assert
        (for all Final_State in States_T =>
           (for some Initial_State in States_T =>
                (for some A_Trigger in Triggers_T =>
                     (Final_State = My_SM(Initial_State, A_Trigger)))));
   ...
  \end{pxcode}

\end{frame}

\begin{frame}[fragile]{Conclusions}
  \begin{itemize}
     \item Improve legacy code through incremental analysis
     \item Reduce costs by replacing unit test with automated proof
     \item Maximise benefit by combining test and proof
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{What next?}
  \begin{itemize}
     \item Try testing your code using Ada 2012 contracts
     \item Try the GPL tools
     \item Read the full industrial paper
     \item Visit www.spark-2014.org
     \item Come and chat or send me a mail: andrew.hawthorn@altran.com
  \end{itemize}
\end{frame}


\end{document}


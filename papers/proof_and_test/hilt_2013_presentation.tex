\documentclass{beamer}
\input{altran-beamer}
\usepackage{listings}
\usepackage{setspace}
\usepackage{tikz}
\usetikzlibrary{calc}
\usetikzlibrary{shadows}

\lstdefinestyle{tinystyle} {basicstyle=\scriptsize\tt,
  keywordstyle=\bf, commentstyle=\rmfamily\it, escapeinside={(*}{*)}}
\lstset{style=tinystyle}

\lstdefinelanguage{SPARK}{ language = [95]Ada, morekeywords = {pre,
    post, assert, assume, check, derives, hide, global, inherit, from,
    own, initializes, main_program, input, output, in_out,
    refined_pre, refined_post, some, depends}, comment=[l][commentstyle]{--\ },
  showstringspaces=false }

\lstset{language=SPARK}

\title{Optimising Verification Effort\\with SPARK 2014}
\author{Andrew Hawthorn}
\hypersetup{colorlinks=true}
\begin{document}

\begin{altrantitle}
  \titleprismlabela{Formally Specify}
  \titleprismlabelb{Test and Prove}
  \titleprismlabelc{Reduce Cost}
\end{altrantitle}

%\begin{frame}[fragile]{Contents}
%  \tableofcontents
%\end{frame}

\makeatletter
\newenvironment{btHighlight}[1][]
{\begingroup\tikzset{bt@Highlight@par/.style={#1}}\begin{lrbox}{\@tempboxa}}
{\end{lrbox}\bt@HL@box[bt@Highlight@par]{\@tempboxa}\endgroup}

\newcommand\btHL[1][]{%
  \begin{btHighlight}[#1]\bgroup\aftergroup\bt@HL@endenv%
}
\def\bt@HL@endenv{%
  \end{btHighlight}%
  \egroup
}
\newcommand{\bt@HL@box}[2][]{%
  \tikz[remember picture]{%
    \pgfpathrectangle{\pgfpoint{1pt}{0pt}}{\pgfpoint{\wd #2}{\ht #2}}%
    \pgfusepath{use as bounding box}%
    \node[anchor=base west,%
          outer sep=0pt,%
          inner xsep=1pt,%
          inner ysep=0pt,%
          rounded corners=2pt,%
          minimum height=\ht\strutbox+1pt,%
          #1]%
          {%
            \raisebox{1pt}{\strut}\strut\usebox{#2}%
          };%
  }%
}
\makeatother

\section{Introduction}

\begin{frame}[fragile]{Key messages}
  \begin{itemize}
  \item Precision of contracts can be tailored to project need
  \item LLRs can be represented in Ada package specifications
  \item Test and proof can be easily combined

  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Agenda}
  \begin{itemize}
     \item When to start thinking about proof and test?
     \item The verification spectrum
     \item Informally combining proof and test
     \item Formally combining proof and test (the 178C way)
     \item Scenario summary
     \item Only prove
     \item Only test
     \item Prove and test
     \item Test to debug contracts
     \item Test to prove contracts (state machine example)
     \item Conclusions
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Techncial Planning}
  \begin{itemize}
      \item This slide will be an animation of a V-lifecycle diagram
      \item Key messages: If you are thinking about combining proof and test, ake sure you consider it at the start of your project
      \item SPARK often seen as just a coding language
      \item Proof means SPARK also covers unit verification
      \item Proof implies formal specification which brings SPARK into LLRs
      \item NB review of Tokeneer Z suggests writing spec in SPARK isn't any more challenging than writing in Z but provides plenty of benefits (eg don't need to respecify to prove properties, rapid prototyping options available etc)
      \item Modular verification means SPARK can be applied at architecture and architecture can be verified statically

  \end{itemize}
\end{frame}

\section{What?}

\begin{frame}[fragile]{Verification Spectrum}
  \begin{itemize}
      \item The following slides will walk through the verification spectrum with code examples.
     \item Example code: Presenter and audience counter (first is more precise)o
     \item ask audience to id faults? Give them a 10-second count=down timer.
  \end{itemize}
\end{frame}
\begin{frame}[fragile]{Verification Spectrum}

  \lstdefinestyle{magic}{
    basicstyle=\tiny\tt,
    keywordstyle=\color{AnColour02},
    moredelim=**[is][{\btHL[fill=AnSecondaryYellow!50,name=error]}]{`}{`},
  }

  \begin{columns}
    \begin{column}{2cm}
      \begin{tikzpicture}[x=1cm,y=1.2cm]
        \tikzstyle{legend}=[font=\scriptsize,text badly centered,text width=1.6cm]
        \tikzstyle{unused}=[fill=white]
        \tikzstyle{error}=[fill=AnSecondaryRed]
        \tikzstyle{ok}=[fill=AnSecondaryGreen]

        \foreach \y in {1, 2, 3, 4, 5, 6} {
          \draw[fill=AnGrey01] (0, \y) -- (2, \y) -- (2, \y + 1) -- (0, \y + 1) -- (0, \y);
          \draw[white,thick]   (0, \y) -- (2, \y) -- (2, \y + 1) -- (0, \y + 1) -- (0, \y);
        }

        \node[legend] at (0.8, 6.5) {In \spark\ subset};
        \node[legend] at (0.8, 5.5) {Globals satisfied};
        \node[legend] at (0.8, 4.5) {Variables initialised};
        \node[legend] at (0.8, 3.5) {No RT errors};
        \node[legend] at (0.8, 2.5) {Partially proven};
        \node[legend] at (0.8, 1.5) {Fully\\proven};

        \draw<-1>[unused] (1.7, 6.5) circle (0.1cm);
        \draw<2>[error]   (1.7, 6.5) circle (0.1cm);
        \draw<3->[ok]     (1.7, 6.5) circle (0.1cm);

        \draw<-1>[unused]  (1.7, 5.5) circle (0.1cm);
        \draw<2>[error]    (1.7, 5.5) circle (0.1cm);
        \draw<3->[ok]      (1.7, 5.5) circle (0.1cm);

        \draw<-1>[unused] (1.7, 4.5) circle (0.1cm);
        \draw<2>[error]   (1.7, 4.5) circle (0.1cm);
        \draw<3->[ok]     (1.7, 4.5) circle (0.1cm);

        \draw<-1>[unused] (1.7, 3.5) circle (0.1cm);
        \draw<2>[error]   (1.7, 3.5) circle (0.1cm);
        \draw<3->[error]     (1.7, 3.5) circle (0.1cm);

        \draw<-1>[unused] (1.7, 2.5) circle (0.1cm);
        \draw<2>[error]   (1.7, 2.5) circle (0.1cm);
        \draw<3->[error]     (1.7, 2.5) circle (0.1cm);

        \draw<-1>[unused] (1.7, 1.5) circle (0.1cm);
        \draw<2>[error]   (1.7, 1.5) circle (0.1cm);
        \draw<3->[error]     (1.7, 1.5) circle (0.1cm);
      \end{tikzpicture}
    \end{column}

    \begin{column}{9cm}
      %\hrule

      \begin{onlyenv}<1>
      \begin{pxcode}[language=SPARK,style=magic,gobble=8]
        package Conference_Attendance
        is
           Max_Attendance : constant := 1000;
           type Count_T is range 0 .. Max_Attendance;
           Audience_Count, Presenter_Count : Count_T := 0;
           Presenter_Set : Name_Sets.Set;

           procedure Inc_Audience (N : Integer)
           with Global => (In_Out => Audience_Count),
                Pre    => (N >= 0, Audience_Count + N <= Max_Attendance),
                Post   => (Audience_Count = Audience_Count + N);

           procedure Inc_Presenter(Name : String)
           with Global => (In_Out => Presenter_Count, Presenter_List),
                Pre    => (Presenter_Count < Max_Attendance);
                Post   => (Presenters_Set.Insert(Name) and 
                           Presenter_Count = Presenters_Set.Count);
           ...


        package body Conference_Attendance
        is
           procedure Inc_Audience (N : Integer)
           is
           begin
              Audience_Count := Audience_Count - N;
           end Inc_Audience;

           ...

      \end{pxcode}
      \end{onlyenv}

      \begin{onlyenv}<2>
      \begin{pxcode}[language=SPARK,style=magic,gobble=8]
        package Conference_Numbers
        is
           A_Count, P_Count : Integer := 0;

           procedure Inc_Audience (N : Integer)
           with Global => (`In_Out => A_Count`),
                Pre    => (N >= 0),
                Post   => (A_Count = A_Count + N);
        end Counters;

        package body Counters
        is
           procedure Inc_Audience (N : Integer)
           is
           begin
              A_Count := A_Count + N;
           end Inc_Audience;
        end Counters;
      \end{pxcode}
      \end{onlyenv}

      \begin{onlyenv}<3>
      \begin{pxcode}[language=SPARK,style=magic,gobble=8]
        package Conference_Attendance
        is
           Max_Attendance : constant := 1000;
           type Count_T is range 0 .. Max_Attendance;
           Audience_Count, Presenter_Count : Count_T := 0;
           Presenter_Set : Name_Sets.Set;

           procedure Inc_Audience (N : Integer)
           with Global => (In_Out => Audience_Count),
                Pre    => (N >= 0, Audience_Count + N <= Max_Attendance),
                Post   => (Audience_Count = Audience_Count + N);

           procedure Inc_Presenter(Name : String)
           with Global => (In_Out => Presenter_Count, Presenter_List),
                Pre    => (Presenter_Count < Max_Attendance);
                Post   => (Presenters_Set.Insert(Name) and 
                           Presenter_Count = Presenters_Set.Count);
           ...


        package body Conference_Attendance
        is
           procedure Inc_Audience (N : Integer)
           is
           begin
              Audience_Count := `Audience_Count - N`;
           end Inc_Audience;

           ...
      \end{pxcode}
      \end{onlyenv}

      %\hrule
    \end{column}
  \end{columns}

\end{frame}

\begin{frame}[fragile]{Combining proof and test overview}
  \begin{itemize}
     \item This slide could be a Venn diagram (rings: proof, test, 178)
     \item Key message: neither full proof, nor full test is sufficient
     \item talk about system test as out of scope
     \item List properties that can be proven/tested (RTE, partial correctness, full correctness, spec validation, full state space coverage, termination, hw integration, sw integration)
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Scenario Summary}
  \begin{itemize}
     \item Key message: 
  \end{itemize}
\begin{center}
\begin{tabular}{l | c | c | c}
    & Fully specify & Partially specify & Can't specify \\
  \hline
  Only prove & R & NA & NA \\
  Only test & O & O & R \\
  Prove some and test some & O & O & O \\
  Test to debug contracts & O & O & NA \\
\end{tabular}
\end{center}

\end{frame}

\begin{frame}[fragile]{Only prove}
  \begin{itemize}
     \item Key message: Proof isn't just possible, it is often easier than test!
     \item Show code for Proven and Are_Coprime and say they were proven automatically - much better than testing!!
     \item Don't show code for Factorial because it relies on "Assume"
     \item Use simple state machine example with bug in code 
     \item Take screenshot from GPS to show path of error 

     \item simple methods of increasing provability:
     \begin{itemize}
        \item Describe when proof is easy/hard (linear/non-linear arithmetic) (logic vs computations?)
        \item increase time spent by prover
        \item strengthen pre-conditions
        \item add assertions to the code
     \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Only test}
  \begin{itemize}
     \item Key message: Examples where proof is not effective, VectorCast provide a solution
     \item Code structure may be v. complex
     \item Contracts hard to formalise
     \item One slide to show an the mergesort example
     \item One slide to show screen shot from VectorCast (Mergesort_Same_Values.csv)
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Prove and test}
  \begin{itemize}
     \item Key message: Mixing of proof and test most effective method
     \item Often find lowest-level operations proof automatically
     \item concentrating test effort on high-level ops is better value
     \item Start by attempting to prove, give up then
     \item resort to testing
     \item prove a subset of the properties (eg RTE, safety properties)
     
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Test to debug contracts}
  \begin{itemize}
     \item Key message: Executing contracts is a great way of checking them
     \item state machine post-condition
     \item can be done without the body being implemented
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Test to prove contracts}
  \begin{itemize}
     \item Key message: When provers aren't capable, execute contract over all cases
     \item state machine assert example
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Conclusions}
  \begin{itemize}
     \item Key message: Read the paper, checkout spark2014 Beta
     \item SPARK 2014 make formal methods easier to use and 
     \item 178C makes it easier to apply formal methods
     \item combining proof and test can be more efficient than test alone
     \item 
  \end{itemize}
\end{frame}

\end{document}

